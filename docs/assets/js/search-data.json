{"0": {
    "doc": "About",
    "title": "About How to Data",
    "content": " ",
    "url": "/about/#about-how-to-data",
    "relUrl": "/about/#about-how-to-data"
  },"1": {
    "doc": "About",
    "title": "Purpose",
    "content": "How to Data is a free, online reference site targeted primarily at analytics and data science students. It’s organized around statistical and data-related tasks and shows their implementation in a wide variety of software packages. ",
    "url": "/about/#purpose",
    "relUrl": "/about/#purpose"
  },"2": {
    "doc": "About",
    "title": "Scope",
    "content": "The website began at Bentley University and is initially targeted at the needs of students and faculty at that institution. It includes pages that organize the content around Bentley’s curriculum. But new content from other schools and businesses is always welcome, including new ways to organize existing content to better suit your organization’s needs. We aim for this resource to be as broadly useful as possible. We aim for the site to cover all the tasks useful to students in the data-related courses of study at Bentley (e.g., the Data Analytics major), and show how to accomplish those tasks in several common software packages and programming languages. But the site is just beginning, and does not yet cover every data-related course at Bentley. ",
    "url": "/about/#scope",
    "relUrl": "/about/#scope"
  },"3": {
    "doc": "About",
    "title": "History",
    "content": "The website was begun in Summer 2021 by Nathan Carter (a faculty member in Bentley’s Mathematical Sciences Department), with help from some other faculty and students. ",
    "url": "/about/#history",
    "relUrl": "/about/#history"
  },"4": {
    "doc": "About",
    "title": "Aren’t there websites like this already?",
    "content": "Not really. Here’s what I’ve seen, and why it’s not exactly what How to Data is designed to accomplish. | Software documentation . | Example: the pandas manual | Documentation is specific to one piece of software; How to Data aims to show how each task is solved in many different pieces of software. | Software documentation is not organized around the courses students are taking. | . | Q&amp;A sites . | Example: Stack Overflow | While an invaluable resource, such sites can have overly specific questions that don’t always teach a general lesson in a didactic way. | They are also not organized around a student’s coursework. | . | Interactive online lessons . | Example: DataCamp | These are excellent tools for a flipped classroom or individual study, but are not excellent references; they expect you to take your own notes. | They also typically have paywalls to support their business model. | . | Existing academic references . | Example: UCLA’s data analysis examples and annotated output | That website has very similar goals to How to Data, with one major exception—the lessons on that website are lengthy, while ours aim to be very bite-sized, answering one specific question with a short snippet of code that it’s easy to take and re-use. They’re aiming more to teach, while we’re aiming to get you the code or steps you need to do a task. | . | . ",
    "url": "/about/#arent-there-websites-like-this-already",
    "relUrl": "/about/#arent-there-websites-like-this-already"
  },"5": {
    "doc": "About",
    "title": "Why the funny name?",
    "content": "The Internet spawns many strange and amusing new ways to speak and write. One example innovation is using the words “how to” followed by a noun. Examples include online images of dogs, captioned with the phrase “I forgot how to dog”, or the book How to College. How to Data follows this pattern. ",
    "url": "/about/#why-the-funny-name",
    "relUrl": "/about/#why-the-funny-name"
  },"6": {
    "doc": "About",
    "title": "About",
    "content": " ",
    "url": "/about/",
    "relUrl": "/about/"
  },"7": {
    "doc": "Acknowledgments",
    "title": "Acknowledgments",
    "content": " ",
    "url": "/acknowledgments/",
    "relUrl": "/acknowledgments/"
  },"8": {
    "doc": "Acknowledgments",
    "title": "Content Contributors",
    "content": "Any solution on this website lists the author(s) at the bottom of the page. Here’s an example. Scroll to the bottom of it to see the authors. A complete list of authors who have contributed solutions so far appears below. Want to become one of them? Here’s how! . | Author | Solutions contributed | . | Nathan Carter (ncarter@bentley.edu) | 96 | . | Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) | 74 | . | Krtin Juneja (KJUNEJA@falcon.bentley.edu) | 30 | . | Ni Shi (shi_ni@bentley.edu) | 5 | . | Debayan Sen (DSEN@bentley.edu) | 3 | . | Andrew Quagliaroli (aquagliaroli@falcon.bentley.edu) | 3 | . ",
    "url": "/acknowledgments/#content-contributors",
    "relUrl": "/acknowledgments/#content-contributors"
  },"9": {
    "doc": "Acknowledgments",
    "title": "Advisors",
    "content": "The following faculty members have proofread student work or given advice on website structure or content. | Moinak Bhaduri | Nathan Carter | Reagan Mozer | Gregory Vaughan | . ",
    "url": "/acknowledgments/#advisors",
    "relUrl": "/acknowledgments/#advisors"
  },"10": {
    "doc": "Acknowledgments",
    "title": "Supporters",
    "content": "Bentley University supported the creation of this website in 2021 with the following resources. | a grant supporting Prof. Carter’s work creating the site infrastructure | a research assistantship for a student to add site content | . ",
    "url": "/acknowledgments/#supporters",
    "relUrl": "/acknowledgments/#supporters"
  },"11": {
    "doc": "Bentley University GB213",
    "title": "Topic - Bentley University GB213",
    "content": "GB213 is an undergraduate Business Statistics course at Bentley University. The description from the course catalog can be found here. Topics included in the course are listed as tasks below. Mathematical topics include random variables, discrete and continuous probability distributions, confidence intervals, hypothesis testing, single-variable linear models, and optionally ANOVA and/or $\\chi^2$ tests, time permitting. ",
    "url": "/bentley-university-gb213/#topic---bentley-university-gb213",
    "relUrl": "/bentley-university-gb213/#topic---bentley-university-gb213"
  },"12": {
    "doc": "Bentley University GB213",
    "title": "Basics",
    "content": ". | How to do basic mathematical computations | How to quickly load some sample data | How to compute summary statistics | . ",
    "url": "/bentley-university-gb213/#basics",
    "relUrl": "/bentley-university-gb213/#basics"
  },"13": {
    "doc": "Bentley University GB213",
    "title": "Random variables and probability distributions",
    "content": ". | How to generate random values from a distribution | How to compute probabilities from a distribution | How to plot continuous probability distributions | How to plot discrete probability distributions | . ",
    "url": "/bentley-university-gb213/#random-variables-and-probability-distributions",
    "relUrl": "/bentley-university-gb213/#random-variables-and-probability-distributions"
  },"14": {
    "doc": "Bentley University GB213",
    "title": "Confidence intervals and hypothesis testing",
    "content": ". | How to find critical values and p-values from the t-distribution | How to find critical values and p-values from the normal distribution | How to compute a confidence interval for a population mean | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/bentley-university-gb213/#confidence-intervals-and-hypothesis-testing",
    "relUrl": "/bentley-university-gb213/#confidence-intervals-and-hypothesis-testing"
  },"15": {
    "doc": "Bentley University GB213",
    "title": "Linear modeling, time permitting",
    "content": ". | How to fit a linear model to two columns of data | How to compute R-squared for a simple linear model | . Content last modified on 07 December 2021. Contributed by Nathan Carter (ncarter@bentley.edu) . Downloads . | Solutions in Python (download PDF) | Solutions in R (download PDF) | Solutions in Julia (download PDF) | . ",
    "url": "/bentley-university-gb213/#linear-modeling-time-permitting",
    "relUrl": "/bentley-university-gb213/#linear-modeling-time-permitting"
  },"16": {
    "doc": "Bentley University GB213",
    "title": "Bentley University GB213",
    "content": " ",
    "url": "/bentley-university-gb213/",
    "relUrl": "/bentley-university-gb213/"
  },"17": {
    "doc": "Bentley University GR521",
    "title": "Topic - Bentley University GR521",
    "content": "GR521 is a graduate Managerial Statistics course at Bentley University. The description from the course catalog can be found here. Mathematical topics include random variables, discrete and continuous probability distributions, confidence intervals, hypothesis testing, single-variable linear models, and optionally advanced topics such as data mining, time permitting. ",
    "url": "/bentley-university-gr521/#topic---bentley-university-gr521",
    "relUrl": "/bentley-university-gr521/#topic---bentley-university-gr521"
  },"18": {
    "doc": "Bentley University GR521",
    "title": "Basics",
    "content": ". | How to do basic mathematical computations | How to quickly load some sample data | How to compute summary statistics | . ",
    "url": "/bentley-university-gr521/#basics",
    "relUrl": "/bentley-university-gr521/#basics"
  },"19": {
    "doc": "Bentley University GR521",
    "title": "Random variables and probability distributions",
    "content": ". | How to generate random values from a distribution | How to compute probabilities from a distribution | How to plot continuous probability distributions | How to plot discrete probability distributions | . ",
    "url": "/bentley-university-gr521/#random-variables-and-probability-distributions",
    "relUrl": "/bentley-university-gr521/#random-variables-and-probability-distributions"
  },"20": {
    "doc": "Bentley University GR521",
    "title": "Confidence intervals and hypothesis testing",
    "content": ". | How to find critical values and p-values from the t-distribution | How to find critical values and p-values from the normal distribution | How to compute a confidence interval for a population mean | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/bentley-university-gr521/#confidence-intervals-and-hypothesis-testing",
    "relUrl": "/bentley-university-gr521/#confidence-intervals-and-hypothesis-testing"
  },"21": {
    "doc": "Bentley University GR521",
    "title": "Linear modeling",
    "content": ". | How to fit a linear model to two columns of data | How to compute R-squared for a simple linear model | . ",
    "url": "/bentley-university-gr521/#linear-modeling",
    "relUrl": "/bentley-university-gr521/#linear-modeling"
  },"22": {
    "doc": "Bentley University GR521",
    "title": "Other end-of-semester topics, time permitting",
    "content": ". | How to do a one-way analysis of variance (ANOVA) | How to perform a chi-squared test on a contingency table | . Content last modified on 07 December 2021. Contributed by Nathan Carter (ncarter@bentley.edu) . Downloads . | Solutions in Python (download PDF) | Solutions in R (download PDF) | Solutions in Julia (download PDF) | . ",
    "url": "/bentley-university-gr521/#other-end-of-semester-topics-time-permitting",
    "relUrl": "/bentley-university-gr521/#other-end-of-semester-topics-time-permitting"
  },"23": {
    "doc": "Bentley University GR521",
    "title": "Bentley University GR521",
    "content": " ",
    "url": "/bentley-university-gr521/",
    "relUrl": "/bentley-university-gr521/"
  },"24": {
    "doc": "Bentley University GR526",
    "title": "Topic - Bentley University GR526",
    "content": "GR526 is a graduate course at Bentley University that gives an overview of Calculus from a computational viewpoint, for students who plan to study quantitative finance. The description from the course catalog can be found here. Topics include limits, derivatives, integrals, differential equations, implicit differentiation, Taylor series, and continuous probability. By-hand computation is minimized and the use of a computer algebra system is required, such as Maxima or SymPy. ",
    "url": "/bentley-university-gr526/#topic---bentley-university-gr526",
    "relUrl": "/bentley-university-gr526/#topic---bentley-university-gr526"
  },"25": {
    "doc": "Bentley University GR526",
    "title": "Basic Symbolic Mathematics",
    "content": ". | How to do basic mathematical computations | How to create symbolic variables | How to substitute a value for a symbolic variable | . ",
    "url": "/bentley-university-gr526/#basic-symbolic-mathematics",
    "relUrl": "/bentley-university-gr526/#basic-symbolic-mathematics"
  },"26": {
    "doc": "Bentley University GR526",
    "title": "Functions and Graphs",
    "content": ". | How to compute the domain of a function | How to graph mathematical functions | How to graph curves that are not functions | How to write a piecewise-defined function | How to graph a two-variable function as a surface | . ",
    "url": "/bentley-university-gr526/#functions-and-graphs",
    "relUrl": "/bentley-university-gr526/#functions-and-graphs"
  },"27": {
    "doc": "Bentley University GR526",
    "title": "Equations and Systems",
    "content": ". | How to write symbolic equations | How to solve symbolic equations | How to isolate one variable in an equation | . ",
    "url": "/bentley-university-gr526/#equations-and-systems",
    "relUrl": "/bentley-university-gr526/#equations-and-systems"
  },"28": {
    "doc": "Bentley University GR526",
    "title": "Limits, Sequences, and Series",
    "content": ". | How to compute the limit of a function | How to define a mathematical sequence | How to graph mathematical sequences | How to define a mathematical series (and evaluate it) | . ",
    "url": "/bentley-university-gr526/#limits-sequences-and-series",
    "relUrl": "/bentley-university-gr526/#limits-sequences-and-series"
  },"29": {
    "doc": "Bentley University GR526",
    "title": "Differentiation",
    "content": ". | How to compute the derivative of a function | How to compute the Taylor series for a function | How to compute the error bounds on a Taylor approximation | How to do implicit differentiation | How to find the critical numbers of a function | . ",
    "url": "/bentley-university-gr526/#differentiation",
    "relUrl": "/bentley-university-gr526/#differentiation"
  },"30": {
    "doc": "Bentley University GR526",
    "title": "Antidifferentiation",
    "content": ". | How to write and evaluate indefinite integrals | How to write and evaluate definite integrals | . ",
    "url": "/bentley-university-gr526/#antidifferentiation",
    "relUrl": "/bentley-university-gr526/#antidifferentiation"
  },"31": {
    "doc": "Bentley University GR526",
    "title": "Differential Equations",
    "content": ". | How to write an ordinary differential equation | How to solve an ordinary differential equation | . Content last modified on 07 June 2021. Contributed by Nathan Carter (ncarter@bentley.edu) . Downloads . | Solutions in Python (download PDF) | . ",
    "url": "/bentley-university-gr526/#differential-equations",
    "relUrl": "/bentley-university-gr526/#differential-equations"
  },"32": {
    "doc": "Bentley University GR526",
    "title": "Bentley University GR526",
    "content": " ",
    "url": "/bentley-university-gr526/",
    "relUrl": "/bentley-university-gr526/"
  },"33": {
    "doc": "Bentley University MA214",
    "title": "Topic - Bentley University MA214",
    "content": "MA214 is an undergraduate statistics course at Bentley University that builds on the basic managerial statistics course taken by all students. The description from the course catalog can be found here. It covers hypothesis tests, analysis of variance, multiple regression, and contingency tables. ",
    "url": "/bentley-university-ma214/#topic---bentley-university-ma214",
    "relUrl": "/bentley-university-ma214/#topic---bentley-university-ma214"
  },"34": {
    "doc": "Bentley University MA214",
    "title": "Review of statistical inference",
    "content": ". | How to compute a confidence interval for a population mean | How to compute a confidence interval for a population mean using z-scores | How to compute a confidence interval for the population proportion | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | How to do a hypothesis test for population variance | How to do a hypothesis test for the mean with known standard deviation | . ",
    "url": "/bentley-university-ma214/#review-of-statistical-inference",
    "relUrl": "/bentley-university-ma214/#review-of-statistical-inference"
  },"35": {
    "doc": "Bentley University MA214",
    "title": "Two populations",
    "content": ". | How to compute a confidence interval for a mean difference (matched pairs) | How to choose the sample size in a study with two population means | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the ratio of two population variances | How to do a hypothesis test for the difference between means when both population variances are known | How to do a hypothesis test for the difference between two proportions | How to do a hypothesis test for the ratio of two population variances | How to do a Kruskal-Wallis test | How to do a one-sided hypothesis test for two sample means | How to do a Wilcoxon rank-sum test | How to do a Wilcoxon signed-rank test | How to do a Wilcoxon signed-rank test for matched pairs | . ",
    "url": "/bentley-university-ma214/#two-populations",
    "relUrl": "/bentley-university-ma214/#two-populations"
  },"36": {
    "doc": "Bentley University MA214",
    "title": "Variance inference",
    "content": ". | How to compute a confidence interval for a single population variance | . ",
    "url": "/bentley-university-ma214/#variance-inference",
    "relUrl": "/bentley-university-ma214/#variance-inference"
  },"37": {
    "doc": "Bentley University MA214",
    "title": "Chi-squares tests",
    "content": ". | How to perform a chi-squared test on a contingency table | How to do a goodness of fit test for a multinomial experiment | . ",
    "url": "/bentley-university-ma214/#chi-squares-tests",
    "relUrl": "/bentley-university-ma214/#chi-squares-tests"
  },"38": {
    "doc": "Bentley University MA214",
    "title": "ANOVA",
    "content": ". | How to do a one-way analysis of variance (ANOVA) | How to do a two-way ANOVA test with interaction | How to do a two-way ANOVA test without interaction | How to compute Fisher’s confidence intervals | How to perform an analysis of covariance (ANCOVA) | How to perform post-hoc analysis with Tukey’s HSD test | How to use Bonferroni’s Correction method | . ",
    "url": "/bentley-university-ma214/#anova",
    "relUrl": "/bentley-university-ma214/#anova"
  },"39": {
    "doc": "Bentley University MA214",
    "title": "Regression",
    "content": ". | How to fit a linear model to two columns of data | How to compute a confidence interval for the expected value of a response variable | How to compute R-squared for a simple linear model | How to predict the response variable in a linear model | . ",
    "url": "/bentley-university-ma214/#regression",
    "relUrl": "/bentley-university-ma214/#regression"
  },"40": {
    "doc": "Bentley University MA214",
    "title": "Nonparametric tests",
    "content": ". | How to create a QQ-plot | How to test data for normality with Pearson’s chi-squared test | How to test data for normality with the D’Agostino-Pearson test | How to test data for normality with the Jarque-Bera test | . Content last modified on 07 December 2021. Contributed by Nathan Carter (ncarter@bentley.edu) . Downloads . | Solutions in Python (download PDF) | Solutions in R (download PDF) | . ",
    "url": "/bentley-university-ma214/#nonparametric-tests",
    "relUrl": "/bentley-university-ma214/#nonparametric-tests"
  },"41": {
    "doc": "Bentley University MA214",
    "title": "Bentley University MA214",
    "content": " ",
    "url": "/bentley-university-ma214/",
    "relUrl": "/bentley-university-ma214/"
  },"42": {
    "doc": "Bentley University MA252",
    "title": "Topic - Bentley University MA252",
    "content": "MA252 is an undergraduate statistics course at Bentley University that focuses on model building using regression. The description from the course catalog can be found here. It covers simple linear regression, multivariate linear regression, logistic linear regression, model building, transformations, and interactions. ",
    "url": "/bentley-university-ma252/#topic---bentley-university-ma252",
    "relUrl": "/bentley-university-ma252/#topic---bentley-university-ma252"
  },"43": {
    "doc": "Bentley University MA252",
    "title": "Simple Linear Regression",
    "content": ". | How to fit a linear model to two columns of data | How to compute a confidence interval for the expected value of a response variable | How to compute R-squared for a simple linear model | How to predict the response variable in a linear model | . ",
    "url": "/bentley-university-ma252/#simple-linear-regression",
    "relUrl": "/bentley-university-ma252/#simple-linear-regression"
  },"44": {
    "doc": "Bentley University MA252",
    "title": "Multivariate Linear Regression",
    "content": ". | How to fit a multivariate linear model | How to add an interaction term to a model | How to add a polynomial term to a model | How to add a transformed term to a model | How to compute a confidence interval for a regression coefficient | How to compute adjusted R-squared | . ",
    "url": "/bentley-university-ma252/#multivariate-linear-regression",
    "relUrl": "/bentley-university-ma252/#multivariate-linear-regression"
  },"45": {
    "doc": "Bentley University MA252",
    "title": "Model Building",
    "content": ". | How to compute covariance and correlation coefficients | How to compute the standard error of the estimate for a model | How to do a hypothesis test of a coefficient’s significance | How to do a test of joint significance | How to do a Spearman rank correlation test | . ",
    "url": "/bentley-university-ma252/#model-building",
    "relUrl": "/bentley-university-ma252/#model-building"
  },"46": {
    "doc": "Bentley University MA252",
    "title": "Residual Analysis",
    "content": ". | How to compute the residuals of a linear model | . Content last modified on 07 December 2021. Contributed by Nathan Carter (ncarter@bentley.edu) . Downloads . | Solutions in Python (download PDF) | Solutions in R (download PDF) | . ",
    "url": "/bentley-university-ma252/#residual-analysis",
    "relUrl": "/bentley-university-ma252/#residual-analysis"
  },"47": {
    "doc": "Bentley University MA252",
    "title": "Bentley University MA252",
    "content": " ",
    "url": "/bentley-university-ma252/",
    "relUrl": "/bentley-university-ma252/"
  },"48": {
    "doc": "Bentley University MA255",
    "title": "Topic - Bentley University MA255",
    "content": "MA255 is an undergraduate statistics course at Bentley University on the Design of Experiments. The description from the course catalog can be found here. The course covers various experimental designs including factorial and fractional factorial designs, interaction among factors, and applications in management (including cost savings and policy making) as well as in marketing. The sequence of topics below is not necessarily the final version; this topic page is under construction. ",
    "url": "/bentley-university-ma255/#topic---bentley-university-ma255",
    "relUrl": "/bentley-university-ma255/#topic---bentley-university-ma255"
  },"49": {
    "doc": "Bentley University MA255",
    "title": "Summarizing data and exploratory analysis",
    "content": ". | How to summarize a column | How to compute summary statistics | How to summarize and compare data by groups | How to create bivariate plots to compare groups | . ",
    "url": "/bentley-university-ma255/#summarizing-data-and-exploratory-analysis",
    "relUrl": "/bentley-university-ma255/#summarizing-data-and-exploratory-analysis"
  },"50": {
    "doc": "Bentley University MA255",
    "title": "Experiments with one treatment factor",
    "content": ". | How to check the assumptions of a linear model | How to compute the power of a test comparing two population means | How to perform an analysis of covariance (ANCOVA) | How to perform pairwise comparisons | How to perform post-hoc analysis with Tukey’s HSD test | How to test for a treatment effect in a single factor design | . ",
    "url": "/bentley-university-ma255/#experiments-with-one-treatment-factor",
    "relUrl": "/bentley-university-ma255/#experiments-with-one-treatment-factor"
  },"51": {
    "doc": "Bentley University MA255",
    "title": "Analyzing data from a larger design",
    "content": ". | How to plot interaction effects of treatments | How to analyze the sample means of different treatment conditions | How to compare two nested linear models | How to conduct a mixed designs ANOVA | How to conduct a repeated measures ANOVA | How to perform a planned comparison test | . Content last modified on 07 December 2021. Contributed by Nathan Carter (ncarter@bentley.edu) . Downloads . | Solutions in Python (download PDF) | Solutions in R (download PDF) | . ",
    "url": "/bentley-university-ma255/#analyzing-data-from-a-larger-design",
    "relUrl": "/bentley-university-ma255/#analyzing-data-from-a-larger-design"
  },"52": {
    "doc": "Bentley University MA255",
    "title": "Bentley University MA255",
    "content": " ",
    "url": "/bentley-university-ma255/",
    "relUrl": "/bentley-university-ma255/"
  },"53": {
    "doc": "Bentley University MA346",
    "title": "Topic - Bentley University MA346",
    "content": "MA346 is an undergraduate data science course at Bentley University. The description from the course catalog can be found here. Topics included in the course are listed as tasks below. Mathematical topics include functions and relations, a review of basic statistics, and (time permitting) networks, matrices, and an introduction to supervised learning. Computing topics include Jupyter notebooks (locally and in the cloud), Python and pandas, abstraction, concatenation and merging, map-reduce, split-apply-combine, data munging, version control, and dashboards. Communication topics include best practices for writing reports, documenting code and computational notebooks, and data visualization. ",
    "url": "/bentley-university-ma346/#topic---bentley-university-ma346",
    "relUrl": "/bentley-university-ma346/#topic---bentley-university-ma346"
  },"54": {
    "doc": "Bentley University MA346",
    "title": "Basics",
    "content": ". | How to do basic mathematical computations | How to quickly load some sample data | How to compute summary statistics | . ",
    "url": "/bentley-university-ma346/#basics",
    "relUrl": "/bentley-university-ma346/#basics"
  },"55": {
    "doc": "Bentley University MA346",
    "title": "Data manipulation",
    "content": ". | How to convert a text column into dates | How to create a data frame from scratch | . ",
    "url": "/bentley-university-ma346/#data-manipulation",
    "relUrl": "/bentley-university-ma346/#data-manipulation"
  },"56": {
    "doc": "Bentley University MA346",
    "title": "Statistics in Python",
    "content": ". | How to compute covariance and correlation coefficients | . ",
    "url": "/bentley-university-ma346/#statistics-in-python",
    "relUrl": "/bentley-university-ma346/#statistics-in-python"
  },"57": {
    "doc": "Bentley University MA346",
    "title": "Plotting",
    "content": ". | How to create basic plots | How to add details to a plot | How to change axes, ticks, and scale in a plot | How to create a histogram | How to create a box (and whisker) plot | How to create a QQ-plot | . This page is not yet complete. More content will be added here over time. Content last modified on 07 December 2021. Contributed by Nathan Carter (ncarter@bentley.edu) . Downloads . | Solutions in Python (download PDF) | Solutions in R (download PDF) | . ",
    "url": "/bentley-university-ma346/#plotting",
    "relUrl": "/bentley-university-ma346/#plotting"
  },"58": {
    "doc": "Bentley University MA346",
    "title": "Bentley University MA346",
    "content": " ",
    "url": "/bentley-university-ma346/",
    "relUrl": "/bentley-university-ma346/"
  },"59": {
    "doc": "Contributing",
    "title": "Contributing to How to Data",
    "content": "By contributing to How to Data, you’re permitting your work to be used under the same license as the rest of the site. See licensing information in the README of our GitHub repository. ",
    "url": "/contributing/#contributing-to-how-to-data",
    "relUrl": "/contributing/#contributing-to-how-to-data"
  },"60": {
    "doc": "Contributing",
    "title": "If you’ve come to this page because you have a question…",
    "content": "You probably want to be browsing our Tasks page. If your question isn’t there, this site may not be the right place for you. It’s a reference for common questions, not a place to ask individual questions. We highly recommend the following websites that answer custom/individual questions. | For programming questions: Stack Overflow | For statistics questions: Cross Validated | For mathematics questions: Math Stack Exchange | . ",
    "url": "/contributing/#if-youve-come-to-this-page-because-you-have-a-question",
    "relUrl": "/contributing/#if-youve-come-to-this-page-because-you-have-a-question"
  },"61": {
    "doc": "Contributing",
    "title": "If you’ve come to this page because there’s a mistake on our site…",
    "content": "Please tell us! The best way to do so is to file a new issue in our source code repository. ",
    "url": "/contributing/#if-youve-come-to-this-page-because-theres-a-mistake-on-our-site",
    "relUrl": "/contributing/#if-youve-come-to-this-page-because-theres-a-mistake-on-our-site"
  },"62": {
    "doc": "Contributing",
    "title": "If you’ve come to this page because you have a suggested improvement…",
    "content": "Great! You can make the edit yourself, and we’ll review it for inclusion. Here’s how: . | View whichever solution you’d like to improve. | At the bottom of the page, click the link that says “edit the source.” | Click the pencil icon on the right above the page content to start editing. | Under the “Commit changes” heading, write a short phrase to explain what you’re submitting, such as “Fixing incorrect RMSE formula.” | Make sure you’re creating a new branch and a pull request. (A “pull request” is a request for the How to Data maintainers to review and accept your submission.) | Click “Commit changes.” | . ",
    "url": "/contributing/#if-youve-come-to-this-page-because-you-have-a-suggested-improvement",
    "relUrl": "/contributing/#if-youve-come-to-this-page-because-you-have-a-suggested-improvement"
  },"63": {
    "doc": "Contributing",
    "title": "If you’ve come to this page because you want to create new content…",
    "content": "Excellent! Download this zipped folder and read the document inside it to see how to get started. The download contains example content you can edit to create new tasks and/or solutions that are then ready to upload, following the instructions in the document. When writing new content, please follow these guidelines: . | Write plenty of explanations. Comments in code are great. Comments between code cells are great. Explain everything you’re doing in your code. | Break your work into bite-sized pieces. Really large chunks of complex code are not helpful to learners. If you have many nested function calls, consider breaking them down into small assignment statements instead. | Use helpful names for variables and functions. Do not call a variable t when you could call it seconds_elapsed. Do not call a function convert when you could call it inches_to_cm. | . ",
    "url": "/contributing/#if-youve-come-to-this-page-because-you-want-to-create-new-content",
    "relUrl": "/contributing/#if-youve-come-to-this-page-because-you-want-to-create-new-content"
  },"64": {
    "doc": "Contributing",
    "title": "Contributing",
    "content": " ",
    "url": "/contributing/",
    "relUrl": "/contributing/"
  },"65": {
    "doc": "How to add a polynomial term to a model (in Python, using sklearn)",
    "title": "How to add a polynomial term to a model (in Python, using sklearn)",
    "content": "# How to add a polynomial term to a model (in Python, using sklearn) [See all solutions.](../how-to-add-a-polynomial-term-to-a-model) ## Task Sometimes, a simple linear model isn't sufficient to describe the data. How can we include a higher-order term in a regression model, such as the square or cube of one of the predictors? Related tasks: * [How to add a transformed term to a model](../how-to-add-a-transformed-term-to-a-model) * [How to add an interaction term to a model](../how-to-add-an-interaction-term-to-a-model) ## Solution We begin with a fabricated dataset of 20 points. You can replace the code below with your own, real, data. ```python import numpy as np import pandas as pd x = np.arange(0,20) # List of integers from 0 to 19 y = [3,4,5,7,9,20,31,50,70,75,80,91,101,120,135,160,179,181,190,193] # List of 20 integers ``` We extend our dataset with a new column (or \"feature\"), containing $x^2$. ```python from sklearn.preprocessing import PolynomialFeatures poly = PolynomialFeatures( degree=2, include_bias=False ) x_matrix = x.reshape( -1, 1 ) # make x a matrix so that we can add columns poly_features = poly.fit_transform( x_matrix ) # add a second column, so we now have x and x^2 ``` Next, fit a regression model to the new features, which are $x$ and $x^2$. ```python from sklearn.linear_model import LinearRegression poly_reg_model = LinearRegression() # Our model will be linear in the features x and x^2 poly_reg_model.fit( poly_features, y ) # Use regression to create the model ``` LinearRegression() Finally, get the coefficients and intercept of the model. ```python poly_reg_model.intercept_, poly_reg_model.coef_ ``` (-8.384415584415635, array([6.28628389, 0.27420825])) Thus the equation for our model of degree two is $\\widehat{y} = -8.38 + 6.28x + 0.27x^2$ Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to add a polynomial term to a model/Python, using sklearn.ipynb). Contributed by Debayan Sen (DSEN@bentley.edu) ",
    "url": "/how-to-add-a-polynomial-term-to-a-model-in-python-using-sklearn/",
    "relUrl": "/how-to-add-a-polynomial-term-to-a-model-in-python-using-sklearn/"
  },"66": {
    "doc": "How to add a polynomial term to a model (in R)",
    "title": "How to add a polynomial term to a model (in R)",
    "content": "# How to add a polynomial term to a model (in R) [See all solutions.](../how-to-add-a-polynomial-term-to-a-model) ## Task Sometimes, a simple linear model isn't sufficient to describe the data. How can we include a higher-order term in a regression model, such as the square or cube of one of the predictors? Related tasks: * [How to add a transformed term to a model](../how-to-add-a-transformed-term-to-a-model) * [How to add an interaction term to a model](../how-to-add-an-interaction-term-to-a-model) ## Solution We're going to use the `Pressure` dataset in R's `ggplot` library as example data. It contains observations of pressure and temperature. You would use your own data instead. ```R # install.packages( \"ggplot2\" ) # if you haven't done this already library(ggplot2) data(\"pressure\") ``` Let's model temperature as the dependent variable with pressure squared as the independent variable. To place the \"pressure squared\" term in the model, we use R's `poly` function, as shown below. It automatically includes a pressure term as well (not squared). ```R # Build the model model |t|) (Intercept) 180.00 14.31 12.581 1.03e-09 *** poly(pressure, 2)1 361.84 62.36 5.802 2.70e-05 *** poly(pressure, 2)2 -186.66 62.36 -2.993 0.0086 ** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 62.36 on 16 degrees of freedom Multiple R-squared: 0.7271, Adjusted R-squared: 0.693 F-statistic: 21.31 on 2 and 16 DF, p-value: 3.079e-05 Now we have a model of the form $\\hat t = 180 + 361.84p - 186.66p^2$, where $t$ stands for temperature and $p$ for pressure. You can change the number in the `poly` function. For example, if we wanted to create a third-degree polynomial term then we would have specified `poly(pressure, 3)`, and it would have included pressure, pressure squared, and pressure cubed. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to add a polynomial term to a model/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-add-a-polynomial-term-to-a-model-in-r/",
    "relUrl": "/how-to-add-a-polynomial-term-to-a-model-in-r/"
  },"67": {
    "doc": "How to add a polynomial term to a model",
    "title": "How to add a polynomial term to a model",
    "content": " ",
    "url": "/how-to-add-a-polynomial-term-to-a-model/",
    "relUrl": "/how-to-add-a-polynomial-term-to-a-model/"
  },"68": {
    "doc": "How to add a polynomial term to a model",
    "title": "Description",
    "content": "Sometimes, a simple linear model isn’t sufficient to describe the data. How can we include a higher-order term in a regression model, such as the square or cube of one of the predictors? . Related tasks: . | How to add a transformed term to a model | How to add an interaction term to a model | . ",
    "url": "/how-to-add-a-polynomial-term-to-a-model/#description",
    "relUrl": "/how-to-add-a-polynomial-term-to-a-model/#description"
  },"69": {
    "doc": "How to add a polynomial term to a model",
    "title": "Using sklearn, in Python",
    "content": "View this solution alone. We begin with a fabricated dataset of 20 points. You can replace the code below with your own, real, data. | 1 2 3 4 5 . | import numpy as np import pandas as pd x = np.arange(0,20) # List of integers from 0 to 19 y = [3,4,5,7,9,20,31,50,70,75,80,91,101,120,135,160,179,181,190,193] # List of 20 integers . | . We extend our dataset with a new column (or “feature”), containing $x^2$. | 1 2 3 4 . | from sklearn.preprocessing import PolynomialFeatures poly = PolynomialFeatures( degree=2, include_bias=False ) x_matrix = x.reshape( -1, 1 ) # make x a matrix so that we can add columns poly_features = poly.fit_transform( x_matrix ) # add a second column, so we now have x and x^2 . | . Next, fit a regression model to the new features, which are $x$ and $x^2$. | 1 2 3 4 . | from sklearn.linear_model import LinearRegression poly_reg_model = LinearRegression() # Our model will be linear in the features x and x^2 poly_reg_model.fit( poly_features, y ) # Use regression to create the model . | . | 1 . | LinearRegression() . | . Finally, get the coefficients and intercept of the model. | 1 . | poly_reg_model.intercept_, poly_reg_model.coef_ . | . | 1 . | (-8.384415584415635, array([6.28628389, 0.27420825])) . | . Thus the equation for our model of degree two is $\\widehat{y} = -8.38 + 6.28x + 0.27x^2$ . Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-add-a-polynomial-term-to-a-model/#using-sklearn-in-python",
    "relUrl": "/how-to-add-a-polynomial-term-to-a-model/#using-sklearn-in-python"
  },"70": {
    "doc": "How to add a polynomial term to a model",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use the Pressure dataset in R’s ggplot library as example data. It contains observations of pressure and temperature. You would use your own data instead. | 1 2 3 . | # install.packages( \"ggplot2\" ) # if you haven't done this already library(ggplot2) data(\"pressure\") . | . Let’s model temperature as the dependent variable with pressure squared as the independent variable. To place the “pressure squared” term in the model, we use R’s poly function, as shown below. It automatically includes a pressure term as well (not squared). | 1 2 3 . | # Build the model model &lt;- lm(temperature ~ poly(pressure, 2), data = pressure) summary(model) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | Call: lm(formula = temperature ~ poly(pressure, 2), data = pressure) Residuals: Min 1Q Median 3Q Max -113.095 -44.543 6.157 50.459 75.791 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 180.00 14.31 12.581 1.03e-09 *** poly(pressure, 2)1 361.84 62.36 5.802 2.70e-05 *** poly(pressure, 2)2 -186.66 62.36 -2.993 0.0086 ** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 62.36 on 16 degrees of freedom Multiple R-squared: 0.7271, Adjusted R-squared: 0.693 F-statistic: 21.31 on 2 and 16 DF, p-value: 3.079e-05 . | . Now we have a model of the form $\\hat t = 180 + 361.84p - 186.66p^2$, where $t$ stands for temperature and $p$ for pressure. You can change the number in the poly function. For example, if we wanted to create a third-degree polynomial term then we would have specified poly(pressure, 3), and it would have included pressure, pressure squared, and pressure cubed. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-add-a-polynomial-term-to-a-model/#solution-in-r",
    "relUrl": "/how-to-add-a-polynomial-term-to-a-model/#solution-in-r"
  },"71": {
    "doc": "How to add a polynomial term to a model",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-add-a-polynomial-term-to-a-model/#topics-that-include-this-task",
    "relUrl": "/how-to-add-a-polynomial-term-to-a-model/#topics-that-include-this-task"
  },"72": {
    "doc": "How to add a polynomial term to a model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-add-a-polynomial-term-to-a-model/#opportunities",
    "relUrl": "/how-to-add-a-polynomial-term-to-a-model/#opportunities"
  },"73": {
    "doc": "How to add a transformed term to a model (in Python, using NumPy and sklearn)",
    "title": "How to add a transformed term to a model (in Python, using NumPy and sklearn)",
    "content": "# How to add a transformed term to a model (in Python, using NumPy and sklearn) [See all solutions.](../how-to-add-a-transformed-term-to-a-model) ## Task Sometimes, a simple linear model isn't sufficient for our data, and we need more complex terms or transformed variables in the model to make adequate predictions. How do we include these complex and transformed terms in a regression model? Related tasks: * [How to add a polynomial term to a model](../how-to-add-a-polynomial-term-to-a-model) * [How to add an interaction term to a model](../how-to-add-an-interaction-term-to-a-model) ## Solution We're going to create the `Pressure` dataset as example data. It contains observations of pressure and temperature. You would use your own data instead. ```python import pandas as pd pressure = pd.DataFrame( { 'temperature': [0,20,40,60,80,100,120,140,160,180,200, 220,240,260,280,300,320,340,360], 'pressure': [0.0002,0.0012,0.0060,0.0300,0.0900,0.2700,0.7500, 1.8500,4.2000,8.8000,17.3000,32.1000,57.0000,96.0000, 157.0000,247.0000,376.0000,558.0000,806.0000] } ) pressure ``` | | temperature | pressure | . | 0 | 0 | 0.0002 | . | 1 | 20 | 0.0012 | . | 2 | 40 | 0.0060 | . | 3 | 60 | 0.0300 | . | 4 | 80 | 0.0900 | . | 5 | 100 | 0.2700 | . | 6 | 120 | 0.7500 | . | 7 | 140 | 1.8500 | . | 8 | 160 | 4.2000 | . | 9 | 180 | 8.8000 | . | 10 | 200 | 17.3000 | . | 11 | 220 | 32.1000 | . | 12 | 240 | 57.0000 | . | 13 | 260 | 96.0000 | . | 14 | 280 | 157.0000 | . | 15 | 300 | 247.0000 | . | 16 | 320 | 376.0000 | . | 17 | 340 | 558.0000 | . | 18 | 360 | 806.0000 | . Let's model temperature as the dependent variable with the logarithm of pressure as the independent variable. To transform the independent variable pressure, we use NumPy's `np.log` function, as shown below. It uses the natural logarithm (base $e$). ```python import numpy as np # Compute the logarithm of pressure X = pressure[['pressure']] log_X = np.log(X) # Build the linear model using Scikit-Learn from sklearn.linear_model import LinearRegression y = pressure['temperature'] log_model = LinearRegression() log_model.fit(log_X, y) # Display regression coefficients and R-squared value of the model log_model.intercept_, log_model.coef_, log_model.score(log_X, y) ``` (153.97045660511063, array([23.78440995]), 0.9464264282083346) The model is $\\hat t = 153.97 + 23.784\\log p$, where $t$ stands for temperature and $p$ for pressure. Another example transformation is the square root transformation. As with `np.log`, just apply the `np.sqrt` function to the appropriate term when defining the model. ```python # Compute the square root of pressure X = pressure[['pressure']] sqrt_X = np.sqrt(X) # Build the linear model using Scikit-Learn from sklearn.linear_model import LinearRegression y = pressure['temperature'] sqrt_model = LinearRegression() sqrt_model.fit(sqrt_X, y) # Display regression coefficients and R-squared value of the model sqrt_model.intercept_, sqrt_model.coef_, sqrt_model.score( log_X, y ) ``` (98.56139249917803, array([11.44621468]), 0.29600246256782614) The model is $\\hat t = 98.561 + 11.446\\sqrt{p}$, with $t$ and $p$ having the same meanings as above. Content last modified on 18 October 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to add a transformed term to a model/Python, using NumPy and sklearn.ipynb). Contributed by Ni Shi (shi_ni@bentley.edu) ",
    "url": "/how-to-add-a-transformed-term-to-a-model-in-python-using-numpy-and-sklearn/",
    "relUrl": "/how-to-add-a-transformed-term-to-a-model-in-python-using-numpy-and-sklearn/"
  },"74": {
    "doc": "How to add a transformed term to a model (in R)",
    "title": "How to add a transformed term to a model (in R)",
    "content": "# How to add a transformed term to a model (in R) [See all solutions.](../how-to-add-a-transformed-term-to-a-model) ## Task Sometimes, a simple linear model isn't sufficient for our data, and we need more complex terms or transformed variables in the model to make adequate predictions. How do we include these complex and transformed terms in a regression model? Related tasks: * [How to add a polynomial term to a model](../how-to-add-a-polynomial-term-to-a-model) * [How to add an interaction term to a model](../how-to-add-an-interaction-term-to-a-model) ## Solution We're going to use the `Pressure` dataset in R's `ggplot` library as example data. It contains observations of pressure and temperature. You would use your own data instead. ```R # install.packages( \"ggplot2\" ) # if you haven't done this already library(ggplot2) data(\"pressure\") ``` Let's model temperature as the dependent variable with the logarithm of pressure as the independent variable. To place the \"log of pressure\" term in the model, we use R's `log` function, as shown below. It uses the naturarl logarithm (base $e$). ```R # Build the model model.log |t|) (Intercept) 153.970 6.330 24.32 1.20e-14 *** log(pressure) 23.784 1.372 17.33 3.07e-12 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 26.81 on 17 degrees of freedom Multiple R-squared: 0.9464, Adjusted R-squared: 0.9433 F-statistic: 300.3 on 1 and 17 DF, p-value: 3.07e-12 The model is $\\hat t = 153.97 + 23.784\\log p$, where $t$ stands for temperature and $p$ for pressure. Another example transformation is the square root transformation. As with `log`, just apply the `sqrt` function to the appropriate term when defining the model. ```R # Build the model model.sqrt |t|) (Intercept) 98.561 15.244 6.465 5.81e-06 *** sqrt(pressure) 11.446 1.367 8.372 1.95e-07 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 51.16 on 17 degrees of freedom Multiple R-squared: 0.8048, Adjusted R-squared: 0.7933 F-statistic: 70.1 on 1 and 17 DF, p-value: 1.953e-07 The model is $\\hat t = 98.561 + 11.446\\sqrt{p}$, with $t$ and $p$ having the same meanings as above. Content last modified on 16 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to add a transformed term to a model/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-add-a-transformed-term-to-a-model-in-r/",
    "relUrl": "/how-to-add-a-transformed-term-to-a-model-in-r/"
  },"75": {
    "doc": "How to add a transformed term to a model",
    "title": "How to add a transformed term to a model",
    "content": " ",
    "url": "/how-to-add-a-transformed-term-to-a-model/",
    "relUrl": "/how-to-add-a-transformed-term-to-a-model/"
  },"76": {
    "doc": "How to add a transformed term to a model",
    "title": "Description",
    "content": "Sometimes, a simple linear model isn’t sufficient for our data, and we need more complex terms or transformed variables in the model to make adequate predictions. How do we include these complex and transformed terms in a regression model? . Related tasks: . | How to add a polynomial term to a model | How to add an interaction term to a model | . ",
    "url": "/how-to-add-a-transformed-term-to-a-model/#description",
    "relUrl": "/how-to-add-a-transformed-term-to-a-model/#description"
  },"77": {
    "doc": "How to add a transformed term to a model",
    "title": "Using NumPy and sklearn, in Python",
    "content": "View this solution alone. We’re going to create the Pressure dataset as example data. It contains observations of pressure and temperature. You would use your own data instead. | 1 2 3 4 5 6 7 8 9 . | import pandas as pd pressure = pd.DataFrame( { 'temperature': [0,20,40,60,80,100,120,140,160,180,200, 220,240,260,280,300,320,340,360], 'pressure': [0.0002,0.0012,0.0060,0.0300,0.0900,0.2700,0.7500, 1.8500,4.2000,8.8000,17.3000,32.1000,57.0000,96.0000, 157.0000,247.0000,376.0000,558.0000,806.0000] } ) pressure . | . | | temperature | pressure | . | 0 | 0 | 0.0002 | . | 1 | 20 | 0.0012 | . | 2 | 40 | 0.0060 | . | 3 | 60 | 0.0300 | . | 4 | 80 | 0.0900 | . | 5 | 100 | 0.2700 | . | 6 | 120 | 0.7500 | . | 7 | 140 | 1.8500 | . | 8 | 160 | 4.2000 | . | 9 | 180 | 8.8000 | . | 10 | 200 | 17.3000 | . | 11 | 220 | 32.1000 | . | 12 | 240 | 57.0000 | . | 13 | 260 | 96.0000 | . | 14 | 280 | 157.0000 | . | 15 | 300 | 247.0000 | . | 16 | 320 | 376.0000 | . | 17 | 340 | 558.0000 | . | 18 | 360 | 806.0000 | . Let’s model temperature as the dependent variable with the logarithm of pressure as the independent variable. To transform the independent variable pressure, we use NumPy’s np.log function, as shown below. It uses the natural logarithm (base $e$). | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . | import numpy as np # Compute the logarithm of pressure X = pressure[['pressure']] log_X = np.log(X) # Build the linear model using Scikit-Learn from sklearn.linear_model import LinearRegression y = pressure['temperature'] log_model = LinearRegression() log_model.fit(log_X, y) # Display regression coefficients and R-squared value of the model log_model.intercept_, log_model.coef_, log_model.score(log_X, y) . | . | 1 . | (153.97045660511063, array([23.78440995]), 0.9464264282083346) . | . The model is $\\hat t = 153.97 + 23.784\\log p$, where $t$ stands for temperature and $p$ for pressure. Another example transformation is the square root transformation. As with np.log, just apply the np.sqrt function to the appropriate term when defining the model. | 1 2 3 4 5 6 7 8 9 10 11 12 . | # Compute the square root of pressure X = pressure[['pressure']] sqrt_X = np.sqrt(X) # Build the linear model using Scikit-Learn from sklearn.linear_model import LinearRegression y = pressure['temperature'] sqrt_model = LinearRegression() sqrt_model.fit(sqrt_X, y) # Display regression coefficients and R-squared value of the model sqrt_model.intercept_, sqrt_model.coef_, sqrt_model.score( log_X, y ) . | . | 1 . | (98.56139249917803, array([11.44621468]), 0.29600246256782614) . | . The model is $\\hat t = 98.561 + 11.446\\sqrt{p}$, with $t$ and $p$ having the same meanings as above. Content last modified on 18 October 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-add-a-transformed-term-to-a-model/#using-numpy-and-sklearn-in-python",
    "relUrl": "/how-to-add-a-transformed-term-to-a-model/#using-numpy-and-sklearn-in-python"
  },"78": {
    "doc": "How to add a transformed term to a model",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use the Pressure dataset in R’s ggplot library as example data. It contains observations of pressure and temperature. You would use your own data instead. | 1 2 3 . | # install.packages( \"ggplot2\" ) # if you haven't done this already library(ggplot2) data(\"pressure\") . | . Let’s model temperature as the dependent variable with the logarithm of pressure as the independent variable. To place the “log of pressure” term in the model, we use R’s log function, as shown below. It uses the naturarl logarithm (base $e$). | 1 2 3 . | # Build the model model.log &lt;- lm(temperature ~ log(pressure), data = pressure) summary(model.log) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | Call: lm(formula = temperature ~ log(pressure), data = pressure) Residuals: Min 1Q Median 3Q Max -28.60 -22.30 -10.13 20.00 48.61 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 153.970 6.330 24.32 1.20e-14 *** log(pressure) 23.784 1.372 17.33 3.07e-12 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 26.81 on 17 degrees of freedom Multiple R-squared: 0.9464, Adjusted R-squared: 0.9433 F-statistic: 300.3 on 1 and 17 DF, p-value: 3.07e-12 . | . The model is $\\hat t = 153.97 + 23.784\\log p$, where $t$ stands for temperature and $p$ for pressure. Another example transformation is the square root transformation. As with log, just apply the sqrt function to the appropriate term when defining the model. | 1 2 3 . | # Build the model model.sqrt &lt;- lm(temperature ~ sqrt(pressure), data = pressure) summary(model.sqrt) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | Call: lm(formula = temperature ~ sqrt(pressure), data = pressure) Residuals: Min 1Q Median 3Q Max -98.72 -34.74 11.53 42.75 56.59 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 98.561 15.244 6.465 5.81e-06 *** sqrt(pressure) 11.446 1.367 8.372 1.95e-07 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 51.16 on 17 degrees of freedom Multiple R-squared: 0.8048, Adjusted R-squared: 0.7933 F-statistic: 70.1 on 1 and 17 DF, p-value: 1.953e-07 . | . The model is $\\hat t = 98.561 + 11.446\\sqrt{p}$, with $t$ and $p$ having the same meanings as above. Content last modified on 16 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-add-a-transformed-term-to-a-model/#solution-in-r",
    "relUrl": "/how-to-add-a-transformed-term-to-a-model/#solution-in-r"
  },"79": {
    "doc": "How to add a transformed term to a model",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-add-a-transformed-term-to-a-model/#topics-that-include-this-task",
    "relUrl": "/how-to-add-a-transformed-term-to-a-model/#topics-that-include-this-task"
  },"80": {
    "doc": "How to add a transformed term to a model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-add-a-transformed-term-to-a-model/#opportunities",
    "relUrl": "/how-to-add-a-transformed-term-to-a-model/#opportunities"
  },"81": {
    "doc": "How to add an interaction term to a model (in R)",
    "title": "How to add an interaction term to a model (in R)",
    "content": "# How to add an interaction term to a model (in R) [See all solutions.](../how-to-add-an-interaction-term-to-a-model) ## Task Sometimes, a simple linear model isn't sufficient for our data, and we need more complex terms or transformed variables in the model to make adequate predictions. How do we include these complex and transformed terms in a regression model? Related tasks: * [How to add a polynomial term to a model](../how-to-add-a-polynomial-term-to-a-model) * [How to add a transformed term to a model](../how-to-add-a-transformed-term-to-a-model) ## Solution We're going to use the `ToothGrowth` dataset in R as example data. It contains observations of tooth growth for guinea pigs who received various doses of various supplements. You would use your own data instead. ```R df |t|) (Intercept) 11.550 1.581 7.304 1.09e-09 *** suppVC -8.255 2.236 -3.691 0.000507 *** dose 7.811 1.195 6.534 2.03e-08 *** suppVC:dose 3.904 1.691 2.309 0.024631 * --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 4.083 on 56 degrees of freedom Multiple R-squared: 0.7296, Adjusted R-squared: 0.7151 F-statistic: 50.36 on 3 and 56 DF, p-value: 6.521e-16 Now we have a model of the form $\\hat L = 11.55 - 8.255s + 7.811d + 3.904sd$, where $L$ stands for tooth length, $s$ for whether the VC supplement was given, and $d$ for the dose given. Content last modified on 16 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to add an interaction term to a model/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-add-an-interaction-term-to-a-model-in-r/",
    "relUrl": "/how-to-add-an-interaction-term-to-a-model-in-r/"
  },"82": {
    "doc": "How to add an interaction term to a model",
    "title": "How to add an interaction term to a model",
    "content": " ",
    "url": "/how-to-add-an-interaction-term-to-a-model/",
    "relUrl": "/how-to-add-an-interaction-term-to-a-model/"
  },"83": {
    "doc": "How to add an interaction term to a model",
    "title": "Description",
    "content": "Sometimes, a simple linear model isn’t sufficient for our data, and we need more complex terms or transformed variables in the model to make adequate predictions. How do we include these complex and transformed terms in a regression model? . Related tasks: . | How to add a polynomial term to a model | How to add a transformed term to a model | . ",
    "url": "/how-to-add-an-interaction-term-to-a-model/#description",
    "relUrl": "/how-to-add-an-interaction-term-to-a-model/#description"
  },"84": {
    "doc": "How to add an interaction term to a model",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use the ToothGrowth dataset in R as example data. It contains observations of tooth growth for guinea pigs who received various doses of various supplements. You would use your own data instead. | 1 . | df &lt;- ToothGrowth . | . Let’s model tooth length (len) based on the product of two predictors, the supplement given (supp) and its dosage (dose). We simply use the ordinary multiplication operator in R, written *, to express the product of these two factors when creating the model, as shown below. Note that supp is a categorical variable with two values, so the model will include a binary variable for whether the supplement was equal to “VC.” . | 1 2 3 . | # Build the model model &lt;- lm(len ~ supp*dose, data = df) summary(model) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 . | Call: lm(formula = len ~ supp * dose, data = df) Residuals: Min 1Q Median 3Q Max -8.2264 -2.8462 0.0504 2.2893 7.9386 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 11.550 1.581 7.304 1.09e-09 *** suppVC -8.255 2.236 -3.691 0.000507 *** dose 7.811 1.195 6.534 2.03e-08 *** suppVC:dose 3.904 1.691 2.309 0.024631 * --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 4.083 on 56 degrees of freedom Multiple R-squared: 0.7296, Adjusted R-squared: 0.7151 F-statistic: 50.36 on 3 and 56 DF, p-value: 6.521e-16 . | . Now we have a model of the form $\\hat L = 11.55 - 8.255s + 7.811d + 3.904sd$, where $L$ stands for tooth length, $s$ for whether the VC supplement was given, and $d$ for the dose given. Content last modified on 16 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-add-an-interaction-term-to-a-model/#solution-in-r",
    "relUrl": "/how-to-add-an-interaction-term-to-a-model/#solution-in-r"
  },"85": {
    "doc": "How to add an interaction term to a model",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-add-an-interaction-term-to-a-model/#topics-that-include-this-task",
    "relUrl": "/how-to-add-an-interaction-term-to-a-model/#topics-that-include-this-task"
  },"86": {
    "doc": "How to add an interaction term to a model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-add-an-interaction-term-to-a-model/#opportunities",
    "relUrl": "/how-to-add-an-interaction-term-to-a-model/#opportunities"
  },"87": {
    "doc": "How to add details to a plot (in Python, using Matplotlib)",
    "title": "How to add details to a plot (in Python, using Matplotlib)",
    "content": "# How to add details to a plot (in Python, using Matplotlib) [See all solutions.](../how-to-add-details-to-a-plot) ## Task After making a plot, we might want to add axis labels, a title, gridlines, or text. Plotting packages provide tons of tools for this sort of thing. What are some of the essentials? Related topics: * [How to create basic plots](../how-to-create-basic-plots) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some fake data using Python lists, for simplicity. But everything we show below works also if your data is in columns of a DataFrame, such as `df['age']`. ```python patient_height = [ 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ] patient_weight = [ 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ] ``` The conventional way to import matplotlib in Python is as follows. ```python import matplotlib.pyplot as plt ``` The following code creates a plot with many details added, but each is independent of the others, so you can take just the bit of code that you need. ```python plt.scatter( patient_height, patient_weight ) plt.xlabel( 'This is the x axis label.' ) plt.ylabel( 'This is the y axis label.' ) plt.title( 'This is the title.' ) plt.grid() # Turns on gridlines plt.text( 70, 200, 'Text at (70,200)' ) # Text method 1 plt.annotate( 'Text at (60,150)', (60,150) ) # Text method 2 plt.annotate( 'Text with arrow', xytext=(60,225), xy=(72,244), arrowprops={'color':'red'} ) # Text with arrow plt.show() ``` ![png](data:image/png;base64,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 ) Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to add details to a plot/Python, using Matplotlib.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-add-details-to-a-plot-in-python-using-matplotlib/",
    "relUrl": "/how-to-add-details-to-a-plot-in-python-using-matplotlib/"
  },"88": {
    "doc": "How to add details to a plot (in R)",
    "title": "How to add details to a plot (in R)",
    "content": "# How to add details to a plot (in R) [See all solutions.](../how-to-add-details-to-a-plot) ## Task After making a plot, we might want to add axis labels, a title, gridlines, or text. Plotting packages provide tons of tools for this sort of thing. What are some of the essentials? Related topics: * [How to create basic plots](../how-to-create-basic-plots) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some fake data using R vectors, for simplicity. But everything we show below works also if your data is in columns of a data frame, such as `df$age`. ```R patient_height <- c( 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ) patient_weight <- c( 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ) ``` The following code creates a plot with many details added, but each is independent of the others, so you can take just the bit of code that you need. ```R plot( patient_height, patient_weight, main=\"This is the title.\", xlab=\"This is the x axis label.\", ylab=\"This is the y axis label.\" ) # Scatter plot with labels grid() # Turns on gridlines text( 70, 200, \"Text at (70,200)\" ) # Add text text( 65, 225, \"Point 1\", pos=2 ) # Text to the left of a point text( 72, 244, \"Point 2\", pos=4 ) # Text to the right of a point arrows( 65, 225, 72, 244, col='red' ) # Arrow from (65,225) to (72,244) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAIAAAByhViMAAAACXBIWXMAABJ0AAASdAHeZh94 AAAgAElEQVR4nOzde1xM+f8H8PdUU6EIqaSUS0uJLWE3yS3WPeQWlpVl3XexWuyXkl23/VqE 7GZda92J1rp8l3VZl2y0bj+sayEVInS/TPP749j59q3UlHmfmTlezz9+j86Z05n39H39zr7N vOd8ZEqlkgAAAABA/xlouwAAAAAA0Aw0dgAAAAASgcYOAAAAQCLQ2AEAAABIBBo7AAAAAIlA YwcAAAAgEWjsAAAAACQCjR0AAACARKCxAwAAAJAINHYAAAAAEoHGDgAAAEAi0NgBAAAASAQa OwAAAACJQGMHAAAAIBFo7AAAAAAkAo0dAAAAgESgsQMAAACQCDR2AAAAABKBxg4AAABAItDY AQAAAEgEGjsAAAAAiUBjBwAAACARaOwAAAAAJAKNHQAAAIBEoLEDAAAAkAg0dgAAAAASgcYO AAAAQCLQ2AEAAABIBBo7AAAAAIlAYwcAAAAgEWjsAAAAACQCjR0AAACARKCxAwAAAJAINHYA AAAAEoHGDgAAAEAi0NgBAAAASAQaOwAAAACJQGMHAAAAIBFo7AAAAAAkAo0dALDYvXu3TCaT yWSmpqaaPVjjz64XT6SRArReLQBwQ2MHAGrp0qWLTD0//vijtosFAHhHGWm7AAAAcnNzW758 OREZGWnmoqTxExLR48eP69Wrp1Aobty40bRpU02d9i0LeNMr1Xq1AKAVaOwAQC1eXl5mZmaq zfv371+6dEn4uWfPnnK5XPVQgwYNKnryxo0bT5069e2L5DshEe3cuVOhUGj2nG9fwJteqdar BQCtQGMHAGoJCQkpurlu3bqxY8cKP2/ZssXCwkIbRYlqx44delSA1qsFAK3AjB0A8DIwMCCi U6dOde3atWbNmmZmZt7e3kePHi16zJuG+gsKCtauXdulSxcrKyu5XG5lZdW6detFixalpqaW /aSaPWHv3r1lMtmZM2eETWdnZ5lMVux9MnVepuDmzZvjx493cnIyNTWtXr1669atV65cWVBQ ULkCSr5SdarVSFUAoIPwjh0A8DI1Nf3tt9/69OmTl5cn7Dl9+nT37t0PHTrUtWvXMn4xPz// o48+OnHihGrP06dPnz59euHChXXr1v3222+NGjWqUCUaP2FRar7MqKio4cOH5+TkCJu5ubkX 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 pZWVVcn3HevXrz9//vysrCyO59VsY5efn5+fn6+RUwGoIFe6qWRj9+TJEwcHhxo1asycOTMy MnLhwoV2dnYmJiYnTpwQDhg/fjwRHTlyRNjcvXs3EU2bNk2pVMbExIwYMYKIgoKC9u7d++zZ s1Kf9MKFC6ampra2tvPnz1+7du2sWbPMzc2trKxSU1PVP8n58+eJaPLkyWXkavny5UR0/Phx YTM7O9vQ0NDHx6fYYaNGjSKiu3fvqvEHUyqVypycHLlc7uXlpc451XzSwsLCOnXqNG7cWM0a gJUErle63NjpzYIekllSDHfcBg7Ilb4IDg5+9OhRTExMq1athD0ff/xxs2bNZsyYIfRS//73 vw8fPjxx4sSrV68WFBRMmzbtvffeW7BgARF9+OGHwr3iPT09u3fv/qaniI2NdXFx+f777zt2 7CjsqVev3pQpU7Zt2zZ58mQ1TyKsFenu7v748eNSc5WZmblw4UIfHx/Vszx8+FChUJQc0XZw cCCie/fuqTlfGB4enp+f7+/vr845FQqFOk8qk8k6d+68Y8eOhIQER0dHdcoAPrhesdKbxk4y S4phaBQ4IFd6QalU7tq1q0WLFnZ2dikpKcJOuVzetm3b//znPxkZGWZmZmZmZhs2bPDx8Vm0 aFFmZuajR49Onz5dpUoV9Z9lwoQJwg2qiCg/P1+hULi4uBCR6our6rh9+zYRNWjQ4E3RWr16 9dOnT4ODg1V70tPTiUj4J3dRZmZmqkfLdfLkycDAwHbt2gnvXJZ7TvWf1MnJiYju3LmDxk7r cL1ipTeNnTpLiv3xxx9RUVEVauwKCwsPHjyYnZ1dxjFxcXEuLi7Z2dnVqlUT4ihcLMzMzCqx KVyAlErl258Km9hErnR8s7CwkP6Rnp7+5MmT1NTU1NTUunXrUgk3btxo1aqVTCbr1KnTmDFj Fi9eXFhY+OWXX3p6eqrOLByZnZ2dnp5exvNu3779559/vnLlyosXL1TnF76um56eXvRuoG96 CampqURkZ2dXrVq1krnKyclZunSpl5eXm5ub6tGsrCwq8t9s1cFKpZKIcnJyyq6ZiPbv3z96 9GhXV9ctW7ZkZ2erXm9+fn6x383JySn6XMLnekVPJfzlZTKZ6omEMZ6HDx+WWwY2cb0qdzMz M1P495IO0pvGTs0lxfbu3Vuh096/f//TTz8t+QX+onJzcydPnvz06dPq1aubmJjk5eU9evRI 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 ia1bt9b+vGHDBovF0rVrV+1igwYNEhMT5Q6XW0pKSq1atQq+T+3atbWVzNLs8uXLpf+QKLxr 166ZzeZ8X28NCgoym83Xrl3T4Rh0BQl0BQl0Jcr6vJx7yXHjxo1ubm5NmzbVLloslnv37kkd 7X9Vq1bt8OHDBd/n0KFD1apV0+c8RcbSqMGUL19eKfXnn3/ef9ONGzdy7iCNriCBriCBrkRZ /4ldQEDA9u3blVKXL19eu3Zt69atnZyctJsOHz6svQdQBy+99NLy5cs/+eQT7YXtPG7fvj16 9Og1a9Z06dJFn/MUWdWqVdkbNRJ3d/eQkJBVq1bdf9Pq1atDQ0P1eXcRXUECXUECXYmy/hO7 bt26DR8+PCEh4ezZs2lpae+88452/YIFC+bPn59zUdqYMWN27NgxZMiQsWPHNmzY0M/Pz93d 3WKxpKWlnT17dt++fXfu3GnatOnIkSP1OU+R8YnbxjNs2LDu3buHh4dHRUXlXPn9999PmTJl 0aJF+pyBriCBriCBrkRZH+wGDRp04sSJZcuWOTk5TZs2rVmzZtr1Q4cOffLJJ4cNGyZ8wv/w 9PTcs2fPzJkzFyxYsHXr1qysrJybHB0dGzRo0KtXr169epX+XAywNIo8OnfufPLkyZdffvm5 555r1KiRUmrv3r3bt2+Pi4vr1KmTPmegK0igK0igK1HW3xX7IL/88ktYWJhN/sOYzebz589r v3nCw8PD398/59VhCSX7rtiLFy8qPnHbiOLj4xcvXnzkyBGlVL169V599VXdPp1Y0RVk0BUk GKCr0vyu2PzHsuTkZGdnZ+2TfpOTk/O9T40aNbS3+3l7e8udL18uLi45b0K8d+/eiRMnzGZz 3bp1nZ2ddT5JEbA0alQhISF6TnJ50BVK1o0bN77//nsPDw+l1K1bt6Kiokr5Z7/DjvB8JSr/ wc7Hx6dNmzbr16/X/lzwQxT5Z34Pa/PmzePGjUtMTKxdu/bo0aMbNWq0YcOGXr16Xbp0SSnl 4eExceLEfv366XOYImNjFBLoCiVo5cqV0dHRrq6uTZo0UUrt3LkgopoEAAAgAElEQVTznXfe mTt3bocOHWx9NBgBz1ei8h/sunTpkvOzh1LyPtM9e/a0adMmMzPTw8Njw4YN27dv//nnnzt3 7lyhQoXXX3/dbDb//PPP/fv3r1mz5t/+9jdbH7YgpX8LEPaIrlBSdu7c2bVr1zFjxrz33nva sk1mZubHH3/ctWvXLVu2hIeH2/qAsHs8X4kq+o6dzqKiovbv379hw4bg4OCrV6926dLl9OnT Xl5ee/bscXV1VUrduHGjfv36Tz311E8//VSyfzW/eQKlH12hpLRo0SIgIGDevHnqf7vq2bPn uXPnNm/ebNvjwQAM8Hxlfzt2pdDu3bsHDhwYHByslKpcufLHH3/8l7/8ZezYsdpUp5Ty8vLq 3bv3Z5999rCPfOHChYyMjALucO3aNS8vLy1EjfaxzDm/J+qhLiYlJSml/Pz8iv9QXOQiXXGx ZC+mpaWdPHly9OjR2sXcXfXo0eO1115LS0vL+SduKTkzF+3uogGerzIzM0vt1qndDHY3b94M CAjIuai9m6Zy5cq57+Pj43Pr1q2HetjTp08HBgZavdvo0aMvXLjg4uLi4uKSkZFx4sQJpVRg YGARLt68eVM7efEfiotcpCsuluzFxMTE9evXa//rlaeratWqbdiwITEx0eaH5KK9XzTA89WZ M2f+/ve/q1LJbl6K9fb2jomJGTNmjHZx27ZtzZs3nzp16ttvv51znxEjRsydO/dBb+N9kIsX L+b72yxyLF269NNPPz1z5oynp6d2TXHGfLPZrJRycXEp/kNxkYt0xcWSvZiWlvbUU08tWrSo efPm6n+72rx582uvvXbixAl+YsfFYl40wPPVnTt3qlevvm7dulL4UqzdDHZdu3b917/+tWLF ivDw8H//+9+vvvpqZmbm7du3d+/erf307vfffw8PD2/ZsuXy5ctL9q8u2R07ACjNWrZsWb16 9fnz5+e5vkePHhcuXNi0aZNNTgWUKhns2BXf6NGjf/jhh4iICO1ixYoVd+7cGRkZ+cQTTzRq 1MhsNu/fv99isQwZMsS257TKAEujKIXoCiVl7NixLVq0CAoK+sc//qF93pjFYvnoo4+WLl26 detWW58ORsDzlagytj5AYT311FO7d+/u2rVro0aNevbsuXv37tq1a69bt65u3bpbt27ds2eP v7//ypUrGzZsaOuTWnH58uXLly/b+hQwGrpCSQkPD1+2bNmnn37q5+c3f/78+fPn+/n5ffrp p8uWLSuFP5yAPeL5SlRh5+WsrKycD55JT0+Pj493cnIKCQnR8/Oj69atu2TJkjzX7N27Ny0t 7e7du3neSFFq8YnbkEBXKEHt27dv0aLF2rVrtf2TSZMmvfDCCzlLxkAx8Xwlyvpgl5WV9fbb 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 XUECXUECXYlisNMbS6OQQFeQQFeQQFei2LHTG0ujkEBXkEBXkEBXohjs9MbSKCTQFSTQFSTQ lSheitUbS6OQQFeQQFeQQFeiGOz0xtIoJNAVJNAVJNCVKPsb7CwWS0JCwpkzZ1JTU5VSFSpU CAoK8vPzs/W5CoulUUigK0igK0igK1H2NNjduHFj/PjxCxcuvHLlSp6b/P39e/fuHRsb6+rq apOzFZ62MVq2rD1951H60RUk0BUk0JUou/m2JiUlhYeHJyQkBAUFtW3bNiAgwM3NTSl169at 06dPb9u2bdSoUStXrtyyZYuXl5etD1sQbWPU19fX1geBodAVJNAVJNCVKLsZ7N5///0LFy58 ++23nTp1uv/WrKys2bNnDxgwIC4ubsqUKfofr/BYGoUEuoIEuoIEuhJlN4PdDz/80L1793yn OqWUg4NDv379tm/fvmrVqlI+2LE0Cgl0BQl0BQl0JcpuPscuJSWlVq1aBd+ndu3apf+jcRwc HNgbRYmjK0igK0igK1F2M9hVq1bt8OHDBd/n0KFD1apV0+c8RcYnbkMCXUECXUECXYmym8Hu pZdeWr58+SeffJKenn7/rbdv3x49evSaNWu6dOmi/9keCp+4DQl0BQl0BQl0JcpuduzGjBmz Y8eOIUOGjB07tmHDhn5+fu7u7haLJS0t7ezZs/v27btz507Tpk1Hjhxp65NawdIoJNAVJNAV JNCVKLsZ7Dw9Pffs2TNz5swFCxZs3bo1Kysr5yZHR8cGDRr06tWrV69epf9le5ZGIYGuIIGu IIGuRNnNYKeUcnJyGjRo0KBBg8xm8/nz57XfPOHh4eHv7+/k5GTr0xVW6R89YY/oChLoChLo SpQ9DXY5XFxcgoKClFJZWVnHjx8/cOCAn5+fvfxWMT5xGxLoChLoChLoSpTdvHlCKbV79+4B AwbkXFy0aJGvr29wcHB4eLi/v39ISMj27dtteLxCYmkUEugKEugKEuhKlN3My1u3bm3Tpo2T k9P06dNNJtOKFSu6d+/u7u7eqVOnypUrnzx5ctOmTa1bt961a1eDBg1sfdiCsDQKCXQFCXQF CXQlym4Gu7i4OE9Pz127dmlBvPfeewEBAXv27PHx8dHusHfv3hYtWsTFxX3//fc2PakVLI1C Al1BAl1BAl2JspuXYg8ePPj6668HBgYqpW7evJmQkPDuu+/mTHVKqUaNGr322ms7duyw3RkL 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 gg==) Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to add details to a plot/R.Rmd). Contributed by Debayan Sen (DSEN@bentley.edu) ",
    "url": "/how-to-add-details-to-a-plot-in-r/",
    "relUrl": "/how-to-add-details-to-a-plot-in-r/"
  },"89": {
    "doc": "How to add details to a plot",
    "title": "How to add details to a plot",
    "content": " ",
    "url": "/how-to-add-details-to-a-plot/",
    "relUrl": "/how-to-add-details-to-a-plot/"
  },"90": {
    "doc": "How to add details to a plot",
    "title": "Description",
    "content": "After making a plot, we might want to add axis labels, a title, gridlines, or text. Plotting packages provide tons of tools for this sort of thing. What are some of the essentials? . Related topics: . | How to create basic plots | How to create a histogram | How to create a box (and whisker) plot | How to change axes, ticks, and scale in a plot | How to create bivariate plots to compare groups | How to plot interaction effects of treatments | . ",
    "url": "/how-to-add-details-to-a-plot/#description",
    "relUrl": "/how-to-add-details-to-a-plot/#description"
  },"91": {
    "doc": "How to add details to a plot",
    "title": "Using Matplotlib, in Python",
    "content": "View this solution alone. We will create some fake data using Python lists, for simplicity. But everything we show below works also if your data is in columns of a DataFrame, such as df['age']. | 1 2 . | patient_height = [ 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ] patient_weight = [ 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ] . | . The conventional way to import matplotlib in Python is as follows. | 1 . | import matplotlib.pyplot as plt . | . The following code creates a plot with many details added, but each is independent of the others, so you can take just the bit of code that you need. | 1 2 3 4 5 6 7 8 9 10 . | plt.scatter( patient_height, patient_weight ) plt.xlabel( 'This is the x axis label.' ) plt.ylabel( 'This is the y axis label.' ) plt.title( 'This is the title.' ) plt.grid() # Turns on gridlines plt.text( 70, 200, 'Text at (70,200)' ) # Text method 1 plt.annotate( 'Text at (60,150)', (60,150) ) # Text method 2 plt.annotate( 'Text with arrow', xytext=(60,225), xy=(72,244), arrowprops={'color':'red'} ) # Text with arrow plt.show() . | . Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-add-details-to-a-plot/#using-matplotlib-in-python",
    "relUrl": "/how-to-add-details-to-a-plot/#using-matplotlib-in-python"
  },"92": {
    "doc": "How to add details to a plot",
    "title": "Solution, in R",
    "content": "View this solution alone. We will create some fake data using R vectors, for simplicity. But everything we show below works also if your data is in columns of a data frame, such as df$age. | 1 2 . | patient_height &lt;- c( 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ) patient_weight &lt;- c( 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ) . | . The following code creates a plot with many details added, but each is independent of the others, so you can take just the bit of code that you need. | 1 2 3 4 5 6 7 8 9 . | plot( patient_height, patient_weight, main=\"This is the title.\", xlab=\"This is the x axis label.\", ylab=\"This is the y axis label.\" ) # Scatter plot with labels grid() # Turns on gridlines text( 70, 200, \"Text at (70,200)\" ) # Add text text( 65, 225, \"Point 1\", pos=2 ) # Text to the left of a point text( 72, 244, \"Point 2\", pos=4 ) # Text to the right of a point arrows( 65, 225, 72, 244, col='red' ) # Arrow from (65,225) to (72,244) . | . Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-add-details-to-a-plot/#solution-in-r",
    "relUrl": "/how-to-add-details-to-a-plot/#solution-in-r"
  },"93": {
    "doc": "How to add details to a plot",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA346 | . ",
    "url": "/how-to-add-details-to-a-plot/#topics-that-include-this-task",
    "relUrl": "/how-to-add-details-to-a-plot/#topics-that-include-this-task"
  },"94": {
    "doc": "How to add details to a plot",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-add-details-to-a-plot/#opportunities",
    "relUrl": "/how-to-add-details-to-a-plot/#opportunities"
  },"95": {
    "doc": "How to analyze the sample means of different treatment conditions (in Python, using Matplotlib and Seaborn)",
    "title": "How to analyze the sample means of different treatment conditions (in Python, using Matplotlib and Seaborn)",
    "content": "# How to analyze the sample means of different treatment conditions (in Python, using Matplotlib and Seaborn) [See all solutions.](../how-to-analyze-the-sample-means-of-different-treatment-conditions) ## Task In a single-factor experiment with three or more treatment levels, how can we compare them to see which one impacts the outcome variable the most? ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data('ToothGrowth') ``` To visually plot the means of the length of the tooth based on the Vitamin C dosage levels we can create a pointplot. We will have to import the `seaborn` and `matplotlib.pyplot` packages to be able to create it. ```python import seaborn as sns import matplotlib.pyplot as plt sns.pointplot( x = 'dose', y = 'len', data = df, ci = 95, # ci stands for Confidence Interval capsize = 0.1 ) # the width of the \"caps\" on error bars plt.show() ``` ![png](data:image/png;base64,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 ) The point plot informs us that as the dosage levels increase, the tooth length also increases. To obtain the actual numbers, we can use the `groupby` function to compute the treatment level means, and the `mean` function to compute the mean for the entire column. ```python df.groupby('dose')['len'].mean() ``` dose 0.5 10.605 1.0 19.735 2.0 26.100 Name: len, dtype: float64 ```python df['len'].mean() ``` 18.813333333333336 If you wish to display the difference between the overall mean and the group means, you can subtract the overall mean from the treatment level means. ```python df.groupby('dose')['len'].mean() - df['len'].mean() ``` dose 0.5 -8.208333 1.0 0.921667 2.0 7.286667 Name: len, dtype: float64 Content last modified on 26 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to analyze the sample means of different treatment conditions/Python, using Matplotlib and Seaborn.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-analyze-the-sample-means-of-different-treatment-conditions-in-python-using-matplotlib-and-seaborn/",
    "relUrl": "/how-to-analyze-the-sample-means-of-different-treatment-conditions-in-python-using-matplotlib-and-seaborn/"
  },"96": {
    "doc": "How to analyze the sample means of different treatment conditions (in R, using gplots and emmeans)",
    "title": "How to analyze the sample means of different treatment conditions (in R, using gplots and emmeans)",
    "content": "# How to analyze the sample means of different treatment conditions (in R, using gplots and emmeans) [See all solutions.](../how-to-analyze-the-sample-means-of-different-treatment-conditions) ## Task In a single-factor experiment with three or more treatment levels, how can we compare them to see which one impacts the outcome variable the most? ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R df <- ToothGrowth ``` To visually plot the means of the length of the tooth based on the Vitamin C dosage levels we can create a pointplot. We will use the `gplots` package. In the code below, `bars=TRUE` gives 95% confidence intervals for the means. ```R # install.packages(\"gplots\") # If you have not yet installed it library(gplots) plotmeans(len~dose, data=df, bars=TRUE) ``` Attaching package: ‘gplots’ The following object is masked from ‘package:stats’: lowess ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAIAAAByhViMAAAACXBIWXMAABJ0AAASdAHeZh94 AAAgAElEQVR4nOzdaUBU9eL/8YMIBirQFXfBJe1mea+ZK4n7Lw1wwWETTcSFQMRMc60wMQkp tzG1cEfFXRFNvYKAso4C1z3NfQvFUlRA2ef/wP5mXhIXmO+cM+/Xozwz6OdB4bv5nhmMtFqt BAAAAPmrInoAAAAAKgZhBwAAoBCEHQAAgEIQdgAAAApB2AEAACgEYQcAAKAQhB0AAIBCEHYA AAAKQdgBAAAoBGEHAACgEIQdAACAQhB2AAAACkHYAQAAKARhBwAAoBCEHQAAgEIQdgAAAApB 2AEAACgEYQcAAKAQhB0AAIBCEHYAAAAKQdgBAAAoBGEHAACgEIQdAACAQhB2AAAACkHYAQAA KARhBwAAoBCEHQAAgEIQdgAAAApB2AEAACgEYQcAAKAQhB0AAIBCEHYAAAAKQdgBAAAoBGEH AACgEIQdAACAQhB2AAAACkHYAQAAKARhBwAAoBCEHQAAgEIQdgAAAApB2AEAACgEYQcAAKAQ hB0AAIBCEHYAAAAKQdgBAAAoBGEHAACgEIQdAACAQhB2AAAACkHYAQAAKARhBwAAoBCEHQAA gEIQdgAAAApB2AEAACgEYQcAAKAQhB0AAIBCEHYAAAAKQdgBAAAoBGEHAACgEIQdAACAQhB2 AAAACkHYAQAAKARhBwAAoBCEHQAAgEIQdgAAAApB2AEAACgEYQcAAKAQhB0AAIBCEHYAAAAK QdgBAAAoBGEHAACgEIQdAACAQhB2AAAACkHYAQAAKARhBwAAoBCEHQAAgEIQdgAAAApB2AEA ACgEYQcAAKAQhB0AAIBCEHYAAAAKQdgBAAAoBGEHAACgEIQdAACAQhB2AAAACkHYAQAAKARh BwAAoBCEHQAAgEIQdgAAAApB2AEAACgEYQcAAKAQhB0AAIBCEHYAAAAKQdgBAAAoBGEHAACg EIQdAACAQhB2AAAAClFV9AB5OHbsWHFxsegVAABAL1StWrV169aiV5SBsCtfenp6+/btRa8A AAB6JC0trV27dqJXPI2wK19hYaEkSQUFBaampqK3AAAAwQoLC6tVq/YoD/QN99gBAAAoBGEH AACgEIQdAACAQhB2AAAACkHYAQAAKARhBwAAoBCEHQAAgEIQdgAAAApB2AEAACgEYQcAAKAQ hB0AAIBCEHYAAAAKQdgBAAAoBGEHAACgEIQdAACAQhB2AAAACkHYAQAAKARhBwAAoBCEHQAA gEIQdgAAAApRVfQAAADwp6IiKTFRKi19+npxsXT1qtSsWRlfYm0tvfuuDqZBBgg7AAD0yM8/ S+7uZYRdUZGUlydZWZXxJW+8IaWl6WAaZICwAwBAj7RuLf3+exnXd++WPDykO3d0Pgiywj12 AAAACkHYAQAAKARhBwAAoBCEHQAAgEIQdgAAAApB2AEAACgEYQcAAKAQhB0AAIBCEHYAAAAK QdgBAAAoBGEHAACgEIQdAACAQhB2AAAACkHYAQAAKARhBwAAoBCEHQAAgEIQdgAAAApB2AEA ACgEYQcAAKAQhB0AAIBCEHYAAAAKQdgBAAAoBGEHAACgEIQdAACAQhB2AAAACkHYAQAAKARh BwAAoBCEHQAAgEIQdgAAAApB2AEAACgEYQcAAKAQhB0AAIBCEHYAAAAKQdgBAAAoBGEHAIAM VKsmVasmegT0HmEHAIAM9OolHTkiegT0HmEHAIAMGBlJtraiR0DvEXYAAAAKQdgBAAAoBGEH AACgEIQdAACAQhB2AAAACkHYAQAAKARhBwAAoBCEHQAAgEJUFT0AAACU48yZMxkZGVlZWS1a tHj//fdr1aolehH0FGEHAID+unPnzsiRI3fs2NGoUaO6deueO3euuLh4xowZkyZNEj0N+oiw AwBAT5WUlDg5OeXl5R09erR169aSJJWWlq5du9bf39/IyGjixImiB0LvEHYAAOip9evXnz59 +syZM/Xq1Xt0pUqVKsOGDZMkyd/ff+TIka+//rrQgdA7vHkCAAA9tWvXLhcXl8dV99iQIUNM TU1jY2OFrII+I+wAANBTmZmZzZo1e/TPISEh//rXvx79c9WqVW1tbTMzM8VNg57iKBYAAD1l ZWX1+++/l5SUBAQEhIeHR0REPH7o999/t7KyErgN+omwAwBAT3Xr1m3JkiXnzp1LTU3dt29f ly5dHl1PSkq6ceNG165dxc6DHuIoFgAAPeXi4pKZmXnw4MG4uLjHVXf27Nlhw4Z5eXk1adJE 6DroI16xAwBAH128eNHBwaFx48Z5eXmOjo49evSoW7fuL7/8EhMT88EHHyxZskT0QOgjXrED AEDvHD582M7OrnHjxunp6WfOnAkMDDQzM/vll1/eeuutHTt27Nq1y9zcXPRG6CNesQMAQL/s 3LnT09PT3d196dKlJiYmkiT5+fmJHgV54BU7AAD0yMqVK11cXMaOHbtq1apHVQc8P8IOAAC9 oNVqZ8yY4evru3jx4tmzZ4ueA1niKBYAAPEKCwtHjhy5Y8eOqKgoR0dH0XMgV4QdAACC5ebm urm5HT169MCBA23bthU9BzJG2AEAINKNGzecnJzy8/M1Gk3jxo1Fz4G8cY8dAADCnDp1qlOn TtWqVUtISKDq8OoIOwAAxIiPj7e3t2/btm1cXJy1tbXoOVACwg4AAAG2bdvm6Ojo5eW1detW MzMz0XOgEIQdAAC6plarPTw8ZsyYoVarq1Th72JUGP5lAgBAd0pKSsaOHTtlypR169ZNmTLl +b8wI0N6773K2wWF4F2xAADoSEFBgZeXV0xMTHR0dNeuXV/oa2/elM6eraRdUA7CDgAAXbhz 586AAQOuX7+enJzcsmVL0XOgTIQdAACV7tKlSw4ODqampomJiY0aNRI9B4rFPXYAAFSu9PR0 Ozs7GxubpKQkqg6VirADAKASxcTE9OzZ88MPP9yzZ4+FhYXoOVA4eYddYWFhWlpafHz8pUuX RG8BAOBpq1atcnJy8vf3X7VqlYmJieg5UD7ZhN2sWbPi4+OfvBIWFlavXr0OHTr07NmzWbNm 7dq1O3r0qKh5AAA8SavVzpgx4+OPP164cOHs2bONjIxEL4JBkE3YBQYG7tu37/Evd+/e7efn 9+DBg4EDB/r6+nbu3DkjI6N79+4XLlwQOBIAAEmSiouLfX1958yZExkZ6efnJ3oODIhc3xU7 fvx4S0vL1NTUx+8Y3759u6ura3Bw8MqVK8VuAwAYstzcXHd39//+978HDhxo166d6DkwLLIM u99+++3cuXOff/75k58DpFKpBgwYEB0dLXAYAMDA3bhxo2/fvvfu3UtMTGzRooXoOTA4sjmK fVJ+fr4kSf/76Y6tWrW6deuWiEUAAEinT5+2s7MzMTFJTU2l6iCELMOuQYMGlpaW169ff+p6 ZmZmzZo1hUwCABi41NTUrl27tmnTJj4+vnbt2qLnwEDJKeyuXr2anp5+/vz57Oxsf3//FStW PHjw4PGjZ86c2bRpU+fOnQUuBAAYpu3bt/fq1cvT03Pr1q1mZmai58BwySnsNmzY0L59+xYt WtSuXTskJOT8+fN79+599ND69evbtWv38OHDwMBAsSMBAIZGrVa7u7tPnjx54cKFxsbGoufA oMnmzROrVq26+4R79+7dvXv39ddff/To3bt3raysNm7c2L59e7E7AQCGQ6vVTp06dcGCBWvW rBk8eLDoOYB8ws7b2/sZj3p5efn5+VWp8sIvQObn5y9duvThw4fPeM7Fixdf9LcFACheQUGB t7f3f/7zn3379nXv3l30HECSZBR2z1ajRg1JkrKzs+/du9ekSZPn/8Lbt29v2LChqKjoGc/5 /fffJUkqLCw0NTV9tZkAAIXIzs52dnY+f/78gQMHWrduLXoO8Ac5hd3x48enTZt26tQpGxsb T09PX1/fp25lCA0NDQ0N1Wq1z/97NmzYMDU19dnPCQsL43PDAQCPXb582dHR0djYWKPR2NjY iJ4D/Ek2YZecnNyrV6+CggJzc/PMzMykpKTNmzdHRkY+vs0OAAAdOHHihKOj45tvvrl9+3ZL S0vRc4C/kM27YkNCQkpLSyMjI3Nzc3NycubNm5eSktKnT5+8vDzR0wAAhmL//v329vY9evTY u3cvVQc9JJuwO378uIeHh7Ozs5GRUbVq1caPH/+f//zn2LFj7u7uJSUlotcBAJQvPDzc0dHR 29t79erV3HUN/SSbsLt582azZs2evNKzZ8/ly5fv2bNnwoQJolYBAAxEaGjoqFGjFixYoFar X+JDGADdkM09dnXr1j169OhTF4cOHXr69OmQkJBGjRpNmjRJyDAAgLKVlJSMGTNm7dq127dv 79evn+g5wLPIJuxUKtX333+/aNEiX19fExOTx9eDg4MzMzMnT56cmZnJmSwAoGLl5eV5eHho NJro6Gh+aiX0n2zCbvr06Tt27Bg7dmxUVFRMTMzj60ZGRqtWrbK0tFywYIHAeQAA5bl582bf vn2zs7NTUlLefPNN0XOA8snmLoFatWplZGT4+/u3atXqqYeMjIzUavW2bdveeOMNIdsAAMpz 4cKFrl27Ghsbp6amUnWQC9m8YidJkrW19eLFi//uUZVKpVKpdLkHAKBUGo2mf//+dnZ2GzZs MDc3Fz0HeF6yecUOAADd2LFjR8+ePfv3779t2zaqDvJC2AEA8KeFCxe6urpOnjx5+fLlVavK 6VwLkOR1FAsAQOXRarVBQUEhISGrV6/+6KOPRM8BXgZhBwCAVFhYOHz48J07d0ZFRX344Yei 5wAvibADABi6u3fvOjs7nz17NjEx8d133xU9B3h5hB0AwKBlZmY6OjoWFxdrNBpbW1vRc4BX wpsnAACG6+TJk506dfrHP/6RlJRE1UEBCDsAgIGKjY21t7fv2LHjnj17rKysRM8BKgBHsQAA Q7R27dqRI0eOHj16/vz5Varo0cscly9LY8ZIhYVPX//9dyk/X/rggzK+pHlz6YcfdDANMkDY AQAMjlqtnjhx4oIFC8aMGSN6y9Nq1JDefVcqKXn6+sOHUp06Ups2ZXyJjY0OdkEeCDsAgAEp KSkZO3bsypUrIyIi3N3dRc8pg7W1FBwsegRki7ADABiKvLw8T0/P5OTk/fv329vbi54DVDzC DgBgEG7fvt2/f/8bN26kpKT885//FD0HqBR6dLsoAACV5OLFi++//35RUVFqaipVBwUj7AAA Cnf48GE7O7smTZrExsbWrVtX9BygEhF2AAAli4qK6tGjh5OT008//VSzZk3Rc4DKRdgBABRr xYoVbm5ukyZNWrlypYmJieg5QKXjzRMAAAXSarVBQUHBwcFLlizx8fERPQfQEcIOAKA0hYWF I0aMiIqK2rlzp4ODg+g5gO4QdgAARcnJyXFzczt+/PjBgwffe+890XMAnSLsAADKkZmZ6eTk VFhYmJqa2rhxY9FzAF3jzRMAAIU4deqUnZ2dmZnZwYMHqToYJsIOAKAE8fHx9vb27dq1i42N tba2Fj0HEIOwAwDI3tatWx0dHb28vLZs2WJmZiZ6DiAMYQcAkDe1Wj1o0KCgoCC1Wl2lCn+v waDx5gkAgFyVlJSMGzdu+fLl69atGzRokOg5gHiEHQBAlvLz8728vPbv3x8dHd21a1fRcwC9 QNgBAOTnzp07AwYMuH79ekpKyltvvSV6DqAvCDsAgMxcunTJwcGhWrVqSUlJDRs2FD0H0CPc ZAoAkJO0tDQ7OzsbG5vExESqDngKYQcAkI3o6OhevXp9+OGHe/bssbCwED0H0DuEHQBAHlau XOnk5OTv779q1SoTExPRcwB9RNgBAPSdVqudMWOGr6/vokWLZs+ebWRkJHoRoKd48wQAQK8V Fxf7+/uvX79+x44dTk5OoucAeo2wAwDor9zcXHd39yNHjhw8eLBt27ai5wD6jrADAOipGzdu 9O3b9/79+4mJic2bNxc9B5AB7rEDAOijn3/+2c7OztTUNCUlhaoDnhNhBwDQO6mpqd26dWvT pk1cXFzt2rVFzwFkg7ADAOiXbdu29ezZc/Dgwdu2bTMzMxM9B5ATwg4AoEfUarWHh8eUKVPU anWVKvwlBbwY3jwBANALWq12ypQpCxcuXLt2raenp+g5gCwRdgAA8QoKCoYNGxYdHb1v375u 3bqJngPIFWEHABAsOzt7wIABFy5ciI+Pb926teg5gIwRdgAAkS5fvuzg4FC1alWNRmNjYyN6 DiBv3JcKABDm+PHj9vb2DRs2TEpKouqAV0fYAQDEiImJ6dKlS69evfbu3WtpaSl6DqAEhB0A QIDVq1c7OTl5e3uvXr3axMRE9BxAIQg7AICuhYaG+vj4qNVqtVptZGQkeg6gHLx5AgCgOyUl JWPGjFm3bl1kZGTfvn1FzwGUhrADAOhIXl6eh4eHRqOJjo5+//33Rc8BFIiwAwDows2bN/v2 7ZudnZ2SkvLmm2+KngMoE/fYAQAq3fnz57t06WJsbJyamkrVAZWHsAMAVC6NRmNnZ/fOO+/E x8fXqVNH9BxAyQg7AEAlioyM7Nmzp7Oz89atW83NzUXPARSOsAMAVJaFCxe6ublNnjx52bJl VatyVzdQ6fjPDABQ8bRabVBQUEhISHh4+JAhQ0TPAQwFYQcAqGAFBQXDhw//6aefdu7c2adP H9FzAANC2AEAKlJ2dvbAgQPPnTuXkJDw7rvvip4DGBbCDgBQYX799VdHR8eSkpLU1FRbW1vR cwCDw5snAAAV48SJE506dapVq1ZycjJVBwhB2AEAKkBsbKy9vX2nTp327NljaWkpeg5goAg7 AMCrWrNmjYODg7e396ZNm1577TXRcwDDRdgBAF6JWq0eOXLk/Pnz1Wp1lSr8tQKIxJsnAAAv qaSkJCAgYPXq1evXr3dzcxM9BwBhBwB4KXl5eYMGDUpJSYmJibG3txc9B4AkEXYAgJdw+/bt /v3737hxIyUl5Z///KfoOQD+wM0QAIAXc+HCBTs7u6KiIo1GQ9UBeoWwAwC8gEOHDtnZ2TVt 2jQ2NrZOnTqi5wD4C8IOAPC8oqKievbs2a9fv927d9esWVP0HABPI+wAAM9l+fLlbm5ukyZN WrFiRdWq3KIN6CP+ywQAlEOr1QYFBQUHBy9ZssTHx0f0HAB/i7ADADxLYWHh8OHDd+7cuXPn TgcHB9FzADwLYQcA+Fs5OTmurq4nTpxISEho06aN6DkAykHYAQDKlpmZ6eTkVFhYqNFobG1t Rc8BUD7ePAEAKMPJkyc7depkZmaWkJBA1QFyQdgBAJ4WFxdnb2/foUOH2NjYWrVqiZ4D4HkR dgCAv9iyZYuTk9OwYcM2b95sZmYmeg6AF0DYAQD+pFarPT09Z86cqVarq1Th7whAZnjzBABA kiSppKTkk08+WbFiRUREhIeHh+g5AF4GYQcAkPLz84cOHRoXFxcTE9OlSxfRcwC8JMIOAAzd nTt3+vfvn5mZmZyc/NZbb4meA+DlEXYAYNAuXrzo6OhYrVq1xMTEhg0bip4D4JVwYywAGK60 tDQ7OztbW1uqDlAGXrEDgKeFh0vr1pVx/cYNSZKk+vXLeOijj6Rhwyp3VYXbt2+fm5ubi4vL 0qVLTUxMRM8BUAEIOwB42ltvSf/3f2Vc37JFkqSyH5LdnWkrV6709fX97LPPZs+eLXoLgApD 2AHA0zp2lDp2LOP6mTOSJElTpuh4TgXTarVBQUHBwcGLFy/++OOPRc8BUJEIOwAwIMXFxaNH j964cWNUVJSjo6PoOQAqGGEHAIYiNzfXzc3t6NGjBw4caNu2reg5ACoeYQcABuHGjRtOTk45 OTmJiYnNmzcXPQdApeDjTgBA+U6dOtWpU6dq1aqlpqZSdYCCEXYAoHApKSndunVr27ZtXFyc tbW16DkAKhFhBwBKtm3btl69eg0ZMmTr1q1mZmai5wCoXIQdACiWWq328PCYMmWKWq2uUoVv +IDy8eYJAFCgkpKSTz/9dNmyZevWrRs0aJDoOQB0hLADAKUpKCjw8vKKiYnZt29ft27dRM8B oDuEHQAoyp07d5ydnS9evHjgwIF///vfoucA0CnCDgCU49KlS46OjiYmJhqNplGjRqLnANA1 7qUFAIVIT0+3s7Nr2LBhUlISVQcYJsIOAJQgJiamZ8+effr02bt3r4WFheg5AMQg7ABA9lav Xu3k5DR8+PDVq1ebmJiIngNAGMIOAGRMq9XOmDHDx8dn4cKFarXayMhI9CIAIvHmCQCQq+Li 4jFjxkRERERGRvbt21f0HADiEXYAIEu5ubkeHh6HDh2Kjo5+//33Rc8BoBcIOwCQn5s3bzo5 Od27dy81NbVFixai5wDQF9xjBwAyc/r06U6dOpmYmFB1AJ5C2AGAnGg0mq5du7Zp0yYuLq52 7dqi5wDQL4QdAMhGZGRkz549nZ2dt2zZYm5uLnoOAL1D2AGAPKjVajc3t8mTJy9btqxqVe6Q BlAGvjUAgL7TarXTpk2bP3/+mjVrBg8eLHoOAP1F2AGAXisoKPD29t69e/euXbt69+4teg4A vUbYAYD+ys7OdnZ2Pn/+fEJCwrvvvit6DgB9R9gBgJ66fPmyo6OjsbGxRqOxsbERPQeADPDm CQDQRydOnOjSpUv9+vWTkpKoOgDPibADAL2zf/9+e3v77t27792719LSUvQcALJB2AGAfgkP D3d0dPT29g4PDzc1NRU9B4CcEHYAoEdCQ0NHjRq1YMECtVpdpQrfogG8GN48AQB6oaSkJCAg YM2aNdu3b+/Xr5/oOQBkibADAPHy8vI8PDw0Gk10dHTnzp1FzwEgV4QdAAiWlZXVt2/fO3fu pKSkvPnmm6LnAJAxbuAAAJEuXLjQpUsXIyOj1NRUqg7AKyLsAECYQ4cO2dnZtWzZ8sCBA3Xq 1BE9B4DsEXYAIMaOHTt69OjRr1+/bdu2mZubi54DQAkIOwAQ4Pvvv3d1dZ08efKKFSuqVuV2 ZwAVg+8mAKBTWq02KCgoJCRk9erVH330keg5ABSFsAMA3SksLBw+fPjOnTujoqI+/PBD0XMA KA1hBwA6cvfu3YEDB/7yyy8JCQlt2rQRPQeAAskv7LRa7aVLly5evJiTkyNJkqWlZYsWLWxs bETvAoBnyczMdHR0LCoq0mg0tra2oucAUCY5hV12dnZwcPDatWtv3br11EO2trajRo2aOHGi mZmZkG0A8AwnT550dHR84403IiMjraysRM8BoFiyCbsbN2507tz50qVLLVq0cHR0bNy4cfXq 1SVJun///oULFw4ePDh9+vRt27bFx8e//vrroscCwJ/i4uJUKtX//d//rVu37rXXXhM9B4CS ySbsAgMDr1+/vnnzZjc3t/99tKSkJCwsLCAgICgoaMGCBbqfB8AQqFQv/CVr164dNWqUn5/f /Pnzq1ThE6YAVC7ZfJfZvXv30KFDy6w6SZKMjY39/f3d3d23b9+u42EADEe/flK/fi/wfLVa PWLEiLlz56rVaqoOgA7I5hvN7du333jjjWc/p2XLlllZWbrZAwDPUFJSMmbMmClTpkRERAQE BIieA8BQyOYotkGDBseOHXv2c44cOdKgQQPd7AGAv/PgwYNBgwYlJyfv37/f3t5e9BwABkQ2 r9g5Oztv2bJlzpw5BQUF//toXl7eV199FRUV5eHhofttAPDY7du3e/fuffLkyeTkZKoOgI7J 5hW7GTNmJCYmTpo0aebMmR06dLCxsalRo4ZWq83Nzb1y5crhw4cfPHjQpUuXL7/8UvRSAIbr 4sWLDg4OFhYWqampdevWFT0HgMGRTdhZWVmlpqYuXrx4zZo1Bw4cKCkpefyQiYlJ27ZtR4wY MWLECGNjY4EjARiyw4cP9+vXr3Xr1tu2batZs6boOQAMkWzCTpIkU1PT8ePHjx8/Pj8//9q1 a49+8oSFhYWtra2pqenL/Z4FBQURERHFxcXPeE5iYuLL/eYADEdUVNTgwYM9PDzCwsJMTExE zwFgoOQUdo+99tprLVq0+N/r2dnZ9+7da9KkyfP/Vr/99ltYWNiTr/+V+RxJkrRa7QvOBGAo VqxYMXr06M8//3zGjBmitwAwaHIKu+PHj0+bNu3UqVM2Njaenp6+vr5PHbyGhoaGhoa+UIE1 atTo0KFDz35OWFiYn5+fkZHRy4wGoGharTYoKCg4OHjJkiU+Pj6i5wAwdLIJu+Tk5F69ehUU FJibm2dmZiYlJW3evDkyMpIfIAZAZ4qKiiRJenzSWlhYOHLkyB07dkRFRTk6OgqdBgCSJKOP OwkJCSktLY2MjMzNzc3JyZk3b15KSkqfPn3y8vJETwOgcEVFRXPmzPn3v/9do0aNGjVq/Pvf /54zZ052dvaAAQP2799/8OBBqg6AnpDNK3bHjx/38PBwdnaWJKlatWrjx49v3bq1g4ODu7v7 zp07eTMsgEqSn5/ft2/fEydOjB8/vkOHDpIkHT58ODQ0dObMmQ0bNtRoNI0bNxa9EQD+IJuw u3nzZrNmzZ680rNnz+XLl3t5eU2YMEGtVosaBkDZvv32259//jk9Pd3GxubRlbp16y5atOj+ /fsDBgyg6gDoFdkcxdatW/fo0aNPXRw6dOi0adMWLlz43XffCVkFQNm0Wu3SpUu/+OKLx1UX Hx9vb2/fsWPH0NDQdevW8X55AHpFNmGnUql27dq1aNGiRzcvPxYcHDxs2LDJkyePHz/+wYMH ouYBUKQ7d+78+uuvXbt2ffTLbdu2OTg4DB8+fMuWLT179vz111+zs7PFLgSAJ8nmKHb69Ok7 duwYO3ZsVFRUTEzM4+tGRkarVq2ytLRcsGCBwHkAFKm0tFSSpCpVqkiSdOTIkaFDh06fPv3z zz+XJOnRrb3P/hRMANAx2bxiV6tWrYyMDH9//1atWj31kJGRkVqt3rZt2xtvvCFkGwClqlWr Vp06dQ4fPnznzh1XV1dnZ+dHVSdJ0qFDh+rUqWNtbS12IQA8STav2EmSZG1tvfkqesYAACAA SURBVHjx4r97VKVSqVQqXe4BoHhVqlQZNmxYcHDw+vXra9SosWzZskfXb9++/eg+ED66HIBe kc0rdgAgRGBgYF5eXlxc3JAhQ65cufLzzz+vWrWqY8eOVlZWgYGBotcBwF8QdgDwLHFxcb/9 9puzs/PcuXPfeeedd955Z+rUqc7OzgkJCTVr1hS9DgD+Qk5HsQCgY2fPnh02bNhXX3316MW5 W7duSZJUp04d0bsAoGyEHQCULTc3d+DAgV27dv3iiy8eXSHpAOg5jmIBoAxarXbEiBFFRUVr 1qx59HEnAKD/eMUOAMowe/bsvXv3pqamWllZid4CAM+LsAOAp8XGxk6fPj0iIuJ/PzgTAPQZ 5wsA8BdXr14dNGjQ+PHj3d3dRW8BgBdD2AHAn/Lz811cXP71r3998803orcAwAvjKBYA/jRm zJisrKw9e/ZUrcq3RwDyw3cuAPjD4sWLIyIiEhMTa9euLXoLALwMwg4AJEmSUlNTJ0yYsHjx 4vbt24veAgAviXvsAEDKyspyc3MbPnz4qFGjnvG0hAQpIUFnowDghfGKHQBDV1RU5O7u3qhR I7Va/exnrlolSZLUtasuVgHASyDsABi6CRMm/PLLL+np6dWqVRO9BQBeCWEHwKBFRESEhYXF xMQ0atRI9BYAeFXcYwfAcB07duzjjz/+9ttvu3XrJnoLAFQAwg6AgcrOzlapVAMGDPj0009F bwGAikHYATBEpaWlQ4YMqV69+rJly0RvAYAKwz12AAxRYGCgRqM5fPhw9erVRW8BgApD2AEw ODt37gwNDY2KimrevLnoLQBQkTiKBWBYzp496+XlNX36dCcnJ9FbAKCCEXYADEhubq5KperS pcuXX34pegsAVDzCDoCh0Gq1I0aMKCwsXLt2bZUqfPcDoEDcYwfAUISGhu7Zs0ej0VhZWYne AgCVgrADYBBiY2MDAwPXrVvXqlUr0VsAoLJwGAFA+a5everp6fnpp596eHiI3gIAlYiwA6Bw +fn5Li4urVq1CgkJEb0FACoXR7EAFG7MmDFZWVm7d++uWpXveAAUjm9zAJRs8eLFERERCQkJ derUEb0FACodYQdAsTQazYQJExYvXtyhQwfRWwBAF8oPO61Wu3Xr1jVr1ly/fr2oqOh/n3Dy 5MlKGAYAryQrK8vV1XX48OGjRo0SvQUAdKT8sJs7d+6kSZMkSTI3NzcxMan8SQDwqoqKitzd 3Rs1aqRWq0VvAQDdKT/s1Gp1nz59lixZ0qxZMx0MAoBX99lnn505cyYjI6NatWqitwCA7pQf dllZWVu3bqXqAMjF+vXrf/jhh5iYmEaNGoneAgA6Vf7n2NWtW1er1epgCgC8uuPHj/v4+Hz7 7bfdu3cXvQUAdK38sPP09Fy7dq0OpgDAK8rOzlapVP379x8/frzoLQAgQPlHsdOnT3d1dR0y ZIiXl5etre3/vn+iefPmlbMNAF5AaWnpkCFDzM3Nly9fLnoLAIhRftjVrFnz0T+sX7++zCdw UAtAH0yfPj01NTUtLa169eqitwCAGOWHnaenp6mpKT+KB4A+27lz5+zZs6OiojhDAGDIys+1 v3uhDgD0xNmzZ728vAIDA52cnERvAQCRyn/zxGM5OTmnTp26e/du5a0BgBeVm5urUqm6dOkS GBgoegsACPZcYXfw4MF27dpZWFi0atVKo9E8uti/f//Y2NjK3AYA5dBqtSNHjiwoKFi7dm2V Ki/wf6oAoEjlfx88fPhw7969z54926dPn8cXf/vtt7S0NEdHx4yMjMqcBwDPEhoaunv37sjI SCsrK9FbAEC88sNu5syZ9erV+/nnn1evXv34Yu3atY8dO1avXr2vv/66EtcBwN+LjY0NDAxc sWJFq1atRG8BAL1QfthpNJrRo0f/70/mqVOnjp+fX0JCQuUMA4BnuXr1qqen57hx4zw8PERv AQB9UX7Y3bt3z8bGpsyH6tevn5ubW9GTAKAc+fn5Li4urVq1mj17tugtAKBHyv+4k3r16p0+ fbrMhxISEho0aFDRkwCgHGPGjMnKytq9ezcfsQkATyr/FTtHR8clS5b897//ffJidnb2F198 sWrVKj41CoCOLVmyJCIiYuvWrXXq1BG9BQD0S/lhFxQUVKNGjY4dOz5quGnTprVp06Z+/frf fPONra3t9OnTK38kAPxBo9FMmDBh0aJFHTp0EL0FAPRO+WFXr1699PR0Hx+fK1euSJJ09OjR o0eP1qxZc/To0WlpaXXr1q38kQAgSZKUlZXl6uo6bNiwUaNGid4CAProuW5PqVOnzpIlSxYv Xnzr1q2cnJyaNWvScwB0rLi42MPDo2HDhgsXLhS9BQD0VNlhd/369b/7gtdee62oqOjJJ/zv J6EAQIX77LPPTp8+nZGRUa1aNdFbAEBPlR12f/f5JmXSarUVNAYAyrZ+/folS5bExMTwf5IA 8Axlhx0f+AlAfxw/ftzHxyc0NLR79+6itwCAXis77DZu3KjjHQBQpuzsbJVK1b9//wkTJoje AgD6rvx3xQKAKKWlpR999JGJicnSpUtFbwEAGeBD2wHor+nTpycmJh4+fLhmzZq6/HNPn5YS E8u4fvasJElSmZHZpYvUsmXlrgKAchF2APTUzp07Q0JCtm7d+tZbb+n4j96/X1qwoIzr9+5J kiSFhpbxUEEBYQdAPMIOgD46e/asl5dXYGDgwIEDdf+njx0rjR2r+z8WAF4V99gB0Du5ubkq lapjx46BgYGitwCAnBB2APSLVqsdOXJkXl7e+vXrjY2NRc8BADnhKBaAfvn222937dqVnJxc q1Yt0VsAQGYIOwB6JC4u7ssvv1yxYkWbNm1EbwEA+eEoFoC+uHr16qBBg8aNG+fl5SV6CwDI EmEHQC/k5+e7urq++eabISEhorcAgFxxFAtALwQEBFy/fj0jI8PExET0FgCQK8IOgHg//PDD mjVr4uPj69evL3oLAMgYR7EABNNoNOPHj1+8eHHnzp1FbwEAeSPsAIiUlZXl5ubm4eHh4+Mj egsAyB5hB0CY4uJiDw+P2rVr//jjj6K3AIAScI8dAGEmTpx48uTJ9PR0MzMz0VsAQAkIOwBi bNiwYdGiRXv27GnSpInoLQCgEBzFAhDg+PHjPj4+oaGhvXv3Fr0FAJSDsAOga9nZ2SqVqnfv 3hMmTBC9BQAUhbADoFOlpaUfffSRiYnJ6tWrjYyMRM8BAEXhHjsAOvXVV18lJiYeOnTIwsJC 9BYAUBrCDoDu7Nq165tvvtmyZUvLli1FbwEABeIoFoCOnDt3bujQoYGBgSqVSvQWAFAmwg6A LuTm5g4cOLBjx46BgYGitwCAYhF2ACqdVqsdOXJkXl7e+vXrjY2NRc8BAMXiHjsAle67777b tWtXcnJyrVq1RG8BACUj7ABUrri4uC+++GLFihVt2rQRvQUAFI6jWACV6Nq1a4MGDfrkk0+8 vLxEbwEA5SPsAFSW/Px8FxeXN998c/bs2aK3AIBB4CgWQGUJCAi4fv16RkaGiYmJ6C0AYBAI OwCV4scff1yzZk18fHz9+vVFbwEAQ8FRLICKd+jQoU8//XTRokWdO3cWvQUADAhhB6CCZWVl ubq6uru7f/zxx6K3AIBhIewAVKTi4mIPD4/atWuHhYWJ3gIABod77ABUpIkTJ548eTItLc3M zEz0FgAwOIQdgAqzYcOGRYsW7dmzp2nTpqK3AIAh4igWQMU4fvy4j4/P7Nmze/fuLXoLABgo wg5ABcjOzlapVL179/7ss89EbwEAw0XYAXhVpaWlH330kYmJyerVq42MjETPAQDDxT12AF7V jBkzEhMTDx06ZGFhIXoLABg0wg7AK9m1a1dwcPCWLVtatmwpegsAGDqOYgG8vHPnznl5eQUG BqpUKtFbAACEHYCXlZubq1Kp2rdvHxgYKHoLAECSCDsAL0er1Y4cOTI3N3fDhg3Gxsai5wAA JIl77AC8nDlz5uzatSspKalWrVqitwAA/kDYAXhh8fHxn3/++fLly9977z3RWwAAf+IoFsCL uXbtmoeHx9ixY4cNGyZ6CwDgLwg7AC+goKDAxcWlRYsWs2fPFr0FAPA0jmIBvICAgIDr16+n p6ebmpqK3gIAeBphB+B5hYWFhYeHx8XFNWjQQPQWAEAZOIoF8FwOHTo0bty477//3t7eXvQW AEDZCDsA5cvKynJ1dXV3d/f19RW9BQDwtwg7AOUoLi728PCwtrYOCwsTvQUA8CzcYwegHJMm TTpx4kR6erqZmZnoLQCAZyHsADzLhg0bvv/++927dzdt2lT0FgBAOTiKBfC3Tpw44ePjM3v2 7D59+ojeAgAoH2EHoGzZ2dkqlap3796fffaZ6C0AgOdC2AEoQ2lp6dChQ6tWrbp69WojIyPR cwAAz4V77ACUISgoKCEh4dChQxYWFqK3AACeF2EH4Gk//fTTrFmztmzZ0rJlS9FbAAAvgKNY AH9x7ty5oUOHfvnllyqVSvQWAMCLIewA/CkvL0+lUrVv33769OmitwAAXhhhB+BPI0eOzM3N 3bBhg7GxsegtAIAXxj12AP4wZ86cnTt3JiUl1apVS/QWAMDLIOwASJIkxcfHT5s2bfny5e+9 957oLQCAl8RRLADp2rVrgwYNCggIGDZsmOgtAICXR9gBhq6goMDFxaV58+ahoaGitwAAXglH sYChCwgIuHbtWkZGhqmpqegtAIBXQtgBBi0sLCw8PDwuLq5BgwaitwAAXhVHsYDhOnTo0Lhx 4xYuXGhvby96CwCgAsj7FbvCwsJjx47l5uY2adKkadOmoucAcnLr1i1XV1d3d3c/Pz/RWwAA FUM2r9jNmjUrPj7+ySthYWH16tXr0KFDz549mzVr1q5du6NHj4qaB8hLcXGxh4eHtbV1WFiY 6C0AgAojm7ALDAzct2/f41/u3r3bz8/vwYMHAwcO9PX17dy5c0ZGRvfu3S9cuCBwJCAXkydP Pn78+Pbt283MzERvAQBUGLkexY4fP97S0jI1NbVly5aPrmzfvt3V1TU4OHjlypVitwF6buPG jQsXLty9ezc3MACAwsjmFbsn/fbbb+fOnRszZszjqpMkSaVSDRgwIDo6WuAwQP+dOHFi1KhR ISEhffr0Eb0FAFDBZBl2+fn5kiQ9WXWPtGrV6tatWyIWAfJw9+5dlUr1wQcfTJw4UfQWAEDF k2XYNWjQwNLS8vr1609dz8zMrFmzppBJgP4rLS396KOPjI2Nw8PDjYyMRM8BAFQ8OYXd1atX 09PTz58/n52d7e/vv2LFigcPHjx+9MyZM5s2bercubPAhYA+mzlzZkJCQmRkpIWFhegtAIBK Iac3T2zYsGHDhg1PXtm7d6+Li4skSevXr//4448fPnwYGBgoaB2g13766adZs2Zt2rTpf+9h AAAohmzCbtWqVXefcO/evbt3777++uuPHr17966VldXGjRvbt28vdiegh86fPz906NDPP//8 0f8IAQCUykir1YreUAFyc3PNzc2rVHnhk+XCwsKIiIiioqJnPCchISEiIiInJ6dGjRqvsBEQ Iy8vr1OnTvXr19+7d6+xsbHoOQAge4WFhdWqVUtOTn7//fdFb3mabF6xe7ZHyXX79u3s7Ozm zZs//xdmZWXNmTPn0dts/879+/clSVJGAcMAjRw5MicnJz4+nqoDAMVTSNg98t1334WGhr5Q gdnY2Jw6derZzwkLC/Pz8+NdhJCjOXPmREVFJScnW1tbi94CAKh0igo7AE+Kj4+fNm3asmXL 3nvvPdFbAAC6IKePOwHw/K5duzZo0KAxY8Z4e3uL3gIA0BHZvGLXrl27cp/z66+/6mAJoP8K CgpcXV2bN2/+7bffit4CANAd2YTdkSNHJEkyMTF5xnOKi4t1NQfQawEBAVevXs3IyDA1NRW9 BQCgO7I5ip00aVL16tVPnjyZ//f48ZeAJElLly4NDw/fsmVLgwYNRG8BAOiUbMLu66+/bt68 uaen57M/cw4wcIcPH/7kk08WLlxob28vegsAQNdkE3YmJiYRERGnTp36/PPPRW8B9NStW7dc XFzc3d39/PxEbwEACCCbe+wkSWrZsuXNmzefcSOdg4ODlZWVLicB+qO4uNjDw8Pa2josLEz0 FgCAGHIKO0mSLCwsnvFot27dunXrprMxgF6ZMmXK8ePH09PTzczMRG8BAIghs7ADUKaNGzeq 1erdu3c3bdpU9BYAgDCyuccOwN85ceLEqFGjvvnmmz59+ojeAgAQibAD5O3u3bsqleqDDz6Y NGmS6C0AAMEIO0DGtFrtiBEjjI2Nw8PDjYyMRM8BAAjGPXaAjAUFBe3fv1+j0Tz7fUUAAANB 2AFyFR0dPWvWrE2bNr399tuitwAA9AJHsYAsXb58efDgwdOmTXNxcRG9BQCgLwg7QH4ePnyo UqnatGkzY8YM0VsAAHqEo1hAfvz8/O7cuRMdHW1sbCx6CwBAjxB2gMzMnTt38+bNSUlJ1tbW orcAAPQLYQfISXJy8rRp05YuXdq2bVvRWwAAeod77ADZuHHjhpubm7+/v7e3t+gtAAB9RNgB 8lBUVOTm5ta0adNvv/1W9BYAgJ7iKBaQhzFjxly4cCEjI8PU1FT0FgCAniLsABlYs2bN6tWr Y2NjGzRoIHoLAEB/cRQL6LsjR474+fmp1eouXbqI3gIA0GuEHaDXbt++rVKpXFxcRo8eLXoL AEDfEXaA/iopKRk8eLCVlVVYWJjoLQAAGeAeO0B/TZkyJT09PT093dzcXPQWAIAMEHaAnoqM jFywYMFPP/3UtGlT0VsAAPLAUSygj86cOePt7R0cHPzhhx+K3gIAkA3CDtA7OTk5KpWqR48e kydPFr0FACAnhB2gX7Ra7bBhw0pLS9esWWNkZCR6DgBATrjHDtAvQUFB+/fv12g0FhYWorcA AGSGsAP0SHR09KxZszZu3Pj222+L3gIAkB+OYgF9cfny5cGDB0+dOtXV1VX0FgCALBF2gF54 +PChSqVq06ZNUFCQ6C0AALniKBbQC35+fnfu3ImOjjY2Nha9BQAgV4QdIN68efM2b96clJRk bW0tegsAQMYIO0Cw5OTkqVOnLl26tG3btqK3AADkjXvsAJFu3Ljh5uY2evRob29v0VsAALJH 2AHCFBUVubm5NWnS5LvvvhO9BQCgBBzFAsIEBARcuHAhIyPD1NRU9BYAgBIQdoAYa9euXbVq VWxsbIMGDURvAQAoBEexgABHjhzx9fVdsGBBly5dRG8BACgHYQfo2u3bt11cXFxcXPz9/UVv AQAoCmEH6FRJScngwYMtLCzCwsJEbwEAKA332AE6NWXKlPT09LS0NHNzc9FbAABKQ9gBuhMZ GblgwYKffvqpWbNmorcAABSIo1hAR86cOePt7T1r1qwPP/xQ9BYAgDIRdoAu5OTkqFSqHj16 TJkyRfQWAIBiEXZApdNqtd7e3qWlpeHh4UZGRqLnAAAUi3vsgEo3c+bMmJgYjUZjaWkpegsA QMkIO6ByxcTEzJo1a8OGDW+//bboLQAAheMoFqhEly9f9vT0nDJliqurq+gtAADlI+yAyvLw 4UMXF5c2bdoEBQWJ3gIAMAgcxQKVZfTo0bdv3963b5+xsbHoLQAAg0DYAZVi/vz5mzZtSkpK sra2Fr0FAGAoCDug4qWkpEydOvXHH39s27at6C0AAAPCPXZABbtx44arq6uvr+/w4cNFbwEA GBbCDqhIRUVF7u7uTZo0mTNnjugtAACDw1EsUJHGjh17/vz59PR0U1NT0VsAAAaHsAMqzNq1 a1euXBkbG9uwYUPRWwAAhoijWKBiHDlyxNfXd/78+V26dBG9BQBgoAg7oALcvn3bxcVFpVKN GTNG9BYAgOEi7IBXVVJSMnjwYAsLi6VLl4reAgAwaNxjBz01bZp04UIZ10+dkpo1k8zMnr5u aiqFhkpC7m2bOnVqenp6Wlqaubm5gD8eAID/j7CDnqpRQ3r99TKunz0r2dqW8ZCxsSTkB3dF RkbOnz9/165dzZo1E/DHAwDwBMIOeuqLL8q+HhEhBQRITk66XfM3zpw54+3tPWvWLAcHB9Fb AADgHjvgZeXk5KhUqh49ekyZMkX0FgAAJImwA16OVqv19vYuLS0NDw83MjISPQcAAEniKBZ4 OV9//XV0dPShQ4csLS1FbwEA4A+EHfDCYmJivv766w0bNrz99tuitwAA8CeOYoEXc/nyZU9P z8mTJ7u6uoreAgDAXxB2wAt4+PChi4vLu+++O3PmTNFbAAB4GkexwAsYPXr07du39+3bZyzk Q/MAAHgmwg54XgsWLNi0aVNSUpK1tbXoLQAAlIGwA55LSkrKlClTfvzxx7Zt24reAgBA2bjH DijfzZs33dzcPv744+HDh4veAgDA3yLsgHIUFRW5ubk1btx47ty5orcAAPAsHMUC5Rg7duy5 c+cyMjJMTU1FbwEA4FkIO+BZ1q5du3Llyv379zds2FD0FgAAysFRLPC3jh496uvrO2/evK5d u4reAgBA+Qg7oGx37txRqVQqlSogIED0FgAAngthB5ShpKRk8ODBFhYWS5cuFb0FAIDnxT12 QBmmTZuWlpaWlpZmbm4uegsAAM+LsAOetmPHjnnz5u3atatZs2aitwAA8AI4igX+4pdffhk2 bNjXX3/t4OAgegsAAC+GsAP+lJOTM3DgwB49ekydOlX0FgAAXhhhB/xBq9UOHz68pKQkPDzc yMhI9BwAAF4Y99gBf5g1a9a+ffs0Go2lpaXoLQAAvAzCDpAkSYqJiZk5c+b69evfeecd0VsA AHhJHMUC0pUrVwYPHjxp0iQ3NzfRWwAAeHmEHQzdw4cPVSpV69atv/76a9FbAAB4JRzFwtD5 +/v//vvv+/btMzY2Fr0FAIBXQtjBoKnV6o0bNyYmJlpbW4veAgDAqyLsYLhSUlImT578ww8/ tGvXTvQWAAAqAPfYwUDdvHnTzc3Nx8dnxIgRorcAAFAxCDsYoqKiIjc3N1tb23nz5oneAgBA heEoFobok08+OXfuXEZGhqmpqegtAABUGMIOBmft2rUrVqzYv39/w4YNRW8BAKAicRQLw3L0 6FFfX9958+Z17dpV9BYAACoYYQcDcufOHZVKpVKpAgICRG8BAKDiEXYwFKWlpYMHD7awsFi6 dKnoLQAAVArusYOhmDZt2uHDh9PT083NzUVvAQCgUhB2MAg7duyYO3furl27mjVrJnoLAACV haNYKN8vv/wybNiwmTNnOjg4iN4CAEAlIuygcDk5OSqVqnv37tOmTRO9BQCAykXYQcm0Wu3w 4cOLi4vXrFljZGQkeg4AAJWLe+ygZMHBwfv27dNoNJaWlqK3AABQ6Qg7KNb+/fuDgoLWr1// zjvviN4CAIAucBQLZbpy5Yqnp+fEiRPd3NxEbwEAQEcIOyjQw4cPVSpV69atZ82aJXoLAAC6 w1EsZKZNG6lRo3Ke4+/v//vvv//nP/8xNjbWySgAAPQCYQeZSUws5wlqtXrjxo2JiYm1a9fW ySIAAPQFYQdFSUlJmTx58g8//NCuXTvRWwAA0DXusYNy3Lx5083NzcfHZ8SIEaK3AAAgAGEH hSgqKnJ3d7e1tZ03b57oLQAAiMFRLBRi3LhxZ8+ezcjIMDU1Fb0FAAAxCDsowbp165YvX75/ //6GDRuK3gIAgDAcxUL2jh496uvrO3fu3K5du4reAgCASIQd5O3OnTsqlcrZ2Xns2LGitwAA IBhhBxkrLS0dMmRIzZo1ly1bJnoLAADicY8dZOzzzz8/dOhQWlqaubm56C0AAIhH2EEeSktL t27dGhsbe+bMmXr16rVv375+/fpz5szZtWvXG2+8IXodAAB6gbCDDNy/f3/AgAFpaWl9+/bt 1avXjRs3vv/++2vXrvn4+Dg4OIheBwCAviDsIAM+Pj5ZWVmnT5+2sbGRJCknJ+fgwYO2trbb tm375ptvatWqJXogAAB6gTdPQN+dO3du8+bN4eHhj6pOq9UOHz68pKQkIyPjH//4R1hYmOiB AADoC16xg75LTk62sbFp3779o1+GhIRER0drNJpatWr169cvOTlZ7DwAAPQHr9hB392/f//1 119//MudO3euXr367bffliTp9ddfv3//vrhpAADoF16xg76zsbG5cuVKUVGRiYmJJEkajebx Q+fOnWvUqJG4aQAA6BdesYO+69WrV2lp6cqVK5+6fvXq1e3btzs7OwtZBQCAHiLsoO8sLCxC QkLGjRu3ePHigoKCRxeTkpI++OCD9u3bu7m5iZ0HAID+IOwgA2PGjFmwYMGXX35Zs2bNt956 y8rKqlu3bh07dtyxY0eVKvw7DADAH7jHDvLg5+c3dOjQw4cPnzt3rm7dum3btuXuOgAAnkLY QTaqV6/eo0ePHj16iB4CAICekl/YabXaS5cuXbx4MScnR5IkS0vLFi1aPProWgAAAEMmp7DL zs4ODg5eu3btrVu3nnrI1tZ21KhREydONDMzE7INAABAONmE3Y0bNzp37nzp0qUWLVo4Ojo2 bty4evXqkiTdv3//woULBw8enD59+rZt2+Lj45/8MFsAAADDIZuwCwwMvH79+ubNm8v8eIuS kpKwsLCAgICgoKAFCxbofh4AAIBwsvmoiN27dw8dOvTvPrTM2NjY39/f3d19+/btOh4GAACg J2QTdrdv337jjTee/ZyWLVtmZWXpZg8AAIC+kU3YNWjQ4NixY89+zpEjRxo0aKCbPQAAAPpG NmHn7Oy8ZcuWOXPmPP6hUk/Ky8v76quvoqKiPDw8dL8NAABAH8jmzRMzZsxITEycNGnSzJkz O3ToYGNjU6NGDa1Wm5ube+XKlcOHDz948KBLly5ffvml6KWoXKdPS2++KRkbi94BAID+kU3Y WVlZpaamLl68eM2aNQcOHCgpKXn8kImJSdu2bUeMGDFixAhj/sJXOjs7kAzqMwAAE4pJREFU afNmqXdv0TsAANA/sgk7SZJMTU3Hjx8/fvz4/Pz8a9euPfrJExYWFra2tqampi/3exYWFm7Y sKHM493HEhMTX+43R2UoLpaKiv5fe3caFNWx93G8R2YGZVFBQR+QRQOlRkRZ3PEa0cStjESS uMQKopRBccO4p9yjCYWJSQxutwotTUIRK0aTWIYqsxBRKYyIccEom6CMCgoKIghynhfz3Llc BOJ9Ipyh5/t5xfTpc/yfskt/9Onpo3YRAACYpdYU7Ezatm3r7e39dPvdu3dLSkq8vLye/VK3 b9+OiYlpOtg9fPhQCMFcIAAAMHOtMtg1JjY2NiYmRlGUZz/Fzc3t8uXLTfc5derUsGHDCHYA AMDMtZpvxQIAAKBpBDsAAABJtJpHsYGBgX/Z5+bNmy1QCQAAgHlqNcHu3LlzQgidTtdEn5qa mpYqBwAAwOy0mkexy5Yts7W1vXjxYmXjli5dqnaZAAAAqmk1wW7Tpk1eXl7Tpk2rZhMzAACA hrSaYKfT6b788stLly6tXr1a7VoAAADMUatZYyeE6N27961bt5pYSDdu3LiOHTu2ZEkAAADm ozUFOyFE+/btmzg6YsSIESNGtFgxAAAAZqXVPIoFAABA0wh2AAAAkiDYAQAASIJgBwAAIAmC HQAAgCQIdgAAAJIg2AEAAEiCYAcAACAJgh0AAIAkCHYAAACSINgBAABIgmAHAAAgCYIdAACA JAh2AAAAkiDYAQAASIJgBwAAIAmCHQAAgCQIdgAAAJIg2AEAAEiCYAcAACAJgh0AAIAkCHYA AACSINgBAABIgmAHAAAgCYIdAACAJAh2AAAAkiDYAQAASIJgBwAAIAmCHQAAgCQIdgAAAJIg 2AEAAEiCYAcAACAJgh0AAIAktGoXADRswACRnd1Ae0WFmDpV6HT129u0ET/9JPr1a4HSAAAw UwQ7mKl//lMUFzfQnpMj3N2F9qmR26aNePHFFqgLAADzRbCDmerfX+0KAABobVhjBwAAIAmC HQAAgCQIdmitSkpKli5d6uHhYW1t3b1795CQkNTU1LodSktLFy9e7OnpqdfrXVxcIiIiDAaD WtVCPoxAqIjhh8ZoFEVRuwZzd+rUqWHDhlVVVen1erVrwf+5d+9eQEBAXl7ehAkT/P39c3Jy EhMTtVptWlpa3759hRCPHz8eMmRIenp6aGiov79/dnb2gQMHunXrdvbsWQcHB7XLR6vHCISK GH6qe/z4sbW19cmTJ4cOHap2LU9R8FdOnjwphKiqqlK7EPxbVFSUEGL79u2mlm+++UYIMX78 eOPHjz/+WAgRExNj6pCYmCiEePfdd1u6VsiIEQgVMfxUV1VVJYQ4efKk2oU0gBm7v8aM3fM1 ffr0hISEsrKyTZs2JSYmGgwGZ2fnJUuWLF68WKPRCCGysrIaO9fOzq5r165CiOjo6AsXLhw7 dkz3rx3tFEWxtbV1dnbOy8sTQvj5+WVnZxcVFVlbW5tO9/b2fvDgwa1bt4x/ECwTIxAqYvjJ gRm71o0Zu+crLCxMCDFmzJjIyMjTp0+fPHnylVdeEULEx8crilJdXd3EcJ00aVJjl62srNTp dMOGDVMU5dGjR1ZWVqNGjarXZ+bMmUKI7OzsZr1BmDlGIFTE8JODOc/YsY8dWppWqxVCODo6 7ty509iyc+fOF1544dChQ+Hh4VZWVgcPHmzsXFdX18YO7d69u7q6eurUqUKIgoKCJ0+euLm5 1evj4eEhhMjJyenRo8ffvxG0UoxAqIjhh+ZGsIM6jL+2GvXo0cPGxubGjRtCCI1G8/rrr/+3 V0tOTl62bFlQUFBkZKQQoqysTAhha2tbr5udnZ3pKCwcIxAqYvih+bDdCdTh7u5e96NOp2v6 GUQTEhISxowZ4+Pjc+TIEW2dd409vY5EUZQG22GBGIFQEcMPzYcZO6jDtOb3ac+ydthIUZT1 69dv3Lhx7NixX3/9tb29vbG9ffv2oqFfTB88eCCEMHWDJWMEQkUMPzQfgh3MS01Njbe3d2NH J02adPjwYePPiqJERETEx8cvWLBg27ZtVlZWpm7u7u5arfb69ev1Ts/OzhZCNHF9gBEIFTH8 8PcR7GBenn3tcHR0dHx8/JYtW1atWlWvm16vDwgISEtLq6iosLGxMTbW1tYmJye7ubnVewgC 1MUIhIoYfngOVPs+buvBdifP1+zZs4UQ165dq9vYoUOHPn36PPtFjLtxLlq0qLEOe/bsEUKs X7/e1GL8DtqGDRv+HzVDJoxAqIjhJwe2OwGes+XLlwshamtrV65cWe/QihUrHBwcZs2adeDA gfXr1587d87f3z8zMzMxMbFv375Lly5Vo17IhhEIFTH80BS1k2UrwIzd8/VcfmFtYkjn5uYa +5SVlRlfkq3T6VxdXaOiou7evfscbwStFCMQKmL4ycGcZ+x4pdhf45ViAADAxJxfKcY+dgAA AJIg2AEAAEiCYAcAACAJvhX714xL66ytrdUuBAAAmAvzXHnPlyeeyfnz52tqatSuAkIIERQU FBUV1b9/f7ULgSUybg82Z84ctQuBJcrIyIiLi0tJSVG7EAghhFar7devn9pVNIAZu2dinn95 lsnKymrkyJETJkxQuxBYop9++kkIMWPGDLULgSVycHDYtWtXQECA2oXArLHGDgAAQBIEOwAA AEkQ7AAAACRBsAMAAJAEwQ4AAEASBDsAAABJEOwAAAAkQbADAACQBMEOAABAErx5Aq2MXq83 z9fzwRIw9qAi/vXDs+BdsWhl8vLy3N3d27RhshkqKCkpEUI4ODioXQgsUW1tbX5+vqenp9qF wKwR7AAAACTBtAcAAIAkCHYAAACSINgBAABIgmAHAAAgCYIdAACAJAh2AAAAkiDYAQAASIJg BwAAIAmCHQAAgCQIdgAAAJIg2AEAAEiCYAcAACAJgh0AAIAkCHYAAACSINgBAABIgmAH81Ja Wrp48WJPT0+9Xu/i4hIREWEwGJrov2/fPk1D3n///RarGRaiurp61apVVlZWgYGBatcCy1JS UrJ06VIPDw9ra+vu3buHhISkpqaqXRTMlFbtAoB/e/z48ahRo9LT00NDQ/39/bOzs/fv3//z zz+fPXvWwcGhwVNKS0uFENOmTXN3d6/bPmzYsJaoGBYjMzNzxowZ165dU7sQWJx79+4FBATk 5eVNmDAhLCwsJycnMTExKSkpLS2tb9++alcHs0OwgxmJi4tLT0+PiYlZvny5sWXMmDFTpkzZ vHnz1q1bGzzFGOyWLFnCJAqaz4MHDwICAvr06ZOenu7j46N2ObAsa9euzcvL2759+/z5840t kydPDg0NXbly5dGjR9WtDWaIR7EwI/v377e3t1+0aJGp5c033/Ty8jpw4ICiKA2eYgx2HTt2 bKESYZFqamrmzZt36tQpLy8vtWuBxdHpdKNGjXrnnXdMLa+99lq7du0uXbqkYlUwWwQ7mIvK ysoLFy4MHDjQ2tq6bntQUNCdO3dyc3MbPMsU7J48eXLjxo3i4uKWqBUWxtHRcevWrTqdTu1C YIm2bdt2/PjxusPv8ePHNTU13bp1U7EqmC2CHcxFQUHBkydP3Nzc6rV7eHgIIXJycho86/79 +0KITz75xMnJyc3NzcnJqWfPnl999VVzVwsAatm9e3d1dfXUqVPVLgTmiDV2MBdlZWVCCFtb 23rtdnZ2pqNPM87YJSQkLF++3NXVNTMzMy4u7q233iorK6v75AIA5JCcnLxs2bKgoKDIyEi1 a4E5ItjBvGg0mnotxtV1T7cbrVmzZv78+WPHjjUlwhkzZvj7+69evTo8PFyv1zdrtQDQkhIS EsLDw318fI4cOaLV8j84GsCjWJiL9u3bi4Zm5h48eCCEsLe3b/Cs4ODg0NDQuvN8L7744vjx 4+/du3f+/PlmKxYAWpSiKOvWrZs+ffrIkSN//fVXR0dHtSuCmSLvw1y4u7trtdrr16/Xa8/O zhZCeHt7P/ulnJ2dhRDl5eXPsTwAUIuiKBEREfHx8QsWLNi2bZuVlZXaFcF8MWMHc6HX6wMC AtLS0ioqKkyNtbW1ycnJbm5u9fYfNiovL9+5c2dCQkK9duMuAMZvXQBAaxcdHR0fH79ly5bP PvuMVIemEexgRmbPnl1RUREbG2tq2bNnT2FhYUREhPFjZWVlRkaGcQ5PCGFjY7N58+Y5c+Zc uXLFdMqRI0dSUlL8/Px69OjRksUDQHM4dOjQp59+umjRolWrVqldC1oBTWP7vgIt78mTJyNH jjxx4sSkSZP8/f0zMzMTExN9fHxSU1NtbGyEEBcvXuzbt++oUaOOHz9uPOW7774LCQmxsbGZ OnWqi4vLxYsXDx8+bG9v/8svv/j7+6t6N5BHcnLysWPHjD9v3brVyckpLCzM+HHZsmWdOnVS rzTIz8vLKzs7e8GCBcZ/ButasWJFY69bhMUi2MG8lJeXb9iw4eDBg4WFhc7OziEhIRs3bjQt E3462AkhTp8+vWnTptOnT5eXlzs7O48ePXrNmjW8IQDP0YcfftjYZMm1a9cYbGhWje0JIITI zc319PRswVrQChDsAAAAJMEaOwAAAEkQ7AAAACRBsAMAAJAEwQ4AAEASBDsAAABJEOwAAAAk QbADAACQBMEOAABAEgQ7AAAASRDsAAAAJEGwAwAAkATBDgAAQBIEOwAAAEkQ7AAAACRBsAMA AJAEwQ4AAEASBDsAAABJEOwAAAAkQbADAACQBMEOAABAEgQ7AAAASRDsAAAAJEGwAwAAkATB DgAAQBIEOwAAAEkQ7AAAACRBsAMAAJAEwQ4AAEASBDsAAABJEOwAAAAkQbADAACQBMEOAABA EgQ7ABBCCK1WO3jwYLWrAIC/hWAHAAAgCYIdAACAJAh2AAAAkiDYAbBER48eDQgIaNeunbOz c0RERGlpab0O169fDw8Pd3V11ev1nTt3fvXVV9PS0kxHq6qqYmNj+/Xr16FDB3t7e19f39jY 2NraWlOH27dvR0VFeXh46PV6JyenkJCQM2fOtNC9AbBgGkVR1K4BAFpUSkrKSy+91KVLl/nz 5zs5OSUnJ1+/fj01NdXf3z81NVUIUVBQEBgYWFFRMXfu3D59+ty8eXPHjh3FxcXHjx8PCgoS QsyaNWvv3r3Tp08fPny4RqNJSkr69ttvo6KiPv/8cyFEUVHRgAEDSktLIyMjfXx8CgoKduzY UVRUlJSUNGLECJVvHoDcFACwMGPHjhVCpKWlmVrmzZsnhBg0aJDxY1hYmBDi0KFDpg6XL1+2 srIaPHiw8aONjc2QIUPqXjM6Ojo0NLSmpkZRlLlz52q12jNnzpiO5ufn29vbBwYGNt9NAYCi KMzYAbAstbW1dnZ2Li4uWVlZpsaMjAw/P79BgwalpqYqiuLg4NC2bVuDwaDRaEx9hg8fnpKS Ulxc3KlTp44dO9ra2p47d87Z2bne9RVFcXZ2dnd3P3r0aN32mTNnJiUllZWV2dnZNesNArBk rLEDYFkMBsOjR4969OhRt7FXr16mn2/dunX//v0+ffrUTXVCiJ49ewohrl69KoTYuHFjYWGh t7f322+/vXfv3ps3b5q63blzp7i4OD09/X/+U1JSkhAiPz+/We8OgIXTql0AALSoiooKIUTb tm3rNrZt29YU4x4+fCiEsLW1rXdiu3btTEcXLlzo4+Ozffv2Q4cOHThwQKPRjBs3bseOHR4e HmVlZUKI/v37f/DBB0//6S4uLs//lgDgXwh2ACyLMZ9VVlbWbSwvLzetSzE+KjUGuLqMLfb2 9saPwcHBwcHBVVVVJ06c+OKLL/bv3z969OhLly6ZOhhX8gFAS+JRLADL0rVrV71en5ubW7fx jz/+qNvB0dExMzOz3hLky5cvazQa4wNZE2tr69GjR+/bty8yMjIrKysjI6NLly6dO3e+cuVK vS1UioqKmuFuAOA/EOwAWBatVjt06NCsrKy6G8vFxcXV7TN58mSDwXDkyBFTS0ZGRlpaWnBw cMeOHVNTU11dXffv31/3lDZt2gghdDqdEOKNN96orKyMjY01HS0qKvL19Z04cWIz3RQAGPGt WAAW59ixYxMmTHBycpo1a1anTp2Sk5MrKirOnj3bq1cv4z52hYWFAQEB5eXlCxcu7NmzZ15e Xlxc3KNHj1JSUnx9fWtqavz8/K5evRoWFta/f3+NRvP777/v27dv6NChv/32m0ajuXPnzoAB A/Lz88PDw0eMGFFYWLhr1y6DwXD06NGXX35Z7bsHIDOCHQBLlJiYuHnz5j///LNDhw4TJ078 6KOPfH19O3funJ6ebuxQUFCwbt26H3/8saioyNHRMTg4eO3atb179zYevXfv3qZNm77//nuD waDT6Tw9PadMmbJgwQLTVia3bt3auHHjDz/8YDAY7Ozs/vGPf7z33nsDBw5U524BWAyCHQAA gCRYYwcAACAJgh0AAIAkCHYAAACSINgBAABIgmAHAAAgCYIdAACAJAh2AAAAkiDYAQAASIJg BwAAIAmCHQAAgCQIdgAAAJIg2AEAAEiCYAcAACAJgh0AAIAkCHYAAACSINgBAABIgmAHAAAg CYIdAACAJAh2AAAAkiDYAQAASIJgBwAAIAmCHQAAgCQIdgAAAJIg2AEAAEiCYAcAACAJgh0A AIAkCHYAAACSINgBAABIgmAHAAAgCYIdAACAJP4XUqIJv9U49nEAAAAASUVORK5CYII=) The point plot informs us that as the dosage levels increase, the tooth length also increases. To obtain the actual numbers, we can use the code below. The first line converts the numerical dosage values to a categorical variable, which may not be necessary if your data was already categorical. ```R df$dose.factor = as.factor(df$dose) aov1 = aov(len~dose.factor, data=df) model.tables(aov1, type='means') ``` Tables of means Grand mean 18.81333 dose.factor dose.factor 0.5 1 2 10.605 19.735 26.100 If you wish to display the difference between the overall mean and the group means, you can simply omit the `type='means'` parameter. ```R model.tables(aov1) ``` Tables of effects dose.factor dose.factor 0.5 1 2 -8.208 0.922 7.287 To also see the specific values for the confidence intervals plotted earlier, we can use the `emmeans` package (Estimated Marginal Means or Least-Squares Means). ```R # install.packages(\"emmeans\") # If you have not yet installed it library(emmeans) emmeans(aov1,'dose.factor') ``` dose.factor emmean SE df lower.CL upper.CL 0.5 10.6 0.949 57 8.71 12.5 1 19.7 0.949 57 17.84 21.6 2 26.1 0.949 57 24.20 28.0 Confidence level used: 0.95 Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to analyze the sample means of different treatment conditions/R, using gplots and emmeans.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-analyze-the-sample-means-of-different-treatment-conditions-in-r-using-gplots-and-emmeans/",
    "relUrl": "/how-to-analyze-the-sample-means-of-different-treatment-conditions-in-r-using-gplots-and-emmeans/"
  },"97": {
    "doc": "How to analyze the sample means of different treatment conditions",
    "title": "How to analyze the sample means of different treatment conditions",
    "content": " ",
    "url": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/",
    "relUrl": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/"
  },"98": {
    "doc": "How to analyze the sample means of different treatment conditions",
    "title": "Description",
    "content": "In a single-factor experiment with three or more treatment levels, how can we compare them to see which one impacts the outcome variable the most? . ",
    "url": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#description",
    "relUrl": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#description"
  },"99": {
    "doc": "How to analyze the sample means of different treatment conditions",
    "title": "Using Matplotlib and Seaborn, in Python",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 2 . | from rdatasets import data df = data('ToothGrowth') . | . To visually plot the means of the length of the tooth based on the Vitamin C dosage levels we can create a pointplot. We will have to import the seaborn and matplotlib.pyplot packages to be able to create it. | 1 2 3 4 5 6 . | import seaborn as sns import matplotlib.pyplot as plt sns.pointplot( x = 'dose', y = 'len', data = df, ci = 95, # ci stands for Confidence Interval capsize = 0.1 ) # the width of the \"caps\" on error bars plt.show() . | . The point plot informs us that as the dosage levels increase, the tooth length also increases. To obtain the actual numbers, we can use the groupby function to compute the treatment level means, and the mean function to compute the mean for the entire column. | 1 . | df.groupby('dose')['len'].mean() . | . | 1 2 3 4 5 . | dose 0.5 10.605 1.0 19.735 2.0 26.100 Name: len, dtype: float64 . | . | 1 . | df['len'].mean() . | . | 1 . | 18.813333333333336 . | . If you wish to display the difference between the overall mean and the group means, you can subtract the overall mean from the treatment level means. | 1 . | df.groupby('dose')['len'].mean() - df['len'].mean() . | . | 1 2 3 4 5 . | dose 0.5 -8.208333 1.0 0.921667 2.0 7.286667 Name: len, dtype: float64 . | . Content last modified on 26 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#using-matplotlib-and-seaborn-in-python",
    "relUrl": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#using-matplotlib-and-seaborn-in-python"
  },"100": {
    "doc": "How to analyze the sample means of different treatment conditions",
    "title": "Using gplots and emmeans, in R",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 . | df &lt;- ToothGrowth . | . To visually plot the means of the length of the tooth based on the Vitamin C dosage levels we can create a pointplot. We will use the gplots package. In the code below, bars=TRUE gives 95% confidence intervals for the means. | 1 2 3 . | # install.packages(\"gplots\") # If you have not yet installed it library(gplots) plotmeans(len~dose, data=df, bars=TRUE) . | . | 1 2 3 4 5 6 . | Attaching package: ‘gplots’ The following object is masked from ‘package:stats’: lowess . | . The point plot informs us that as the dosage levels increase, the tooth length also increases. To obtain the actual numbers, we can use the code below. The first line converts the numerical dosage values to a categorical variable, which may not be necessary if your data was already categorical. | 1 2 3 . | df$dose.factor = as.factor(df$dose) aov1 = aov(len~dose.factor, data=df) model.tables(aov1, type='means') . | . | 1 2 3 4 5 6 7 8 9 . | Tables of means Grand mean 18.81333 dose.factor dose.factor 0.5 1 2 10.605 19.735 26.100 . | . If you wish to display the difference between the overall mean and the group means, you can simply omit the type='means' parameter. | 1 . | model.tables(aov1) . | . | 1 2 3 4 5 6 . | Tables of effects dose.factor dose.factor 0.5 1 2 -8.208 0.922 7.287 . | . To also see the specific values for the confidence intervals plotted earlier, we can use the emmeans package (Estimated Marginal Means or Least-Squares Means). | 1 2 3 . | # install.packages(\"emmeans\") # If you have not yet installed it library(emmeans) emmeans(aov1,'dose.factor') . | . | 1 2 3 4 5 6 . | dose.factor emmean SE df lower.CL upper.CL 0.5 10.6 0.949 57 8.71 12.5 1 19.7 0.949 57 17.84 21.6 2 26.1 0.949 57 24.20 28.0 Confidence level used: 0.95 . | . Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#using-gplots-and-emmeans-in-r",
    "relUrl": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#using-gplots-and-emmeans-in-r"
  },"101": {
    "doc": "How to analyze the sample means of different treatment conditions",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#topics-that-include-this-task",
    "relUrl": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#topics-that-include-this-task"
  },"102": {
    "doc": "How to analyze the sample means of different treatment conditions",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#opportunities",
    "relUrl": "/how-to-analyze-the-sample-means-of-different-treatment-conditions/#opportunities"
  },"103": {
    "doc": "How to change axes, ticks, and scale in a plot (in Python, using Matplotlib)",
    "title": "How to change axes, ticks, and scale in a plot (in Python, using Matplotlib)",
    "content": "# How to change axes, ticks, and scale in a plot (in Python, using Matplotlib) [See all solutions.](../how-to-change-axes-ticks-and-scale-in-a-plot) ## Task The mathematical markings and measurements in a plot can make a big difference on its readability and usefulness. These include the range of each axis, which points on that axis are marked with tick marks, and whether the axes use linear or logarithmic scaling. How can we customize these options? Related topics: * [How to create basic plots](../how-to-create-basic-plots) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some fake data using Python lists, for simplicity. But everything we show below works also if your data is in columns of a DataFrame, such as `df['age']`. ```python patient_id = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] patient_height = [ 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ] patient_weight = [ 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ] ``` The conventional way to import matplotlib in Python is as follows. ```python import matplotlib.pyplot as plt ``` You can change the plot range and where tick marks are shown, in either the $x$ or $y$ directions (or both) as follows. ```python plt.scatter( patient_height, patient_weight ) plt.xlim( [ 0, 80 ] ) # Plot from x=0 to x=80. plt.ylim( [ 0, 250 ] ) # Plot from y=0 to y=250. plt.xticks( range(0,80,10) ) # Put x axis ticks every 10 units. plt.yticks( range(0,250,50) ) # Y ticks every 50. You can provide any list. plt.show() ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXcAAAD4CAYAAAAXUaZHAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/MnkTPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAPpklEQVR4nO3dUYxc51nG8f+LbcI2LTjBTmSvHRyQZZpQYpeVSWWE0oR03Qg1plKRI4F8EclcuFIiVQavkChcRI1kUeCCVDI0JBIlIbSOYxUUN3JaVSBouq7T2k6yxDSm2V1juy1WKlgF23252LPxeD2bnd2d2Tnz+f+TRjPnmzMzT9bOM+PvnP0mMhNJUll+otsBJEntZ7lLUoEsd0kqkOUuSQWy3CWpQEu7HQBgxYoVuW7dum7HkKSecuTIke9n5spm99Wi3NetW8fw8HC3Y0hST4mI/5zpPqdlJKlAtfjkLkm94sDRMfYeGmH8/ASrl/exe3AD2zb1dzvWVSx3SWrRgaNjDO0/xsSFSwCMnZ9gaP8xgNoVvNMyktSivYdG3in2KRMXLrH30EiXEs3McpekFo2fn5jTeDdZ7pLUotXL++Y03k2WuyS1aPfgBvqWLblirG/ZEnYPbuhSopl5QFWSWjR10NSzZSSpMNs29deyzKdzWkaSCmS5S1KBLHdJKpDlLkkFstwlqUCWuyQVyHKXpAJZ7pJUIMtdkgpkuUtSgSx3SSqQ5S5JBbLcJalAlrskFchyl6QCWe6SVCDLXZIKZLlLUoEsd0kqkOUuSQWy3CWpQJa7JBXIcpekAlnuklQgy12SCmS5S1KBlnY7gCTNx4GjY+w9NML4+QlWL+9j9+AGtm3q73as2rDcJfWcA0fHGNp/jIkLlwAYOz/B0P5jABZ8xWkZST1n76GRd4p9ysSFS+w9NNKlRPVjuUvqOePnJ+Y0fi2atdwjYm1EfDUiXo2IExHxUDV+Y0S8EBGvV9c3NDxmKCJORsRIRAx28j9A0rVn9fK+OY1fi1r55H4R+FRmvh+4E9gVEbcBe4DDmbkeOFxtU923Hbgd2Ao8FhFLOhFe0rVp9+AG+pZdWSt9y5awe3BDlxLVz6wHVDPzNHC6uv2jiHgV6AfuB+6qdnsS+BrwB9X405n5NvBGRJwENgP/2u7wkq5NUwdNp58tA7Dl0Rc9g4Y5ni0TEeuATcA3gJur4iczT0fETdVu/cC/NTxstBqb/lw7gZ0At9xyy5yDS7q2bdvUf0Vx98oZNIt1CmfLB1Qj4r3Al4CHM/Otd9u1yVheNZC5LzMHMnNg5cqVrcaQpKZ64QyaqTegsfMTJJffgA4cHWv7a7VU7hGxjMli/0Jm7q+Gz0TEqur+VcDZanwUWNvw8DXAeHviSlJzvXAGzWK+AbVytkwAnwdezczPNtx1ENhR3d4BPNcwvj0irouIW4H1wEvtiyxJV+uFM2gW8w2olU/uW4DfBe6OiJery33Ao8C9EfE6cG+1TWaeAJ4BXgGeB3Zl5qXmTy1J7dELZ9As5htQK2fL/DPN59EB7pnhMY8AjywglyTNyUxn0NTpYOruwQ1XHPSFzr0BubaMpGJMP4OmbhbzDchyl6RFtFhvQK4tI0kFstwlqUCWuyQVyHKXpAJZ7pJUIM+WkdQT/M7UubHcJdXeYq34WNIbiNMykmpvMRbcWswVGxeD5S6p9hZjwa1eWDJ4Lix3SbW3GAtu9cKSwXNhuUuqvcVY8bEXlgyeC8tdUu1t29TPZz7+AfqX9xFA//I+PvPxD7T1YGerbyAHjo6x5dEXuXXPP7Ll0RdrOyfv2TKSekKnF9xqZcXGXvmeVrDcJekds72BvNtB17qVu9MyktSiXjroarlLUot66aCr5S6pJ9ThQGYvfE/rFOfcJdVeXQ5k9sL3tE6x3CXVXp0OZNb9e1qnOC0jqfZ66UBmXVjukmqvlw5k1oXlLqn2eulAZl045y6p9nrpQGZdWO6SekKvHMisC6dlJKlAlrskFchyl6QCWe6SVCDLXZIKZLlLUoEsd0kqkOUuSQWatdwj4vGIOBsRxxvG/jgixiLi5epyX8N9QxFxMiJGImKwU8ElSTNr5ZP7E8DWJuN/lpkbq8s/AUTEbcB24PbqMY9FxJImj5UkddCs5Z6ZXwd+2OLz3Q88nZlvZ+YbwElg8wLySZLmYSFz7p+MiO9U0zY3VGP9wJsN+4xWY1eJiJ0RMRwRw+fOnVtADEnSdPMt988BvwBsBE4Df1qNR5N9s9kTZOa+zBzIzIGVK1fOM4YkqZl5lXtmnsnMS5n5Y+CvuDz1Mgqsbdh1DTC+sIiSpLmaV7lHxKqGzd8Cps6kOQhsj4jrIuJWYD3w0sIiSpLmatb13CPiKeAuYEVEjAKfBu6KiI1MTrmcAn4PIDNPRMQzwCvARWBXZl5q8rSSpA6KzKZT4otqYGAgh4eHux1DUoccODrmtyh1QEQcycyBZvf5TUySOurA0TGG9h9j4sLkP+LHzk8wtP8YgAXfQS4/IKmj9h4aeafYp0xcuMTeQyNdSnRt8JO7pI4aPz8xp/GFcPrnMj+5S+qo1cv75jQ+X1PTP2PnJ0guT/8cODrW1tfpFZa7pI7aPbiBvmVXLjHVt2wJuwc3tPV1nP65ktMykjpqalqk09Mlizn90wssd0kdt21Tf8fnvlcv72OsSZG3e/qnVzgtI6kIizX90yv85C6pCIs1/dMrLHdJxViM6Z9e4bSMJBXIcpekAlnuklQgy12SCmS5S1KBLHdJKpDlLkkFstwlqUCWuyQVyHKXpAJZ7pJUIMtdkgpkuUtSgSx3SSqQ5S5JBbLcJalAlrskFchyl6QCWe6SVCDLXZIKZLlLUoEsd0kqkOUuSQWy3CWpQJa7JBVo1nKPiMcj4mxEHG8YuzEiXoiI16vrGxruG4qIkxExEhGDnQouSZpZK5/cnwC2ThvbAxzOzPXA4WqbiLgN2A7cXj3msYhY0ra0kqSWzFrumfl14IfThu8HnqxuPwlsaxh/OjPfzsw3gJPA5vZElSS1ar5z7jdn5mmA6vqmarwfeLNhv9Fq7CoRsTMihiNi+Ny5c/OMIUlqpt0HVKPJWDbbMTP3ZeZAZg6sXLmyzTEk6do233I/ExGrAKrrs9X4KLC2Yb81wPj840mS5mO+5X4Q2FHd3gE81zC+PSKui4hbgfXASwuLKEmaq6Wz7RARTwF3ASsiYhT4NPAo8ExEPAh8D/gEQGaeiIhngFeAi8CuzLzUoeySpBnMWu6Z+cAMd90zw/6PAI8sJJQkaWH8DVVJKpDlLkkFstwlqUCWuyQVyHKXpAJZ7pJUIMtdkgpkuUtSgSx3SSqQ5S5JBbLcJalAlrskFchyl6QCWe6SVCDLXZIKZLlLUoEsd0kqkOUuSQWy3CWpQJa7JBXIcpekAlnuklQgy12SCmS5S1KBLHdJKpDlLkkFstwlqUCWuyQVyHKXpAJZ7pJUIMtdkgpkuUtSgSx3SSqQ5S5JBVq6kAdHxCngR8Al4GJmDkTEjcDfA+uAU8BvZ+Z/LyymJGku2vHJ/cOZuTEzB6rtPcDhzFwPHK62JUmLqBPTMvcDT1a3nwS2deA1JEnvYqHlnsBXIuJIROysxm7OzNMA1fVNzR4YETsjYjgihs+dO7fAGJKkRguacwe2ZOZ4RNwEvBARr7X6wMzcB+wDGBgYyAXmkCQ1WNAn98wcr67PAs8Cm4EzEbEKoLo+u9CQkqS5mXe5R8T1EfG+qdvAR4DjwEFgR7XbDuC5hYaUJM3NQqZlbgaejYip5/m7zHw+Ir4JPBMRDwLfAz6x8JiSpLmYd7ln5neBO5qM/wC4ZyGhJEkL42+oSlKBLHdJKpDlLkkFstwlqUCWuyQVyHKXpAJZ7pJUIMtdkgpkuUtSgSx3SSqQ5S5JBbLcJalAlrskFchyl6QCWe6SVCDLXZIKZLlLUoEsd0kqkOUuSQWy3CWpQJa7JBXIcpekAlnuklQgy12SCmS5S1KBLHdJKpDlLkkFstwlqUCWuyQVyHKXpAJZ7pJUIMtdkgpkuUtSgSx3SSqQ5S5JBepYuUfE1ogYiYiTEbGnU68jSbpaR8o9IpYAfwl8FLgNeCAibuvEa0mSrtapT+6bgZOZ+d3M/D/gaeD+Dr2WJGmapR163n7gzYbtUeBXG3eIiJ3Azmrz7Yg43qEs7bQC+H63Q7TAnO1lzvbphYzQOzl/bqY7OlXu0WQsr9jI3AfsA4iI4cwc6FCWtjFne5mzvXohZy9khN7J+W46NS0zCqxt2F4DjHfotSRJ03Sq3L8JrI+IWyPiJ4HtwMEOvZYkaZqOTMtk5sWI+CRwCFgCPJ6ZJ97lIfs6kaMDzNle5myvXsjZCxmhd3LOKDJz9r0kST3F31CVpAJZ7pJUoK6Xe12XKYiIxyPibOP59xFxY0S8EBGvV9c3dDnj2oj4akS8GhEnIuKhmub8qYh4KSK+XeX8kzrmnBIRSyLiaER8udquXc6IOBURxyLi5YgYrnHO5RHxxYh4rfp7+qG65YyIDdXPceryVkQ8XLecc9XVcq/5MgVPAFunje0BDmfmeuBwtd1NF4FPZeb7gTuBXdXPr2453wbuzsw7gI3A1oi4k/rlnPIQ8GrDdl1zfjgzNzacj13HnH8BPJ+ZvwjcweTPtVY5M3Ok+jluBH4F+F/gWWqWc84ys2sX4EPAoYbtIWCom5mm5VsHHG/YHgFWVbdXASPdzjgt73PAvXXOCbwH+BaTv7Fcu5xM/k7GYeBu4Mt1/XMHTgErpo3VKifw08AbVCdu1DXntGwfAf6l7jlbuXR7WqbZMgX9XcrSipsz8zRAdX1Tl/O8IyLWAZuAb1DDnNVUx8vAWeCFzKxlTuDPgd8HftwwVsecCXwlIo5US3lA/XL+PHAO+JtqmuuvI+J66pez0Xbgqep2nXPOqtvlPusyBZpdRLwX+BLwcGa+1e08zWTmpZz8Z+8aYHNE/FKXI10lIn4TOJuZR7qdpQVbMvODTE5p7oqIX+92oCaWAh8EPpeZm4D/ocZTG9UvXH4M+IduZ2mHbpd7ry1TcCYiVgFU12e7nIeIWMZksX8hM/dXw7XLOSUzzwNfY/J4Rt1ybgE+FhGnmFzJ9O6I+Fvql5PMHK+uzzI5P7yZ+uUcBUarf6UBfJHJsq9bzikfBb6VmWeq7brmbEm3y73Xlik4COyobu9gco67ayIigM8Dr2bmZxvuqlvOlRGxvLrdB/wG8Bo1y5mZQ5m5JjPXMfl38cXM/B1qljMiro+I903dZnKe+Dg1y5mZ/wW8GREbqqF7gFeoWc4GD3B5Sgbqm7M13Z70B+4D/h34D+APu52nIddTwGngApOfQB4EfpbJg22vV9c3djnjrzE5jfUd4OXqcl8Nc/4ycLTKeRz4o2q8VjmnZb6LywdUa5WTybnsb1eXE1P/39QtZ5VpIzBc/dkfAG6oac73AD8AfqZhrHY553Jx+QFJKlC3p2UkSR1guUtSgSx3SSqQ5S5JBbLcJalAlrskFchyl6QC/T85dKy8UDOVnwAAAABJRU5ErkJggg== ) If you need either axis to be logarithmically scaled, it takes just one line of code. ```python import numpy as np # Just using this to make random data. plt.scatter( np.random.rand(100), np.random.rand(100) ) plt.xscale( 'log' ) # You can include one of these two plt.yscale( 'log' ) # lines, or both, or neither. plt.show() ``` ![png](data:image/png;base64,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 ) Content last modified on 23 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to change axes, ticks, and scale in a plot/Python, using Matplotlib.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-change-axes-ticks-and-scale-in-a-plot-in-python-using-matplotlib/",
    "relUrl": "/how-to-change-axes-ticks-and-scale-in-a-plot-in-python-using-matplotlib/"
  },"104": {
    "doc": "How to change axes, ticks, and scale in a plot",
    "title": "How to change axes, ticks, and scale in a plot",
    "content": " ",
    "url": "/how-to-change-axes-ticks-and-scale-in-a-plot/",
    "relUrl": "/how-to-change-axes-ticks-and-scale-in-a-plot/"
  },"105": {
    "doc": "How to change axes, ticks, and scale in a plot",
    "title": "Description",
    "content": "The mathematical markings and measurements in a plot can make a big difference on its readability and usefulness. These include the range of each axis, which points on that axis are marked with tick marks, and whether the axes use linear or logarithmic scaling. How can we customize these options? . Related topics: . | How to create basic plots | How to create a histogram | How to create a box (and whisker) plot | How to add details to a plot | How to create bivariate plots to compare groups | How to plot interaction effects of treatments | . ",
    "url": "/how-to-change-axes-ticks-and-scale-in-a-plot/#description",
    "relUrl": "/how-to-change-axes-ticks-and-scale-in-a-plot/#description"
  },"106": {
    "doc": "How to change axes, ticks, and scale in a plot",
    "title": "Using Matplotlib, in Python",
    "content": "View this solution alone. We will create some fake data using Python lists, for simplicity. But everything we show below works also if your data is in columns of a DataFrame, such as df['age']. | 1 2 3 . | patient_id = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] patient_height = [ 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ] patient_weight = [ 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ] . | . The conventional way to import matplotlib in Python is as follows. | 1 . | import matplotlib.pyplot as plt . | . You can change the plot range and where tick marks are shown, in either the $x$ or $y$ directions (or both) as follows. | 1 2 3 4 5 6 . | plt.scatter( patient_height, patient_weight ) plt.xlim( [ 0, 80 ] ) # Plot from x=0 to x=80. plt.ylim( [ 0, 250 ] ) # Plot from y=0 to y=250. plt.xticks( range(0,80,10) ) # Put x axis ticks every 10 units. plt.yticks( range(0,250,50) ) # Y ticks every 50. You can provide any list. plt.show() . | . If you need either axis to be logarithmically scaled, it takes just one line of code. | 1 2 3 4 5 . | import numpy as np # Just using this to make random data. plt.scatter( np.random.rand(100), np.random.rand(100) ) plt.xscale( 'log' ) # You can include one of these two plt.yscale( 'log' ) # lines, or both, or neither. plt.show() . | . Content last modified on 23 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-change-axes-ticks-and-scale-in-a-plot/#using-matplotlib-in-python",
    "relUrl": "/how-to-change-axes-ticks-and-scale-in-a-plot/#using-matplotlib-in-python"
  },"107": {
    "doc": "How to change axes, ticks, and scale in a plot",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA346 | . ",
    "url": "/how-to-change-axes-ticks-and-scale-in-a-plot/#topics-that-include-this-task",
    "relUrl": "/how-to-change-axes-ticks-and-scale-in-a-plot/#topics-that-include-this-task"
  },"108": {
    "doc": "How to change axes, ticks, and scale in a plot",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-change-axes-ticks-and-scale-in-a-plot/#opportunities",
    "relUrl": "/how-to-change-axes-ticks-and-scale-in-a-plot/#opportunities"
  },"109": {
    "doc": "How to check the assumptions of a linear model (in Python, using NumPy, SciPy, sklearn, Matplotlib and Seaborn)",
    "title": "How to check the assumptions of a linear model (in Python, using NumPy, SciPy, sklearn, Matplotlib and Seaborn)",
    "content": "# How to check the assumptions of a linear model (in Python, using NumPy, SciPy, sklearn, Matplotlib and Seaborn) [See all solutions.](../how-to-check-the-assumptions-of-a-linear-model) ## Task If you plan to use a linear model to describe some data, it's important to check if it satisfies the assumptions for linear regression. How can we do that? ## Solution When performing a linear regression, the following assumptions should be checked. ### 1. We have two or more columns of numerical data of the same length. The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) We can see that our columns all have the same length. ```python from rdatasets import data df = data('mtcars') df = df[['mpg','cyl','wt']] # Select the 3 variables we're interested in df.info() ``` RangeIndex: 32 entries, 0 to 31 Data columns (total 3 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 mpg 32 non-null float64 1 cyl 32 non-null int64 2 wt 32 non-null float64 dtypes: float64(2), int64(1) memory usage: 896.0 bytes ### 2. Scatter plots we've made suggest a linear relationship. Scatterplots are covererd in [how to create basic plots](../how-to-create-basic-plots), but after making the model, we can also examine the residuals. So let's make the model. Our predictors will be the number of cylinders and the weight of the car and the response will be miles per gallon. (See also [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data).) ```python from sklearn.linear_model import LinearRegression model = LinearRegression() predictors = df[['cyl','wt']] response = df['mpg'] model.fit( X=predictors, y=response ) predictions = model.predict(predictors) ``` We test for linearity with residual plots. We show just one residual plot here; you should make one for each predictor. Seaborn has a function for just this purpose. (See also [how to compute the residuals of a linear model](../how-to-compute-the-residuals-of-a-linear-model).) ```python import seaborn as sns import matplotlib.pyplot as plt # The \"lowess\" parameter adds a smooth line through the data: sns.residplot(x = df['wt'], y = response, data=df, lowess=True) plt.xlabel(\"Weight\") plt.title('Miles per gallon') plt.show() ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYAAAAEWCAYAAABv+EDhAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/MnkTPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAuaUlEQVR4nO3deXhU9dn/8fedjSQQCFvYVxeWgCuiuCDuO9jWp9a2arXt0Pq0VmutVSsKrf5qW5e29nEp1rXaauvCpoBSRFBQUBACQTFskSUBAgSyTZLv74+ZxBATmJDlnJn5vC64Zs4yZ+6cKzn3Od/VnHOIiEj8SfA6ABER8YYSgIhInFICEBGJU0oAIiJxSglARCROKQGIiMQpJQCJSmb2mJndFX4/zszyvY6prdT/ec1sg5md62VMEp2SvA5ApC4z2wD0Bno753bUWb8cOBYY5Jzb4Jz7kTcRisQOPQGIH60HrqpZMLORQJp34TSPmelGS3xJCUD86DngmjrL1wLP1t3BzJ42s9829GEz621m/zGzQjNbb2Y31tk22syWmtleM9tuZg82coxxZpZvZneY2Y5wMct36mxvZ2Z/NLNN4eM8ZmZp9T57m5ltA55q4PiJZvZA+NjrzewnZuZqkoWZXWdma8ys2MzyzGxiJCcuHNfDZrYl/P9hM2tXL65bzKzAzLaa2XWRHFdikxKA+NFioKOZDTOzROBK4PlIPmhmCcB0YAXQBzgHuMnMLgjv8ifgT865jsARwEsHOVxPoFv4ONcCT5jZkPC2+4GjgeOAI8P7TKr32S7AACDQwLF/CFwU/vwJwOX1thcAlwIdgeuAh8zshIPEWuNO4JTwcY8FRgO/rhdXp3C83wf+amadIziuxCAlAPGrmqeA84Bc4IsIP3cS0N05N8U5V+GcywP+BnwrvD0IHGlm3Zxz+5xziw9xvLucc+XOuXeAmcA3zcwIXcBvds7tcs4VA/fV+Q6AauDu8GdLGzjuNwklonznXBHwu7obnXMznXOfu5B3gDnAGRH8/N8BpjjnCpxzhcBk4Oo624Ph7UHn3CxgHzCkgeNIHFDZpPjVc8ACYBD1in8OYQDQ28x211mXCLwbfv99YAqQa2brgcnOuRmNHKvIObe/zvJGQhXU3YF0YFkoFwBg4e+pUeicKztInL2BzXWW677HzC4C7ib0lJEQ/r6VBzle3eNubCDmGjudc5V1lkuADhEcV2KQEoD4knNuY/gCfTGhi3akNgPrnXNHNXLcz4CrwkVFXwf+bWZd613oa3Q2s/Z1tvUHVgE7gFIg2znX2JPJoYbZ3Qr0rbPcr+ZNuMz+P4SegF53zgXN7DVCSeZQthBKgjl1Yt4SweckDqkISPzs+8DZjVycG/MBsDdcAZsWrmwdYWYnAZjZd82su3OuGtgd/kzVQY432cxSzOwMQmXyL4c/+zdC5fJZ4eP2qVPPEImXgJ+FP5cJ3FZnWwrQDigEKsNPA+dHeNwXgV+bWXcz60aoXiKi+hOJP0oA4lvhMvClTfxMFXAZoUrQ9YTu1qcSqvgEuBDIMbN9hCqEv3WQopptQBGhO+h/AD9yzuWGt90GrAMWm9le4C2aVpb+N0Ll+p8AHwOzgEqgKlyncCOhJFEEfBuYFuFxfwssDR93JfBReJ3IV5gmhBH5KjMbBzzvnOt7iF1b6vsuAh5zzg1oi+8TAT0BiHgiXDx1sZklmVkfQhW+r3odl8QXJQARbxihJppFhIqA1nBgPwKRVqciIBGROKUnABGROBVV/QC6devmBg4c6HUYIiJRZdmyZTucc93rr4+qBDBw4ECWLm1Sq0ARkbhnZhsbWq8iIBGROKUEICISp5QARETilBKAiEicUgIQEYlTUdUKKB7Mzy3g8QV5bC4qoV/ndCaOHcy4oVlehyUiMUhPAD4yP7eASdNyKCguIzMtmYLiMiZNy2F+boHXoYlIDFIC8JHHF+SRnGikpyRhFnpNTjQeX5DndWgiEoOUAHxkc1EJacmJB6xLS04kv6jEo4hEJJYpAfhIv87plAYPnJyqNFhF387pHkUkIrFMCcBHJo4dTLDKUVJRiXOh12CVY+LYwV6HJiIxSAnAR8YNzWLK+GyyMlLZUxokKyOVKeOz1QpIRFqFmoH6zLihWbrgi0ibUAJogNrii0g8UBFQPWqLLyLxQgmgHrXFF5F4oQRQj9rii0i8UAKoR23xRSReKAHUo7b4IhIvlADqUVt8EYkXnjYDNbNMYCowAnDA9c65972MCdQWX0Tig9f9AP4EvOmcu8LMUgAVtIuINEFz+i15VgRkZh2BscCTAM65Cufcbq/iERGJNs3tt+RlHcBgoBB4ysw+NrOpZta+/k5mFjCzpWa2tLCwsO2jFBHxqeb2W/IyASQBJwCPOueOB/YDv6q/k3PuCefcKOfcqO7du7d1jCIivtXcfkteJoB8IN85tyS8/G9CCUFERCLQ3H5LniUA59w2YLOZDQmvOgdY7VU8IiLRprn9lrxuBfRT4B/hFkB5wHUexyMiEjXGDc1iCqG6gPyiEvo2sRWQpwnAObccGOVlDCIi0aw5/ZbUE1hEJE4pAYiIxCklABGROKUEICISp5QARETilBKAiEicUgIQEYlTSgAiInFKCUBEJE4pAYiIxCklABGROKUEICISp5QARETilBKAiEicUgIQEYlTSgAiInFKCUBEJE4pAYiIxCklABGROKUEICISp5QARETilBKAiEicUgIQEYlTSV4HINLa5ucW8PiCPDYXldCvczoTxw5m3NAsr8MS8ZyeACSmzc8tYNK0HAqKy8hMS6aguIxJ03KYn1vgdWginlMCkJj2+II8khON9JQkzEKvyYnG4wvyvA5NxHOeJwAzSzSzj81shtexSOzZXFRCWnLiAevSkhPJLyrxKCIR//A8AQA/A9Z4HYTEpn6d0ykNVh2wrjRYRd/O6R5FJOIfniYAM+sLXAJM9TIOiV0Txw4mWOUoqajEudBrsMoxcexgr0MT8ZzXTwAPA78EqhvbwcwCZrbUzJYWFha2WWASG8YNzWLK+GyyMlLZUxokKyOVKeOz1QpIBA+bgZrZpUCBc26ZmY1rbD/n3BPAEwCjRo1ybROdxJJxQ7N0wRdpgJdPAKcB481sA/BP4Gwze97DeERE4opnCcA5d7tzrq9zbiDwLWCec+67XsUjIhJvvK4DEBERj/hiKAjn3HxgvsdhiIjEFT0BiIjEKSUAEZE4pQQgIhKnlABEROKUEoCISJxSAhARiVNKACIiMWxfeWWj23zRD0BERFpWcVmQZ97bwNSF6xvdRwlARCSG7C0L8vSiDTy5cD17SoMH3VcJQEQkBuwprbnw57G3LFTsk5acyDVjBnDH/Q1/RglARCSK7SkN8tSi9Ty5cD3F4Qt/ekoi14wZyA/PGETXDu24o5HPKgGIiEShPSVBnly0nqcWfXnhb5+SyDWnDuSHZwymS/uUQx5DCUBEJIrsLqngyYXreXrRBorLv7zwXxu+8HeO4MJfQwlARCQKFO2vYOrCPJ55b2Nt084O7ZK47rSBfP/0QWSmR37hr6EEICLiY/vKK3l0/jqeXrSB/RVVAGS0S+K60wfx/dMG0Sk9+bCPrQQgIuJDzjleX76F+2atoaC4HICM1CSuP20Q1zfzwl9DCUBExGdWb9nL3dNW8eGGIgBSkxOYOPYIrj99EJ3Smn/hr6EEICLiE3tKgjwwdy3PL95ItQutu2RkL+64ZBh9MtNa/PuUAESi3PzcAh5fkMfmohL6dU5n4tjBjBua5XVY0gTV1Y6Xlm7m97PXsmt/BQBHZnVg8vhsTjuyW6t9rxKASBSbn1vApGk5JCcamWnJFBSXMWlaDlNASSBKLN+8m7tfX8WK/D1AqGXPTecexbWnDiQ5sXXH61QCkJgTT3fEjy/IIznRSE8J/SmnpyRRUlHJ4wvyYvZnjhU79pXz+zdzeWlpfu26r5/Qh19dOJSsjqltEoMSgMSUeLsj3lxUQma9SsG05ETyi0o8ikgOpbKqmucXb+SBuZ/W9uAd3qsjUyZkM2pglzaNJaoSwIad+9m+t4webZQdJfrE2x1xv87pFBSX1f68AKXBKvp2TvcwKmnMkryd3D0th9xtxQB0SkvmFxcM4duj+5OYYG0eT1RNCFNcVsl5D77DKx/l45zzOhzxoc1FJaQlJx6wLpbviCeOHUywylFSUYlzoddglWPi2MFehyZ1bNtTxo0vfsyVTywmd1sxZnDV6P789xfjuPqUAZ5c/CHKngASE4y9ZZX8/KUVzFq5jfu+PoKsDD0NyJfi7Y543NAsphB68skvKqFvjNd5RJuKymr+vmg9f377M0rCvXiP75/JlPEjGNm3U6t/f019WHL3gSMb2u5ZAjCzfsCzQE+gGnjCOfeng33m6B4ZnJzdg9k523lrzXaWPrSLyeOzGX9sb8y8yaDiLxPHDmbStBxKKipJS06kNFgV83fE44Zm6YLvQ+98WsjkaTnk7dgPQLcOKdx24VC+cUJfEtrgjr9ufRiuusF5Ib18AqgEbnHOfWRmGcAyM5vrnFvd2AeSEozHvnsi01Zs4e5pOewuCfKzfy5n1sqt/PbykXTPaNd20Ysv6Y5YvLZ5Vwm/mbGaOau3A6GSi2vGDOCmc49u0V68h1K/PqwhniUA59xWYGv4fbGZrQH6AI0mAAAzY8JxfRhzRFfueGUVb63Zzuyc7Xywfhe/uXwElx7Tuw2iFz/THbF4oSxYxWPvfM6j8z+nvLIagFMGd2Hy+BEM6ZnR5vE01EKsPl/UAZjZQOB4YEmkn8nKSOVv15zIa8u/4O7XcygqCfKTFz5m5idbmTJhhJ4GRKRNOOeYs3o7v5mxmvyiUgB6dkzlzkuGcekxvTwrnm6oPqw+z1sBmVkH4D/ATc65vQ1sD5jZUjNbWlhYWH8bXzu+L3N/fibnhO/43li1jfMfeofXl3+hlkIi0qo+L9zHtU99yMTnlpFfVEpyonHDuCN4+5Yzuczjusm6LcQaY15eJM0sGZgBzHbOPXio/UeNGuWWLl3a4Lb/rtnOvbNy+XzHPmp+pPOH9+C3X1NLIRFpWfvLK/nLvHU8uTCPYFXognPm0d25+7LhDO7ewePovlTTCug/v76qoqJg/VeKRTxLABZKjc8Au5xzN0XymcYSQN3a7qQEY3NRaW2Tq05pydwzfjiXH9dHLYVEpFmcc0xbERqjf/ve0Bj9/bqkMenSbM4dluXba4yZLXPOjaq/3ss6gNOAq4GVZrY8vO4O59ysph6ofm334G7tKSguZ9f+CvaUBrn5XyuYsWIr9319pHoRi8hhyd22l0mv5/DB+l0AtEtK4H/POpLA2MGk1ut8GC28bAW0EGiRdFm/ttvMyMpoR1KCcUzfTN7M2cbbuQWc9+A73HXpcK44sa9vM7WI+Mue0iAPzf2U5xZvpCo8SP+F2T2585Jh9OsS3R0MfdEKqLka6/05oGt7Hv3uCcxcuZVJr+ewa38Ft/77E2au3Mp9XxtJ71aYYEFEYkN1tePfy/K5/81cdobH6B/cvT33XJbN2KO7exxdy4ioDsDMvt7A6j3ASudcQYtH1YhI6gDq9v6cMj67tj34zn3lTJqWw8xPtgKhSZXvvGQYV57UT08DInKAFZt3M2laDis27wagfUoiPzv3KL536iBSkjxvPNlkjdUBRJoAZgJjgP+GV40DFgNHA1Occ8+1XKiNO1groJra7kP1/py1cit3vbaqNqOfcVQ3/t/XR8bsWDEiErld+yv4w+xc/vnh5trWhJcf15vbLx4W1fWHzU0A04EfOOe2h5d7AI8CPwAWOOdGtHC8DTpYAmiKXfsruGdaDtNWbAFC2f32i4fx7dH922SMDhHxl8qqal74YBMPzPmUPaVBAIb2zGDy+GxOHtzV4+iar7kJYKVzbmSdZSNU/DPCzD52zh3fsuE2rKUSQI3ZOdu489VV7NgXas41ZnBXfn/FMVFfsSMNi6eZwiRyH27YxaTXc1izNdQPtWNqErecP4TvnNyfpFaekrGtNDcB/B/QH3g5vOoKYDNwKzDDOXdWC8baqA59h7jLJj3Ton+4u0sqmDJ9Na98/AUA6SmJ3HbhUK4+ZYCeBmJIJPVEEl+27y3j/81aw2vLQyUBZnDlqH7cesEQunaIraFkmpsADPg6cDqhppsLgf+4Nu5Fltl/qDvxZ4+1yh/u22u2c8erK2s7d4we1IX7v3EMg7q1b7HvEO9c9cTir7QUK6moJCsjlRcDp3gYmbS1ispqnn5vPX966zP2hzuMHtu3E5MnjOC4fpneBteAlnhybSwBRPR8E77QLwLmA28DC9v64l8jPSWJ5ETj8QV5LXrcc4b1YM5NZ3LFiX0B+GD9Li58eAF//e86glXVLfpd0vbibaYwadi7nxVy0Z8WcN+sXPZXVNGlfQr3f2Mkr95wmm8v/pOm5VBQXHbAHNfzc1um8WVECcDMfgB8AHyNUPHPYjO7vkUiOAyt9YfbKT2ZP/7PsTx13Un0yUyjvLKaP8xey2V/WchHm4pa/Puk7fTrnE5psOqAdbE8U5gcKL+ohB8/v4yrn/yAzwv3k2DwvVMH8t9bxnHlSf5t/FF3lAMza/Eb4EhrOG4FjnfOfc85dy1wInBbi0RwGFr7D/esIVnMuXks1582iASD3G3FfOPR97j79VUUlwVb7Xul9Wju3PhUFqziz29/xrkPvsMbq7YBMHpgF2b89AzuGZ9Np/S2m6DlcLT2k2ukPYHzgeI6y8WEKoHbXFv94bZvl8Sky4Yz4bje/OqVlazZupdn3t/I7JztTJmQzfnZPVv1+6Vlaaaw+OKc4+01BUyZsZpNu0IXyx4d23HHxcOiagrZ1p7jOtJK4GeBkcDr4VXjCRUJfQoQyVDOLSGj7xB3aQu3AopEsKqavy9cz0NvfUpZMFQfcNGIntwzPjuqO4eI1BcLTWXX79jPlOk5/HdtaP6Q5ETj+tMH8dOzj6JDu+ga/aalWq81txXQ3eG3NTtb+L0BOOcmRxxJM7R0P4Cm2rSzhDtfW8m7n+0AQsNJ3HTe0VwzZgDJMdJeWOJXtDeVLamo5JF565j67noqwg03zjiqG3dfls2RWf4Zo7+pIh3l4GCamwBOAu4ABvJlsZFzzh3TpCiayesEAKFHy9eXb2HKjNXsCg8nMaRHBveMz2bMEdHfY1DiV7Q2lXXOMXPlVu6duYate8oA6JOZxl2XDueC7B5RU9zTmpo7H8DzwC+AVUBct4k0My4/vg9nHt2dB+au5R9LNrF2ezFX/W0xlx3bmzsvHkbPTioWkujT0CTifm8q++n2Yu5+PYf383YCkJKUwI/PPIIfnXkEaSnROUZ/W4o0ARQ656a3aiRRpnP7FH57+Ui+dVJ/Jr2+io827Wb6ii28vWY7N55zFNefFp2jBkr8au0Kx5a0tyzIw3M/45n3N9SO0X/e8B7cdclw+nf1X7x+FWkR0DnAVYQ6gZXXrHfOvdJ6oX2VH4qAGlJd7Xjl4y/43Rtr2LEvNscNl9gXDXUADf2tDerWnkmXDeesIf6I0Y+aWwfwPDAUyOHLIiDnnGvTzmB+TQA19paFZg569v0DZw769aXDfHkXJVJfS1Q4tpZVX+ypfdqG0LhdPz37KK4/fSDtklTcczAtOhqoV/yeAGrUnzs0NTmBG8ZF99yhIl4p2l/BH+as5cUPNtWO0X/Zsb254+Kh9OqkWf0i0dwE8DfgIefc6tYILlLRkgAg1DJh2oot3DdrTe0Ac/27pHP3ZcM5Z1gPj6MT8b+qaseLH2zij3PWsrsk1ANfLe4OT3MTwBrgCGA9oToAI06bgULTOsvsK6/kL/M+48l311MZLhY6Z2gWky4bzoCuGmlUpCHLNobG6M/ZEhqjP6NdEj8//2iuPmVAzIzR35aamwAGNLTeObexBWKLmB8SwOFWlK0r2Mc903JYuC7UiSwlKYEfjR3Mj8cdqeZqUSgWesz6UUFxGb97I5dXPvqidt3/nNiXX144lO4ZsTVGf1tqVgLwCz8kgOZ0lnHOMTtnG7+ZsYYvdpcCoQ4rd1w8jItH9lSHlSgRDa1lok2wqppn3tvAw299xr7ySgBG9unE5AnZnNC/s8fRRb/mdgSTsOZ0ljEzLhzRizOPzuL/5q/j8Xfy+GJ3Kf/7wkeMGtCZX1863JdjksuB6g7RC6E5KkoqKnl8QZ4SwGFYtG4H90zL4bOCfQB0Tk/m1guGcuVJ/Uj06TDNsUIJoIlaorNMWkoit5w/hL6ZafzuzVyKSoIs3VjE5X9dxITjevPLC4fSJ1OtG/wqGnvM+tEXu0u5b+YaZq7cCkCCwXdOHsAt5x9NZnqKx9HFB9WmNFFLjSs/P7eAv87/nC7tUxjYNb221/Dry7dw9h/n8/s3czX3gE9pcpnmKa+s4q//Xce5D7xTe/E/cUBnpv3kdH5z+Qhd/NuQpwnAzC40s7Vmts7MfuVlLJEaNzSLKeOzycpIZU9pkKyM1MMq+61bjJCRmszRWR3onpFCcqJRXlnN/83/nLP+OJ/nF2+kUlNS+oomlzl883K3c8FDC/jD7LWUBqvontGOB795LP/+0RhG9OnkdXhxx7NKYDNLJDSfwHmEJpz5ELjqYH0N/FAJ3FJOv38emWnJB1T8OucoKqngihP78cSCvNq7zCOzOnDHxUM5a0iWKop9oi16zMZSS6ONO/czZfpq3g7PZZuUYFx32kBuPOcoMlL9PStXLGjWpPCtZDSwzjmX55yrAP4JTDjYBzZu3Mj06aEx6SorKwkEAsyaNQuAsrIyAoEAc+bMAWDfvn0EAgHmzZsHwO7duwkEAixYsACAHTt2EAgEeO+99wDYtm0bgUCAJUuWAJCfn08gEGDZsmUAbNiwgUAgwIoVKwBYt24dgUCAnJwcANauXUsgEGDt2rUA5OTkEAgEWLduHQArVqwgEAiwYcMGALqWfkHhm3+hsjjULLR8y1oK3/wLvVIquPm8o/nDuA70Kd+IEWpCev3TSznxF8+weG0+APPmzSMQCLBvX6jibM6cOQQCAcrKQsPhzpo1i0AgQGVlqEXF9OnTCQQCtefy1Vdf5YYbbqhdfvnll7nxxhtrl1988UVuvvnm2uXnnnuOW2+9tXb56aef5vbbb69dnjp1KnfddVft8mOPPcbkyV9OE/HII49w77331i4//PDD3H///bXLDzzwAA888EDt8v3338/DDz9cu3zvvffyyCOP1C5PnjyZxx57rHb5rrvuYurUqbXLt99+O08//XTt8q233spzzz1Xu3zzzTfz4osv1i7feOONvPzyy7XLN9xwA6+++mrtciAQOOB374UHf83VfXfx7m1n89Q1x/HCg79u0d+9b373Ou6cOo2C4jI6VBSR99qD3Pn3mczPLWj2796yZcsIBALk54d+l5YsWUIgEGDbttCUie+99x6BQIAdO0K/mwsWLCAQCLB7926gab97JRWVTHxkBuN+/3btxf+ojtWM2TufOy8ZTkZqsn73mvi7dzjXvcZ4mQD6cOC0kvnhdQcws4CZLTWzpcFg7JSJjz+2N86F5ix1zlFeWYVz8N2T+wPQJS2B7P3L+cc1Izj9yG4A7EruzlVPreAXL6+gqCx6mu9K023dU0pS7WTgkGhGUkLLTQbe2hzwxqptnPvAO8zON5wl0rtTKo9+5wR+PLSSjOp9XocoeFsE9D/ABc65H4SXrwZGO+d+2thnYqkICCIvRnDOMf/TQu6buaa2qVxqcgKBMwYz8cwjaB9l09zFgtYunmmsiHBPaZB3bzu7xb6nNXy2vZh7puewaF14jP7EBCaeOZgfjzvigNZz0nb82A8gH+hXZ7kvsMWjWDwxbmhWRBcNM+OsIVmccWQ3Xlqaz4NzP2XHvnL+PG8d//xwM/d+bSTnDdf4Qm2lbkewzLRkCorLmDQthynQYkkgmsbmr1FcFuTPb3/GU4s2HDDsyV2XDmdgNw174kdeFgF9CBxlZoPMLAX4FjDNw3h8LykxgW+f3J/5t47jp2cfSWpyAgXF5fzw2aXc9M+PKQpPUSmtq24LLrPQa3JiyxbPRFNLI+ccr3yUz9kPvMPfwmNeDeiazt+/N4onv3eSLv4+5tkTgHOu0sx+AswGEoG/O+dyvIonmnRol8Qt5w/hm6P68atXPmHRup28tnwLC9ft5LeXZ3PhiF5ehxjT2qIj2LihWUwB347NXyNnyx7ufj2HpRuLgFDR5E/PPorvnz5IQ59HAY0FFOWcc7z4wWbum7WmdgyVS47pxZTx2XTtoMGzWkO0Tp7eknaXVPDAnE/5x5KNhEt7uGRkL+64ZJh6sfuQH5uBSgswM759cn9m3zy2dvrJmZ9s5byHFjB9xRaiKcFHi2gqnmlpVdWOF5Zs4qw/zue5xaGL/1FZHXjhByfz1++coIt/lNETQAxxzvHysnx+M2M1xWWhp4ELs3vym8tHaCjdFubnqRNby0ebirj79RxWfrEHCBVF3nTuUVx76kCSNUa/r2k46DiybU8Zd7y6knnhjjeZ6cncc1k2E47rrZ7E0mSFxeX8/s1cXl6WX7vu6yf04VcXDSUrI9XDyCRSSgBxxjnHqx9/weTpq9lTGupAd+6wLO792kh6dNQfbUuJpeEa6qusqubZ9zfy0NxPKQ7XL2X37siUCdmcOKCLx9FJUygBxKmCvWXc+doq5q7eDkDH1CSuP30Q3x7dnywlgmaJ5Ylh3v98J/dMy2Ht9mIAOqUlc+sFQ7hqdH+N0R+FlADiWM0E9fdMy6EoPLl2UoJx0cheXDtmACcO6KyiocMQa62BKiqrWfT5Dl76cDNvrAqNC2QGV43uzy/OH0KX9hqmOVr5sSewtBEzY8JxfTjtyG5MfXc9//pwE0UlQaav2ML0FVsY3qsj1546gPHH9tH8xE0QCxPDBKuqWbRuBzM/2crsnG3sDTceADi+fyZTxo9gZF8N0xyr9AQQh8qCVcz4ZCvPvr+BT/L31K7vlJbMlSf147snD6B/19YdciAWys6j9QkgWFXNe5/vZOYnW5izeju7S74cZNEMThrQhatO7seEY/uQoOKemKAiIGnQ8s27efa9Dcz4ZCsV4YlnzODsIVlcc+pAzjiyW4tfBFqr7LyguIzFebtYnLeTxXk7KdpfQdcO7RjSM4Mxg7ty8qAuHJnVocWKu6KpDiBYVc37n+9k1sqtvJmzrcGL/sUje3LRyF5qJBCDlADkoHbsK+dfH27m+cUb2bqnrHb9oG7tufqUAXzt+D50jrAM+FB39y1157xjXzlL8nbxft4OFuftYl3BoYcY7pyezKBu7enZKZUeHUP/e9a8dgq9b0oxmJ/7A1RWVfN+Xviiv2pbbf1PjZMGdubikb24aEQvenbSRT+WKQFIRCqrqnlrzXaeeW8j7+ftrF2fmGCMGtCZ84b34PzhPRstIorkrvhwhzretb+CJeG7+/fzdvLp9q9e8FOTExg1oAtjjuhKvy7pFOwt4+NNu1mct5OdEQ6W1zE16asJIpwcQsmiHavy9/C3het9V4RVWVXNkvW7mBEu099V72ceNSB80R/Zk16d1Gs3XigBSJN9ur2YZ9/fwCsffUFJxYGToA/pkcH52T04b3gPRvbpVHsxj+TuPtIngN0lFSxZv4v3Pw9d9HO3FX8lxnZJCZw4oDOnDO7KmCO6ckzfTrRL+uodvHOOvB37+XjTbrbsLmXb3jK27ykLve4tY8e+po+kmpRgpCYnkJhgJJjx7dH9OWd4D3p0TCUro12r9o4NTSJUzd6yIHtLK9myu5Q3c7Yxe9W2ryS6E8MX/Yt10Y9bSgBy2MqCVSz8bAdzV2/n7dztX7lY9uyYyrnDszhveE/ueOUTOqenHPTuvrGnhNsuGEJKcmLoDv/znazZtpf6v54piQkc3z+TMUd05ZTBXTmuX2aLjDpZUVlN4b5ytu0JJYTa13rvy4LVER3PDDqkJNG+XRLt2yXSoV0SKUkJGEb4X+1+hlFzuuov18RWFqyiNFhFWbCa/eWV7C0LEqxq/G/3hP6Z4Yt+L3prfJ64pwQgLaKq2rF8cxFzVm9n7urt5BXuP2B7ohmpKQlkpoXqCxIsVAHZpX07fveNkaSnJJGeksjHG4t4+r0NrN+5n+TEBNolJbBpV0ntyJI1khON4/t15pTBXTjliK6c0L+zZ8MMO+fYW1bJ+Q+9Q2pSIpXVjrJgFeWV1QSrqqmorMbLv6bj+2dyycheXDSylwZlkwMoAUir+LxwH3PDyeCjTUVfuWNvqqQE49h+mYwJF+mc0L+z7/omHKwIa+q1o2qLlfaWVrK/PDQx+r7yqnCCcLXnyAE4V5s0nIOapdD70GtKUgJpyYmkJode01IS6ZiWTMfUZDqmJtExLZlOackaf18apQQgra6wuJy312znxQ82sWrLXnCQkAAJZpRXNlx0kphgHNO3U6gMf3BXRg3s7Pt5Y6Op+acIKAGIx6qrHaXBKvZXVFJSHnqtqKzmqB4ZdIjCSe393PxTpD4NBSGeSkiwcIVoEmR4HU3zjRuapQu+RD3N4iAiEqeUAERE4pQSgIhInFICEBGJU0oAIiJxSglARCROqRmoSJSIhUl0xF/0BCASBWp6HxcUl5GZlkxBcRmTpuUwP7fA69AkinmSAMzsD2aWa2afmNmrZpbpRRwi0eLxBXkkJxrpKUmYhV6TE43HF+R5HZpEMa+eAOYCI5xzxwCfArd7FEfUmp9bwFVPLOb0++dx1ROLdScY4zYXlZBWb7C3aJuAXvzHkwTgnJvjnKsMLy4G+noRR7RScUD86dc5ndLggZPylAar6Nu54ZnZRCLhhzqA64E3GttoZgEzW2pmSwsLC9swLP9ScUD8mTh2MMEqR0lFJc6FXoNVjoljB3sdmkSxVksAZvaWma1q4P+EOvvcCVQC/2jsOM65J5xzo5xzo7p3795a4UYVFQfEn3FDs5gyPpusjFT2lAbJykjV8NPSbK3WDNQ5d+7BtpvZtcClwDkumsak9oF+ndO/MiFJaxUHqOmhf2gEUmlpXrUCuhC4DRjvnNNtaxO1VXGA6hpEYptXdQCPEBoVfq6ZLTezxzyKIyq1VXGA6hpEYpsnPYGdc0d68b2xpC2KAzYXlZCZlnzAOtU1iMQOP7QCEp9S00OR2KYEECcOp+OYmh6KxDYlgDhwuJW5anooEts0GmgcqFuZC5CekkRJRSWPL8g75MVcTQ9FYpcSQBxo68pc9R0QiQ4qAooDbVmZq74DItFDCSAOtGVlrvoOiEQPJYA40JaVuRqnSCR6qA4gTrRVZW5bjlPkV6oDkWihJwBpUfHed0B1IBJNlACkRcV73wHVgUg0URGQtLh47jug8ZMkmugJQKQFNdTkdse+cvaUBjV/s/iOEoBIC6pfB1JYXEbhvgrat0tUnYD4jhKASAuqXwdSUlFFVkYK3Tqkqk5AfEd1ACItrG4dyOn3z1OdgPiWEoBIK2rtfhHqcyDNoSIgkVbUmv0i1OdAmksJQKQVtWa/CPU5kOZSEZBIK2utfhHqcyDNpScAkSilOZuluZQARJrocOZXbg3xPu6SNJ8SgEgT+KniNd7HXZLmUx2ASBM0Z37l1hDP4y5J8ykBiDTB4VS8qq2++JWnRUBm9gszc2bWzcs4RCLV1IpXPxUZidTnWQIws37AecAmr2IQaaqmVryqrb74mZdPAA8BvwSchzGINElTK141R7L4mSd1AGY2HvjCObfCzLwIQeSwNaXiVXMki5+12hOAmb1lZqsa+D8BuBOYFOFxAma21MyWFhYWtla4Iq1CbfXFz8y5ti2BMbORwNtAzTNwX2ALMNo5t+1gnx01apRbunRpK0co0rJqWgHlF5XQV62AxANmtsw5N6r++jYvAnLOrQRqf/vNbAMwyjm3o61jEWkLaqsvfqWewCIiccrzjmDOuYFexyAiEo/0BCAiEqc8fwIQaS0agkHk4PQEIDFJQzCIHJoSgMQkDcEgcmhKABKTNASDyKEpAUhM0nSJIoemBCAxSUMwiByaEoDEJE2XKHJoagYqMUtDMIgcnJ4ARETilBKAiEicUgIQEYlTSgAiInFKCUBEJE61+YxgzWFmhcBGr+OIQDcgGia4iZY4QbG2FsXa8vwY5wDnXPf6K6MqAUQLM1va0PRrfhMtcYJibS2KteVFS5ygIiARkbilBCAiEqeUAFrHE14HEKFoiRMUa2tRrC0vWuJUHYCISLzSE4CISJxSAhARiVNKAIfBzPqZ2X/NbI2Z5ZjZzxrYx8zsz2a2zsw+MbMTfBzrODPbY2bLw/8neRRrqpl9YGYrwrFObmAfv5zXSGL1xXkNx5JoZh+b2YwGtvninNaJ52Cx+umcbjCzleE4ljaw3VfntSEaDvrwVAK3OOc+MrMMYJmZzXXOra6zz0XAUeH/JwOPhl/bWiSxArzrnLvUg/jqKgfOds7tM7NkYKGZveGcW1xnH7+c10hiBX+cV4CfAWuAjg1s88s5rXGwWME/5xTgLOdcY52+/HZev0JPAIfBObfVOfdR+H0xoV/WPvV2mwA860IWA5lm1quNQ400Vl8In6t94cXk8P/6rRT8cl4jidUXzKwvcAkwtZFdfHFOIaJYo4lvzmtjlACaycwGAscDS+pt6gNsrrOcj8cX3oPECjAmXJzxhpllt21kXwo//i8HCoC5zjnfntcIYgV/nNeHgV8C1Y1s98055dCxgj/OKYQS/hwzW2ZmgQa2++m8NkgJoBnMrAPwH+Am59ze+psb+Ihnd4iHiPUjQmOFHAv8BXitjcOr5Zyrcs4dB/QFRpvZiHq7+Oa8RhCr5+fVzC4FCpxzyw62WwPr2vycRhir5+e0jtOccycQKur5XzMbW2+7L87rwSgBHKZwue9/gH84515pYJd8oF+d5b7AlraIrb5Dxeqc21tTnOGcmwUkm1m3Ng6zfky7gfnAhfU2+ea81mgsVp+c19OA8Wa2AfgncLaZPV9vH7+c00PG6pNzWhPLlvBrAfAqMLreLn45r41SAjgMZmbAk8Aa59yDjew2Dbgm3BLgFGCPc25rmwUZFkmsZtYzvB9mNprQ78XOtouyNo7uZpYZfp8GnAvk1tvNL+f1kLH64bw65253zvV1zg0EvgXMc859t95uvjinkcTqh3Ma/u724UYVmFl74HxgVb3dfHFeD0atgA7PacDVwMpwGTDAHUB/AOfcY8As4GJgHVACXNf2YQKRxXoF8GMzqwRKgW85b7qI9wKeMbNEQn/YLznnZpjZj+rE6pfzGkmsfjmvX+HTc9ogn57THsCr4VyUBLzgnHszms4raCgIEZG4pSIgEZE4pQQgIhKnlABEROKUEoCISJxSAhARiVNKABL3zOwhM7upzvJsM5taZ/kBM/t5I5+dYmbnHuL495jZLxpYn2lmNzQjdJFmUQIQgfeAUwHMLAHoBtQdY+ZUYFFDH3TOTXLOvXWY35sJKAGIZ5QAREIX91PD77MJ9egsNrPOZtYOGAZgZu+EB/6aXTOqo5k9bWZXhN9fbGa5ZrbQQuPA1x3PfriZzTezPDO7Mbzud8ARFhpP/g9t8YOK1KWewBL3nHNbzKzSzPoTSgTvExq1cQywh9AQ2g8BE5xzhWZ2JXAvcH3NMcwsFXgcGOucW29mL9b7mqHAWUAGsNbMHgV+BYwIDygn0uaUAERCap4CTgUeJJQATiWUAL4gNNbL3HDX/0Sg/pguQ4E859z68PKLQN0hgmc658qBcjMrIDSUgIinlABEQmrqAUYSKgLaDNwC7AXmAX2cc2MO8vmGhv6tq7zO+yr0tyc+oDoAkZBFwKXArvA4/7sIVdKOAf4FdDezMRAaXruBiUhygcEWmnQH4MoIvrOYUJGQiCeUAERCVhJq/bO43ro94fHerwDuN7MVwHK+rDQGwDlXSqhFz5tmthDYTqj4qFHOuZ3AIjNbpUpg8YJGAxVpIWbWITxJvAF/BT5zzj3kdVwijdETgEjL+WF4zoUcoBOhVkEivqUnABGROKUnABGROKUEICISp5QARETilBKAiEicUgIQEYlT/x8iD25qPfMH0AAAAABJRU5ErkJggg== ) ### 3. After making the model, the residuals seem normally distributed. We can check this by constructing a QQ-plot, which compares the distribution of the residuals to a normal distribution. Here we use SciPy, but there are other methods; see [how to create a QQ-plot](../how-to-create-a-qq-plot). ```python from scipy import stats residuals = response - predictions # Compute the residuals stats.probplot(residuals, dist=\"norm\", plot=plt) plt.title(\"Normal Q-Q Plot\") plt.show() ``` ![png](data:image/png;base64,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 ) ### 4. After making the model, the residuals seem homoscedastic. This assumption is sometimes called \"equal variance,\" and can be checked by the `regplot` function in Seaborn. We must first standardize the residuals, which we can do with NumPy. We want to see a plot with no clear pattern; a cone shape to the data would indicate heteroscedasticity, the opposite of homoscedasticity. ```python import numpy as np standardized_residuals = np.sqrt(np.abs(residuals)) sns.regplot(x = predictions, y = standardized_residuals, scatter=True, lowess=True) plt.ylabel(\"Standarized residuals\") plt.xlabel(\"Fitted value\") plt.title(\"Scale-Location\") plt.show() ``` ![png](data:image/png;base64,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 ) Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to check the assumptions of a linear model/Python, using NumPy, SciPy, sklearn, Matplotlib and Seaborn.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-check-the-assumptions-of-a-linear-model-in-python-using-numpy-scipy-sklearn-matplotlib-and-seaborn/",
    "relUrl": "/how-to-check-the-assumptions-of-a-linear-model-in-python-using-numpy-scipy-sklearn-matplotlib-and-seaborn/"
  },"110": {
    "doc": "How to check the assumptions of a linear model (in R)",
    "title": "How to check the assumptions of a linear model (in R)",
    "content": "# How to check the assumptions of a linear model (in R) [See all solutions.](../how-to-check-the-assumptions-of-a-linear-model) ## Task If you plan to use a linear model to describe some data, it's important to check if it satisfies the assumptions for linear regression. How can we do that? ## Solution When performing a linear regression, the following assumptions should be checked. ### 1. We have two or more columns of numerical data of the same length. The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) We can see that our columns all have the same length. ```R df <- mtcars head(df) ``` mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 ### 2. Scatter plots we've made suggest a linear relationship. Scatterplots are covererd in [how to create basic plots](../how-to-create-basic-plots), but after making the model, we can also examine the residuals. So let's make the model. Our predictors will be the number of cylinders and the weight of the car and the response will be miles per gallon. (See also [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data).) ```R model = lm(mpg~ cyl + wt, data=df) ``` We test for linearity with residual plots. We show just one residual plot here; you should make one for each predictor. R's plot function knows how to create residual plots. (See also [how to compute the residuals of a linear model](../how-to-compute-the-residuals-of-a-linear-model).) ```R plot(model, which = 1) ``` ![png](data:image/png;base64,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 TqWnp1dcGxQUlPi/3nrrLSFEQECAra1tFbv98MMPKy12hw4d8vb27tKlS8UDnT9//sCBAxcu XPD39x8/frzu1bQjRowwNTW9dOlSamrqs88+O2nSpFo9JdnUUOwAAGiicnJyFi5caGVl5erq +vjjj9va2np7e589e7bsNhYWFh3/V4sWLUSZS7GXL18ODAy0tbW1tLT09fWNiooSQgwdOvTw 4cPLli2r+NJbjUYTHh4+ffr0soP379+3s7PbunWrl5dXx44dV69eLZPJzpw5c//+/StXrsyc ObNFixYKheK555570EtvoUOxAwCgKSoqKgoMDDx48OCuXbvu3r2bm5t77ty5Tp069e/fPzo6 uub7mTRpkqmp6V9//ZWcnOzm5jZ27Nji4uLjx487OjquWLEiKSmp3PZPPvlk586dyw1aWVl9 8803ffv21S2mpKQUFhY6OjpaWVkNHDjw3//+d2pqam5u7vbt283NzYcOHfoIf26JM5inYgEA QB367LPP4uLi4uPjHRwcdCOurq5ffvnl9OnTn3vuuXPnztVwP7/88otCobC0tBRCzJ49u3TO 4YcOlpubO3Xq1LFjx/r6+goh9uzZM3z4cHt7eyGEtbX1l19+WRoYFXHGDgCApuirr7569tln K5ak5cuXx8XFXbp0SbcYEhJi9r927txZdvtLly4FBQW1adPG3t5+8ODBQojc3NyHTnXjxo3+ /ftbWVnt3r1bCFFUVDRy5Mhu3brdunVLrVZ/9NFHTzzxRK1OKDY1FDsAAJqia9euubi4VBx3 dHS0sLAonZx/zJgxcf9r/PjxpRv//fffw4cP79u37+XLl1NSUk6ePPkokc6cOePu7j5s2LBD hw7p3iN6+vTp2NjY9evXt2nTxsLCYvr06Z6entu3b3+Uo0gbl2IBAGiKzMzMKj21VlxcXFBQ YGZmplu0srKq4vW1MTExOTk5S5Ys0b11MzIy8qHzREdHjxo1atOmTVOnTi0bRghRUlJSOlJU VPTQh2gKOGMHAEBT5O7ufuzYsYrjJ06cKCkpcXV1rclOOnXqJITQvXX96NGj+/btE0LcvHlT CKFUKq9du5aZmVm2lgkh7ty5c/PmzbS0NCFEcnLyzZs3MzIy8vLynn766ZkzZ/bv3//mf2Vm Znp5ebVt2/bVV19NT0/Pz8/fs2dPeHj4pEmTHv2PL1laVGfLli1CCLVare8gAADUmYiICCMj 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 rkJggg==) ### 3. After making the model, the residuals seem normally distributed. We can check this by constructing a QQ-plot, which compares the distribution of the residuals to a normal distribution. Here we use SciPy, but there are other methods; see [how to create a QQ-plot](../how-to-create-a-qq-plot). ```R plot(model, which = 2) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAADAFBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGC goKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OU lJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWm pqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4 uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnK ysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc 3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u 7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////i sF19AAAACXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3dB3wT5f8H8Ke7pZQyy16K66ds FJEhAopMUVCGAwUFFRQHCKiIBaEsQUARAWWDslEZMqsos2XIEgqUVQoFWmihM83zu5HVNkmT 3JPc+rxff3NP7i53X/rL55/L5e55CAUAyYjcBQBoAYIEwACCBMAAggTAAIIEwACCBMAAggTA AIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACC BMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTA AIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACC BMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTA AIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAggTAAIIEwACCBMAAgqR+PckluUsA BEkZFpOQU2Lr3vruvtY2SMaV3aoGR9YfdrHgKg5mAzMIkjIsJqSt2JIUpJutSckug/vXIyEL bddwMBvYQZCUYTFpSRYLLSlBym9Det/kG3+U89toXcHBbGAIQVKGxWRdzahUviUE6fzrVYLK ddlH+ZRcaxe6nvYmaQOiwpruuzukSnizeH69fd3KBdV8JZHaBmkFedIotmL97su3bNzBbGAI QVKGxWTDr2QA3+KDdDGq5LAF46qG7KL0VdKnw/ijtC9pF31wQWiNzsPjVpWumEtpXGiVMXNG RETdsA1SZ7LTvMG2ZJdl4w5mA0MIkjIsJr/R5/x2UzFIfckarnUi4HFK+5Fn+M+Q/uQd7vEl 0oN7HEL+oXRWo51ccyaZaRuk8qF55g1OJhMtG3cwGxhCkJSBD9LF8Lp5QpCMkRWFQ7EW5AaX oKV8sz/Zyj1+JnyPmkVWiS/KzdpOPrYJksGvlmWDK8mH5qaD2cASgqQMfJC4j4tJQpCukDbC zP5kN/dfnNg8wT2OJju4x7lkOfe4qFVpwhliE6Q8UtOywRVcYtIGciYXmQ1egCApgxCkvHol zvNBSiBdhJmDuY+h/iSBb4qT0cI3HCFII0mT+bF75hUIEi0fnGPe4BQulJf4pDUvMhu8AEFS BiFIdLdfF3pffZps+kR6g+x1FKSssOoZXHNzwSB1IpvNG+xA/rZs3MFsYAhBUgYxSPQtsubh +pSWrSx8R2rql+YoSInkeX72yIJBWk6am85uxwfcZ7Rs3MFsYAhBUgZTkFIrVPsfF6Q3yVru ySG/ttRRkDL9GvJrVCUDbYNkaEpeSecbB6v5bbJu3MFsYAhBUgZTkOhCQrggJVUq+enC6KiI Iw6DRDuTgctHldkYWG3ZHZtLhK7UJeVf/3LE0/6h82237mA2sIMgKYM5SPQpPkj04huVA6N6 8SfqHAUppU+FyDa7aHTJSsm2F63mfP1YKUIeHHKm4OYdzAZmECTteZFscWM2MIEgac8G0tLg +mxgAkHSoA6k6YTpLs8GFhAkDbrzdpngVi7PBhYQJAAGJAfJcOJAFotCANTM8yD982L9bvE0 4RFCIr5jWBCAGnkcpL1BJIiUOts8/OUXSpJfWZYEoD4eB6lz0BrD5bqvBOyi9FR4O5YlAaiP x0Eq9wr3sJ0IZ4FeL1N4adJZq81xAKpy2IdBChrNPdwhb/PtTwMLLTxDAFTsgO+CVPs1/jFy BP/Ys2LhpRetH0hfkQxP9wEghxy+Uww3eRyk/iGW7mj2BHV3suJsBAnUxadBSijjN1JsvRIU uN/JiggSqIxPg0RPtPtcbNStvt7ZeggSqIxvg2SR5HwxggQqI1OQioEggcogSAAMIEgADCBI AAwgSAAMIEgADCBIAAwgSAAMIEgADCBIAAwgSAAMIEgADCBIAAwgSAAMIEgADCBIAAwgSAAM IEgADCBIAAwgSAAMIEgADCBIAAwgSAAMIEgADCBIAAwgSAAMIEgADCBIAAwgSAAMIEgADCBI AAwgSAAMIEgADCBIAAwgSAAMIEgADCBIAAwgSAAMIEgADCBIAAwgSAAMIEgADCBIAAwgSAAM IEgADCBIAAwgSAAMIEgADCBIAAwgSAAMIEgAjgSs5P/PJQgSaEdPIqrvYPmfuwrNuPphneBy T/7saHsIEuhSSmLiLrIgMTHJwfJuMQWfn6tce8mxf4YHfuZg/cJBOjK8Y8fhR+yuiiCBpiSS TZRe71st8vHttFlfbkaS/x/m50/7BdekpzqVL/nEXnHlDtVu85P5vbPNq1C/uQ+1szwRg2R5 RUxAq2HDWgXE2NsvggSaIgTpyVYXs6cEnplfgsvJ1Br55uf0Xi4D9brdzBhU0cCvm+b/jeV1 5lXC6v6dbnkiBsn8ipXBa/g11wSvsrNfBAk0hQ/SUbKfa9X5LLP0D5Q+9oXluRCk6+mUHiZn +HXjyA7zyyyrhH9i80QMkvkVDYeK6w5tZGe/CBJoCh+kteQu1+rSiw56jJ7zT7Q+54P019OV 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 uQuxdaJRhLLeIjmNSPdx/YJqK+ouWcX9lajP3k4KDNIgMpN7XE06yl2IjdthTRJCFPUWmUr4 ri1+IR/LXYgN5f2VqM/eTgoM0gdtc7lHY1hNuQuxcfPjXKqst0iDiGx+UidKQaPuKu+vRH32 dlJgkETZQc3lLqEQRb1FsgLaCtPXicJ6G1HUX8nK628nxQZpuvCJrCSKeoucJmKndqPJVpkr KURRfyUrr7+dlBqk2OAWeXLXUIii3iLxZJAwnUzWyFxJIYr6K1l4/+2koCClDeRMFtvLQhrd lLcakW1NinqLxJPBwnQSWStzJYUo6q9k5oO3k4KCdIkfTlo4kjV+QZ5Nl7scgbUmhb1FEkhf Yfo52SZvIYUp6q8k8snbSUFBsjD2I+8Z5C6iKEW9RXICWwvT3uSCzJUUoqi/ksA3byclBmkI GS93CfYo6y3StATfs3N+lepyF1KIsv5KPN+8nRQYpNVkiNwl2KWst8gc8iX3+D2JlruQQpT1 V6I+ezspMEj3kveGCxR09UssV05AJe7hhtyVmBlakueie/nVVdKIA8r7K1GfvZ0UGCRilih3 JVYx5poS5K7EImNozaCqgxRxbtNMgX8ln72dFBgkAPVBkAAYQJAAGECQABhAkAAYQJAAGECQ ABhAkAAYQJAAGECQABhAkAAYQJAAGECQABhAkAAYQJAAGECQABhAkAAYQJAAGECQABhAkAAY QJAAGECQABhAkAAYQJAAGECQABhAkAAYQJAAGECQABhAkAAYQJAAGECQABhAkAAYQJAAGECQ fKe/pyPZ9STJjhZc8rwc85YlbwQoguRlH1sGXiTNPQpSDP+SmPYOxj+1zYBxZbeqwZH1h110 d8sIEgsIkletH8IpRwZzj9M9CdIVssnZYpsM3GxNSnYZ3L8eCVno5pYRJBYQJO97mGQJUw+C tN7VIOW3Ib2FgZn/KOe30b0tI0gsIEjeZw3S2Qm1g6uPMXLtq+/WCCr/3H5+9vnXqwSV67KP 8m/pa+1C19ss7MQfE+4SvyMl969Sot43edxq+7qVC6r5SiK1zcAK8qRRbMX63ZfPvzKNa+eR tgXW700yPqkZXG2q0XbLwkas9WRPqleqZN1J+b77+2gCguR91iC90TBmUnWyjNKUmpHDF4+v FhJL6cWoksMWjKsasovSV0mfDuOP2izc8yr5Yu1N4e2eUjXyvSmdSX9K40KrjJkzIiLqhm2Q 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) ### 4. After making the model, the residuals seem homoscedastic. This assumption is sometimes called \"equal variance,\" and can be checked by the `regplot` function in Seaborn. We must first standardize the residuals, which we can do with NumPy. We want to see a plot with no clear pattern; a cone shape to the data would indicate heteroscedasticity, the opposite of homoscedasticity. ```R plot(model, which = 3) # assumption of equal variance ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAIAAAByhViMAAAACXBIWXMAABJ0AAASdAHeZh94 AAAgAElEQVR4nOzdeUBUZcP38WsYGHZBZBNFccENRRJEBRTCct9ySc30UcxcKEvThMo9M2+t zC1Nzcrccl/JfQMXxAUVdwRXQCSWQfZh3j/meXi5QQEVZuD4/fw1c51rzvkN3jf9OKtMrVYL AAAAVH16ug4AAACA8kGxAwAAkAiKHQAAgERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUO AABAIih2AAAAEkGxAwAAkAiKHQAAgERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUOAABA Iih2AAAAEkGxAwAAkAiKHQAAgERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUOAABAIih2 AAAAEkGxAwAAkAiKHQAAgERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUOAABAIih2AAAA EkGxAwAAkAiKHQAAgERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUOAABAIih2AAAAEkGx AwAAkAiKHQAAgERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUOAABAIih2AAAAEkGxAwAA kAiKHQAAgERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUOAABAIih2AAAAEkGxAwAAkAiK HQAAgERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUOAABAIih2AAAAEkGxAwAAkAiKHQAA gERQ7AAAACSCYgcAACARFDsAAACJoNgBAABIBMUOAABAIih2ACRo0KBBMpns4cOHug5SnjRf Kj4+XtdBAFReFDsA2pafn79ly5YePXrUq1fP2NjY2Ni4QYMGQ4cOjYyM1HW0/++vv/6SyWQz ZszQYYbvv//+zp07BW/d3Nw6d+5saGiow0gAKjl9XQcA8MYZPHjw33//Xbdu3f79+9vb26em pp4/f37Dhg3bt28PCQlp3769rgNWCnFxccHBwW5ubg0bNtSMBAUFBQUF6TYVgEqOYgdAq44e Pfr333/7+voeOnRIX////wravXt3r169xo8ff/HiRR3GqzzOnTun6wgAqh4OxQLQqmvXrgkh BgwYULjVCSF69uy5du3a+fPn5+fna0bi4+M/+uijWrVqmZqatmzZ8ueff87LyyuYHx4e/t57 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 LCyIqKKiQkU7c+bMqayszMjIKC4ulkqlYWFhXbq04yDs7e3NnZ/LyspiGMbd3Z2I3NzcuPnZ 06dPe3h4qL6DhHs7LU4WA0DHgcIOALSDm4Tlzqi9vby8POVF7gK+9957z8LCokuXLg8ePFBe e+HCBbUcVFnXrl0lEkleXp7yHPHt27d37Nhx8+ZNbnHGjBlisTgtLS0tLa2hoaGd7odVGDNm jEgkOnPmTFZWVv/+/bkP3N3d/cKFCwUFBfn5+aovsCMi7pcnmp0uB4COCYUdAGiHei/M3717 t+L1nTt3cnNz+/XrJ5FIhEKhq6vr9evXf/vtN25tfX39xo0b1XLQRgIDA8vKyr7//ntFZNWq VVFRUXV1ddyisbHxpEmTjh8/npSU5Obm1uyNI2okFotHjx6dk5OTlZXl4eHBBd3d3evq6rZs 2UJKF9hxE9PcbLIyFTe4AEDHhGvsAEA7uMvLTp06FRAQ8Pat1dXVffjhh/7+/g0NDX/5y19Y lo2JieFWLV26dMqUKb6+vvPnz+/WrdvevXt79eql4mK4NxYbG3vs2LHIyMhr167Z2tpKpdJj x46FhYUpPwk5PDz8hx9+uHr1quIxe21VWFjY+o29vb2/+uqr6upqRWHXv39/ExOTPXv22NjY ODg4cEHuDo+4uLiCggJ3d/ehQ4cSEcuyp06dsre3t7Oze7NUAUDzcMYOALTDxcXF3Nw8MzNT La0lJiba29uvWbMmOjpaX18/KSkpNDSUWzV58uRdu3YJhcI//elP69evHzNmzN/+9jeWZVXc P/FmevbsmZOTExISsn///pUrV966devrr79WPpVIRGPHjrWxsdHX1+eez9fevL29q6uriWjM mDFchGGY0aNHV1dXK98PGxAQEBwc/Ouvv65bt04xbf3LL7+UlJT4+PhoIE8AUBeGZVlt5wAA nVRcXNyKFSuOHz/+NtVDSEhIWlpaUVFRz549W7lLZWWlkZFRQEDAkSNH3vi4b6aoqKh3795z 5sxp9KNnHdDMmTPT0tJu376teGILAHR8OGMHAFqzcOFCU1PTtWvXtutR9uzZM3bs2MuXLysi SUlJRKT6SR/t5PPPPyeixYsXa/7QbXLv3r19+/aFhYWhqgN4t+AaOwDQGgMDg/j4+NDQ0Pj4 +KioqHY6iqOjY05Ojr+/f2RkpKWl5S+//PLdd9/Z2NjMnTu3nY7Y1N27dzMzM48cOZKZmRkb G9voccodTX19/ezZs01NTePi4rSdCwC0DQo7ANCm6dOnnzt3bsmSJaNGjXJxcWmPQwwfPvyn n3766quvEhISysvLe/ToERYWtnbtWu7pu5px/fr1hQsXmpmZrV+/XvEjFh3W6tWrz58/n5mZ KZFItJ0LALQNrrEDAAAA4AlcYwcAAADAEyjsAAAAAHji/wBv6bw+xpi+IgAAAABJRU5ErkJg gg==) Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to check the assumptions of a linear model/R.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-check-the-assumptions-of-a-linear-model-in-r/",
    "relUrl": "/how-to-check-the-assumptions-of-a-linear-model-in-r/"
  },"111": {
    "doc": "How to check the assumptions of a linear model",
    "title": "How to check the assumptions of a linear model",
    "content": " ",
    "url": "/how-to-check-the-assumptions-of-a-linear-model/",
    "relUrl": "/how-to-check-the-assumptions-of-a-linear-model/"
  },"112": {
    "doc": "How to check the assumptions of a linear model",
    "title": "Description",
    "content": "If you plan to use a linear model to describe some data, it’s important to check if it satisfies the assumptions for linear regression. How can we do that? . ",
    "url": "/how-to-check-the-assumptions-of-a-linear-model/#description",
    "relUrl": "/how-to-check-the-assumptions-of-a-linear-model/#description"
  },"113": {
    "doc": "How to check the assumptions of a linear model",
    "title": "Using NumPy, SciPy, sklearn, Matplotlib and Seaborn, in Python",
    "content": "View this solution alone. When performing a linear regression, the following assumptions should be checked. 1. We have two or more columns of numerical data of the same length. The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See how to quickly load some sample data.) We can see that our columns all have the same length. | 1 2 3 4 . | from rdatasets import data df = data('mtcars') df = df[['mpg','cyl','wt']] # Select the 3 variables we're interested in df.info() . | . | 1 2 3 4 5 6 7 8 9 10 . | &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 3 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 mpg 32 non-null float64 1 cyl 32 non-null int64 2 wt 32 non-null float64 dtypes: float64(2), int64(1) memory usage: 896.0 bytes . | . 2. Scatter plots we’ve made suggest a linear relationship. Scatterplots are covererd in how to create basic plots, but after making the model, we can also examine the residuals. So let’s make the model. Our predictors will be the number of cylinders and the weight of the car and the response will be miles per gallon. (See also how to fit a linear model to two columns of data.) . | 1 2 3 4 5 6 7 8 . | from sklearn.linear_model import LinearRegression model = LinearRegression() predictors = df[['cyl','wt']] response = df['mpg'] model.fit( X=predictors, y=response ) predictions = model.predict(predictors) . | . We test for linearity with residual plots. We show just one residual plot here; you should make one for each predictor. Seaborn has a function for just this purpose. (See also how to compute the residuals of a linear model.) . | 1 2 3 4 5 6 7 . | import seaborn as sns import matplotlib.pyplot as plt # The \"lowess\" parameter adds a smooth line through the data: sns.residplot(x = df['wt'], y = response, data=df, lowess=True) plt.xlabel(\"Weight\") plt.title('Miles per gallon') plt.show() . | . 3. After making the model, the residuals seem normally distributed. We can check this by constructing a QQ-plot, which compares the distribution of the residuals to a normal distribution. Here we use SciPy, but there are other methods; see how to create a QQ-plot. | 1 2 3 4 5 . | from scipy import stats residuals = response - predictions # Compute the residuals stats.probplot(residuals, dist=\"norm\", plot=plt) plt.title(\"Normal Q-Q Plot\") plt.show() . | . 4. After making the model, the residuals seem homoscedastic. This assumption is sometimes called “equal variance,” and can be checked by the regplot function in Seaborn. We must first standardize the residuals, which we can do with NumPy. We want to see a plot with no clear pattern; a cone shape to the data would indicate heteroscedasticity, the opposite of homoscedasticity. | 1 2 3 4 5 6 7 . | import numpy as np standardized_residuals = np.sqrt(np.abs(residuals)) sns.regplot(x = predictions, y = standardized_residuals, scatter=True, lowess=True) plt.ylabel(\"Standarized residuals\") plt.xlabel(\"Fitted value\") plt.title(\"Scale-Location\") plt.show() . | . Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-check-the-assumptions-of-a-linear-model/#using-numpy-scipy-sklearn-matplotlib-and-seaborn-in-python",
    "relUrl": "/how-to-check-the-assumptions-of-a-linear-model/#using-numpy-scipy-sklearn-matplotlib-and-seaborn-in-python"
  },"114": {
    "doc": "How to check the assumptions of a linear model",
    "title": "Solution, in R",
    "content": "View this solution alone. When performing a linear regression, the following assumptions should be checked. 1. We have two or more columns of numerical data of the same length. The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See how to quickly load some sample data.) We can see that our columns all have the same length. | 1 2 . | df &lt;- mtcars head(df) . | . | 1 2 3 4 5 6 7 . | mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 . | . 2. Scatter plots we’ve made suggest a linear relationship. Scatterplots are covererd in how to create basic plots, but after making the model, we can also examine the residuals. So let’s make the model. Our predictors will be the number of cylinders and the weight of the car and the response will be miles per gallon. (See also how to fit a linear model to two columns of data.) . | 1 . | model = lm(mpg~ cyl + wt, data=df) . | . We test for linearity with residual plots. We show just one residual plot here; you should make one for each predictor. R’s plot function knows how to create residual plots. (See also how to compute the residuals of a linear model.) . | 1 . | plot(model, which = 1) . | . 3. After making the model, the residuals seem normally distributed. We can check this by constructing a QQ-plot, which compares the distribution of the residuals to a normal distribution. Here we use SciPy, but there are other methods; see how to create a QQ-plot. | 1 . | plot(model, which = 2) . | . 4. After making the model, the residuals seem homoscedastic. This assumption is sometimes called “equal variance,” and can be checked by the regplot function in Seaborn. We must first standardize the residuals, which we can do with NumPy. We want to see a plot with no clear pattern; a cone shape to the data would indicate heteroscedasticity, the opposite of homoscedasticity. | 1 . | plot(model, which = 3) # assumption of equal variance . | . Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-check-the-assumptions-of-a-linear-model/#solution-in-r",
    "relUrl": "/how-to-check-the-assumptions-of-a-linear-model/#solution-in-r"
  },"115": {
    "doc": "How to check the assumptions of a linear model",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-check-the-assumptions-of-a-linear-model/#topics-that-include-this-task",
    "relUrl": "/how-to-check-the-assumptions-of-a-linear-model/#topics-that-include-this-task"
  },"116": {
    "doc": "How to check the assumptions of a linear model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-check-the-assumptions-of-a-linear-model/#opportunities",
    "relUrl": "/how-to-check-the-assumptions-of-a-linear-model/#opportunities"
  },"117": {
    "doc": "How to choose the sample size in a study with two population means (in Python, using statsmodels)",
    "title": "How to choose the sample size in a study with two population means (in Python, using statsmodels)",
    "content": "# How to choose the sample size in a study with two population means (in Python, using statsmodels) [See all solutions.](../how-to-choose-the-sample-size-in-a-study-with-two-population-means) ## Task When designing a study, it is important to choose a sample size that is large enough to perform a useful test but that is also economically feasible. How we choose the sample size depends on what test we plan to run on the data from our study. Here, let's say our data will be used to compare two population means. If we are planning such a study, how do we determine how large it should be in order for the test that compares the population means to have a certain power? Related tasks: * [How to compute the power of a test comparing two population means](../how-to-compute-the-power-of-a-test-comparing-two-population-means) ## Solution Example: Let’s say we’re designing a study to assess the effectiveness of a new four-week exercise program for weight loss. Assume that weight loss in four-week exercise programs is normally distributed with a standard deviation of around 5 pounds. The goal is that the new exercise program will have a 4-pound higher weight loss than the average program. (Notice that we will be comparing the means of two populations, the weight loss in each of two programs.) We choose a value $0 \\leq \\alpha \\leq 1$ as the probability of a Type I error in our test that compares the two means. (Recall, Type I error is for a false positive, finding we should reject $H_0$ when it's actually true). Let’s set $\\alpha$ to be 0.05 here. We choose a value $0 \\leq \\beta \\leq 1$ as the probability of a Type II error (false negative, failing to reject $H_0$ when it’s actually false). Let’s set $\\beta$ to be 0.2 here. The test's power is $1-\\beta$, or in this case, 0.8. What should the sample size be for each group? ```python from statsmodels.stats.power import TTestIndPower standard_deviation = 5 desired_increase = 4 alpha = 0.05 beta = 0.2 analysis = TTestIndPower() analysis.solve_power( effect_size=desired_increase / standard_deviation, power=1 - beta, alpha=alpha) ``` 25.52457250047935 Our sample size needs to be 26 participants in order for the power of the study to be 80% with our specified parameters. Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to choose the sample size in a study with two population means/Python, using statsmodels.ipynb). Contributed by Andrew Quagliaroli (aquagliaroli@falcon.bentley.edu) ",
    "url": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means-in-python-using-statsmodels/",
    "relUrl": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means-in-python-using-statsmodels/"
  },"118": {
    "doc": "How to choose the sample size in a study with two population means (in R)",
    "title": "How to choose the sample size in a study with two population means (in R)",
    "content": "# How to choose the sample size in a study with two population means (in R) [See all solutions.](../how-to-choose-the-sample-size-in-a-study-with-two-population-means) ## Task When designing a study, it is important to choose a sample size that is large enough to perform a useful test but that is also economically feasible. How we choose the sample size depends on what test we plan to run on the data from our study. Here, let's say our data will be used to compare two population means. If we are planning such a study, how do we determine how large it should be in order for the test that compares the population means to have a certain power? Related tasks: * [How to compute the power of a test comparing two population means](../how-to-compute-the-power-of-a-test-comparing-two-population-means) ## Solution Example: Let's say we're designing a study to assess the effectiveness of a new four-week exercise program for weight loss. Assume that weight loss in four-week exercise programs is normally distributed with a standard deviation of around 5 pounds. The goal is that the new exercise program will have a 4-pound higher weight loss than the average program. (Notice that we will be comparing the means of two populations, the weight loss in each of two programs.) We choose a value $0 \\le \\alpha \\le 1$ as the probability of a Type I error in our test that compares the two means. (Recall, Type I error is for a false positive, finding we should reject $H_0$ when it’s actually true). Let's set $\\alpha$ to be 0.05 here. We choose a value $0 \\le \\beta \\le 1$ as the probability of a Type II error (false negative, failing to reject $H_0$ when it’s actually false). Let's set $\\beta$ to be 0.2 here. The test's power is $1-\\beta$, or in this case, 0.8. What should the sample size be for each group? ```R # sd = standard deviation = 5 pounds # delta = desired increase = 4 pounds # sig.level = alpha = 0.05 # power = 1 - beta = 1 - 0.20 = 0.80 # n = NULL so R computes it for us power.t.test(n = NULL, delta = 4, sd = 5, sig.level = 0.05, power = 0.80) ``` Two-sample t test power calculation n = 25.52463 delta = 4 sd = 5 sig.level = 0.05 power = 0.8 alternative = two.sided NOTE: n is number in *each* group Our sample size needs to be 26 participants in order for the power of the study to be 80% with our specified parameters. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to choose the sample size in a study with two population means/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means-in-r/",
    "relUrl": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means-in-r/"
  },"119": {
    "doc": "How to choose the sample size in a study with two population means",
    "title": "How to choose the sample size in a study with two population means",
    "content": " ",
    "url": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/",
    "relUrl": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/"
  },"120": {
    "doc": "How to choose the sample size in a study with two population means",
    "title": "Description",
    "content": "When designing a study, it is important to choose a sample size that is large enough to perform a useful test but that is also economically feasible. How we choose the sample size depends on what test we plan to run on the data from our study. Here, let’s say our data will be used to compare two population means. If we are planning such a study, how do we determine how large it should be in order for the test that compares the population means to have a certain power? . Related tasks: . | How to compute the power of a test comparing two population means | . ",
    "url": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#description",
    "relUrl": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#description"
  },"121": {
    "doc": "How to choose the sample size in a study with two population means",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. Example: Let’s say we’re designing a study to assess the effectiveness of a new four-week exercise program for weight loss. Assume that weight loss in four-week exercise programs is normally distributed with a standard deviation of around 5 pounds. The goal is that the new exercise program will have a 4-pound higher weight loss than the average program. (Notice that we will be comparing the means of two populations, the weight loss in each of two programs.) . We choose a value $0 \\leq \\alpha \\leq 1$ as the probability of a Type I error in our test that compares the two means. (Recall, Type I error is for a false positive, finding we should reject $H_0$ when it’s actually true). Let’s set $\\alpha$ to be 0.05 here. We choose a value $0 \\leq \\beta \\leq 1$ as the probability of a Type II error (false negative, failing to reject $H_0$ when it’s actually false). Let’s set $\\beta$ to be 0.2 here. The test’s power is $1-\\beta$, or in this case, 0.8. What should the sample size be for each group? . | 1 2 3 4 5 6 7 8 9 10 . | from statsmodels.stats.power import TTestIndPower standard_deviation = 5 desired_increase = 4 alpha = 0.05 beta = 0.2 analysis = TTestIndPower() analysis.solve_power( effect_size=desired_increase / standard_deviation, power=1 - beta, alpha=alpha) . | . | 1 . | 25.52457250047935 . | . Our sample size needs to be 26 participants in order for the power of the study to be 80% with our specified parameters. Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#using-statsmodels-in-python",
    "relUrl": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#using-statsmodels-in-python"
  },"122": {
    "doc": "How to choose the sample size in a study with two population means",
    "title": "Solution, in R",
    "content": "View this solution alone. Example: Let’s say we’re designing a study to assess the effectiveness of a new four-week exercise program for weight loss. Assume that weight loss in four-week exercise programs is normally distributed with a standard deviation of around 5 pounds. The goal is that the new exercise program will have a 4-pound higher weight loss than the average program. (Notice that we will be comparing the means of two populations, the weight loss in each of two programs.) . We choose a value $0 \\le \\alpha \\le 1$ as the probability of a Type I error in our test that compares the two means. (Recall, Type I error is for a false positive, finding we should reject $H_0$ when it’s actually true). Let’s set $\\alpha$ to be 0.05 here. We choose a value $0 \\le \\beta \\le 1$ as the probability of a Type II error (false negative, failing to reject $H_0$ when it’s actually false). Let’s set $\\beta$ to be 0.2 here. The test’s power is $1-\\beta$, or in this case, 0.8. What should the sample size be for each group? . | 1 2 3 4 5 6 . | # sd = standard deviation = 5 pounds # delta = desired increase = 4 pounds # sig.level = alpha = 0.05 # power = 1 - beta = 1 - 0.20 = 0.80 # n = NULL so R computes it for us power.t.test(n = NULL, delta = 4, sd = 5, sig.level = 0.05, power = 0.80) . | . | 1 2 3 4 5 6 7 8 9 10 . | Two-sample t test power calculation n = 25.52463 delta = 4 sd = 5 sig.level = 0.05 power = 0.8 alternative = two.sided NOTE: n is number in *each* group . | . Our sample size needs to be 26 participants in order for the power of the study to be 80% with our specified parameters. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#solution-in-r",
    "relUrl": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#solution-in-r"
  },"123": {
    "doc": "How to choose the sample size in a study with two population means",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#topics-that-include-this-task",
    "relUrl": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#topics-that-include-this-task"
  },"124": {
    "doc": "How to choose the sample size in a study with two population means",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#opportunities",
    "relUrl": "/how-to-choose-the-sample-size-in-a-study-with-two-population-means/#opportunities"
  },"125": {
    "doc": "How to compare two nested linear models (in Python, using statsmodels)",
    "title": "How to compare two nested linear models (in Python, using statsmodels)",
    "content": "# How to compare two nested linear models (in Python, using statsmodels) [See all solutions.](../how-to-compare-two-nested-linear-models) ## Task Model $A$ is said to be \"nested\" in model $B$ if the predictors included in $A$ are a subset of those included in $B$. In such a situation, how can we determine if the larger model (in this case $B$) is significantly better than the smaller (reduced) model? We can use an Extra Sums of Squares test, also called a partial $F$-test, to compare two nested linear. This technique will also help us with another question. If we have a multivarate linear model, $$\\hat{y}=\\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\cdots + \\beta_kx_k,$$ how can we test the influence of only some of the coefficients? If we remove some of the coefficients, we have a smaller model nested in the larger one, so the question is the same. Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) We will create two models, one nested inside the other, in a natural way in this example. But this is not the only way to create nested models; it is just an example. ```python from rdatasets import data df = data('mtcars') ``` Consider a model using number of cylinders (cyl) and weight of car (wt) to predict its fuel efficiency (mpg). We create this model and perform an ANOVA to see if the predictors are significant. We use the Ordinary Least Squares module from `statsmodels`. ```python from statsmodels.formula.api import ols add_model = ols('mpg ~ cyl + wt', data = df).fit() import statsmodels.api as sm sm.stats.anova_lm(add_model, typ= 1) ``` | | df | sum_sq | mean_sq | F | PR(&gt;F) | . | cyl | 1.0 | 817.712952 | 817.712952 | 124.043687 | 5.424327e-12 | . | wt | 1.0 | 117.162269 | 117.162269 | 17.773034 | 2.220200e-04 | . | Residual | 29.0 | 191.171966 | 6.592137 | NaN | NaN | . In the final column of output we see that all numbers are below $0.05$, which suggests that both predictors are significant. A natural question to ask is whether the two predictors have an interaction effect. Let's create a model containing the interaction term. ```python int_model = ols('mpg ~ cyl*wt', data = df).fit() sm.stats.anova_lm(int_model, typ= 1) ``` | | df | sum_sq | mean_sq | F | PR(&gt;F) | . | cyl | 1.0 | 817.712952 | 817.712952 | 145.856269 | 1.280635e-12 | . | wt | 1.0 | 117.162269 | 117.162269 | 20.898350 | 8.942713e-05 | . | cyl:wt | 1.0 | 34.195767 | 34.195767 | 6.099533 | 1.988242e-02 | . | Residual | 28.0 | 156.976199 | 5.606293 | NaN | NaN | . As seen in the final column of output, there is a significant interaction between the two predictors (bottom number being below $0.05$). We now have one model (`add_model`) nested inside a larger model (`int_model`). To check which model is better, we can conduct an ANOVA comparing the two models. We use the `anova_lm` function from `statsmodels`. ```python from statsmodels.stats.anova import anova_lm anova_lm(add_model, int_model) ``` | | df_resid | ssr | df_diff | ss_diff | F | Pr(&gt;F) | . | 0 | 29.0 | 191.171966 | 0.0 | NaN | NaN | NaN | . | 1 | 28.0 | 156.976199 | 1.0 | 34.195767 | 6.099533 | 0.019882 | . We have just performed this hypothesis test: $H_0 =$ the two models are equally useful for predicting the outcome $H_a =$ the larger model is significantly better than the smaller model In the final column of the output, called **Pr(>F)**, the only number in that column is our test statistic, $0.019882$. Since is below our chosen threshold of $0.05$, we reject the null hypothesis, and prefer to use the second model. This method can be used to check if covariates should be included in the model, or if additional variables should be added as well. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compare two nested linear models/Python, using statsmodels.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-compare-two-nested-linear-models-in-python-using-statsmodels/",
    "relUrl": "/how-to-compare-two-nested-linear-models-in-python-using-statsmodels/"
  },"126": {
    "doc": "How to compare two nested linear models (in R)",
    "title": "How to compare two nested linear models (in R)",
    "content": "# How to compare two nested linear models (in R) [See all solutions.](../how-to-compare-two-nested-linear-models) ## Task Model $A$ is said to be \"nested\" in model $B$ if the predictors included in $A$ are a subset of those included in $B$. In such a situation, how can we determine if the larger model (in this case $B$) is significantly better than the smaller (reduced) model? We can use an Extra Sums of Squares test, also called a partial $F$-test, to compare two nested linear. This technique will also help us with another question. If we have a multivarate linear model, $$\\hat{y}=\\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\cdots + \\beta_kx_k,$$ how can we test the influence of only some of the coefficients? If we remove some of the coefficients, we have a smaller model nested in the larger one, so the question is the same. Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) We will create two models, one nested inside the other, in a natural way in this example. But this is not the only way to create nested models; it is just an example. ```R # install.packages(\"datasets\") # if you have not done so already library(datasets) data(mtcars) df F) cyl 1 817.7130 817.712952 124.04369 5.424327e-12 wt 1 117.1623 117.162269 17.77303 2.220200e-04 Residuals 29 191.1720 6.592137 NA NA The final column of output suggests that both predictors are significant. A natural question to ask is whether the two predictors have an interaction effect. Let’s create a model containing the interaction term. ```R # Build the model with interaction int_model F) cyl 1 817.71295 817.712952 145.856269 1.280635e-12 wt 1 117.16227 117.162269 20.898350 8.942713e-05 cyl:wt 1 34.19577 34.195767 6.099533 1.988242e-02 Residuals 28 156.97620 5.606293 NA NA As seen in the final column of output, there is a significant interaction between the two predictors. We now have one model (`add_model`) nested inside a larger model (`int_model`). To check which model is better, we can conduct an ANOVA comparing the two models. ```R # Use ANOVA to compare the models anova(add_model, int_model) ``` Res.Df RSS Df Sum of Sq F Pr(>F) 1 29 191.1720 NA NA NA NA 2 28 156.9762 1 34.19577 6.099533 0.01988242 We have just performed this hypothesis test: $H_0 =$ the two models are equally useful for predicting the outcome $H_a =$ the larger model is significantly better than the smaller model In the final column of the output, called `Pr(>F)`, the only number in that column is our test statistic, $0.01988$. Since is below our chosen threshold of $0.05$, we reject the null hypothesis, and prefer to use the second model. This method can be used to check if covariates should be included in the model, or if additional variables should be added as well. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compare two nested linear models/R.md). Contributed by: * Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) * Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-compare-two-nested-linear-models-in-r/",
    "relUrl": "/how-to-compare-two-nested-linear-models-in-r/"
  },"127": {
    "doc": "How to compare two nested linear models",
    "title": "How to compare two nested linear models",
    "content": " ",
    "url": "/how-to-compare-two-nested-linear-models/",
    "relUrl": "/how-to-compare-two-nested-linear-models/"
  },"128": {
    "doc": "How to compare two nested linear models",
    "title": "Description",
    "content": "Model $A$ is said to be “nested” in model $B$ if the predictors included in $A$ are a subset of those included in $B$. In such a situation, how can we determine if the larger model (in this case $B$) is significantly better than the smaller (reduced) model? We can use an Extra Sums of Squares test, also called a partial $F$-test, to compare two nested linear. This technique will also help us with another question. If we have a multivarate linear model, . \\[\\hat{y}=\\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\cdots + \\beta_kx_k,\\] how can we test the influence of only some of the coefficients? If we remove some of the coefficients, we have a smaller model nested in the larger one, so the question is the same. Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to conduct a mixed designs ANOVA | How to conduct a repeated measures ANOVA | How to perform an analysis of covariance (ANCOVA) | . ",
    "url": "/how-to-compare-two-nested-linear-models/#description",
    "relUrl": "/how-to-compare-two-nested-linear-models/#description"
  },"129": {
    "doc": "How to compare two nested linear models",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See how to quickly load some sample data.) . We will create two models, one nested inside the other, in a natural way in this example. But this is not the only way to create nested models; it is just an example. | 1 2 . | from rdatasets import data df = data('mtcars') . | . Consider a model using number of cylinders (cyl) and weight of car (wt) to predict its fuel efficiency (mpg). We create this model and perform an ANOVA to see if the predictors are significant. We use the Ordinary Least Squares module from statsmodels. | 1 2 3 4 5 . | from statsmodels.formula.api import ols add_model = ols('mpg ~ cyl + wt', data = df).fit() import statsmodels.api as sm sm.stats.anova_lm(add_model, typ= 1) . | . | | df | sum_sq | mean_sq | F | PR(&gt;F) | . | cyl | 1.0 | 817.712952 | 817.712952 | 124.043687 | 5.424327e-12 | . | wt | 1.0 | 117.162269 | 117.162269 | 17.773034 | 2.220200e-04 | . | Residual | 29.0 | 191.171966 | 6.592137 | NaN | NaN | . In the final column of output we see that all numbers are below $0.05$, which suggests that both predictors are significant. A natural question to ask is whether the two predictors have an interaction effect. Let’s create a model containing the interaction term. | 1 2 . | int_model = ols('mpg ~ cyl*wt', data = df).fit() sm.stats.anova_lm(int_model, typ= 1) . | . | | df | sum_sq | mean_sq | F | PR(&gt;F) | . | cyl | 1.0 | 817.712952 | 817.712952 | 145.856269 | 1.280635e-12 | . | wt | 1.0 | 117.162269 | 117.162269 | 20.898350 | 8.942713e-05 | . | cyl:wt | 1.0 | 34.195767 | 34.195767 | 6.099533 | 1.988242e-02 | . | Residual | 28.0 | 156.976199 | 5.606293 | NaN | NaN | . As seen in the final column of output, there is a significant interaction between the two predictors (bottom number being below $0.05$). We now have one model (add_model) nested inside a larger model (int_model). To check which model is better, we can conduct an ANOVA comparing the two models. We use the anova_lm function from statsmodels. | 1 2 . | from statsmodels.stats.anova import anova_lm anova_lm(add_model, int_model) . | . | | df_resid | ssr | df_diff | ss_diff | F | Pr(&gt;F) | . | 0 | 29.0 | 191.171966 | 0.0 | NaN | NaN | NaN | . | 1 | 28.0 | 156.976199 | 1.0 | 34.195767 | 6.099533 | 0.019882 | . We have just performed this hypothesis test: . $H_0 =$ the two models are equally useful for predicting the outcome . $H_a =$ the larger model is significantly better than the smaller model . In the final column of the output, called Pr(&gt;F), the only number in that column is our test statistic, $0.019882$. Since is below our chosen threshold of $0.05$, we reject the null hypothesis, and prefer to use the second model. This method can be used to check if covariates should be included in the model, or if additional variables should be added as well. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compare-two-nested-linear-models/#using-statsmodels-in-python",
    "relUrl": "/how-to-compare-two-nested-linear-models/#using-statsmodels-in-python"
  },"130": {
    "doc": "How to compare two nested linear models",
    "title": "Solution, in R",
    "content": "View this solution alone. The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See how to quickly load some sample data.) . We will create two models, one nested inside the other, in a natural way in this example. But this is not the only way to create nested models; it is just an example. | 1 2 3 4 . | # install.packages(\"datasets\") # if you have not done so already library(datasets) data(mtcars) df &lt;- mtcars . | . Consider a model using number of cylinders (cyl) and weight of car (wt) to predict its fuel efficiency (mpg). We create this model and perform an ANOVA to see if the predictors are significant. | 1 2 3 4 . | # Build the model add_model &lt;- lm(mpg ~ cyl + wt, data = df) # Perform an ANOVA anova(add_model) . | . | 1 2 3 4 . | Df Sum Sq Mean Sq F value Pr(&gt;F) cyl 1 817.7130 817.712952 124.04369 5.424327e-12 wt 1 117.1623 117.162269 17.77303 2.220200e-04 Residuals 29 191.1720 6.592137 NA NA . | . The final column of output suggests that both predictors are significant. A natural question to ask is whether the two predictors have an interaction effect. Let’s create a model containing the interaction term. | 1 2 3 4 . | # Build the model with interaction int_model &lt;- lm(mpg ~ cyl * wt, data = df) # Perform an ANOVA anova(int_model) . | . | 1 2 3 4 5 . | Df Sum Sq Mean Sq F value Pr(&gt;F) cyl 1 817.71295 817.712952 145.856269 1.280635e-12 wt 1 117.16227 117.162269 20.898350 8.942713e-05 cyl:wt 1 34.19577 34.195767 6.099533 1.988242e-02 Residuals 28 156.97620 5.606293 NA NA . | . As seen in the final column of output, there is a significant interaction between the two predictors. We now have one model (add_model) nested inside a larger model (int_model). To check which model is better, we can conduct an ANOVA comparing the two models. | 1 2 . | # Use ANOVA to compare the models anova(add_model, int_model) . | . | 1 2 3 . | Res.Df RSS Df Sum of Sq F Pr(&gt;F) 1 29 191.1720 NA NA NA NA 2 28 156.9762 1 34.19577 6.099533 0.01988242 . | . We have just performed this hypothesis test: . $H_0 =$ the two models are equally useful for predicting the outcome . $H_a =$ the larger model is significantly better than the smaller model . In the final column of the output, called Pr(&gt;F), the only number in that column is our test statistic, $0.01988$. Since is below our chosen threshold of $0.05$, we reject the null hypothesis, and prefer to use the second model. This method can be used to check if covariates should be included in the model, or if additional variables should be added as well. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compare-two-nested-linear-models/#solution-in-r",
    "relUrl": "/how-to-compare-two-nested-linear-models/#solution-in-r"
  },"131": {
    "doc": "How to compare two nested linear models",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-compare-two-nested-linear-models/#topics-that-include-this-task",
    "relUrl": "/how-to-compare-two-nested-linear-models/#topics-that-include-this-task"
  },"132": {
    "doc": "How to compare two nested linear models",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compare-two-nested-linear-models/#opportunities",
    "relUrl": "/how-to-compare-two-nested-linear-models/#opportunities"
  },"133": {
    "doc": "How to compute a confidence interval for a mean difference (matched pairs) (in Python, using NumPy and SciPy)",
    "title": "How to compute a confidence interval for a mean difference (matched pairs) (in Python, using NumPy and SciPy)",
    "content": "# How to compute a confidence interval for a mean difference (matched pairs) (in Python, using NumPy and SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) ## Task Say we have two sets of data that are not independent of each other and come from a matched-pairs experiment, and we want to construct a confidence interval for the mean difference between these two samples. How do we make this confidence interval? Let's assume we've chosen a confidence level of $\\alpha$ = 0.05. Related tasks: * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We'll use Numpy and SciPy to do some statistics later. ```python import numpy as np from scipy import stats ``` This example computes a 95% confidence interval, but you can choose a different level by choosing a different value for $\\alpha$. ```python alpha = 0.05 ``` We have two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ and $x'_1, x'_2, x'_3, \\ldots, x'_k$. We're going to use some fake data below just as an example; replace it with your real data. ```python sample1 = np.array([15, 10, 7, 22, 17, 14]) sample2 = np.array([ 9, 1, 11, 13, 3, 6]) ``` And now the computations: ```python diff_samples = sample1 - sample2 # differences between the samples n = len(sample1) # number of observations per sample diff_mean = np.mean(diff_samples) # mean of the differences diff_variance = np.var( diff_samples, ddof=1 ) # variance of the differences critical_val = stats.t.ppf(q = 1-alpha/2, df = n - 1) # critical value radius = critical_val*np.sqrt(diff_variance)/np.sqrt(n) # radius of confidence interval ( diff_mean - radius, diff_mean + radius ) # confidence interval ``` (0.7033861582274517, 13.296613841772547) Our 95% confidence interval for the mean difference is $[0.70338, 13.2966]$. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a mean difference (matched pairs)/Python, using NumPy and SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs-in-python-using-numpy-and-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs-in-python-using-numpy-and-scipy/"
  },"134": {
    "doc": "How to compute a confidence interval for a mean difference (matched pairs) (in R)",
    "title": "How to compute a confidence interval for a mean difference (matched pairs) (in R)",
    "content": "# How to compute a confidence interval for a mean difference (matched pairs) (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) ## Task Say we have two sets of data that are not independent of each other and come from a matched-pairs experiment, and we want to construct a confidence interval for the mean difference between these two samples. How do we make this confidence interval? Let's assume we've chosen a confidence level of $\\alpha$ = 0.05. Related tasks: * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We have two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ and $x'_1, x'_2, x'_3, \\ldots, x'_k$. We're going to use some fake data below just as an example; replace it with your real data. ```R sample.1 <- c(15, 10, 7, 22, 17, 14) sample.2 <- c(9, 1, 11, 13, 3, 6) ``` The shortest way to create the confidence interval is with R's `t.test()` function. It's just one line of code (after we choose $\\alpha$). ```R alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) t.test(sample.1, sample.2, paired = TRUE, conf.level = 1-alpha) ``` Paired t-test data: sample.1 and sample.2 t = 2.8577, df = 5, p-value = 0.0355 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.7033862 13.2966138 sample estimates: mean of the differences 7 If you need the lower and upper bounds later, you can save them as variables as follows. ```R conf.interval <- t.test(sample.1, sample.2, paired = TRUE, conf.level = 1-alpha) lower.bound <- conf.interval$conf.int[1] upper.bound <- conf.interval$conf.int[2] ``` It's also possible to do the computation manually, using the code below. ```R diff.samples <- sample.1 - sample.2 # differences between the samples n = length(sample.1) # number of observations per sample diff.mean <- mean(diff.samples) # mean of the differences diff.variance <- var( diff.samples ) # variance of the differences critical.val <- qt(p = alpha/2, df = n - 1, lower.tail=FALSE) # critical value radius <- critical.val*sqrt(diff.variance)/sqrt(n) # radius of confidence interval c( diff.mean - radius, diff.mean + radius ) # confidence interval ``` [1] 0.7033862 13.2966138 Either method gives the same result. Our 95% confidence interval is $[0.70338, 13.2966]$. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a mean difference (matched pairs)/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs-in-r/"
  },"135": {
    "doc": "How to compute a confidence interval for a mean difference (matched pairs)",
    "title": "How to compute a confidence interval for a mean difference (matched pairs)",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/"
  },"136": {
    "doc": "How to compute a confidence interval for a mean difference (matched pairs)",
    "title": "Description",
    "content": "Say we have two sets of data that are not independent of each other and come from a matched-pairs experiment, and we want to construct a confidence interval for the mean difference between these two samples. How do we make this confidence interval? Let’s assume we’ve chosen a confidence level of $\\alpha$ = 0.05. Related tasks: . | How to do a hypothesis test for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a population mean | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#description"
  },"137": {
    "doc": "How to compute a confidence interval for a mean difference (matched pairs)",
    "title": "Using NumPy and SciPy, in Python",
    "content": "View this solution alone. We’ll use Numpy and SciPy to do some statistics later. | 1 2 . | import numpy as np from scipy import stats . | . This example computes a 95% confidence interval, but you can choose a different level by choosing a different value for $\\alpha$. | 1 . | alpha = 0.05 . | . We have two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ and $x’_1, x’_2, x’_3, \\ldots, x’_k$. We’re going to use some fake data below just as an example; replace it with your real data. | 1 2 . | sample1 = np.array([15, 10, 7, 22, 17, 14]) sample2 = np.array([ 9, 1, 11, 13, 3, 6]) . | . And now the computations: . | 1 2 3 4 5 6 7 . | diff_samples = sample1 - sample2 # differences between the samples n = len(sample1) # number of observations per sample diff_mean = np.mean(diff_samples) # mean of the differences diff_variance = np.var( diff_samples, ddof=1 ) # variance of the differences critical_val = stats.t.ppf(q = 1-alpha/2, df = n - 1) # critical value radius = critical_val*np.sqrt(diff_variance)/np.sqrt(n) # radius of confidence interval ( diff_mean - radius, diff_mean + radius ) # confidence interval . | . | 1 . | (0.7033861582274517, 13.296613841772547) . | . Our 95% confidence interval for the mean difference is $[0.70338, 13.2966]$. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#using-numpy-and-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#using-numpy-and-scipy-in-python"
  },"138": {
    "doc": "How to compute a confidence interval for a mean difference (matched pairs)",
    "title": "Solution, in R",
    "content": "View this solution alone. We have two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ and $x’_1, x’_2, x’_3, \\ldots, x’_k$. We’re going to use some fake data below just as an example; replace it with your real data. | 1 2 . | sample.1 &lt;- c(15, 10, 7, 22, 17, 14) sample.2 &lt;- c(9, 1, 11, 13, 3, 6) . | . The shortest way to create the confidence interval is with R’s t.test() function. It’s just one line of code (after we choose $\\alpha$). | 1 2 . | alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) t.test(sample.1, sample.2, paired = TRUE, conf.level = 1-alpha) . | . | 1 2 3 4 5 6 7 8 9 10 . | Paired t-test data: sample.1 and sample.2 t = 2.8577, df = 5, p-value = 0.0355 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.7033862 13.2966138 sample estimates: mean of the differences 7 . | . If you need the lower and upper bounds later, you can save them as variables as follows. | 1 2 3 . | conf.interval &lt;- t.test(sample.1, sample.2, paired = TRUE, conf.level = 1-alpha) lower.bound &lt;- conf.interval$conf.int[1] upper.bound &lt;- conf.interval$conf.int[2] . | . It’s also possible to do the computation manually, using the code below. | 1 2 3 4 5 6 7 8 . | diff.samples &lt;- sample.1 - sample.2 # differences between the samples n = length(sample.1) # number of observations per sample diff.mean &lt;- mean(diff.samples) # mean of the differences diff.variance &lt;- var( diff.samples ) # variance of the differences critical.val &lt;- qt(p = alpha/2, df = n - 1, lower.tail=FALSE) # critical value radius &lt;- critical.val*sqrt(diff.variance)/sqrt(n) # radius of confidence interval c( diff.mean - radius, diff.mean + radius ) # confidence interval . | . | 1 . | [1] 0.7033862 13.2966138 . | . Either method gives the same result. Our 95% confidence interval is $[0.70338, 13.2966]$. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#solution-in-r"
  },"139": {
    "doc": "How to compute a confidence interval for a mean difference (matched pairs)",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#topics-that-include-this-task"
  },"140": {
    "doc": "How to compute a confidence interval for a mean difference (matched pairs)",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs/#opportunities"
  },"141": {
    "doc": "How to compute a confidence interval for a population mean (in Julia)",
    "title": "How to compute a confidence interval for a population mean (in Julia)",
    "content": "# How to compute a confidence interval for a population mean (in Julia) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-population-mean) ## Task If we have a set of data that seems normally distributed, how can we compute a confidence interval for the mean? Assume we have some confidence level already chosen, such as $\\alpha=0.05$. We will use the $t$-distribution because we have not assumed that we know the population standard deviation, and we have not assumed anything about our sample size. If you know the population standard deviation or have a large sample size (typically at least 30), then you can use $z$-scores instead; see [how to compute a confidence interval for a population mean using z-scores](../how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores). Related tasks: * [How to compute a confidence interval for a population mean using z-scores](../how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. ```julia alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) data = [ 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ] # fake # Compute the confidence interval: using HypothesisTests confint( OneSampleTTest( data ), level=1-alpha, tail=:both ) ``` (70.2984781107082, 350.05446306576243) *Note:* The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. Content last modified on 05 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a population mean/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-in-julia/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-in-julia/"
  },"142": {
    "doc": "How to compute a confidence interval for a population mean (in Python, using SciPy)",
    "title": "How to compute a confidence interval for a population mean (in Python, using SciPy)",
    "content": "# How to compute a confidence interval for a population mean (in Python, using SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-population-mean) ## Task If we have a set of data that seems normally distributed, how can we compute a confidence interval for the mean? Assume we have some confidence level already chosen, such as $\\alpha=0.05$. We will use the $t$-distribution because we have not assumed that we know the population standard deviation, and we have not assumed anything about our sample size. If you know the population standard deviation or have a large sample size (typically at least 30), then you can use $z$-scores instead; see [how to compute a confidence interval for a population mean using z-scores](../how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores). Related tasks: * [How to compute a confidence interval for a population mean using z-scores](../how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution This solution uses a 95% confidence level, but you can change that in the first line of code, by specifing a different `alpha`. When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. ```python alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) data = [ 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ] # fake # We will use NumPy and SciPy to compute some of the statistics below. import numpy as np import scipy.stats as stats # Compute the sample mean, as an estimate for the population mean. sample_mean = np.mean( data ) # Compute the Standard Error for the sample Mean (SEM). sem = stats.sem( data ) # The margin of error then has the following formula. moe = sem * stats.t.ppf( 1 - alpha / 2, len( data ) - 1 ) # The confidence interval is centered on the mean with moe as its radius: ( sample_mean - moe, sample_mean + moe ) ``` (70.29847811072423, 350.0544630657464) *Note:* The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a population mean/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-in-python-using-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-in-python-using-scipy/"
  },"143": {
    "doc": "How to compute a confidence interval for a population mean (in R)",
    "title": "How to compute a confidence interval for a population mean (in R)",
    "content": "# How to compute a confidence interval for a population mean (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-population-mean) ## Task If we have a set of data that seems normally distributed, how can we compute a confidence interval for the mean? Assume we have some confidence level already chosen, such as $\\alpha=0.05$. We will use the $t$-distribution because we have not assumed that we know the population standard deviation, and we have not assumed anything about our sample size. If you know the population standard deviation or have a large sample size (typically at least 30), then you can use $z$-scores instead; see [how to compute a confidence interval for a population mean using z-scores](../how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores). Related tasks: * [How to compute a confidence interval for a population mean using z-scores](../how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. ```R alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) data <- c( 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ) # fake # If you need the two values stored in variables for later use, do: answer <- t.test( data, conf.level=1-alpha ) lower_bound <- answer$conf.int[1] upper_bound <- answer$conf.int[2] # If you just need to see the results in a report, do this alone: t.test( data, conf.level=1-alpha ) ``` One Sample t-test data: data t = 3.1853, df = 16, p-value = 0.005753 alternative hypothesis: true mean is not equal to 0 95 percent confidence interval: 70.29848 350.05446 sample estimates: mean of x 210.1765 *Note:* The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a population mean/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-in-r/"
  },"144": {
    "doc": "How to compute a confidence interval for a population mean using z-scores (in Python, using SciPy)",
    "title": "How to compute a confidence interval for a population mean using z-scores (in Python, using SciPy)",
    "content": "# How to compute a confidence interval for a population mean using z-scores (in Python, using SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores) ## Task If we have a set of data that seems normally distributed, how can we compute a confidence interval for the mean? Assume we have some confidence level already chosen, such as $\\alpha=0.05$. We will use the normal distribution, which assumes either that we know the population standard deviation, or we have a large enough sample size (typically at least 30). If neither of these is true in your case, then you can use $t$-scores instead; see [how to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean). Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * How to do a two-sided hypothesis test for a population mean * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution This solution uses a 95% confidence level, but you can change that in the first line of code, by specifing a different `alpha`. When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. We include the population standard deviation below, assuming it is known. See the notes at the end for what to do if you do not know the population standard deviation in your situation. ```python alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) pop_std = 250 # replace with your population standard devation, if known data = [ 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ] # fake # We will use NumPy and SciPy to compute some of the statistics below. import numpy as np import scipy.stats as stats # Compute the sample mean, as an estimate for the population mean. sample_mean = np.mean( data ) # The margin of error then has the following formula. z_score = stats.norm.ppf( 1 - alpha / 2 ) moe = pop_std * z_score / np.sqrt( len( data ) ) # The confidence interval is centered on the mean with moe as its radius: ( sample_mean - moe, sample_mean + moe ) ``` (91.33619807845439, 329.0167430980162) Notes: 1. If you do not have the population standard deviation, but your sample is large enough (typically at least 30), you can approximate the population standard deviation with the sample standard deviation, using the code `std = stats.tstd( data )`. If your sample is not that large, then consider using a different technique instead; see [how to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean). 2. The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a population mean using z-scores/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores-in-python-using-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores-in-python-using-scipy/"
  },"145": {
    "doc": "How to compute a confidence interval for a population mean using z-scores (in R)",
    "title": "How to compute a confidence interval for a population mean using z-scores (in R)",
    "content": "# How to compute a confidence interval for a population mean using z-scores (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores) ## Task If we have a set of data that seems normally distributed, how can we compute a confidence interval for the mean? Assume we have some confidence level already chosen, such as $\\alpha=0.05$. We will use the normal distribution, which assumes either that we know the population standard deviation, or we have a large enough sample size (typically at least 30). If neither of these is true in your case, then you can use $t$-scores instead; see [how to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean). Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * How to do a two-sided hypothesis test for a population mean * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. We include the population standard deviation below, assuming it is known. See the notes at the end for what to do if you do not know the population standard deviation in your situation. ```R alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) pop.std <- 250 # replace with your population standard devation, if known data <- c( 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ) # fake # Compute the sample mean, as an estimate for the population mean. sample.mean <- mean( data ) # The margin of error then has the following formula. z.score <- qnorm( alpha / 2, lower.tail=FALSE ) moe <- pop.std * z.score / sqrt( length( data ) ) # The confidence interval is centered on the mean with moe as its radius: c( sample.mean - moe, sample.mean + moe ) ``` [1] 91.3362 329.0167 Notes: 1. If you do not have the population standard deviation, but your sample is large enough (typically at least 30), you can approximate the population standard deviation with the sample standard deviation, using the code `pop.std <- sd( data )`. If your sample is not that large, then consider using a different technique instead; see [how to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean). 2. The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a population mean using z-scores/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores-in-r/"
  },"146": {
    "doc": "How to compute a confidence interval for a population mean using z-scores",
    "title": "How to compute a confidence interval for a population mean using z-scores",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/"
  },"147": {
    "doc": "How to compute a confidence interval for a population mean using z-scores",
    "title": "Description",
    "content": "If we have a set of data that seems normally distributed, how can we compute a confidence interval for the mean? Assume we have some confidence level already chosen, such as $\\alpha=0.05$. We will use the normal distribution, which assumes either that we know the population standard deviation, or we have a large enough sample size (typically at least 30). If neither of these is true in your case, then you can use $t$-scores instead; see how to compute a confidence interval for a population mean. Related tasks: . | How to compute a confidence interval for a population mean | How to do a two-sided hypothesis test for a population mean | How to do a two-sided hypothesis test for two sample means | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#description"
  },"148": {
    "doc": "How to compute a confidence interval for a population mean using z-scores",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. This solution uses a 95% confidence level, but you can change that in the first line of code, by specifing a different alpha. When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. We include the population standard deviation below, assuming it is known. See the notes at the end for what to do if you do not know the population standard deviation in your situation. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) pop_std = 250 # replace with your population standard devation, if known data = [ 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ] # fake # We will use NumPy and SciPy to compute some of the statistics below. import numpy as np import scipy.stats as stats # Compute the sample mean, as an estimate for the population mean. sample_mean = np.mean( data ) # The margin of error then has the following formula. z_score = stats.norm.ppf( 1 - alpha / 2 ) moe = pop_std * z_score / np.sqrt( len( data ) ) # The confidence interval is centered on the mean with moe as its radius: ( sample_mean - moe, sample_mean + moe ) . | . | 1 . | (91.33619807845439, 329.0167430980162) . | . Notes: . | If you do not have the population standard deviation, but your sample is large enough (typically at least 30), you can approximate the population standard deviation with the sample standard deviation, using the code std = stats.tstd( data ). If your sample is not that large, then consider using a different technique instead; see how to compute a confidence interval for a population mean. | The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. | . Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#using-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#using-scipy-in-python"
  },"149": {
    "doc": "How to compute a confidence interval for a population mean using z-scores",
    "title": "Solution, in R",
    "content": "View this solution alone. When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. We include the population standard deviation below, assuming it is known. See the notes at the end for what to do if you do not know the population standard deviation in your situation. | 1 2 3 4 5 6 7 8 9 10 11 12 13 . | alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) pop.std &lt;- 250 # replace with your population standard devation, if known data &lt;- c( 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ) # fake # Compute the sample mean, as an estimate for the population mean. sample.mean &lt;- mean( data ) # The margin of error then has the following formula. z.score &lt;- qnorm( alpha / 2, lower.tail=FALSE ) moe &lt;- pop.std * z.score / sqrt( length( data ) ) # The confidence interval is centered on the mean with moe as its radius: c( sample.mean - moe, sample.mean + moe ) . | . | 1 . | [1] 91.3362 329.0167 . | . Notes: . | If you do not have the population standard deviation, but your sample is large enough (typically at least 30), you can approximate the population standard deviation with the sample standard deviation, using the code pop.std &lt;- sd( data ). If your sample is not that large, then consider using a different technique instead; see how to compute a confidence interval for a population mean. | The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. | . Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#solution-in-r"
  },"150": {
    "doc": "How to compute a confidence interval for a population mean using z-scores",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#topics-that-include-this-task"
  },"151": {
    "doc": "How to compute a confidence interval for a population mean using z-scores",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean-using-z-scores/#opportunities"
  },"152": {
    "doc": "How to compute a confidence interval for a population mean",
    "title": "How to compute a confidence interval for a population mean",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean/"
  },"153": {
    "doc": "How to compute a confidence interval for a population mean",
    "title": "Description",
    "content": "If we have a set of data that seems normally distributed, how can we compute a confidence interval for the mean? Assume we have some confidence level already chosen, such as $\\alpha=0.05$. We will use the $t$-distribution because we have not assumed that we know the population standard deviation, and we have not assumed anything about our sample size. If you know the population standard deviation or have a large sample size (typically at least 30), then you can use $z$-scores instead; see how to compute a confidence interval for a population mean using z-scores. Related tasks: . | How to compute a confidence interval for a population mean using z-scores | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean/#description"
  },"154": {
    "doc": "How to compute a confidence interval for a population mean",
    "title": "Solution, in Julia",
    "content": "View this solution alone. When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. | 1 2 3 4 5 6 . | alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) data = [ 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ] # fake # Compute the confidence interval: using HypothesisTests confint( OneSampleTTest( data ), level=1-alpha, tail=:both ) . | . | 1 . | (70.2984781107082, 350.05446306576243) . | . Note: The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. Content last modified on 05 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean/#solution-in-julia",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean/#solution-in-julia"
  },"155": {
    "doc": "How to compute a confidence interval for a population mean",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. This solution uses a 95% confidence level, but you can change that in the first line of code, by specifing a different alpha. When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) data = [ 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ] # fake # We will use NumPy and SciPy to compute some of the statistics below. import numpy as np import scipy.stats as stats # Compute the sample mean, as an estimate for the population mean. sample_mean = np.mean( data ) # Compute the Standard Error for the sample Mean (SEM). sem = stats.sem( data ) # The margin of error then has the following formula. moe = sem * stats.t.ppf( 1 - alpha / 2, len( data ) - 1 ) # The confidence interval is centered on the mean with moe as its radius: ( sample_mean - moe, sample_mean + moe ) . | . | 1 . | (70.29847811072423, 350.0544630657464) . | . Note: The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean/#using-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean/#using-scipy-in-python"
  },"156": {
    "doc": "How to compute a confidence interval for a population mean",
    "title": "Solution, in R",
    "content": "View this solution alone. When applying this technique, you would have a series of data values for which you needed to compute a confidence interval for the mean. But in order to provide code that runs independently, we create some fake data below. When using this code, replace our fake data with your real data. | 1 2 3 4 5 6 7 8 9 10 . | alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) data &lt;- c( 435,542,435,4,54,43,5,43,543,5,432,43,36,7,876,65,5 ) # fake # If you need the two values stored in variables for later use, do: answer &lt;- t.test( data, conf.level=1-alpha ) lower_bound &lt;- answer$conf.int[1] upper_bound &lt;- answer$conf.int[2] # If you just need to see the results in a report, do this alone: t.test( data, conf.level=1-alpha ) . | . | 1 2 3 4 5 6 7 8 9 10 . | One Sample t-test data: data t = 3.1853, df = 16, p-value = 0.005753 alternative hypothesis: true mean is not equal to 0 95 percent confidence interval: 70.29848 350.05446 sample estimates: mean of x 210.1765 . | . Note: The solution above assumes that the population is normally distributed, which is a common assumption in introductory statistics courses, but we have not verified that assumption here. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean/#solution-in-r"
  },"157": {
    "doc": "How to compute a confidence interval for a population mean",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean/#topics-that-include-this-task"
  },"158": {
    "doc": "How to compute a confidence interval for a population mean",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-population-mean/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-population-mean/#opportunities"
  },"159": {
    "doc": "How to compute a confidence interval for a regression coefficient (in Python, using statsmodels)",
    "title": "How to compute a confidence interval for a regression coefficient (in Python, using statsmodels)",
    "content": "# How to compute a confidence interval for a regression coefficient (in Python, using statsmodels) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) ## Task Say we have a linear regression model, either single variable or multivariate. How do we compute a confidence interval for the coefficient of one of the explanatory variables in the model? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We’ll assume that you have fit a single linear model to your data, as in the code below, which uses fake example data. You can replace it with your actual data. ```python import statsmodels.api as sm xs = [ 34, 9, 78, 60, 22, 45, 83, 59, 25 ] ys = [ 126, 347, 298, 309, 450, 187, 266, 385, 400 ] xs = sm.add_constant( xs ) model = sm.OLS( ys, xs ) results = model.fit() ``` We can use Python’s `conf_int()` function to find the confidence interval for the model coefficients. You can change the `alpha` parameter to specify a different significance level. Note that if you have a multiple regression model, it will make confidence intervals for all of the coefficient values. ```python results.conf_int( alpha=0.05 ) ``` array([[172.63807531, 535.52642049], [ -4.49196063, 2.47393542]]) Each list in the array represents the 95% confidence interval for the corresponding coefficient in the model beginning with the intercept and each regression coefficient thereafter. Accordingly, the 95% confidence interval for the regression coefficient is $[-4.49196063,2.47393542]$. Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a regression coefficient/Python, using statsmodels.ipynb). Contributed by Andrew Quagliaroli (aquagliaroli@falcon.bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient-in-python-using-statsmodels/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient-in-python-using-statsmodels/"
  },"160": {
    "doc": "How to compute a confidence interval for a regression coefficient (in R)",
    "title": "How to compute a confidence interval for a regression coefficient (in R)",
    "content": "# How to compute a confidence interval for a regression coefficient (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) ## Task Say we have a linear regression model, either single variable or multivariate. How do we compute a confidence interval for the coefficient of one of the explanatory variables in the model? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We'll assume that you have fit a single linear model to your data, as in the code below, which uses fake example data. You can replace it with your actual data. ```R x <- c(34, 9, 78, 60, 22, 45, 83, 59, 25) y <- c(126, 347, 298, 309, 450, 187, 266, 385, 400) model <- lm(y ~ x) ``` We can use R's `confint()` function to find the confidence interval for the model coefficients. You can change the `level` parameter to specify a different confidence level. Note that if you have a multiple regression model, it will make confidence intervals for all of the coefficient values. ```R confint(model, level = 0.95) # or choose any confidence level; here we use 0.95 ``` 2.5 % 97.5 % (Intercept) 172.638075 535.526421 x -4.491961 2.473935 The 95% confidence interval for the regression coefficient is $[-4.491961, 2.473935]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a regression coefficient/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient-in-r/"
  },"161": {
    "doc": "How to compute a confidence interval for a regression coefficient",
    "title": "How to compute a confidence interval for a regression coefficient",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/"
  },"162": {
    "doc": "How to compute a confidence interval for a regression coefficient",
    "title": "Description",
    "content": "Say we have a linear regression model, either single variable or multivariate. How do we compute a confidence interval for the coefficient of one of the explanatory variables in the model? . Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a population mean | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#description"
  },"163": {
    "doc": "How to compute a confidence interval for a regression coefficient",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. We’ll assume that you have fit a single linear model to your data, as in the code below, which uses fake example data. You can replace it with your actual data. | 1 2 3 4 5 6 7 8 . | import statsmodels.api as sm xs = [ 34, 9, 78, 60, 22, 45, 83, 59, 25 ] ys = [ 126, 347, 298, 309, 450, 187, 266, 385, 400 ] xs = sm.add_constant( xs ) model = sm.OLS( ys, xs ) results = model.fit() . | . We can use Python’s conf_int() function to find the confidence interval for the model coefficients. You can change the alpha parameter to specify a different significance level. Note that if you have a multiple regression model, it will make confidence intervals for all of the coefficient values. | 1 . | results.conf_int( alpha=0.05 ) . | . | 1 2 . | array([[172.63807531, 535.52642049], [ -4.49196063, 2.47393542]]) . | . Each list in the array represents the 95% confidence interval for the corresponding coefficient in the model beginning with the intercept and each regression coefficient thereafter. Accordingly, the 95% confidence interval for the regression coefficient is $[-4.49196063,2.47393542]$. Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#using-statsmodels-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#using-statsmodels-in-python"
  },"164": {
    "doc": "How to compute a confidence interval for a regression coefficient",
    "title": "Solution, in R",
    "content": "View this solution alone. We’ll assume that you have fit a single linear model to your data, as in the code below, which uses fake example data. You can replace it with your actual data. | 1 2 3 . | x &lt;- c(34, 9, 78, 60, 22, 45, 83, 59, 25) y &lt;- c(126, 347, 298, 309, 450, 187, 266, 385, 400) model &lt;- lm(y ~ x) . | . We can use R’s confint() function to find the confidence interval for the model coefficients. You can change the level parameter to specify a different confidence level. Note that if you have a multiple regression model, it will make confidence intervals for all of the coefficient values. | 1 . | confint(model, level = 0.95) # or choose any confidence level; here we use 0.95 . | . | 1 2 3 . | 2.5 % 97.5 % (Intercept) 172.638075 535.526421 x -4.491961 2.473935 . | . The 95% confidence interval for the regression coefficient is $[-4.491961, 2.473935]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#solution-in-r"
  },"165": {
    "doc": "How to compute a confidence interval for a regression coefficient",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#topics-that-include-this-task"
  },"166": {
    "doc": "How to compute a confidence interval for a regression coefficient",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-regression-coefficient/#opportunities"
  },"167": {
    "doc": "How to compute a confidence interval for a single population variance (in Python, using SciPy)",
    "title": "How to compute a confidence interval for a single population variance (in Python, using SciPy)",
    "content": "# How to compute a confidence interval for a single population variance (in Python, using SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-single-population-variance) ## Task Let's say we want to compute a confidence interval for the variability of a population. We take a sample of data, $x_1, x_2, x_3, \\ldots, x_k$ and compute its variance, $s^2$. How do we construct a confidence interval for the population variance $\\sigma^2$? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We'll use R's dataset EuStockMarkets here. This dataset has information on the daily closing prices of 4 European stock indices. We're going to look at the variability of Germany's DAX closing prices. For more information on how this is done, see [how to quickly load some sample data](../how-to-quickly-load-some-sample-data). You can replace the example data below with your actual data. ```python # Load in EuStockMarkets data from rdatasets import data import pandas as pd df = data('EuStockMarkets') # Select the column for Germany's DAX closing prices sample = df['DAX'] ``` Now that we have our sample data loaded, let's go ahead and make the confidence interval using SciPy. ```python from scipy import stats # Find the critical values from the right and left tails of the Chi-square distribution alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) n = len( sample ) left_critical_val = stats.chi2.ppf(1-alpha/2, df=n-1) right_critical_val = stats.chi2.ppf(alpha/2, df=n-1) # Find the upper and lower bounds of the confidence interval and print them out lower_bound = ((n - 1)*sample.var())/left_critical_val upper_bound = ((n - 1)*sample.var())/right_critical_val lower_bound, upper_bound ``` (1104642.2801539514, 1256248.1273200295) Our 95% confidence interval for the standard deviation of Germany's DAX closing prices is $[1104642, 1256248]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a single population variance/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-single-population-variance-in-python-using-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-single-population-variance-in-python-using-scipy/"
  },"168": {
    "doc": "How to compute a confidence interval for a single population variance (in R)",
    "title": "How to compute a confidence interval for a single population variance (in R)",
    "content": "# How to compute a confidence interval for a single population variance (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-a-single-population-variance) ## Task Let's say we want to compute a confidence interval for the variability of a population. We take a sample of data, $x_1, x_2, x_3, \\ldots, x_k$ and compute its variance, $s^2$. How do we construct a confidence interval for the population variance $\\sigma^2$? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We'll use R's dataset EuStockMarkets here. This dataset has information on the daily closing prices of 4 European stock indices. We're going to look at the variability of Germany's DAX closing prices. Feel free to replace this sample data with your actual data if you use this code. ```R # install.packages(\"datasets\") # if you have not done so already library(datasets) # Load stock market data, convert to DataFrame, and choose the DAX column. EuStockMarkets <- data.frame(EuStockMarkets) sample <- EuStockMarkets$DAX ``` Now that we have our sample data loaded, let's go ahead and make the confidence interval. ```R # Find the critical values from the right and left tails of the Chi-square distribution alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) n <- length(sample) left_critical_val <- qchisq(p = alpha/2, df = n-1, lower.tail=FALSE) right_critical_val <- qchisq(p = 1-alpha/2, df = n-1, lower.tail=FALSE) # Find the upper and lower bounds of the confidence interval and print them out lower_bound <- ((n - 1)*var(sample))/left_critical_val upper_bound <- ((n - 1)*var(sample))/right_critical_val lower_bound upper_bound ``` [1] 1104642 [1] 1256248 Our 95% confidence interval for the standard deviation of Germany's DAX closing prices is $[1104642, 1256248]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for a single population variance/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-a-single-population-variance-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-single-population-variance-in-r/"
  },"169": {
    "doc": "How to compute a confidence interval for a single population variance",
    "title": "How to compute a confidence interval for a single population variance",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/"
  },"170": {
    "doc": "How to compute a confidence interval for a single population variance",
    "title": "Description",
    "content": "Let’s say we want to compute a confidence interval for the variability of a population. We take a sample of data, $x_1, x_2, x_3, \\ldots, x_k$ and compute its variance, $s^2$. How do we construct a confidence interval for the population variance $\\sigma^2$? . Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a population mean | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#description"
  },"171": {
    "doc": "How to compute a confidence interval for a single population variance",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’ll use R’s dataset EuStockMarkets here. This dataset has information on the daily closing prices of 4 European stock indices. We’re going to look at the variability of Germany’s DAX closing prices. For more information on how this is done, see how to quickly load some sample data. You can replace the example data below with your actual data. | 1 2 3 4 5 6 7 . | # Load in EuStockMarkets data from rdatasets import data import pandas as pd df = data('EuStockMarkets') # Select the column for Germany's DAX closing prices sample = df['DAX'] . | . Now that we have our sample data loaded, let’s go ahead and make the confidence interval using SciPy. | 1 2 3 4 5 6 7 8 9 10 11 12 . | from scipy import stats # Find the critical values from the right and left tails of the Chi-square distribution alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) n = len( sample ) left_critical_val = stats.chi2.ppf(1-alpha/2, df=n-1) right_critical_val = stats.chi2.ppf(alpha/2, df=n-1) # Find the upper and lower bounds of the confidence interval and print them out lower_bound = ((n - 1)*sample.var())/left_critical_val upper_bound = ((n - 1)*sample.var())/right_critical_val lower_bound, upper_bound . | . | 1 . | (1104642.2801539514, 1256248.1273200295) . | . Our 95% confidence interval for the standard deviation of Germany’s DAX closing prices is $[1104642, 1256248]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#using-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#using-scipy-in-python"
  },"172": {
    "doc": "How to compute a confidence interval for a single population variance",
    "title": "Solution, in R",
    "content": "View this solution alone. We’ll use R’s dataset EuStockMarkets here. This dataset has information on the daily closing prices of 4 European stock indices. We’re going to look at the variability of Germany’s DAX closing prices. Feel free to replace this sample data with your actual data if you use this code. | 1 2 3 4 5 6 . | # install.packages(\"datasets\") # if you have not done so already library(datasets) # Load stock market data, convert to DataFrame, and choose the DAX column. EuStockMarkets &lt;- data.frame(EuStockMarkets) sample &lt;- EuStockMarkets$DAX . | . Now that we have our sample data loaded, let’s go ahead and make the confidence interval. | 1 2 3 4 5 6 7 8 9 10 11 . | # Find the critical values from the right and left tails of the Chi-square distribution alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) n &lt;- length(sample) left_critical_val &lt;- qchisq(p = alpha/2, df = n-1, lower.tail=FALSE) right_critical_val &lt;- qchisq(p = 1-alpha/2, df = n-1, lower.tail=FALSE) # Find the upper and lower bounds of the confidence interval and print them out lower_bound &lt;- ((n - 1)*var(sample))/left_critical_val upper_bound &lt;- ((n - 1)*var(sample))/right_critical_val lower_bound upper_bound . | . | 1 2 3 4 5 . | [1] 1104642 [1] 1256248 . | . Our 95% confidence interval for the standard deviation of Germany’s DAX closing prices is $[1104642, 1256248]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#solution-in-r"
  },"173": {
    "doc": "How to compute a confidence interval for a single population variance",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#topics-that-include-this-task"
  },"174": {
    "doc": "How to compute a confidence interval for a single population variance",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-a-single-population-variance/#opportunities"
  },"175": {
    "doc": "How to compute a confidence interval for the difference between two means when both population variances are known (in Python, using NumPy and SciPy)",
    "title": "How to compute a confidence interval for the difference between two means when both population variances are known (in Python, using NumPy and SciPy)",
    "content": "# How to compute a confidence interval for the difference between two means when both population variances are known (in Python, using NumPy and SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) ## Task If we have samples from two independent populations, and both of the population variances are known, how do we construct a confidence interval for the difference between the population means? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We're going to use some fake data here to illustrate how to make the confidence interval. Replace our fake data and population variances with your actual data and population variances if you use this code. ```python sample1 = [15, 10, 7, 22, 17, 14] sample2 = [9, 1, 11, 13, 3, 6] pop1_variance = 2.3 pop2_variance = 3 ``` We will need the size and mean of each sample. ```python import numpy as np n_sample1 = len(sample1) n_sample2 = len(sample2) xbar1 = np.mean(sample1) xbar2 = np.mean(sample2) ``` We can then use that data to create the confidence interval. ```python # Find the critical value from the normal distribution from scipy import stats alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) critical_val = stats.norm.ppf(1-alpha/2) # Find the lower and upper bounds of the confidence interval upper_bound = (xbar1 - xbar2) + \\ critical_val*np.sqrt((pop1_variance/n_sample1) + (pop2_variance/n_sample2)) lower_bound = (xbar1 - xbar2) - \\ critical_val*np.sqrt((pop1_variance/n_sample1) + (pop2_variance/n_sample2)) lower_bound, upper_bound ``` (5.15791188458682, 8.842088115413178) Our 95% confidence interval for the true difference between the population means is $[5.1579, 8.842]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the difference between two means when both population variances are known/Python, using NumPy and SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known-in-python-using-numpy-and-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known-in-python-using-numpy-and-scipy/"
  },"176": {
    "doc": "How to compute a confidence interval for the difference between two means when both population variances are known (in R)",
    "title": "How to compute a confidence interval for the difference between two means when both population variances are known (in R)",
    "content": "# How to compute a confidence interval for the difference between two means when both population variances are known (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) ## Task If we have samples from two independent populations, and both of the population variances are known, how do we construct a confidence interval for the difference between the population means? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We're going to use some fake data here to illustrate how to make the confidence interval. Replace our fake data and population variances with your actual data and population variances if you use this code. ```R sample.1 <- c(15, 10, 7, 22, 17, 14) sample.2 <- c(9, 1, 11, 13, 3, 6) pop1.variance <- 2.3 pop2.variance <- 3 ``` We will need the size and mean of each sample. ```R n.sample1 <- length(sample.1) n.sample2 <- length(sample.2) xbar1 <- mean(sample.1) xbar2 <- mean(sample.2) ``` We can then use that data to create the confidence interval. ```R # Find the critical value from the normal distribution alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) critical.val <- qnorm(p=alpha/2, lower.tail=FALSE) # Find the lower and upper bounds of the confidence interval radius <- critical.val*sqrt(pop1.variance/n.sample1 + pop2.variance/n.sample2) upper.bound <- (xbar1 - xbar2) + radius lower.bound <- (xbar1 - xbar2) - radius lower.bound upper.bound ``` [1] 5.157912 [1] 8.842088 Our 95% confidence interval for the true difference between the population means is $[5.1579, 8.842]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the difference between two means when both population variances are known/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known-in-r/"
  },"177": {
    "doc": "How to compute a confidence interval for the difference between two means when both population variances are known",
    "title": "How to compute a confidence interval for the difference between two means when both population variances are known",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/"
  },"178": {
    "doc": "How to compute a confidence interval for the difference between two means when both population variances are known",
    "title": "Description",
    "content": "If we have samples from two independent populations, and both of the population variances are known, how do we construct a confidence interval for the difference between the population means? . Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a population mean | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#description"
  },"179": {
    "doc": "How to compute a confidence interval for the difference between two means when both population variances are known",
    "title": "Using NumPy and SciPy, in Python",
    "content": "View this solution alone. We’re going to use some fake data here to illustrate how to make the confidence interval. Replace our fake data and population variances with your actual data and population variances if you use this code. | 1 2 3 4 . | sample1 = [15, 10, 7, 22, 17, 14] sample2 = [9, 1, 11, 13, 3, 6] pop1_variance = 2.3 pop2_variance = 3 . | . We will need the size and mean of each sample. | 1 2 3 4 5 . | import numpy as np n_sample1 = len(sample1) n_sample2 = len(sample2) xbar1 = np.mean(sample1) xbar2 = np.mean(sample2) . | . We can then use that data to create the confidence interval. | 1 2 3 4 5 6 7 8 9 10 11 . | # Find the critical value from the normal distribution from scipy import stats alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) critical_val = stats.norm.ppf(1-alpha/2) # Find the lower and upper bounds of the confidence interval upper_bound = (xbar1 - xbar2) + \\ critical_val*np.sqrt((pop1_variance/n_sample1) + (pop2_variance/n_sample2)) lower_bound = (xbar1 - xbar2) - \\ critical_val*np.sqrt((pop1_variance/n_sample1) + (pop2_variance/n_sample2)) lower_bound, upper_bound . | . | 1 . | (5.15791188458682, 8.842088115413178) . | . Our 95% confidence interval for the true difference between the population means is $[5.1579, 8.842]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#using-numpy-and-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#using-numpy-and-scipy-in-python"
  },"180": {
    "doc": "How to compute a confidence interval for the difference between two means when both population variances are known",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use some fake data here to illustrate how to make the confidence interval. Replace our fake data and population variances with your actual data and population variances if you use this code. | 1 2 3 4 . | sample.1 &lt;- c(15, 10, 7, 22, 17, 14) sample.2 &lt;- c(9, 1, 11, 13, 3, 6) pop1.variance &lt;- 2.3 pop2.variance &lt;- 3 . | . We will need the size and mean of each sample. | 1 2 3 4 . | n.sample1 &lt;- length(sample.1) n.sample2 &lt;- length(sample.2) xbar1 &lt;- mean(sample.1) xbar2 &lt;- mean(sample.2) . | . We can then use that data to create the confidence interval. | 1 2 3 4 5 6 7 8 9 10 . | # Find the critical value from the normal distribution alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) critical.val &lt;- qnorm(p=alpha/2, lower.tail=FALSE) # Find the lower and upper bounds of the confidence interval radius &lt;- critical.val*sqrt(pop1.variance/n.sample1 + pop2.variance/n.sample2) upper.bound &lt;- (xbar1 - xbar2) + radius lower.bound &lt;- (xbar1 - xbar2) - radius lower.bound upper.bound . | . | 1 2 3 4 5 . | [1] 5.157912 [1] 8.842088 . | . Our 95% confidence interval for the true difference between the population means is $[5.1579, 8.842]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#solution-in-r"
  },"181": {
    "doc": "How to compute a confidence interval for the difference between two means when both population variances are known",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#topics-that-include-this-task"
  },"182": {
    "doc": "How to compute a confidence interval for the difference between two means when both population variances are known",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known/#opportunities"
  },"183": {
    "doc": "How to compute a confidence interval for the difference between two means when population variances are unknown (in Python, using NumPy and SciPy)",
    "title": "How to compute a confidence interval for the difference between two means when population variances are unknown (in Python, using NumPy and SciPy)",
    "content": "# How to compute a confidence interval for the difference between two means when population variances are unknown (in Python, using NumPy and SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) ## Task If we have samples from two independent populations and both of the population variances are unknown, how do we compute a confidence interval for the difference between the population means? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We're going to use some fake data here to illustrate how to make the confidence interval. Replace our fake data with your actual data if you use this code. ```python sample1 = [15, 10, 7, 22, 17, 14] sample2 = [9, 1, 11, 13, 3, 6] ``` We will need the sizes, means, and variances of each sample. ```python import numpy as np n_sample1 = len(sample1) n_sample2 = len(sample2) xbar1 = np.mean(sample1) xbar2 = np.mean(sample2) var_sample1 = np.var(sample1, ddof = 1) var_sample2 = np.var(sample2, ddof = 1) ``` Before we can compute the confidence interval, we must ask, can we assume that the two population variances are equal? ***IF YES:*** We compute the degrees of freedom and the radius of the confidence interval as follows. ```python df = n_sample1 + n_sample2 - 2 pooled_var = ((n_sample1-1)*var_sample1 + (n_sample2-1)*var_sample2) / df radius = pooled_var*(1/n_sample1 + 1/n_sample2) ``` ***IF NO:*** We *replace* the above code with the following code instead, which does not make the assumption that the population variances are equal. ~~~python # ratio1 = var_sample1/n_sample1 # ratio2 = var_sample2/n_sample2 # df = (ratio1 + ratio2)**2 / (ratio1**2/(n_sample1-1) + ratio2**2/(n_sample2-1)) # radius = ratio1 + ratio2 ~~~ Then, whichever of the two methods above was used, we compute the confidence interval as follows. ```python from scipy import stats # Find the critical value from the normal distribution alpha = 0.05 critical_val = stats.t.ppf(q = 1-alpha/2, df = df) # Find the lower and upper bound of the confidence interval upper_bound = (xbar1 - xbar2) + critical_val*np.sqrt(radius) lower_bound = (xbar1 - xbar2) - critical_val*np.sqrt(radius) lower_bound, upper_bound ``` (0.5980039236697818, 13.401996076330217) The 95% confidence interval for the true difference between these population means is $[0.598,13.402]$. That was computed under the assumption that the variances were equal. See the alternative code above for if the variances were not assumed to be equal; in that case, we would get the slightly different result of $[0.5852, 13.4147]$ instead. Content last modified on 07 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the difference between two means when population variances are unknown/Python, using NumPy and SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown-in-python-using-numpy-and-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown-in-python-using-numpy-and-scipy/"
  },"184": {
    "doc": "How to compute a confidence interval for the difference between two means when population variances are unknown (in R)",
    "title": "How to compute a confidence interval for the difference between two means when population variances are unknown (in R)",
    "content": "# How to compute a confidence interval for the difference between two means when population variances are unknown (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) ## Task If we have samples from two independent populations and both of the population variances are unknown, how do we compute a confidence interval for the difference between the population means? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We're going to use some fake data here to illustrate how to make the confidence interval. Replace our fake data with your actual data if you use this code. ```R sample.1 <- c(15, 10, 7, 22, 17, 14) sample.2 <- c(9, 1, 11, 13, 3, 6) ``` In the example below, we specify `var.equal = FALSE` to indicate that we cannot assume that the variances are equal. If you know them to be equal in your situation, replace `FALSE` with `TRUE`. ```R alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) conf.interval <- t.test(sample.1, sample.2, var.equal = FALSE, conf.level = 1-alpha) # If you need the upper and lower bounds later, store them in variables like this: lower.bound <- conf.interval$conf.int[1] upper.bound <- conf.interval$conf.int[2] # Print out the lower and upper bounds lower.bound upper.bound ``` [1] 0.5852484 [1] 13.41475 Our 95% confidence interval for the true difference between these population means is $[0.5852, 13.4147]$. You can also see the test statistic and $p$-value by inspecting the result of the `t.test` function we ran above. ```R conf.interval ``` Welch Two Sample t-test data: sample.1 and sample.2 t = 2.4363, df = 9.8554, p-value = 0.0354 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.5852484 13.4147516 sample estimates: mean of x mean of y 14.166667 7.166667 Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the difference between two means when population variances are unknown/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown-in-r/"
  },"185": {
    "doc": "How to compute a confidence interval for the difference between two means when population variances are unknown",
    "title": "How to compute a confidence interval for the difference between two means when population variances are unknown",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/"
  },"186": {
    "doc": "How to compute a confidence interval for the difference between two means when population variances are unknown",
    "title": "Description",
    "content": "If we have samples from two independent populations and both of the population variances are unknown, how do we compute a confidence interval for the difference between the population means? . Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a population mean | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#description"
  },"187": {
    "doc": "How to compute a confidence interval for the difference between two means when population variances are unknown",
    "title": "Using NumPy and SciPy, in Python",
    "content": "View this solution alone. We’re going to use some fake data here to illustrate how to make the confidence interval. Replace our fake data with your actual data if you use this code. | 1 2 . | sample1 = [15, 10, 7, 22, 17, 14] sample2 = [9, 1, 11, 13, 3, 6] . | . We will need the sizes, means, and variances of each sample. | 1 2 3 4 5 6 7 . | import numpy as np n_sample1 = len(sample1) n_sample2 = len(sample2) xbar1 = np.mean(sample1) xbar2 = np.mean(sample2) var_sample1 = np.var(sample1, ddof = 1) var_sample2 = np.var(sample2, ddof = 1) . | . Before we can compute the confidence interval, we must ask, can we assume that the two population variances are equal? . IF YES: We compute the degrees of freedom and the radius of the confidence interval as follows. | 1 2 3 . | df = n_sample1 + n_sample2 - 2 pooled_var = ((n_sample1-1)*var_sample1 + (n_sample2-1)*var_sample2) / df radius = pooled_var*(1/n_sample1 + 1/n_sample2) . | . IF NO: We replace the above code with the following code instead, which does not make the assumption that the population variances are equal. | 1 2 3 4 . | # ratio1 = var_sample1/n_sample1 # ratio2 = var_sample2/n_sample2 # df = (ratio1 + ratio2)**2 / (ratio1**2/(n_sample1-1) + ratio2**2/(n_sample2-1)) # radius = ratio1 + ratio2 . | . Then, whichever of the two methods above was used, we compute the confidence interval as follows. | 1 2 3 4 5 6 7 8 9 10 . | from scipy import stats # Find the critical value from the normal distribution alpha = 0.05 critical_val = stats.t.ppf(q = 1-alpha/2, df = df) # Find the lower and upper bound of the confidence interval upper_bound = (xbar1 - xbar2) + critical_val*np.sqrt(radius) lower_bound = (xbar1 - xbar2) - critical_val*np.sqrt(radius) lower_bound, upper_bound . | . | 1 . | (0.5980039236697818, 13.401996076330217) . | . The 95% confidence interval for the true difference between these population means is $[0.598,13.402]$. That was computed under the assumption that the variances were equal. See the alternative code above for if the variances were not assumed to be equal; in that case, we would get the slightly different result of $[0.5852, 13.4147]$ instead. Content last modified on 07 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#using-numpy-and-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#using-numpy-and-scipy-in-python"
  },"188": {
    "doc": "How to compute a confidence interval for the difference between two means when population variances are unknown",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use some fake data here to illustrate how to make the confidence interval. Replace our fake data with your actual data if you use this code. | 1 2 . | sample.1 &lt;- c(15, 10, 7, 22, 17, 14) sample.2 &lt;- c(9, 1, 11, 13, 3, 6) . | . In the example below, we specify var.equal = FALSE to indicate that we cannot assume that the variances are equal. If you know them to be equal in your situation, replace FALSE with TRUE. | 1 2 3 4 5 6 7 8 . | alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) conf.interval &lt;- t.test(sample.1, sample.2, var.equal = FALSE, conf.level = 1-alpha) # If you need the upper and lower bounds later, store them in variables like this: lower.bound &lt;- conf.interval$conf.int[1] upper.bound &lt;- conf.interval$conf.int[2] # Print out the lower and upper bounds lower.bound upper.bound . | . | 1 2 3 4 5 . | [1] 0.5852484 [1] 13.41475 . | . Our 95% confidence interval for the true difference between these population means is $[0.5852, 13.4147]$. You can also see the test statistic and $p$-value by inspecting the result of the t.test function we ran above. | 1 . | conf.interval . | . | 1 2 3 4 5 6 7 8 9 10 . | Welch Two Sample t-test data: sample.1 and sample.2 t = 2.4363, df = 9.8554, p-value = 0.0354 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.5852484 13.4147516 sample estimates: mean of x mean of y 14.166667 7.166667 . | . Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#solution-in-r"
  },"189": {
    "doc": "How to compute a confidence interval for the difference between two means when population variances are unknown",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#topics-that-include-this-task"
  },"190": {
    "doc": "How to compute a confidence interval for the difference between two means when population variances are unknown",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown/#opportunities"
  },"191": {
    "doc": "How to compute a confidence interval for the difference between two proportions (in Python, using SciPy)",
    "title": "How to compute a confidence interval for the difference between two proportions (in Python, using SciPy)",
    "content": "# How to compute a confidence interval for the difference between two proportions (in Python, using SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) ## Task When dealing with qualitative data, we often want to construct a confidence interval for the difference between two population proportions. For example, if we are trying a drug on experimental and control groups of patients, we probably want to compare the proportion of patients who got well in one group versus the other. How do we make such a comparison using a confidence interval? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution Here is some fake data for the purposes of this illustration. Let's say we conduct a survey of people in Boston and of people in Nashville and ask them if they prefer chocolate or vanilla ice cream. We want to compare the proportions of people from the two cities who like vanilla. * Out of 150 people in Boston surveyed, 90 prefer vanilla. * Out of 135 people in Nashville surveyed, 50 prefer vanilla. We'll let $\\bar{p_1}$ represent the proportion of people from Boston who like vanilla and $\\bar{p_2}$ represent the proportion of people from Nashville who like vanilla. You can replace the code for this fake data below with your real data. ```python # number of observations in the samples n1 = 150 n2 = 135 # proportions in the two samples p_bar1 = 90/150 p_bar2 = 50/135 ``` We now compute the confidence interval using tools from SciPy and NumPy. ```python # Find the critical value to compute the confidence interval from scipy import stats alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) critical_value = stats.norm.ppf(1-alpha/2) # Compute the standard error of the proportions import numpy as np std_error = np.sqrt( p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2 ) # Compute the upper and lower bounds of the confidence interval upper_bound = (p_bar1 - p_bar2) + critical_value*std_error lower_bound = (p_bar1 - p_bar2) - critical_value*std_error lower_bound, upper_bound ``` (0.11657216971616415, 0.3426870895430951) The confidence interval for the difference between these two proportions is $[0.11657, 0.34269]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the difference between two proportions/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions-in-python-using-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions-in-python-using-scipy/"
  },"192": {
    "doc": "How to compute a confidence interval for the difference between two proportions (in R)",
    "title": "How to compute a confidence interval for the difference between two proportions (in R)",
    "content": "# How to compute a confidence interval for the difference between two proportions (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) ## Task When dealing with qualitative data, we often want to construct a confidence interval for the difference between two population proportions. For example, if we are trying a drug on experimental and control groups of patients, we probably want to compare the proportion of patients who got well in one group versus the other. How do we make such a comparison using a confidence interval? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution Here is some fake data for the purposes of this illustration. Let's say we conduct a survey of people in Boston and of people in Nashville and ask them if they prefer chocolate or vanilla ice cream. We want to compare the proportions of people from the two cities who like vanilla. * Out of 150 people in Boston surveyed, 90 prefer vanilla. * Out of 135 people in Nashville surveyed, 50 prefer vanilla. We'll let $\\bar{p_1}$ represent the proportion of people from Boston who like vanilla and $\\bar{p_2}$ represent the proportion of people from Nashville who like vanilla. You can replace the code for this fake data below with your real data. ```R # number of observations in the samples n1 <- 150 n2 <- 135 # proportions in the two samples p_bar1 <- 90/150 p_bar2 <- 50/135 ``` We now compute the confidence interval using R's `qnorm` function. ```R # Find the critical value to compute the confidence interval alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) critical_value <- qnorm(p = alpha/2, lower.tail=FALSE) # Compute the standard error of the proportions std_error <- sqrt( p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2 ) # Compute the upper and lower bounds of the confidence interval and print them out upper_bound <- (p_bar1 - p_bar2) + critical_value*std_error lower_bound <- (p_bar1 - p_bar2) - critical_value*std_error lower_bound upper_bound ``` [1] 0.1165722 [1] 0.3426871 The confidence interval for the difference between these two proportions is $[0.11657, 0.34269]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the difference between two proportions/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions-in-r/"
  },"193": {
    "doc": "How to compute a confidence interval for the difference between two proportions",
    "title": "How to compute a confidence interval for the difference between two proportions",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/"
  },"194": {
    "doc": "How to compute a confidence interval for the difference between two proportions",
    "title": "Description",
    "content": "When dealing with qualitative data, we often want to construct a confidence interval for the difference between two population proportions. For example, if we are trying a drug on experimental and control groups of patients, we probably want to compare the proportion of patients who got well in one group versus the other. How do we make such a comparison using a confidence interval? . Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a population mean | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#description"
  },"195": {
    "doc": "How to compute a confidence interval for the difference between two proportions",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. Here is some fake data for the purposes of this illustration. Let’s say we conduct a survey of people in Boston and of people in Nashville and ask them if they prefer chocolate or vanilla ice cream. We want to compare the proportions of people from the two cities who like vanilla. | Out of 150 people in Boston surveyed, 90 prefer vanilla. | Out of 135 people in Nashville surveyed, 50 prefer vanilla. | . We’ll let $\\bar{p_1}$ represent the proportion of people from Boston who like vanilla and $\\bar{p_2}$ represent the proportion of people from Nashville who like vanilla. You can replace the code for this fake data below with your real data. | 1 2 3 4 5 6 . | # number of observations in the samples n1 = 150 n2 = 135 # proportions in the two samples p_bar1 = 90/150 p_bar2 = 50/135 . | . We now compute the confidence interval using tools from SciPy and NumPy. | 1 2 3 4 5 6 7 8 9 10 11 12 13 . | # Find the critical value to compute the confidence interval from scipy import stats alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) critical_value = stats.norm.ppf(1-alpha/2) # Compute the standard error of the proportions import numpy as np std_error = np.sqrt( p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2 ) # Compute the upper and lower bounds of the confidence interval upper_bound = (p_bar1 - p_bar2) + critical_value*std_error lower_bound = (p_bar1 - p_bar2) - critical_value*std_error lower_bound, upper_bound . | . | 1 . | (0.11657216971616415, 0.3426870895430951) . | . The confidence interval for the difference between these two proportions is $[0.11657, 0.34269]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#using-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#using-scipy-in-python"
  },"196": {
    "doc": "How to compute a confidence interval for the difference between two proportions",
    "title": "Solution, in R",
    "content": "View this solution alone. Here is some fake data for the purposes of this illustration. Let’s say we conduct a survey of people in Boston and of people in Nashville and ask them if they prefer chocolate or vanilla ice cream. We want to compare the proportions of people from the two cities who like vanilla. | Out of 150 people in Boston surveyed, 90 prefer vanilla. | Out of 135 people in Nashville surveyed, 50 prefer vanilla. | . We’ll let $\\bar{p_1}$ represent the proportion of people from Boston who like vanilla and $\\bar{p_2}$ represent the proportion of people from Nashville who like vanilla. You can replace the code for this fake data below with your real data. | 1 2 3 4 5 6 . | # number of observations in the samples n1 &lt;- 150 n2 &lt;- 135 # proportions in the two samples p_bar1 &lt;- 90/150 p_bar2 &lt;- 50/135 . | . We now compute the confidence interval using R’s qnorm function. | 1 2 3 4 5 6 7 8 9 10 11 12 . | # Find the critical value to compute the confidence interval alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) critical_value &lt;- qnorm(p = alpha/2, lower.tail=FALSE) # Compute the standard error of the proportions std_error &lt;- sqrt( p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2 ) # Compute the upper and lower bounds of the confidence interval and print them out upper_bound &lt;- (p_bar1 - p_bar2) + critical_value*std_error lower_bound &lt;- (p_bar1 - p_bar2) - critical_value*std_error lower_bound upper_bound . | . | 1 2 3 4 5 . | [1] 0.1165722 [1] 0.3426871 . | . The confidence interval for the difference between these two proportions is $[0.11657, 0.34269]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#solution-in-r"
  },"197": {
    "doc": "How to compute a confidence interval for the difference between two proportions",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#topics-that-include-this-task"
  },"198": {
    "doc": "How to compute a confidence interval for the difference between two proportions",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions/#opportunities"
  },"199": {
    "doc": "How to compute a confidence interval for the expected value of a response variable (in Python, using statsmodels and sklearn)",
    "title": "How to compute a confidence interval for the expected value of a response variable (in Python, using statsmodels and sklearn)",
    "content": "# How to compute a confidence interval for the expected value of a response variable (in Python, using statsmodels and sklearn) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) ## Task If we have a simple linear regression model, $y = \\beta_0 + \\beta_1x + \\epsilon$, where $\\epsilon$ is some random error, then given any $x$ input, $y$ can be veiwed as a random variable because of $\\epsilon$. Let's consider its expected value. How do we construct a confidence interval for that expected value, given a value for the predictor $x$? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution Let's assume that you already have a linear model. We construct an example one here from some fabricated data. For a review of how this preparatory code works, see [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data). ```python import statsmodels.api as sm # Replace the following fake data with your actual data: xs = [ 34, 9, 78, 60, 22, 45, 83, 59, 25 ] ys = [ 126, 347, 298, 309, 450, 187, 266, 385, 400 ] # Create and fit a linear model to the data: xs = sm.add_constant( xs ) model = sm.OLS( ys, xs ).fit() ``` Ask the model to do a prediction of one particular input, in this example $x=40$, with a $95\\%$ confidence interval included ($\\alpha=0.05$). You can replce the $40$ with your chosen $x$ value, or an array of them, and you can replace the $0.05$ with your chosen value of $\\alpha$. (The extra `1` in the input to `get_prediction` is a placeholder, required because the model has been expanded to include a constant term.) ```python model.get_prediction( [1,40] ).summary_frame( alpha=0.05 ) ``` | | mean | mean_se | mean_ci_lower | mean_ci_upper | obs_ci_lower | obs_ci_upper | . | 0 | 313.721744 | 36.823483 | 226.648043 | 400.795444 | 45.876725 | 581.566762 | . Our 95% confidence interval is $[226.648, 400.7954]$. We can be 95% confident that the true average value of $y$, given that $x$ is 40, is between 226.648 and 400.7954. Content last modified on 08 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the expected value of a response variable/Python, using statsmodels and sklearn.ipynb). Contributed by: * Ni Shi (shi_ni@bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable-in-python-using-statsmodels-and-sklearn/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable-in-python-using-statsmodels-and-sklearn/"
  },"200": {
    "doc": "How to compute a confidence interval for the expected value of a response variable (in R)",
    "title": "How to compute a confidence interval for the expected value of a response variable (in R)",
    "content": "# How to compute a confidence interval for the expected value of a response variable (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) ## Task If we have a simple linear regression model, $y = \\beta_0 + \\beta_1x + \\epsilon$, where $\\epsilon$ is some random error, then given any $x$ input, $y$ can be veiwed as a random variable because of $\\epsilon$. Let's consider its expected value. How do we construct a confidence interval for that expected value, given a value for the predictor $x$? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution Let's assume that you already have a linear model. We construct an example one here from some fabricated data. ```R # Make the linear model x <- c(34, 9, 78, 60, 22, 45, 83, 59, 25) y <- c(126, 347, 298, 309, 450, 187, 266, 385, 400) model <- lm(y ~ x) ``` Construct a data frame containing just one entry, the value of the independent variable for which you want to compute the confidence interval. That data frame can then be passed to R's `predict` function to get a confidence interval for the expected value of $y$. ```R # Use your chosen value of x below: data <- data.frame(x=40) # Compute the confidence interval for y: predict(model, data, interval=\"confidence\", level=0.95) # or choose a different confidence level; here we use 0.95 ``` fit lwr upr 1 313.7217 226.648 400.7954 Our 95% confidence interval is $[226.648, 400.7954]$. We can be 95% confident that the true average value of $y$, given that $x$ is 40, is between 226.648 and 400.7954. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the expected value of a response variable/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable-in-r/"
  },"201": {
    "doc": "How to compute a confidence interval for the expected value of a response variable",
    "title": "How to compute a confidence interval for the expected value of a response variable",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/"
  },"202": {
    "doc": "How to compute a confidence interval for the expected value of a response variable",
    "title": "Description",
    "content": "If we have a simple linear regression model, $y = \\beta_0 + \\beta_1x + \\epsilon$, where $\\epsilon$ is some random error, then given any $x$ input, $y$ can be veiwed as a random variable because of $\\epsilon$. Let’s consider its expected value. How do we construct a confidence interval for that expected value, given a value for the predictor $x$? . Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a population mean | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the population proportion | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#description"
  },"203": {
    "doc": "How to compute a confidence interval for the expected value of a response variable",
    "title": "Using statsmodels and sklearn, in Python",
    "content": "View this solution alone. Let’s assume that you already have a linear model. We construct an example one here from some fabricated data. For a review of how this preparatory code works, see how to fit a linear model to two columns of data. | 1 2 3 4 5 6 7 8 9 . | import statsmodels.api as sm # Replace the following fake data with your actual data: xs = [ 34, 9, 78, 60, 22, 45, 83, 59, 25 ] ys = [ 126, 347, 298, 309, 450, 187, 266, 385, 400 ] # Create and fit a linear model to the data: xs = sm.add_constant( xs ) model = sm.OLS( ys, xs ).fit() . | . Ask the model to do a prediction of one particular input, in this example $x=40$, with a $95\\%$ confidence interval included ($\\alpha=0.05$). You can replce the $40$ with your chosen $x$ value, or an array of them, and you can replace the $0.05$ with your chosen value of $\\alpha$. (The extra 1 in the input to get_prediction is a placeholder, required because the model has been expanded to include a constant term.) . | 1 . | model.get_prediction( [1,40] ).summary_frame( alpha=0.05 ) . | . | | mean | mean_se | mean_ci_lower | mean_ci_upper | obs_ci_lower | obs_ci_upper | . | 0 | 313.721744 | 36.823483 | 226.648043 | 400.795444 | 45.876725 | 581.566762 | . Our 95% confidence interval is $[226.648, 400.7954]$. We can be 95% confident that the true average value of $y$, given that $x$ is 40, is between 226.648 and 400.7954. Content last modified on 08 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#using-statsmodels-and-sklearn-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#using-statsmodels-and-sklearn-in-python"
  },"204": {
    "doc": "How to compute a confidence interval for the expected value of a response variable",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s assume that you already have a linear model. We construct an example one here from some fabricated data. | 1 2 3 4 . | # Make the linear model x &lt;- c(34, 9, 78, 60, 22, 45, 83, 59, 25) y &lt;- c(126, 347, 298, 309, 450, 187, 266, 385, 400) model &lt;- lm(y ~ x) . | . Construct a data frame containing just one entry, the value of the independent variable for which you want to compute the confidence interval. That data frame can then be passed to R’s predict function to get a confidence interval for the expected value of $y$. | 1 2 3 4 . | # Use your chosen value of x below: data &lt;- data.frame(x=40) # Compute the confidence interval for y: predict(model, data, interval=\"confidence\", level=0.95) # or choose a different confidence level; here we use 0.95 . | . | 1 2 . | fit lwr upr 1 313.7217 226.648 400.7954 . | . Our 95% confidence interval is $[226.648, 400.7954]$. We can be 95% confident that the true average value of $y$, given that $x$ is 40, is between 226.648 and 400.7954. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#solution-in-r"
  },"205": {
    "doc": "How to compute a confidence interval for the expected value of a response variable",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | Bentley University MA252 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#topics-that-include-this-task"
  },"206": {
    "doc": "How to compute a confidence interval for the expected value of a response variable",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable/#opportunities"
  },"207": {
    "doc": "How to compute a confidence interval for the population proportion (in Python, using SciPy)",
    "title": "How to compute a confidence interval for the population proportion (in Python, using SciPy)",
    "content": "# How to compute a confidence interval for the population proportion (in Python, using SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-population-proportion) ## Task If we have a sample of qualitative data from a normally distributed population, then how do we compute a confidence interval for a population proportion? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We're going to use some fake data here for illustrative purposes, but you can replace our fake data with your real data in the code below. ```python # Replace the next two lines of code with your real data sample_size = 30 sample_proportion = .39 # Find the margin of error from scipy import stats import numpy as np alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) moe = stats.norm.ppf(1-alpha/2) * np.sqrt(sample_proportion*(1-sample_proportion)/sample_size) # Find the confidence interval lower_bound = sample_proportion - moe upper_bound = sample_proportion + moe lower_bound, upper_bound ``` (0.21546413420702207, 0.564535865792978) Our 95% confidence interval is $[0.2155, 0.5645]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the population proportion/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-population-proportion-in-python-using-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-population-proportion-in-python-using-scipy/"
  },"208": {
    "doc": "How to compute a confidence interval for the population proportion (in R)",
    "title": "How to compute a confidence interval for the population proportion (in R)",
    "content": "# How to compute a confidence interval for the population proportion (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-population-proportion) ## Task If we have a sample of qualitative data from a normally distributed population, then how do we compute a confidence interval for a population proportion? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the ratio of two population variances](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Solution We're going to use some fake data here for illustrative purposes, but you can replace our fake data with your real data in the code below. ```R # Replace the next two lines of code with your real data sample_size = 30 sample_proportion = 0.39 # Find the margin of error alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) moe <- qnorm(1-alpha/2, 0, 1) * sqrt(sample_proportion*(1-sample_proportion)/sample_size) # Find the confidence interval upper_bound <- sample_proportion + moe lower_bound <- sample_proportion - moe lower_bound upper_bound ``` [1] 0.2154641 [1] 0.5645359 Our 95% confidence interval is $[0.2155, 0.5645]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the population proportion/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-population-proportion-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-population-proportion-in-r/"
  },"209": {
    "doc": "How to compute a confidence interval for the population proportion",
    "title": "How to compute a confidence interval for the population proportion",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-the-population-proportion/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-population-proportion/"
  },"210": {
    "doc": "How to compute a confidence interval for the population proportion",
    "title": "Description",
    "content": "If we have a sample of qualitative data from a normally distributed population, then how do we compute a confidence interval for a population proportion? . Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a population mean | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the ratio of two population variances | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#description"
  },"211": {
    "doc": "How to compute a confidence interval for the population proportion",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’re going to use some fake data here for illustrative purposes, but you can replace our fake data with your real data in the code below. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . | # Replace the next two lines of code with your real data sample_size = 30 sample_proportion = .39 # Find the margin of error from scipy import stats import numpy as np alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) moe = stats.norm.ppf(1-alpha/2) * np.sqrt(sample_proportion*(1-sample_proportion)/sample_size) # Find the confidence interval lower_bound = sample_proportion - moe upper_bound = sample_proportion + moe lower_bound, upper_bound . | . | 1 . | (0.21546413420702207, 0.564535865792978) . | . Our 95% confidence interval is $[0.2155, 0.5645]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#using-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#using-scipy-in-python"
  },"212": {
    "doc": "How to compute a confidence interval for the population proportion",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use some fake data here for illustrative purposes, but you can replace our fake data with your real data in the code below. | 1 2 3 4 5 6 7 8 9 10 11 12 13 . | # Replace the next two lines of code with your real data sample_size = 30 sample_proportion = 0.39 # Find the margin of error alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) moe &lt;- qnorm(1-alpha/2, 0, 1) * sqrt(sample_proportion*(1-sample_proportion)/sample_size) # Find the confidence interval upper_bound &lt;- sample_proportion + moe lower_bound &lt;- sample_proportion - moe lower_bound upper_bound . | . | 1 2 3 4 5 . | [1] 0.2154641 [1] 0.5645359 . | . Our 95% confidence interval is $[0.2155, 0.5645]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#solution-in-r"
  },"213": {
    "doc": "How to compute a confidence interval for the population proportion",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#topics-that-include-this-task"
  },"214": {
    "doc": "How to compute a confidence interval for the population proportion",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-population-proportion/#opportunities"
  },"215": {
    "doc": "How to compute a confidence interval for the ratio of two population variances (in Python, using SciPy)",
    "title": "How to compute a confidence interval for the ratio of two population variances (in Python, using SciPy)",
    "content": "# How to compute a confidence interval for the ratio of two population variances (in Python, using SciPy) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Task Let's say we want to compute a confidence interval for two population variances. We take two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ and $x'_1, x'_2, x'_3, \\ldots, x'_k$, and compute their variances, $\\sigma_1^2$ and $\\sigma_2^2$. How do we compute a confidence interval for $\\frac{\\sigma_1^2}{\\sigma_2^2}$? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) ## Solution We'll use R's dataset EuStockMarkets as an example; of course you should replace this example data with your actual data when using this code. This dataset has information on the daily closing prices of 4 European stock indices. We're going to compare the variability of Germany's DAX and France's CAC closing prices here. Let's load in the dataset using the process explained in [how to quickly load some sample data](../how-to-quickly-load-some-sample-data). ```python from rdatasets import data import pandas as pd # Load in the EuStockMarkets data and convert to a DataFrame EuStockMarkets = data('EuStockMarkets') df = pd.DataFrame(EuStockMarkets[['DAX', 'CAC']]) # Our two samples are its DAX and CAC columns sample1 = df['DAX'].tolist() sample2 = df['CAC'].tolist() ``` Now that we have our data loaded we can compute the confidence interval. You can change the confidence level by changing the value of $\\alpha$ below. ```python # The degrees of freedom in each sample is its length minus 1 sample1_df = len(sample1) - 1 sample2_df = len(sample2) - 1 # Compute the ratio of the variances import statistics ratio = statistics.variance(sample1) / statistics.variance(sample2) # Find the critical values from the F-distribution from scipy import stats alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) lower_critical_value = 1 / stats.f.ppf(q = 1 - alpha/2, dfn = sample1_df, dfd = sample2_df) upper_critical_value = stats.f.ppf(q = 1 - alpha/2, dfn = sample2_df, dfd = sample1_df) # Compute the confidence interval lower_bound = ratio * lower_critical_value upper_bound = ratio * upper_critical_value lower_bound, upper_bound ``` (3.190589226470889, 3.827043522824141) The 95% confidence interval for the ratio of the variances for Germany's DAX and France's CAC is $[3.191, 3.827]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the ratio of two population variances/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances-in-python-using-scipy/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances-in-python-using-scipy/"
  },"216": {
    "doc": "How to compute a confidence interval for the ratio of two population variances (in R)",
    "title": "How to compute a confidence interval for the ratio of two population variances (in R)",
    "content": "# How to compute a confidence interval for the ratio of two population variances (in R) [See all solutions.](../how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances) ## Task Let's say we want to compute a confidence interval for two population variances. We take two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ and $x'_1, x'_2, x'_3, \\ldots, x'_k$, and compute their variances, $\\sigma_1^2$ and $\\sigma_2^2$. How do we compute a confidence interval for $\\frac{\\sigma_1^2}{\\sigma_2^2}$? Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to compute a confidence interval for a regression coefficient](../how-to-compute-a-confidence-interval-for-a-regression-coefficient) * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to compute a confidence interval for a single population variance](../how-to-compute-a-confidence-interval-for-a-single-population-variance) * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to compute a confidence interval for the difference between two means when population variances are unknown](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-population-variances-are-unknown) * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to compute a confidence interval for the expected value of a response variable](../how-to-compute-a-confidence-interval-for-the-expected-value-of-a-response-variable) * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) ## Solution We'll use R's dataset EuStockMarkets as an example; of course you should replace this example data with your actual data when using this code. This dataset has information on the daily closing prices of 4 European stock indices. We're going to compare the variability of Germany's DAX and France's CAC closing prices here. ```R # install.packages(\"datasets\") # if you have not done so already library(datasets) # Load in the EuStockMarkets data and convert to a DataFrame EuStockMarkets <- data.frame(EuStockMarkets) # Our two samples are its DAX and CAC columns sample.1 <- EuStockMarkets$DAX sample.2 <- EuStockMarkets$CAC ``` Now that we have our data loaded we can compute the confidence interval. You can change the confidence level by changing the value of $\\alpha$ below. ```R # The degrees of freedom in each sample is its length minus 1 df_1 = length(sample.1) - 1 df_2 = length(sample.2) - 1 # Compute the ratio of the variances test.stat.ratio <- var(sample.1)/var(sample.2) # Find the critical values from the F-distribution alpha <- 0.05 # replace with your chosen alpha (here, a 95% confidence level) lower_critical_value <- 1 / qf(p = alpha/2, df1 = df_1, df2 = df_2, lower.tail = FALSE) upper_critical_value <- qf(p = alpha/2, df1 = df_2, df2 = df_1, lower.tail = FALSE) # Compute the confidence interval and print it out lower_bound <- test.stat.ratio*lower_critical_value upper_bound <- test.stat.ratio*upper_critical_value lower_bound upper_bound ``` [1] 3.190589 [1] 3.827044 The 95% confidence interval for the ratio of the variances for Germany's DAX and France's CAC is $[3.191, 3.827]$. Content last modified on 09 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute a confidence interval for the ratio of two population variances/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances-in-r/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances-in-r/"
  },"217": {
    "doc": "How to compute a confidence interval for the ratio of two population variances",
    "title": "How to compute a confidence interval for the ratio of two population variances",
    "content": " ",
    "url": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/"
  },"218": {
    "doc": "How to compute a confidence interval for the ratio of two population variances",
    "title": "Description",
    "content": "Let’s say we want to compute a confidence interval for two population variances. We take two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ and $x’_1, x’_2, x’_3, \\ldots, x’_k$, and compute their variances, $\\sigma_1^2$ and $\\sigma_2^2$. How do we compute a confidence interval for $\\frac{\\sigma_1^2}{\\sigma_2^2}$? . Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to compute a confidence interval for a regression coefficient | How to compute a confidence interval for a population mean | How to compute a confidence interval for a single population variance | How to compute a confidence interval for the difference between two means when both population variances are known | How to compute a confidence interval for the difference between two means when population variances are unknown | How to compute a confidence interval for the difference between two proportions | How to compute a confidence interval for the expected value of a response variable | How to compute a confidence interval for the population proportion | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#description",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#description"
  },"219": {
    "doc": "How to compute a confidence interval for the ratio of two population variances",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’ll use R’s dataset EuStockMarkets as an example; of course you should replace this example data with your actual data when using this code. This dataset has information on the daily closing prices of 4 European stock indices. We’re going to compare the variability of Germany’s DAX and France’s CAC closing prices here. Let’s load in the dataset using the process explained in how to quickly load some sample data. | 1 2 3 4 5 6 7 8 9 10 . | from rdatasets import data import pandas as pd # Load in the EuStockMarkets data and convert to a DataFrame EuStockMarkets = data('EuStockMarkets') df = pd.DataFrame(EuStockMarkets[['DAX', 'CAC']]) # Our two samples are its DAX and CAC columns sample1 = df['DAX'].tolist() sample2 = df['CAC'].tolist() . | . Now that we have our data loaded we can compute the confidence interval. You can change the confidence level by changing the value of $\\alpha$ below. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | # The degrees of freedom in each sample is its length minus 1 sample1_df = len(sample1) - 1 sample2_df = len(sample2) - 1 # Compute the ratio of the variances import statistics ratio = statistics.variance(sample1) / statistics.variance(sample2) # Find the critical values from the F-distribution from scipy import stats alpha = 0.05 # replace with your chosen alpha (here, a 95% confidence level) lower_critical_value = 1 / stats.f.ppf(q = 1 - alpha/2, dfn = sample1_df, dfd = sample2_df) upper_critical_value = stats.f.ppf(q = 1 - alpha/2, dfn = sample2_df, dfd = sample1_df) # Compute the confidence interval lower_bound = ratio * lower_critical_value upper_bound = ratio * upper_critical_value lower_bound, upper_bound . | . | 1 . | (3.190589226470889, 3.827043522824141) . | . The 95% confidence interval for the ratio of the variances for Germany’s DAX and France’s CAC is $[3.191, 3.827]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#using-scipy-in-python",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#using-scipy-in-python"
  },"220": {
    "doc": "How to compute a confidence interval for the ratio of two population variances",
    "title": "Solution, in R",
    "content": "View this solution alone. We’ll use R’s dataset EuStockMarkets as an example; of course you should replace this example data with your actual data when using this code. This dataset has information on the daily closing prices of 4 European stock indices. We’re going to compare the variability of Germany’s DAX and France’s CAC closing prices here. | 1 2 3 4 5 6 7 8 9 . | # install.packages(\"datasets\") # if you have not done so already library(datasets) # Load in the EuStockMarkets data and convert to a DataFrame EuStockMarkets &lt;- data.frame(EuStockMarkets) # Our two samples are its DAX and CAC columns sample.1 &lt;- EuStockMarkets$DAX sample.2 &lt;- EuStockMarkets$CAC . | . Now that we have our data loaded we can compute the confidence interval. You can change the confidence level by changing the value of $\\alpha$ below. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | # The degrees of freedom in each sample is its length minus 1 df_1 = length(sample.1) - 1 df_2 = length(sample.2) - 1 # Compute the ratio of the variances test.stat.ratio &lt;- var(sample.1)/var(sample.2) # Find the critical values from the F-distribution alpha &lt;- 0.05 # replace with your chosen alpha (here, a 95% confidence level) lower_critical_value &lt;- 1 / qf(p = alpha/2, df1 = df_1, df2 = df_2, lower.tail = FALSE) upper_critical_value &lt;- qf(p = alpha/2, df1 = df_2, df2 = df_1, lower.tail = FALSE) # Compute the confidence interval and print it out lower_bound &lt;- test.stat.ratio*lower_critical_value upper_bound &lt;- test.stat.ratio*upper_critical_value lower_bound upper_bound . | . | 1 2 3 4 5 . | [1] 3.190589 [1] 3.827044 . | . The 95% confidence interval for the ratio of the variances for Germany’s DAX and France’s CAC is $[3.191, 3.827]$. Content last modified on 09 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#solution-in-r",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#solution-in-r"
  },"221": {
    "doc": "How to compute a confidence interval for the ratio of two population variances",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#topics-that-include-this-task"
  },"222": {
    "doc": "How to compute a confidence interval for the ratio of two population variances",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#opportunities",
    "relUrl": "/how-to-compute-a-confidence-interval-for-the-ratio-of-two-population-variances/#opportunities"
  },"223": {
    "doc": "How to compute adjusted R-squared (in Python, using statsmodels)",
    "title": "How to compute adjusted R-squared (in Python, using statsmodels)",
    "content": "# How to compute adjusted R-squared (in Python, using statsmodels) [See all solutions.](../how-to-compute-adjusted-r-squared) ## Task If we have fit a multivariate linear model, how can we compute the Adjusted $R^2$ for that model, to measure its goodness of fit? Related tasks: * [How to compute R-squared for a simple linear model](../how-to-compute-r-squared-for-a-simple-linear-model) ## Solution We assume you have already fit a multivariate linear model to some data, as in the code below. (If you're unfamiliar with how to do so, see [how to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model).) The data shown below is fake, and we assume you will replace it with your own real data if you use this code. ```python import pandas as pd import statsmodels.api as sm df = pd.DataFrame( { 'x1':[2, 7, 4, 3, 11, 18, 6, 15, 9, 12], 'x2':[4, 6, 10, 1, 18, 11, 8, 20, 16, 13], 'x3':[11, 16, 20, 6, 14, 8, 5, 23, 13, 10], 'y':[24, 60, 32, 29, 90, 45, 130, 76, 100, 120] } ) xs = df[['x1', 'x2', 'x3']] y = df['y'] xs = sm.add_constant(xs) model = sm.OLS(y, xs).fit() ``` /opt/conda/lib/python3.9/site-packages/statsmodels/tsa/tsatools.py:142: FutureWarning: In a future version of pandas all arguments of concat except for the argument 'objs' will be keyword-only x = pd.concat(x[::order], 1) You can get a lot of information about your model from its summary. ```python model.summary() ``` /opt/conda/lib/python3.9/site-packages/scipy/stats/stats.py:1541: UserWarning: kurtosistest only valid for n>=20 ... continuing anyway, n=10 warnings.warn(\"kurtosistest only valid for n>=20 ... continuing \" OLS Regression Results | Dep. Variable: | y | R-squared: | 0.594 | . | Model: | OLS | Adj. R-squared: | 0.390 | . | Method: | Least Squares | F-statistic: | 2.921 | . | Date: | Tue, 07 Dec 2021 | Prob (F-statistic): | 0.122 | . | Time: | 15:06:52 | Log-Likelihood: | -45.689 | . | No. Observations: | 10 | AIC: | 99.38 | . | Df Residuals: | 6 | BIC: | 100.6 | . | Df Model: | 3 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P>|t| | [0.025 | 0.975] | . | const | 77.2443 | 27.366 | 2.823 | 0.030 | 10.282 | 144.206 | . | x1 | -2.7009 | 2.855 | -0.946 | 0.381 | -9.686 | 4.284 | . | x2 | 7.2989 | 2.875 | 2.539 | 0.044 | 0.265 | 14.333 | . | x3 | -4.8607 | 2.187 | -2.223 | 0.068 | -10.211 | 0.490 | . | Omnibus: | 2.691 | Durbin-Watson: | 2.123 | . | Prob(Omnibus): | 0.260 | Jarque-Bera (JB): | 1.251 | . | Skew: | 0.524 | Prob(JB): | 0.535 | . | Kurtosis: | 1.620 | Cond. No. | 58.2 | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified. In particular, that printout contains the Adjusted $R^2$ value; it is the second value in the right-hand column, near the top. You can also obtain it directly, as follows: ```python model.rsquared_adj ``` 0.390392407508503 In this case, the Adjusted $R^2$ is $0.3904$. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute adjusted R-squared/Python, using statsmodels.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-adjusted-r-squared-in-python-using-statsmodels/",
    "relUrl": "/how-to-compute-adjusted-r-squared-in-python-using-statsmodels/"
  },"224": {
    "doc": "How to compute adjusted R-squared (in R)",
    "title": "How to compute adjusted R-squared (in R)",
    "content": "# How to compute adjusted R-squared (in R) [See all solutions.](../how-to-compute-adjusted-r-squared) ## Task If we have fit a multivariate linear model, how can we compute the Adjusted $R^2$ for that model, to measure its goodness of fit? Related tasks: * [How to compute R-squared for a simple linear model](../how-to-compute-r-squared-for-a-simple-linear-model) ## Solution We assume you have already fit a multivariate linear model to the data, as in the code below. (If you're unfamiliar with how to do so, see [how to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model).) The data shown below is fake, and we assume you will replace it with your own real data if you use this code. ```R x1 |t|) (Intercept) 77.244 27.366 2.823 0.0302 * x1 -2.701 2.855 -0.946 0.3806 x2 7.299 2.875 2.539 0.0441 * x3 -4.861 2.187 -2.223 0.0679 . --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 30.13 on 6 degrees of freedom Multiple R-squared: 0.5936, Adjusted R-squared: 0.3904 F-statistic: 2.921 on 3 and 6 DF, p-value: 0.1222 In particular, that printout contains the Adjusted $R^2$ value; it is the second value in the right-hand column, near the top. You can also obtain it directly, as follows: ```R summary(model)$adj.r.squared ``` [1] 0.3903924 In this case, the Adjusted $R^2$ is $0.3904$. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute adjusted R-squared/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-adjusted-r-squared-in-r/",
    "relUrl": "/how-to-compute-adjusted-r-squared-in-r/"
  },"225": {
    "doc": "How to compute adjusted R-squared",
    "title": "How to compute adjusted R-squared",
    "content": " ",
    "url": "/how-to-compute-adjusted-r-squared/",
    "relUrl": "/how-to-compute-adjusted-r-squared/"
  },"226": {
    "doc": "How to compute adjusted R-squared",
    "title": "Description",
    "content": "If we have fit a multivariate linear model, how can we compute the Adjusted $R^2$ for that model, to measure its goodness of fit? . Related tasks: . | How to compute R-squared for a simple linear model | . ",
    "url": "/how-to-compute-adjusted-r-squared/#description",
    "relUrl": "/how-to-compute-adjusted-r-squared/#description"
  },"227": {
    "doc": "How to compute adjusted R-squared",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. We assume you have already fit a multivariate linear model to some data, as in the code below. (If you’re unfamiliar with how to do so, see how to fit a multivariate linear model.) The data shown below is fake, and we assume you will replace it with your own real data if you use this code. | 1 2 3 4 5 6 7 8 9 10 11 12 . | import pandas as pd import statsmodels.api as sm df = pd.DataFrame( { 'x1':[2, 7, 4, 3, 11, 18, 6, 15, 9, 12], 'x2':[4, 6, 10, 1, 18, 11, 8, 20, 16, 13], 'x3':[11, 16, 20, 6, 14, 8, 5, 23, 13, 10], 'y':[24, 60, 32, 29, 90, 45, 130, 76, 100, 120] } ) xs = df[['x1', 'x2', 'x3']] y = df['y'] xs = sm.add_constant(xs) model = sm.OLS(y, xs).fit() . | . | 1 2 . | /opt/conda/lib/python3.9/site-packages/statsmodels/tsa/tsatools.py:142: FutureWarning: In a future version of pandas all arguments of concat except for the argument 'objs' will be keyword-only x = pd.concat(x[::order], 1) . | . You can get a lot of information about your model from its summary. | 1 . | model.summary() . | . | 1 2 . | /opt/conda/lib/python3.9/site-packages/scipy/stats/stats.py:1541: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=10 warnings.warn(\"kurtosistest only valid for n&gt;=20 ... continuing \" . | . OLS Regression Results | Dep. Variable: | y | R-squared: | 0.594 | . | Model: | OLS | Adj. R-squared: | 0.390 | . | Method: | Least Squares | F-statistic: | 2.921 | . | Date: | Tue, 07 Dec 2021 | Prob (F-statistic): | 0.122 | . | Time: | 15:06:52 | Log-Likelihood: | -45.689 | . | No. Observations: | 10 | AIC: | 99.38 | . | Df Residuals: | 6 | BIC: | 100.6 | . | Df Model: | 3 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P&gt;|t| | [0.025 | 0.975] | . | const | 77.2443 | 27.366 | 2.823 | 0.030 | 10.282 | 144.206 | . | x1 | -2.7009 | 2.855 | -0.946 | 0.381 | -9.686 | 4.284 | . | x2 | 7.2989 | 2.875 | 2.539 | 0.044 | 0.265 | 14.333 | . | x3 | -4.8607 | 2.187 | -2.223 | 0.068 | -10.211 | 0.490 | . | Omnibus: | 2.691 | Durbin-Watson: | 2.123 | . | Prob(Omnibus): | 0.260 | Jarque-Bera (JB): | 1.251 | . | Skew: | 0.524 | Prob(JB): | 0.535 | . | Kurtosis: | 1.620 | Cond. No. | 58.2 | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified. In particular, that printout contains the Adjusted $R^2$ value; it is the second value in the right-hand column, near the top. You can also obtain it directly, as follows: . | 1 . | model.rsquared_adj . | . | 1 . | 0.390392407508503 . | . In this case, the Adjusted $R^2$ is $0.3904$. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-adjusted-r-squared/#using-statsmodels-in-python",
    "relUrl": "/how-to-compute-adjusted-r-squared/#using-statsmodels-in-python"
  },"228": {
    "doc": "How to compute adjusted R-squared",
    "title": "Solution, in R",
    "content": "View this solution alone. We assume you have already fit a multivariate linear model to the data, as in the code below. (If you’re unfamiliar with how to do so, see how to fit a multivariate linear model.) The data shown below is fake, and we assume you will replace it with your own real data if you use this code. | 1 2 3 4 5 . | x1 &lt;- c(2, 7, 4, 3, 11, 18, 6, 15, 9, 12) x2 &lt;- c(4, 6, 10, 1, 18, 11, 8, 20, 16, 13) x3 &lt;- c(11, 16, 20, 6, 14, 8, 5, 23, 13, 10) y &lt;- c(24, 60, 32, 29, 90, 45, 130, 76, 100, 120) model &lt;- lm(y ~ x1 + x2 + x3) . | . You can get a lot of information about your model from its summary. | 1 . | summary(model) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 . | Call: lm(formula = y ~ x1 + x2 + x3) Residuals: Min 1Q Median 3Q Max -25.031 -20.218 -8.373 22.937 35.640 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 77.244 27.366 2.823 0.0302 * x1 -2.701 2.855 -0.946 0.3806 x2 7.299 2.875 2.539 0.0441 * x3 -4.861 2.187 -2.223 0.0679 . --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 30.13 on 6 degrees of freedom Multiple R-squared: 0.5936, Adjusted R-squared: 0.3904 F-statistic: 2.921 on 3 and 6 DF, p-value: 0.1222 . | . In particular, that printout contains the Adjusted $R^2$ value; it is the second value in the right-hand column, near the top. You can also obtain it directly, as follows: . | 1 . | summary(model)$adj.r.squared . | . | 1 . | [1] 0.3903924 . | . In this case, the Adjusted $R^2$ is $0.3904$. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-adjusted-r-squared/#solution-in-r",
    "relUrl": "/how-to-compute-adjusted-r-squared/#solution-in-r"
  },"229": {
    "doc": "How to compute adjusted R-squared",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-compute-adjusted-r-squared/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-adjusted-r-squared/#topics-that-include-this-task"
  },"230": {
    "doc": "How to compute adjusted R-squared",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-adjusted-r-squared/#opportunities",
    "relUrl": "/how-to-compute-adjusted-r-squared/#opportunities"
  },"231": {
    "doc": "How to compute covariance and correlation coefficients (in Python, using pandas and NumPy)",
    "title": "How to compute covariance and correlation coefficients (in Python, using pandas and NumPy)",
    "content": "# How to compute covariance and correlation coefficients (in Python, using pandas and NumPy) [See all solutions.](../how-to-compute-covariance-and-correlation-coefficients) ## Task Covariance is a measure of how much two variables \"change together.\" It is positive when the variables tend to increase or decrease together, and negative when they upward motion of one variable is correlated with downward motion of the other. Correlation normalizes covariance to the interval $[-1,1]$. ## Solution We will construct some random data here, but when applying this, you would use your own data, of course. ```python import pandas as pd import numpy as np df = pd.DataFrame(np.random.rand(10,5)) df.columns = [ 'col1','col2','col3','col4','col5' ] df.head() ``` | | col1 | col2 | col3 | col4 | col5 | . | 0 | 0.499459 | 0.544642 | 0.416081 | 0.770145 | 0.365638 | . | 1 | 0.051560 | 0.094024 | 0.821636 | 0.307194 | 0.269724 | . | 2 | 0.775610 | 0.411586 | 0.754904 | 0.174790 | 0.559466 | . | 3 | 0.747098 | 0.783076 | 0.955363 | 0.944042 | 0.875185 | . | 4 | 0.814148 | 0.943769 | 0.249496 | 0.577307 | 0.715827 | . If you have two pandas Series, you can compute the covariance of just those two variables. Note that every column in a DataFrame is a pandas series. ```python np.cov( df['col1'], df['col2'] ) ``` array([[0.10369366, 0.08926178], [0.08926178, 0.10982211]]) You can also compare all of a DataFrame's columns among one another, each as a separate variable. ```python df.cov() ``` | | col1 | col2 | col3 | col4 | col5 | . | col1 | 0.103694 | 0.089262 | -0.029498 | -0.005259 | 0.056009 | . | col2 | 0.089262 | 0.109822 | -0.068362 | 0.014306 | 0.050707 | . | col3 | -0.029498 | -0.068362 | 0.107503 | 0.003484 | 0.004916 | . | col4 | -0.005259 | 0.014306 | 0.003484 | 0.070548 | -0.017955 | . | col5 | 0.056009 | 0.050707 | 0.004916 | -0.017955 | 0.093274 | . The Pearson correlation coefficient can be computed with `np.corrcoef` in place of `np.cov`. ```python np.corrcoef( df['col1'], df['col2'] ) ``` array([[1. , 0.83645878], [0.83645878, 1. ]]) And pandas DataFrames have a built in method to do this for all numeric columns. ```python df.corr() ``` | | col1 | col2 | col3 | col4 | col5 | . | col1 | 1.000000 | 0.836459 | -0.279384 | -0.061490 | 0.569506 | . | col2 | 0.836459 | 1.000000 | -0.629158 | 0.162532 | 0.501009 | . | col3 | -0.279384 | -0.629158 | 1.000000 | 0.040002 | 0.049098 | . | col4 | -0.061490 | 0.162532 | 0.040002 | 1.000000 | -0.221339 | . | col5 | 0.569506 | 0.501009 | 0.049098 | -0.221339 | 1.000000 | . Content last modified on 10 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute covariance and correlation coefficients/Python, using pandas and NumPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-covariance-and-correlation-coefficients-in-python-using-pandas-and-numpy/",
    "relUrl": "/how-to-compute-covariance-and-correlation-coefficients-in-python-using-pandas-and-numpy/"
  },"232": {
    "doc": "How to compute covariance and correlation coefficients (in R)",
    "title": "How to compute covariance and correlation coefficients (in R)",
    "content": "# How to compute covariance and correlation coefficients (in R) [See all solutions.](../how-to-compute-covariance-and-correlation-coefficients) ## Task Covariance is a measure of how much two variables \"change together.\" It is positive when the variables tend to increase or decrease together, and negative when they upward motion of one variable is correlated with downward motion of the other. Correlation normalizes covariance to the interval $[-1,1]$. ## Solution We will construct some random data here, but when applying this, you would use your own data, of course. ```R # Create a dataframe with random values between 0 and 1 set.seed(1) df <- as.data.frame(matrix(runif(n=50,min=0,max=1),nrow = 10)) names(df) <- c('col1','col2','col3','col4','col5') head(df) ``` col1 col2 col3 col4 col5 1 0.2655087 0.2059746 0.9347052 0.4820801 0.8209463 2 0.3721239 0.1765568 0.2121425 0.5995658 0.6470602 3 0.5728534 0.6870228 0.6516738 0.4935413 0.7829328 4 0.9082078 0.3841037 0.1255551 0.1862176 0.5530363 5 0.2016819 0.7698414 0.2672207 0.8273733 0.5297196 6 0.8983897 0.4976992 0.3861141 0.6684667 0.7893562 In R, we can use the `cov()` function to calculate the covariance between two variables. The default method is Pearson. ```R cov( df$col1, df$col2 ) ``` [1] 0.0004115864 You can also compare all of a DataFrame's columns among one another, each as a separate variable. ```R cov(df) ``` col1 col2 col3 col4 col5 col1 0.0996382947 0.0004115864 -0.0287090091 -0.0052485522 -0.029944309 col2 0.0004115864 0.0731549057 -0.0255386673 -0.0112688616 -0.026535785 col3 -0.0287090091 -0.0255386673 0.0942522913 0.0009465216 0.050640298 col4 -0.0052485522 -0.0112688616 0.0009465216 0.0593140088 -0.008714775 col5 -0.0299443088 -0.0265357850 0.0506402980 -0.0087147752 0.055665077 The Pearson correlation coefficient can be computed with `cor()` in place of `cov()`. ```R cor(df$col1,df$col2) ``` [1] 0.004820878 And you can compute correlation coefficients for all numeric columns in a DataFrame. ```R cor(df) ``` col1 col2 col3 col4 col5 col1 1.000000000 0.004820878 -0.29625051 -0.06827280 -0.4020775 col2 0.004820878 1.000000000 -0.30756049 -0.17107229 -0.4158329 col3 -0.296250506 -0.307560491 1.00000000 0.01265919 0.6991315 col4 -0.068272803 -0.171072293 0.01265919 1.00000000 -0.1516653 col5 -0.402077472 -0.415832858 0.69913152 -0.15166527 1.0000000 Content last modified on 10 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute covariance and correlation coefficients/R.Rmd). Contributed by Ni Shi (shi_ni@bentley.edu) ",
    "url": "/how-to-compute-covariance-and-correlation-coefficients-in-r/",
    "relUrl": "/how-to-compute-covariance-and-correlation-coefficients-in-r/"
  },"233": {
    "doc": "How to compute covariance and correlation coefficients",
    "title": "How to compute covariance and correlation coefficients",
    "content": " ",
    "url": "/how-to-compute-covariance-and-correlation-coefficients/",
    "relUrl": "/how-to-compute-covariance-and-correlation-coefficients/"
  },"234": {
    "doc": "How to compute covariance and correlation coefficients",
    "title": "Description",
    "content": "Covariance is a measure of how much two variables “change together.” It is positive when the variables tend to increase or decrease together, and negative when they upward motion of one variable is correlated with downward motion of the other. Correlation normalizes covariance to the interval $[-1,1]$. ",
    "url": "/how-to-compute-covariance-and-correlation-coefficients/#description",
    "relUrl": "/how-to-compute-covariance-and-correlation-coefficients/#description"
  },"235": {
    "doc": "How to compute covariance and correlation coefficients",
    "title": "Using pandas and NumPy, in Python",
    "content": "View this solution alone. We will construct some random data here, but when applying this, you would use your own data, of course. | 1 2 3 4 5 . | import pandas as pd import numpy as np df = pd.DataFrame(np.random.rand(10,5)) df.columns = [ 'col1','col2','col3','col4','col5' ] df.head() . | . | | col1 | col2 | col3 | col4 | col5 | . | 0 | 0.499459 | 0.544642 | 0.416081 | 0.770145 | 0.365638 | . | 1 | 0.051560 | 0.094024 | 0.821636 | 0.307194 | 0.269724 | . | 2 | 0.775610 | 0.411586 | 0.754904 | 0.174790 | 0.559466 | . | 3 | 0.747098 | 0.783076 | 0.955363 | 0.944042 | 0.875185 | . | 4 | 0.814148 | 0.943769 | 0.249496 | 0.577307 | 0.715827 | . If you have two pandas Series, you can compute the covariance of just those two variables. Note that every column in a DataFrame is a pandas series. | 1 . | np.cov( df['col1'], df['col2'] ) . | . | 1 2 . | array([[0.10369366, 0.08926178], [0.08926178, 0.10982211]]) . | . You can also compare all of a DataFrame’s columns among one another, each as a separate variable. | 1 . | df.cov() . | . | | col1 | col2 | col3 | col4 | col5 | . | col1 | 0.103694 | 0.089262 | -0.029498 | -0.005259 | 0.056009 | . | col2 | 0.089262 | 0.109822 | -0.068362 | 0.014306 | 0.050707 | . | col3 | -0.029498 | -0.068362 | 0.107503 | 0.003484 | 0.004916 | . | col4 | -0.005259 | 0.014306 | 0.003484 | 0.070548 | -0.017955 | . | col5 | 0.056009 | 0.050707 | 0.004916 | -0.017955 | 0.093274 | . The Pearson correlation coefficient can be computed with np.corrcoef in place of np.cov. | 1 . | np.corrcoef( df['col1'], df['col2'] ) . | . | 1 2 . | array([[1. , 0.83645878], [0.83645878, 1. ]]) . | . And pandas DataFrames have a built in method to do this for all numeric columns. | 1 . | df.corr() . | . | | col1 | col2 | col3 | col4 | col5 | . | col1 | 1.000000 | 0.836459 | -0.279384 | -0.061490 | 0.569506 | . | col2 | 0.836459 | 1.000000 | -0.629158 | 0.162532 | 0.501009 | . | col3 | -0.279384 | -0.629158 | 1.000000 | 0.040002 | 0.049098 | . | col4 | -0.061490 | 0.162532 | 0.040002 | 1.000000 | -0.221339 | . | col5 | 0.569506 | 0.501009 | 0.049098 | -0.221339 | 1.000000 | . Content last modified on 10 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-covariance-and-correlation-coefficients/#using-pandas-and-numpy-in-python",
    "relUrl": "/how-to-compute-covariance-and-correlation-coefficients/#using-pandas-and-numpy-in-python"
  },"236": {
    "doc": "How to compute covariance and correlation coefficients",
    "title": "Solution, in R",
    "content": "View this solution alone. We will construct some random data here, but when applying this, you would use your own data, of course. | 1 2 3 4 5 . | # Create a dataframe with random values between 0 and 1 set.seed(1) df &lt;- as.data.frame(matrix(runif(n=50,min=0,max=1),nrow = 10)) names(df) &lt;- c('col1','col2','col3','col4','col5') head(df) . | . | 1 2 3 4 5 6 7 . | col1 col2 col3 col4 col5 1 0.2655087 0.2059746 0.9347052 0.4820801 0.8209463 2 0.3721239 0.1765568 0.2121425 0.5995658 0.6470602 3 0.5728534 0.6870228 0.6516738 0.4935413 0.7829328 4 0.9082078 0.3841037 0.1255551 0.1862176 0.5530363 5 0.2016819 0.7698414 0.2672207 0.8273733 0.5297196 6 0.8983897 0.4976992 0.3861141 0.6684667 0.7893562 . | . In R, we can use the cov() function to calculate the covariance between two variables. The default method is Pearson. | 1 . | cov( df$col1, df$col2 ) . | . | 1 . | [1] 0.0004115864 . | . You can also compare all of a DataFrame’s columns among one another, each as a separate variable. | 1 . | cov(df) . | . | 1 2 3 4 5 6 . | col1 col2 col3 col4 col5 col1 0.0996382947 0.0004115864 -0.0287090091 -0.0052485522 -0.029944309 col2 0.0004115864 0.0731549057 -0.0255386673 -0.0112688616 -0.026535785 col3 -0.0287090091 -0.0255386673 0.0942522913 0.0009465216 0.050640298 col4 -0.0052485522 -0.0112688616 0.0009465216 0.0593140088 -0.008714775 col5 -0.0299443088 -0.0265357850 0.0506402980 -0.0087147752 0.055665077 . | . The Pearson correlation coefficient can be computed with cor() in place of cov(). | 1 . | cor(df$col1,df$col2) . | . | 1 . | [1] 0.004820878 . | . And you can compute correlation coefficients for all numeric columns in a DataFrame. | 1 . | cor(df) . | . | 1 2 3 4 5 6 . | col1 col2 col3 col4 col5 col1 1.000000000 0.004820878 -0.29625051 -0.06827280 -0.4020775 col2 0.004820878 1.000000000 -0.30756049 -0.17107229 -0.4158329 col3 -0.296250506 -0.307560491 1.00000000 0.01265919 0.6991315 col4 -0.068272803 -0.171072293 0.01265919 1.00000000 -0.1516653 col5 -0.402077472 -0.415832858 0.69913152 -0.15166527 1.0000000 . | . Content last modified on 10 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-covariance-and-correlation-coefficients/#solution-in-r",
    "relUrl": "/how-to-compute-covariance-and-correlation-coefficients/#solution-in-r"
  },"237": {
    "doc": "How to compute covariance and correlation coefficients",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | Bentley University MA346 | . ",
    "url": "/how-to-compute-covariance-and-correlation-coefficients/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-covariance-and-correlation-coefficients/#topics-that-include-this-task"
  },"238": {
    "doc": "How to compute covariance and correlation coefficients",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-covariance-and-correlation-coefficients/#opportunities",
    "relUrl": "/how-to-compute-covariance-and-correlation-coefficients/#opportunities"
  },"239": {
    "doc": "How to compute Fisher's confidence intervals (in R)",
    "title": "How to compute Fisher's confidence intervals (in R)",
    "content": "# How to compute Fisher's confidence intervals (in R) [See all solutions.](../how-to-compute-fisher-s-confidence-intervals) ## Task If we run a one-way ANOVA test and find that there is a significant difference between population means, we might want to know which means are actually different from each other. One way to do so is with Fisher's Least Significant Difference Confidence Intervals, which forms a confidence interval for each pair of samples. How do we go about making these confidence intervals? ## Solution We will use some fake data for the purposes of an example, but you can replace it with your real data in the code below. Consider an ice cream shop's sales data over several weekends. ```R num.transactions F) days 2 1965 982.7 4.348 0.034 * Residuals 14 3164 226.0 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 From the $p$-value in the `Pr(>F)` column, we can see that, at the 5% significance level, there are significant differences between the mean number of transactions at the ice cream shop across these weekend days. We'll use the `LSD.test` function (Least Significant Difference) from R's `agricolae` package to get the confidence intervals for each pair of days. Let's use $\\alpha=0.05$ again so that we get 95% confidence intervals. ```R # install.packages(\"agricolae\") # if you have not already done so library(agricolae) test <- LSD.test(model, alpha=0.05, \"days\") test ``` $statistics MSerror Df Mean CV 226.0333 14 109.3529 13.74851 $parameters test p.ajusted name.t ntr alpha Fisher-LSD none days 3 0.05 $means num.transactions std r LCL UCL Min Max Q25 Q50 Q75 Fri 95.16667 12.67149 6 82.00246 108.3309 84 120 89.50 92 93.75 Sat 113.80000 18.36301 5 99.37933 128.2207 99 145 105.00 105 115.00 Sun 119.83333 14.23259 6 106.66913 132.9975 98 134 111.25 123 131.00 $comparison NULL $groups num.transactions groups Sun 119.83333 a Sat 113.80000 ab Fri 95.16667 b attr(,\"class\") [1] \"group\" The portion of this lengthy output on which to focus is the `$groups` section. If the categories share a letter in the \"groups\" column, then their means are not significantly different from each other. Therefore: * Sunday and Saturday share the letter \"a,\" so we know that the number of transactions on these two days are not significantly different from each other. * The same goes for Saturday and Friday, which share the letter \"b.\" * But Sunday and Friday do not share a letter, so the number of transactions on these two days is significantly different. Content last modified on 08 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute Fisher's confidence intervals/R.md). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-compute-fisher-s-confidence-intervals-in-r/",
    "relUrl": "/how-to-compute-fisher-s-confidence-intervals-in-r/"
  },"240": {
    "doc": "How to compute Fisher's confidence intervals",
    "title": "How to compute Fisher’s confidence intervals",
    "content": " ",
    "url": "/how-to-compute-fisher-s-confidence-intervals/#how-to-compute-fishers-confidence-intervals",
    "relUrl": "/how-to-compute-fisher-s-confidence-intervals/#how-to-compute-fishers-confidence-intervals"
  },"241": {
    "doc": "How to compute Fisher's confidence intervals",
    "title": "Description",
    "content": "If we run a one-way ANOVA test and find that there is a significant difference between population means, we might want to know which means are actually different from each other. One way to do so is with Fisher’s Least Significant Difference Confidence Intervals, which forms a confidence interval for each pair of samples. How do we go about making these confidence intervals? . ",
    "url": "/how-to-compute-fisher-s-confidence-intervals/#description",
    "relUrl": "/how-to-compute-fisher-s-confidence-intervals/#description"
  },"242": {
    "doc": "How to compute Fisher's confidence intervals",
    "title": "Solution, in R",
    "content": "View this solution alone. We will use some fake data for the purposes of an example, but you can replace it with your real data in the code below. Consider an ice cream shop’s sales data over several weekends. | 1 2 3 4 . | num.transactions &lt;- c(91, 134, 98, 105, 93, 89, 145, 132, 109, 94, 105, 99, 84, 128, 120, 115, 118) days &lt;- c(\"Fri\", \"Sun\", \"Sun\", \"Sat\", \"Fri\", \"Fri\", \"Sat\", \"Sun\", \"Sun\", \"Fri\", \"Sat\", \"Sat\", \"Fri\", \"Sun\", \"Fri\", \"Sat\", \"Sun\") . | . Let’s assume that you have already performed an ANOVA on this data, as shown below. (If you’re not familiar with ANOVA, see how to do a one-way ANOVA test.) Let’s assume that we chose $\\alpha$ to be 0.05. | 1 2 . | model &lt;- aov(num.transactions ~ days) summary(model) . | . | 1 2 3 4 5 . | Df Sum Sq Mean Sq F value Pr(&gt;F) days 2 1965 982.7 4.348 0.034 * Residuals 14 3164 226.0 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . From the $p$-value in the Pr(&gt;F) column, we can see that, at the 5% significance level, there are significant differences between the mean number of transactions at the ice cream shop across these weekend days. We’ll use the LSD.test function (Least Significant Difference) from R’s agricolae package to get the confidence intervals for each pair of days. Let’s use $\\alpha=0.05$ again so that we get 95% confidence intervals. | 1 2 3 4 5 . | # install.packages(\"agricolae\") # if you have not already done so library(agricolae) test &lt;- LSD.test(model, alpha=0.05, \"days\") test . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 . | $statistics MSerror Df Mean CV 226.0333 14 109.3529 13.74851 $parameters test p.ajusted name.t ntr alpha Fisher-LSD none days 3 0.05 $means num.transactions std r LCL UCL Min Max Q25 Q50 Q75 Fri 95.16667 12.67149 6 82.00246 108.3309 84 120 89.50 92 93.75 Sat 113.80000 18.36301 5 99.37933 128.2207 99 145 105.00 105 115.00 Sun 119.83333 14.23259 6 106.66913 132.9975 98 134 111.25 123 131.00 $comparison NULL $groups num.transactions groups Sun 119.83333 a Sat 113.80000 ab Fri 95.16667 b attr(,\"class\") [1] \"group\" . | . The portion of this lengthy output on which to focus is the $groups section. If the categories share a letter in the “groups” column, then their means are not significantly different from each other. Therefore: . | Sunday and Saturday share the letter “a,” so we know that the number of transactions on these two days are not significantly different from each other. | The same goes for Saturday and Friday, which share the letter “b.” | But Sunday and Friday do not share a letter, so the number of transactions on these two days is significantly different. | . Content last modified on 08 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-fisher-s-confidence-intervals/#solution-in-r",
    "relUrl": "/how-to-compute-fisher-s-confidence-intervals/#solution-in-r"
  },"243": {
    "doc": "How to compute Fisher's confidence intervals",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-compute-fisher-s-confidence-intervals/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-fisher-s-confidence-intervals/#topics-that-include-this-task"
  },"244": {
    "doc": "How to compute Fisher's confidence intervals",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-fisher-s-confidence-intervals/#opportunities",
    "relUrl": "/how-to-compute-fisher-s-confidence-intervals/#opportunities"
  },"245": {
    "doc": "How to compute Fisher's confidence intervals",
    "title": "How to compute Fisher's confidence intervals",
    "content": " ",
    "url": "/how-to-compute-fisher-s-confidence-intervals/",
    "relUrl": "/how-to-compute-fisher-s-confidence-intervals/"
  },"246": {
    "doc": "How to compute probabilities from a distribution (in Excel)",
    "title": "How to compute probabilities from a distribution (in Excel)",
    "content": "# How to compute probabilities from a distribution (in Excel) [See all solutions.](../how-to-compute-probabilities-from-a-distribution) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to compute the probability of a value/values occurring? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution If the probability distribution is a common *discrete* distribution, you can simply use a built-in function from Excel’s set of statistical functions to compute any probability from it. For example, to find the probability that a binomial random variable with p=0.25 yields 3 successes in 5 trials, you can use =BINOM.DIST(3,5,0.25,FALSE). The final parameter, FALSE, tells Excel you are asking only about 3 successes, not the cumulative probability of *up to 3* successes. For other discrete random variables, see the Excel help on POISSON.DIST and HYPGEOM.DIST. If the probability distribution is a common *continuous* distribution, you must ask about the probability of a random value falling in a certain range. You do so by subtracting two outputs of the cumulative distribution function (CDF). For example, to find the probability that a normal random variable with mean 5 and standard deviation 2 falls in the interval \\[6,7\\], you can use =NORM.DIST(7,5,2,TRUE)-NORM.DIST(6,5,2,TRUE). Notice: - It is important to subtract the lower end of the interval from the higher end, not the other way around. (If your probability comes out negative, you have it backwards.) - The final parameter, TRUE, tells Excel you are using the CDF of the distribution. If you use FALSE instead, you will get a wrong answer. For other continuous random variables, see the Excel help on BETA.DIST, CHISQ.DIST, F.DIST, GAMMA.DIST, LOGNORM.DIST, and T.DIST. Content last modified on 09 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute probabilities from a distribution/Excel.docx). ",
    "url": "/how-to-compute-probabilities-from-a-distribution-in-excel/",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution-in-excel/"
  },"247": {
    "doc": "How to compute probabilities from a distribution (in Julia)",
    "title": "How to compute probabilities from a distribution (in Julia)",
    "content": "# How to compute probabilities from a distribution (in Julia) [See all solutions.](../how-to-compute-probabilities-from-a-distribution) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to compute the probability of a value/values occurring? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution You can import many different random variables from Julia's `Distributions` package. The full list of them is online [here](https://juliastats.org/Distributions.jl/stable/univariate/). If you don't have that package installed, first run `using Pkg` and then `Pkg.add( \"Distributions\" )` from within Julia. To compute a probability from a **discrete** distribution, create a random variable, then use the `pdf` function. (This is a slight misnomer, because PDF stands for Probability Density Function, which is a concept related to continuous random variables, but it's the function Julia uses.) ```julia using Distributions # Create a binomial random variable with 10 trials # and probability 0.5 of success on each trial X = Binomial( 10, 0.5 ) # What is the probability of exactly 3 successes? pdf( X, 3 ) ``` 0.1171875000000004 To compute a probability from a **continuous** distribution, create a random variable, then use its Cumulative Density Function, `cdf`. You can only compute the probability that a random value will fall in an interval $[a,b]$, not the probability that it will equal a specific value. ```julia using Distributions # Create a normal random variable with mean μ=10 and standard deviation σ=5 X = Normal( 10, 5 ) # What is the probability of the value lying in the interval [12,13]? cdf( X, 13 ) - cdf( X, 12 ) ``` 0.07032514063960227 Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute probabilities from a distribution/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-probabilities-from-a-distribution-in-julia/",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution-in-julia/"
  },"248": {
    "doc": "How to compute probabilities from a distribution (in Python, using SciPy)",
    "title": "How to compute probabilities from a distribution (in Python, using SciPy)",
    "content": "# How to compute probabilities from a distribution (in Python, using SciPy) [See all solutions.](../how-to-compute-probabilities-from-a-distribution) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to compute the probability of a value/values occurring? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution You can import many different random variables from SciPy's `stats` module. The full list of them is online [here](https://docs.scipy.org/doc/scipy/reference/stats.html#discrete-distributions). To compute a probability from a **discrete** distribution, create a random variable, then use its Probability Mass Function, `pmf`. ```python from scipy import stats # Create a binomial random variable with 10 trials # and probability 0.5 of success on each trial X = stats.binom( 10, 0.5 ) # What is the probability of exactly 3 successes? X.pmf( 3 ) ``` 0.1171875 To compute a probability from a **continuous** distribution, create a random variable, then use its Cumulative Density Function, `cdf`. You can only compute the probability that a random value will fall in an interval $[a,b]$, not the probability that it will equal a specific value. ```python from scipy import stats # Create a normal random variable with mean μ=10 and standard deviation σ=5 X = stats.norm( 10, 5 ) # What is the probability of the value lying in the interval [12,13]? X.cdf( 13 ) - X.cdf( 12 ) ``` 0.07032514063960227 Content last modified on 27 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute probabilities from a distribution/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-probabilities-from-a-distribution-in-python-using-scipy/",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution-in-python-using-scipy/"
  },"249": {
    "doc": "How to compute probabilities from a distribution (in R)",
    "title": "How to compute probabilities from a distribution (in R)",
    "content": "# How to compute probabilities from a distribution (in R) [See all solutions.](../how-to-compute-probabilities-from-a-distribution) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to compute the probability of a value/values occurring? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution Because R is designed for use in statistics, it comes with many probability distributions built in. A list of them is online [here](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Probability-distributions). To compute a probability from a **discrete** distribution, prefix the name of the distribution with `d` (for \"density\") and call it as a function on the value whose probability you want to know, plus any parameters the distrubtion needs. ```R # For a binomial random variable with 10 trials # and probability 0.5 of success on each trial, # what is the probability of exactly 3 successes? dbinom( 3, size=10, prob=0.5 ) ``` [1] 0.1171875 If you change the prefix to `p`, then R will compute the probability *up to* the parameter you specify, as in the following example. ```R # For a binomial random variable with 10 trials # and probability 0.5 of success on each trial, # what is the probability of up to (and including) 3 successes? pbinom( 3, size=10, prob=0.5 ) ``` [1] 0.171875 To compute a probability from a **continuous** distribution, prefix the name with `d`, just as in the example above. But you can compute only the probability that a random value will fall in an interval $[a,b]$, not the probability that it will equal a specific value. ```R # For a normal random variable with mean μ=10 and standard deviation σ=5, # what is the probability of the value lying in the interval [12,13]? pnorm( 13, mean=10, sd=5 ) - pnorm( 12, mean=10, sd=5 ) ``` [1] 0.07032514 Consequently, we can also compute: ```R pnorm( 13, mean=10, sd=5 ) # the probability of a value 13 ``` [1] 0.7257469 [1] 0.2742531 Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute probabilities from a distribution/R.md). Contributed by: * Nathan Carter (ncarter@bentley.edu) * Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-probabilities-from-a-distribution-in-r/",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution-in-r/"
  },"250": {
    "doc": "How to compute probabilities from a distribution",
    "title": "How to compute probabilities from a distribution",
    "content": " ",
    "url": "/how-to-compute-probabilities-from-a-distribution/",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution/"
  },"251": {
    "doc": "How to compute probabilities from a distribution",
    "title": "Description",
    "content": "There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to compute the probability of a value/values occurring? . Related tasks: . | How to generate random values from a distribution | How to plot continuous probability distributions | How to plot discrete probability distributions | . ",
    "url": "/how-to-compute-probabilities-from-a-distribution/#description",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution/#description"
  },"252": {
    "doc": "How to compute probabilities from a distribution",
    "title": "Solution, in Excel",
    "content": "View this solution alone. If the probability distribution is a common discrete distribution, you can simply use a built-in function from Excel’s set of statistical functions to compute any probability from it. For example, to find the probability that a binomial random variable with p=0.25 yields 3 successes in 5 trials, you can use =BINOM.DIST(3,5,0.25,FALSE). The final parameter, FALSE, tells Excel you are asking only about 3 successes, not the cumulative probability of up to 3 successes. For other discrete random variables, see the Excel help on POISSON.DIST and HYPGEOM.DIST. If the probability distribution is a common continuous distribution, you must ask about the probability of a random value falling in a certain range. You do so by subtracting two outputs of the cumulative distribution function (CDF). For example, to find the probability that a normal random variable with mean 5 and standard deviation 2 falls in the interval [6,7], you can use =NORM.DIST(7,5,2,TRUE)-NORM.DIST(6,5,2,TRUE). Notice: . | It is important to subtract the lower end of the interval from the higher end, not the other way around. (If your probability comes out negative, you have it backwards.) . | The final parameter, TRUE, tells Excel you are using the CDF of the distribution. If you use FALSE instead, you will get a wrong answer. | . For other continuous random variables, see the Excel help on BETA.DIST, CHISQ.DIST, F.DIST, GAMMA.DIST, LOGNORM.DIST, and T.DIST. Content last modified on 09 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-probabilities-from-a-distribution/#solution-in-excel",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution/#solution-in-excel"
  },"253": {
    "doc": "How to compute probabilities from a distribution",
    "title": "Solution, in Julia",
    "content": "View this solution alone. You can import many different random variables from Julia’s Distributions package. The full list of them is online here. If you don’t have that package installed, first run using Pkg and then Pkg.add( \"Distributions\" ) from within Julia. To compute a probability from a discrete distribution, create a random variable, then use the pdf function. (This is a slight misnomer, because PDF stands for Probability Density Function, which is a concept related to continuous random variables, but it’s the function Julia uses.) . | 1 2 3 4 5 6 7 8 . | using Distributions # Create a binomial random variable with 10 trials # and probability 0.5 of success on each trial X = Binomial( 10, 0.5 ) # What is the probability of exactly 3 successes? pdf( X, 3 ) . | . | 1 . | 0.1171875000000004 . | . To compute a probability from a continuous distribution, create a random variable, then use its Cumulative Density Function, cdf. You can only compute the probability that a random value will fall in an interval $[a,b]$, not the probability that it will equal a specific value. | 1 2 3 4 5 6 7 . | using Distributions # Create a normal random variable with mean μ=10 and standard deviation σ=5 X = Normal( 10, 5 ) # What is the probability of the value lying in the interval [12,13]? cdf( X, 13 ) - cdf( X, 12 ) . | . | 1 . | 0.07032514063960227 . | . Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-probabilities-from-a-distribution/#solution-in-julia",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution/#solution-in-julia"
  },"254": {
    "doc": "How to compute probabilities from a distribution",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. You can import many different random variables from SciPy’s stats module. The full list of them is online here. To compute a probability from a discrete distribution, create a random variable, then use its Probability Mass Function, pmf. | 1 2 3 4 5 6 7 8 . | from scipy import stats # Create a binomial random variable with 10 trials # and probability 0.5 of success on each trial X = stats.binom( 10, 0.5 ) # What is the probability of exactly 3 successes? X.pmf( 3 ) . | . | 1 . | 0.1171875 . | . To compute a probability from a continuous distribution, create a random variable, then use its Cumulative Density Function, cdf. You can only compute the probability that a random value will fall in an interval $[a,b]$, not the probability that it will equal a specific value. | 1 2 3 4 5 6 7 . | from scipy import stats # Create a normal random variable with mean μ=10 and standard deviation σ=5 X = stats.norm( 10, 5 ) # What is the probability of the value lying in the interval [12,13]? X.cdf( 13 ) - X.cdf( 12 ) . | . | 1 . | 0.07032514063960227 . | . Content last modified on 27 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-probabilities-from-a-distribution/#using-scipy-in-python",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution/#using-scipy-in-python"
  },"255": {
    "doc": "How to compute probabilities from a distribution",
    "title": "Solution, in R",
    "content": "View this solution alone. Because R is designed for use in statistics, it comes with many probability distributions built in. A list of them is online here. To compute a probability from a discrete distribution, prefix the name of the distribution with d (for “density”) and call it as a function on the value whose probability you want to know, plus any parameters the distrubtion needs. | 1 2 3 4 . | # For a binomial random variable with 10 trials # and probability 0.5 of success on each trial, # what is the probability of exactly 3 successes? dbinom( 3, size=10, prob=0.5 ) . | . | 1 . | [1] 0.1171875 . | . If you change the prefix to p, then R will compute the probability up to the parameter you specify, as in the following example. | 1 2 3 4 . | # For a binomial random variable with 10 trials # and probability 0.5 of success on each trial, # what is the probability of up to (and including) 3 successes? pbinom( 3, size=10, prob=0.5 ) . | . | 1 . | [1] 0.171875 . | . To compute a probability from a continuous distribution, prefix the name with d, just as in the example above. But you can compute only the probability that a random value will fall in an interval $[a,b]$, not the probability that it will equal a specific value. | 1 2 3 . | # For a normal random variable with mean μ=10 and standard deviation σ=5, # what is the probability of the value lying in the interval [12,13]? pnorm( 13, mean=10, sd=5 ) - pnorm( 12, mean=10, sd=5 ) . | . | 1 . | [1] 0.07032514 . | . Consequently, we can also compute: . | 1 2 . | pnorm( 13, mean=10, sd=5 ) # the probability of a value &lt; 13 1 - pnorm( 13, mean=10, sd=5 ) # the probability of a value &gt; 13 . | . | 1 2 3 4 5 . | [1] 0.7257469 [1] 0.2742531 . | . Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-probabilities-from-a-distribution/#solution-in-r",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution/#solution-in-r"
  },"256": {
    "doc": "How to compute probabilities from a distribution",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | . ",
    "url": "/how-to-compute-probabilities-from-a-distribution/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-probabilities-from-a-distribution/#topics-that-include-this-task"
  },"257": {
    "doc": "How to compute R-squared for a simple linear model (in Julia)",
    "title": "How to compute R-squared for a simple linear model (in Julia)",
    "content": "# How to compute R-squared for a simple linear model (in Julia) [See all solutions.](../how-to-compute-r-squared-for-a-simple-linear-model) ## Task Let's say we have fit a linear model to two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can we compute $R^2$ for that model, to measure its goodness of fit? Related tasks: * [How to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data) * [How to compute adjusted R-squared](../how-to-compute-adjusted-r-squared) ## Solution We assume you have already fit a linear model to the data, as in the code below, which is explained fully in a separate task, [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data). ```julia using GLM, DataFrames xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] data = DataFrame( xs=xs, ys=ys ) model = lm( @formula( ys ~ xs ), data ) ``` StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}} ys ~ 1 + xs Coefficients: ─────────────────────────────────────────────────────────────────────────── Coef. Std. Error t Pr(>|t|) Lower 95% Upper 95% ─────────────────────────────────────────────────────────────────────────── (Intercept) -37.3214 18.9954 -1.96 0.1066 -86.1508 11.5079 xs 0.13272 0.029589 4.49 0.0065 0.0566587 0.20878 ─────────────────────────────────────────────────────────────────────────── You can get the $R^2$ value from your model using the `r2` function in the GLM package. ```julia r2( model ) ``` 0.8009488239830588 Content last modified on 05 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute R-squared for a simple linear model/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model-in-julia/",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model-in-julia/"
  },"258": {
    "doc": "How to compute R-squared for a simple linear model (in Python, using SciPy)",
    "title": "How to compute R-squared for a simple linear model (in Python, using SciPy)",
    "content": "# How to compute R-squared for a simple linear model (in Python, using SciPy) [See all solutions.](../how-to-compute-r-squared-for-a-simple-linear-model) ## Task Let's say we have fit a linear model to two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can we compute $R^2$ for that model, to measure its goodness of fit? Related tasks: * [How to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data) * [How to compute adjusted R-squared](../how-to-compute-adjusted-r-squared) ## Solution We assume you have already fit a linear model to the data, as in the code below, which is explained fully in a separate task, [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data). ```python import scipy.stats as stats xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] model = stats.linregress( xs, ys ) ``` The $R$ value is part of the model object that `stats.linregress` returns. ```python model.rvalue ``` 0.8949574425541466 You can compute $R^2$ just by squaring it. ```python model.rvalue ** 2 ``` 0.8009488239830586 Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute R-squared for a simple linear model/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model-in-python-using-scipy/",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model-in-python-using-scipy/"
  },"259": {
    "doc": "How to compute R-squared for a simple linear model (in R)",
    "title": "How to compute R-squared for a simple linear model (in R)",
    "content": "# How to compute R-squared for a simple linear model (in R) [See all solutions.](../how-to-compute-r-squared-for-a-simple-linear-model) ## Task Let's say we have fit a linear model to two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can we compute $R^2$ for that model, to measure its goodness of fit? Related tasks: * [How to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data) * [How to compute adjusted R-squared](../how-to-compute-adjusted-r-squared) ## Solution We assume you have already fit a linear model to the data, as in the code below, which is explained fully in a separate task, [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data). ```R xs |t|) (Intercept) -37.32142 18.99544 -1.965 0.10664 xs 0.13272 0.02959 4.485 0.00649 ** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 11.62 on 5 degrees of freedom Multiple R-squared: 0.8009, Adjusted R-squared: 0.7611 F-statistic: 20.12 on 1 and 5 DF, p-value: 0.006486 In particular, it contains the $R^2$ value. ```R summary( model )$r.squared ``` [1] 0.8009488 Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute R-squared for a simple linear model/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model-in-r/",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model-in-r/"
  },"260": {
    "doc": "How to compute R-squared for a simple linear model",
    "title": "How to compute R-squared for a simple linear model",
    "content": " ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model/",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model/"
  },"261": {
    "doc": "How to compute R-squared for a simple linear model",
    "title": "Description",
    "content": "Let’s say we have fit a linear model to two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can we compute $R^2$ for that model, to measure its goodness of fit? . Related tasks: . | How to fit a linear model to two columns of data | How to compute adjusted R-squared | . ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model/#description",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model/#description"
  },"262": {
    "doc": "How to compute R-squared for a simple linear model",
    "title": "Solution, in Julia",
    "content": "View this solution alone. We assume you have already fit a linear model to the data, as in the code below, which is explained fully in a separate task, how to fit a linear model to two columns of data. | 1 2 3 4 5 . | using GLM, DataFrames xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] data = DataFrame( xs=xs, ys=ys ) model = lm( @formula( ys ~ xs ), data ) . | . | 1 2 3 4 5 6 7 8 9 10 11 . | StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}} ys ~ 1 + xs Coefficients: ─────────────────────────────────────────────────────────────────────────── Coef. Std. Error t Pr(&gt;|t|) Lower 95% Upper 95% ─────────────────────────────────────────────────────────────────────────── (Intercept) -37.3214 18.9954 -1.96 0.1066 -86.1508 11.5079 xs 0.13272 0.029589 4.49 0.0065 0.0566587 0.20878 ─────────────────────────────────────────────────────────────────────────── . | . You can get the $R^2$ value from your model using the r2 function in the GLM package. | 1 . | r2( model ) . | . | 1 . | 0.8009488239830588 . | . Content last modified on 05 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model/#solution-in-julia",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model/#solution-in-julia"
  },"263": {
    "doc": "How to compute R-squared for a simple linear model",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We assume you have already fit a linear model to the data, as in the code below, which is explained fully in a separate task, how to fit a linear model to two columns of data. | 1 2 3 4 . | import scipy.stats as stats xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] model = stats.linregress( xs, ys ) . | . The $R$ value is part of the model object that stats.linregress returns. | 1 . | model.rvalue . | . | 1 . | 0.8949574425541466 . | . You can compute $R^2$ just by squaring it. | 1 . | model.rvalue ** 2 . | . | 1 . | 0.8009488239830586 . | . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model/#using-scipy-in-python",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model/#using-scipy-in-python"
  },"264": {
    "doc": "How to compute R-squared for a simple linear model",
    "title": "Solution, in R",
    "content": "View this solution alone. We assume you have already fit a linear model to the data, as in the code below, which is explained fully in a separate task, how to fit a linear model to two columns of data. | 1 2 3 . | xs &lt;- c( 393, 453, 553, 679, 729, 748, 817 ) ys &lt;- c( 24, 25, 27, 36, 55, 68, 84 ) model &lt;- lm( ys ~ xs ) . | . You can get a lot of information about your model from its summary. | 1 . | summary( model ) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | Call: lm(formula = ys ~ xs) Residuals: 1 2 3 4 5 6 7 9.163 2.199 -9.072 -16.795 -4.431 6.047 12.890 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -37.32142 18.99544 -1.965 0.10664 xs 0.13272 0.02959 4.485 0.00649 ** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 11.62 on 5 degrees of freedom Multiple R-squared: 0.8009, Adjusted R-squared: 0.7611 F-statistic: 20.12 on 1 and 5 DF, p-value: 0.006486 . | . In particular, it contains the $R^2$ value. | 1 . | summary( model )$r.squared . | . | 1 . | [1] 0.8009488 . | . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model/#solution-in-r",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model/#solution-in-r"
  },"265": {
    "doc": "How to compute R-squared for a simple linear model",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | Bentley University MA214 | Bentley University MA252 | . ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model/#topics-that-include-this-task"
  },"266": {
    "doc": "How to compute R-squared for a simple linear model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-r-squared-for-a-simple-linear-model/#opportunities",
    "relUrl": "/how-to-compute-r-squared-for-a-simple-linear-model/#opportunities"
  },"267": {
    "doc": "How to compute summary statistics (in Excel)",
    "title": "How to compute summary statistics (in Excel)",
    "content": "# How to compute summary statistics (in Excel) [See all solutions.](../how-to-compute-summary-statistics) ## Task The phrase \"summary statistics\" usually refers to a common set of simple computations that can be done about any dataset, including mean, median, variance, and some of the others shown below. Related tasks: * [How to summarize a column](../how-to-summarize-a-column) * [How to summarize and compare data by groups](../how-to-summarize-and-compare-data-by-groups) ## Solution Let’s assume you have some data in an Excel workbook. We show the first 10 rows the famous example dataset “iris” below, but we assume you are applying what we cover here to your own real data. To compute descriptive statistics, you will need the Data Analysis Toolpak. If you’ve never enabled it before, see [these instructions from Microsoft](https://support.microsoft.com/en-us/office/load-the-analysis-toolpak-in-excel-6a63e598-cd6d-42e3-9317-6b40ba1a66b4#OfficeVersion=Windows) on how to do so. On the Data tab, click the Data Analysis button, shown below. From the list of tools it provides, choose Descriptive Statistics, as shown below, then click OK. Highlight as input *only the numeric columns in your data,* because the Data Analysis Toolpak cannot summarize other kinds of input. (Do not include column headers in your selection.) Then check the “Summary statistics” checkbox, as shown below. Then click OK. Excel will create a new sheet that reports the mean, median, variance, and more, for each column, as shown below. To get a report of the unique values in your column and the frequency of each, you can use a pivot table. Place your cursor anywhere in your data, then on the Insert tab, choose Pivot Table, as shown below. Drag any column’s name from the list of pivot table fields down into both the Rows and Values areas, as shown below. If the column is numeric, then in the drop-down under Values, choose “Value field settings…” and change Sum to Count, then click OK. This is not necessary for non-numeric columns. (See [how to summarize a column](../how-to-summarize-a-column) for an example.) Your pivot table will now contain the desired report. In the iris dataset used in this example, there were precisely 50 observations of each variety. Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute summary statistics/Excel.docx). ",
    "url": "/how-to-compute-summary-statistics-in-excel/",
    "relUrl": "/how-to-compute-summary-statistics-in-excel/"
  },"268": {
    "doc": "How to compute summary statistics (in Julia)",
    "title": "How to compute summary statistics (in Julia)",
    "content": "# How to compute summary statistics (in Julia) [See all solutions.](../how-to-compute-summary-statistics) ## Task The phrase \"summary statistics\" usually refers to a common set of simple computations that can be done about any dataset, including mean, median, variance, and some of the others shown below. Related tasks: * [How to summarize a column](../how-to-summarize-a-column) * [How to summarize and compare data by groups](../how-to-summarize-and-compare-data-by-groups) ## Solution We first load a famous dataset, Fisher's irises, just to have some example data to use in the code that follows. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```julia using RDatasets iris = dataset( \"datasets\", \"iris\" ); ``` How big is the dataset? The output shows number of rows then number of columns. ```julia size( iris ) ``` (150, 5) What are the columns and their data types? The following command shows the first 5 rows, plus the column names and types. ```julia first( iris, 5 ) ``` 5×5 DataFrame | Row | SepalLength | SepalWidth | PetalLength | PetalWidth | Species | . | | Float64 | Float64 | Float64 | Float64 | Cat… | . | 1 | 5.1 | 3.5 | 1.4 | 0.2 | setosa | . | 2 | 4.9 | 3.0 | 1.4 | 0.2 | setosa | . | 3 | 4.7 | 3.2 | 1.3 | 0.2 | setosa | . | 4 | 4.6 | 3.1 | 1.5 | 0.2 | setosa | . | 5 | 5.0 | 3.6 | 1.4 | 0.2 | setosa | . Are any values missing? The following command answers that question, plus provides summary statistics, and the same data type information from above. ```julia describe( iris ) ``` 5×7 DataFrame | Row | variable | mean | min | median | max | nmissing | eltype | . | | Symbol | Union… | Any | Union… | Any | Int64 | DataType | . | 1 | SepalLength | 5.84333 | 4.3 | 5.8 | 7.9 | 0 | Float64 | . | 2 | SepalWidth | 3.05733 | 2.0 | 3.0 | 4.4 | 0 | Float64 | . | 3 | PetalLength | 3.758 | 1.0 | 4.35 | 6.9 | 0 | Float64 | . | 4 | PetalWidth | 1.19933 | 0.1 | 1.3 | 2.5 | 0 | Float64 | . | 5 | Species | | setosa | | virginica | 0 | CategoricalValue{String, UInt8} | . The individual statistics are the column headings, and the numeric columns from the original dataset are listed under the \"Symbol\" heading. We can also compute these statistics (and others) one at a time for any given set of data points. Here, we let `xs` be one column from the above DataFrame, but you could use any array or DataFrame instead. ~~~julia xs = iris.\"SepalLength\" using Statistics mean( xs ) # mean, or average, or center of mass median( xs ) # 50th percentile quantile!( xs, 0.25 ) # compute any percentile, such as the 25th var( xs ) # variance std( xs ) # standard deviation, the square root of the variance sort( xs ) # data in increasing order sum( xs ) # sum, or total ~~~ Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute summary statistics/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-summary-statistics-in-julia/",
    "relUrl": "/how-to-compute-summary-statistics-in-julia/"
  },"269": {
    "doc": "How to compute summary statistics (in Python, using pandas and NumPy)",
    "title": "How to compute summary statistics (in Python, using pandas and NumPy)",
    "content": "# How to compute summary statistics (in Python, using pandas and NumPy) [See all solutions.](../how-to-compute-summary-statistics) ## Task The phrase \"summary statistics\" usually refers to a common set of simple computations that can be done about any dataset, including mean, median, variance, and some of the others shown below. Related tasks: * [How to summarize a column](../how-to-summarize-a-column) * [How to summarize and compare data by groups](../how-to-summarize-and-compare-data-by-groups) ## Solution We first load a famous dataset, Fisher's irises, just to have some example data to use in the code that follows. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data( 'iris' ) ``` How big is the dataset? The output shows number of rows then number of columns. ```python df.shape ``` (150, 5) What are the columns and their data types? Are any values missing? ```python df.info() ``` RangeIndex: 150 entries, 0 to 149 Data columns (total 5 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Sepal.Length 150 non-null float64 1 Sepal.Width 150 non-null float64 2 Petal.Length 150 non-null float64 3 Petal.Width 150 non-null float64 4 Species 150 non-null object dtypes: float64(4), object(1) memory usage: 6.0+ KB What do the first few rows look like? ```python df.head() # Default is 5, but you can do df.head(20) or any number. ``` | | Sepal.Length | Sepal.Width | Petal.Length | Petal.Width | Species | . | 0 | 5.1 | 3.5 | 1.4 | 0.2 | setosa | . | 1 | 4.9 | 3.0 | 1.4 | 0.2 | setosa | . | 2 | 4.7 | 3.2 | 1.3 | 0.2 | setosa | . | 3 | 4.6 | 3.1 | 1.5 | 0.2 | setosa | . | 4 | 5.0 | 3.6 | 1.4 | 0.2 | setosa | . The easiest way to get summary statistics for a pandas DataFrame is with the `describe` function. ```python df.describe() ``` | | Sepal.Length | Sepal.Width | Petal.Length | Petal.Width | . | count | 150.000000 | 150.000000 | 150.000000 | 150.000000 | . | mean | 5.843333 | 3.057333 | 3.758000 | 1.199333 | . | std | 0.828066 | 0.435866 | 1.765298 | 0.762238 | . | min | 4.300000 | 2.000000 | 1.000000 | 0.100000 | . | 25% | 5.100000 | 2.800000 | 1.600000 | 0.300000 | . | 50% | 5.800000 | 3.000000 | 4.350000 | 1.300000 | . | 75% | 6.400000 | 3.300000 | 5.100000 | 1.800000 | . | max | 7.900000 | 4.400000 | 6.900000 | 2.500000 | . The individual statistics are the row headings, and the numeric columns from the original dataset are listed across the top. We can also compute these statistics (and others) one at a time for any given set of data points. Here, we let `xs` be one column from the above DataFrame, but you could use any NumPy array or pandas DataFrame instead. ~~~python xs = df['Sepal.Length'] import numpy as np np.mean( xs ) # mean, or average, or center of mass np.median( xs ) # 50th percentile np.percentile( xs, 25 ) # compute any percentile, such as the 25th np.var( xs ) # variance np.std( xs ) # standard deviation, the square root of the variance np.sort( xs ) # data in increasing order np.sum( xs ) # sum, or total ~~~ Content last modified on 26 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute summary statistics/Python, using pandas and NumPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-summary-statistics-in-python-using-pandas-and-numpy/",
    "relUrl": "/how-to-compute-summary-statistics-in-python-using-pandas-and-numpy/"
  },"270": {
    "doc": "How to compute summary statistics (in R)",
    "title": "How to compute summary statistics (in R)",
    "content": "# How to compute summary statistics (in R) [See all solutions.](../how-to-compute-summary-statistics) ## Task The phrase \"summary statistics\" usually refers to a common set of simple computations that can be done about any dataset, including mean, median, variance, and some of the others shown below. Related tasks: * [How to summarize a column](../how-to-summarize-a-column) * [How to summarize and compare data by groups](../how-to-summarize-and-compare-data-by-groups) ## Solution We first load a famous dataset, Fisher's irises, just to have some example data to use in the code that follows. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R library(datasets) data(iris) ``` How big is the dataset? The output shows number of rows then number of columns. ```R dim(iris) # Short for \"dimensions.\" ``` [1] 150 5 What are the columns and their data types? Can I see a sample of each column? ```R str(iris) # Short for \"structure.\" ``` 'data.frame': 150 obs. of 5 variables: $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... $ Species : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ... What do the first few rows look like? ```R head(iris) # Gives 5 rows by default. You can do head(iris,10), etc. ``` Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa The easiest way to get summary statistics for an R `data.frame` is with the `summary` function. ```R summary(iris) ``` Sepal.Length Sepal.Width Petal.Length Petal.Width Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 Median :5.800 Median :3.000 Median :4.350 Median :1.300 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 Species setosa :50 versicolor:50 virginica :50 The columns from the original dataset are the column headings in the summary output, and the statistics computed for each are listed below those headings. We can also compute these statistics (and others) one at a time for any given set of data points. Here, we let `xs` be one column from the above `data.frame` but you could use any vector or list. ``` xs <- iris$Sepal.Length mean( xs ) # mean, or average, or center of mass median( xs ) # 50th percentile quantile( xs, 0.25 ) # compute any percentile, such as the 25th var( xs ) # variance sd( xs ) # standard deviation, the square root of the variance sort( xs ) # data in increasing order sum( xs ) # sum, or total ``` Content last modified on 26 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute summary statistics/R.Rmd). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-summary-statistics-in-r/",
    "relUrl": "/how-to-compute-summary-statistics-in-r/"
  },"271": {
    "doc": "How to compute summary statistics",
    "title": "How to compute summary statistics",
    "content": " ",
    "url": "/how-to-compute-summary-statistics/",
    "relUrl": "/how-to-compute-summary-statistics/"
  },"272": {
    "doc": "How to compute summary statistics",
    "title": "Description",
    "content": "The phrase “summary statistics” usually refers to a common set of simple computations that can be done about any dataset, including mean, median, variance, and some of the others shown below. Related tasks: . | How to summarize a column | How to summarize and compare data by groups | . ",
    "url": "/how-to-compute-summary-statistics/#description",
    "relUrl": "/how-to-compute-summary-statistics/#description"
  },"273": {
    "doc": "How to compute summary statistics",
    "title": "Solution, in Excel",
    "content": "View this solution alone. Let’s assume you have some data in an Excel workbook. We show the first 10 rows the famous example dataset “iris” below, but we assume you are applying what we cover here to your own real data. To compute descriptive statistics, you will need the Data Analysis Toolpak. If you’ve never enabled it before, see these instructions from Microsoft on how to do so. On the Data tab, click the Data Analysis button, shown below. From the list of tools it provides, choose Descriptive Statistics, as shown below, then click OK. Highlight as input only the numeric columns in your data, because the Data Analysis Toolpak cannot summarize other kinds of input. (Do not include column headers in your selection.) Then check the “Summary statistics” checkbox, as shown below. Then click OK. Excel will create a new sheet that reports the mean, median, variance, and more, for each column, as shown below. To get a report of the unique values in your column and the frequency of each, you can use a pivot table. Place your cursor anywhere in your data, then on the Insert tab, choose Pivot Table, as shown below. Drag any column’s name from the list of pivot table fields down into both the Rows and Values areas, as shown below. If the column is numeric, then in the drop-down under Values, choose “Value field settings…” and change Sum to Count, then click OK. This is not necessary for non-numeric columns. (See how to summarize a column for an example.) . Your pivot table will now contain the desired report. In the iris dataset used in this example, there were precisely 50 observations of each variety. Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-summary-statistics/#solution-in-excel",
    "relUrl": "/how-to-compute-summary-statistics/#solution-in-excel"
  },"274": {
    "doc": "How to compute summary statistics",
    "title": "Solution, in Julia",
    "content": "View this solution alone. We first load a famous dataset, Fisher’s irises, just to have some example data to use in the code that follows. (See how to quickly load some sample data.) . | 1 2 . | using RDatasets iris = dataset( \"datasets\", \"iris\" ); . | . How big is the dataset? The output shows number of rows then number of columns. | 1 . | size( iris ) . | . | 1 . | (150, 5) . | . What are the columns and their data types? The following command shows the first 5 rows, plus the column names and types. | 1 . | first( iris, 5 ) . | . 5×5 DataFrame | Row | SepalLength | SepalWidth | PetalLength | PetalWidth | Species | . | | Float64 | Float64 | Float64 | Float64 | Cat… | . | 1 | 5.1 | 3.5 | 1.4 | 0.2 | setosa | . | 2 | 4.9 | 3.0 | 1.4 | 0.2 | setosa | . | 3 | 4.7 | 3.2 | 1.3 | 0.2 | setosa | . | 4 | 4.6 | 3.1 | 1.5 | 0.2 | setosa | . | 5 | 5.0 | 3.6 | 1.4 | 0.2 | setosa | . Are any values missing? The following command answers that question, plus provides summary statistics, and the same data type information from above. | 1 . | describe( iris ) . | . 5×7 DataFrame | Row | variable | mean | min | median | max | nmissing | eltype | . | | Symbol | Union… | Any | Union… | Any | Int64 | DataType | . | 1 | SepalLength | 5.84333 | 4.3 | 5.8 | 7.9 | 0 | Float64 | . | 2 | SepalWidth | 3.05733 | 2.0 | 3.0 | 4.4 | 0 | Float64 | . | 3 | PetalLength | 3.758 | 1.0 | 4.35 | 6.9 | 0 | Float64 | . | 4 | PetalWidth | 1.19933 | 0.1 | 1.3 | 2.5 | 0 | Float64 | . | 5 | Species | | setosa | | virginica | 0 | CategoricalValue{String, UInt8} | . The individual statistics are the column headings, and the numeric columns from the original dataset are listed under the “Symbol” heading. We can also compute these statistics (and others) one at a time for any given set of data points. Here, we let xs be one column from the above DataFrame, but you could use any array or DataFrame instead. | 1 2 3 4 5 6 7 8 9 10 11 . | xs = iris.\"SepalLength\" using Statistics mean( xs ) # mean, or average, or center of mass median( xs ) # 50th percentile quantile!( xs, 0.25 ) # compute any percentile, such as the 25th var( xs ) # variance std( xs ) # standard deviation, the square root of the variance sort( xs ) # data in increasing order sum( xs ) # sum, or total . | . Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-summary-statistics/#solution-in-julia",
    "relUrl": "/how-to-compute-summary-statistics/#solution-in-julia"
  },"275": {
    "doc": "How to compute summary statistics",
    "title": "Using pandas and NumPy, in Python",
    "content": "View this solution alone. We first load a famous dataset, Fisher’s irises, just to have some example data to use in the code that follows. (See how to quickly load some sample data.) . | 1 2 . | from rdatasets import data df = data( 'iris' ) . | . How big is the dataset? The output shows number of rows then number of columns. | 1 . | df.shape . | . | 1 . | (150, 5) . | . What are the columns and their data types? Are any values missing? . | 1 . | df.info() . | . | 1 2 3 4 5 6 7 8 9 10 11 12 . | &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 150 entries, 0 to 149 Data columns (total 5 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Sepal.Length 150 non-null float64 1 Sepal.Width 150 non-null float64 2 Petal.Length 150 non-null float64 3 Petal.Width 150 non-null float64 4 Species 150 non-null object dtypes: float64(4), object(1) memory usage: 6.0+ KB . | . What do the first few rows look like? . | 1 . | df.head() # Default is 5, but you can do df.head(20) or any number. | . | | Sepal.Length | Sepal.Width | Petal.Length | Petal.Width | Species | . | 0 | 5.1 | 3.5 | 1.4 | 0.2 | setosa | . | 1 | 4.9 | 3.0 | 1.4 | 0.2 | setosa | . | 2 | 4.7 | 3.2 | 1.3 | 0.2 | setosa | . | 3 | 4.6 | 3.1 | 1.5 | 0.2 | setosa | . | 4 | 5.0 | 3.6 | 1.4 | 0.2 | setosa | . The easiest way to get summary statistics for a pandas DataFrame is with the describe function. | 1 . | df.describe() . | . | | Sepal.Length | Sepal.Width | Petal.Length | Petal.Width | . | count | 150.000000 | 150.000000 | 150.000000 | 150.000000 | . | mean | 5.843333 | 3.057333 | 3.758000 | 1.199333 | . | std | 0.828066 | 0.435866 | 1.765298 | 0.762238 | . | min | 4.300000 | 2.000000 | 1.000000 | 0.100000 | . | 25% | 5.100000 | 2.800000 | 1.600000 | 0.300000 | . | 50% | 5.800000 | 3.000000 | 4.350000 | 1.300000 | . | 75% | 6.400000 | 3.300000 | 5.100000 | 1.800000 | . | max | 7.900000 | 4.400000 | 6.900000 | 2.500000 | . The individual statistics are the row headings, and the numeric columns from the original dataset are listed across the top. We can also compute these statistics (and others) one at a time for any given set of data points. Here, we let xs be one column from the above DataFrame, but you could use any NumPy array or pandas DataFrame instead. | 1 2 3 4 5 6 7 8 9 10 11 . | xs = df['Sepal.Length'] import numpy as np np.mean( xs ) # mean, or average, or center of mass np.median( xs ) # 50th percentile np.percentile( xs, 25 ) # compute any percentile, such as the 25th np.var( xs ) # variance np.std( xs ) # standard deviation, the square root of the variance np.sort( xs ) # data in increasing order np.sum( xs ) # sum, or total . | . Content last modified on 26 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-summary-statistics/#using-pandas-and-numpy-in-python",
    "relUrl": "/how-to-compute-summary-statistics/#using-pandas-and-numpy-in-python"
  },"276": {
    "doc": "How to compute summary statistics",
    "title": "Solution, in R",
    "content": "View this solution alone. We first load a famous dataset, Fisher’s irises, just to have some example data to use in the code that follows. (See how to quickly load some sample data.) . | 1 2 . | library(datasets) data(iris) . | . How big is the dataset? The output shows number of rows then number of columns. | 1 . | dim(iris) # Short for \"dimensions.\" . | . | 1 . | [1] 150 5 . | . What are the columns and their data types? Can I see a sample of each column? . | 1 . | str(iris) # Short for \"structure.\" . | . | 1 2 3 4 5 6 . | 'data.frame': 150 obs. of 5 variables: $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... $ Species : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ... | . What do the first few rows look like? . | 1 . | head(iris) # Gives 5 rows by default. You can do head(iris,10), etc. | . | 1 2 3 4 5 6 7 . | Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa . | . The easiest way to get summary statistics for an R data.frame is with the summary function. | 1 . | summary(iris) . | . | 1 2 3 4 5 6 7 8 9 10 11 . | Sepal.Length Sepal.Width Petal.Length Petal.Width Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 Median :5.800 Median :3.000 Median :4.350 Median :1.300 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 Species setosa :50 versicolor:50 virginica :50 . | . The columns from the original dataset are the column headings in the summary output, and the statistics computed for each are listed below those headings. We can also compute these statistics (and others) one at a time for any given set of data points. Here, we let xs be one column from the above data.frame but you could use any vector or list. | 1 2 3 4 5 6 7 8 9 . | xs &lt;- iris$Sepal.Length mean( xs ) # mean, or average, or center of mass median( xs ) # 50th percentile quantile( xs, 0.25 ) # compute any percentile, such as the 25th var( xs ) # variance sd( xs ) # standard deviation, the square root of the variance sort( xs ) # data in increasing order sum( xs ) # sum, or total . | . Content last modified on 26 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-summary-statistics/#solution-in-r",
    "relUrl": "/how-to-compute-summary-statistics/#solution-in-r"
  },"277": {
    "doc": "How to compute summary statistics",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | Bentley University MA255 | Bentley University MA346 | . ",
    "url": "/how-to-compute-summary-statistics/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-summary-statistics/#topics-that-include-this-task"
  },"278": {
    "doc": "How to compute the derivative of a function (in Python, using SymPy)",
    "title": "How to compute the derivative of a function (in Python, using SymPy)",
    "content": "# How to compute the derivative of a function (in Python, using SymPy) [See all solutions.](../how-to-compute-the-derivative-of-a-function) ## Task Given a mathematical function $f(x)$, we write $f'(x)$ or $\\frac{d}{dx}f(x)$ to represent its derivative, or the rate of change of $f$ with respect to $x$. How can we compute $f'(x)$ using mathematical software? ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` In SymPy, we tend to work with formulas (that is, mathematical expressions) rather than functions (like $f(x)$). So if we wish to compute the derivative of $f(x)=10x^2-16x+1$, we will focus on just the $10x^2-16x+1$ portion. ```python var( 'x' ) formula = 10*x**2 - 16*x + 1 formula ``` $\\displaystyle 10 x^{2} - 16 x + 1$ We can compute its derivative by using the `diff` function. ```python diff( formula ) ``` $\\displaystyle 20 x - 16$ If it had been a multi-variable function, we would need to specify the variable with respect to which we wanted to compute a derivative. ```python var( 'y' ) # introduce a new variable formula2 = x**2 - y**2 # consider the formula x^2 + y^2 diff( formula2, y ) # differentiate with respect to y ``` $\\displaystyle - 2 y$ We can compute second or third derivatives by repeating the variable with respect to which we're differentiating. To do partial derivatives, use multiple variables. ```python diff( formula, x, x ) # second derivative with respect to x ``` $\\displaystyle 20$ ```python diff( formula2, x, y ) # mixed partial derivative ``` $\\displaystyle 0$ Content last modified on 31 August 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the derivative of a function/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-the-derivative-of-a-function-in-python-using-sympy/",
    "relUrl": "/how-to-compute-the-derivative-of-a-function-in-python-using-sympy/"
  },"279": {
    "doc": "How to compute the derivative of a function (in R)",
    "title": "How to compute the derivative of a function (in R)",
    "content": "# How to compute the derivative of a function (in R) [See all solutions.](../how-to-compute-the-derivative-of-a-function) ## Task Given a mathematical function $f(x)$, we write $f'(x)$ or $\\frac{d}{dx}f(x)$ to represent its derivative, or the rate of change of $f$ with respect to $x$. How can we compute $f'(x)$ using mathematical software? ## Solution Let's consider the function $f(x)=10x^2-16x+1$. We focus not on the whole function, but just the expression on the right-hand side, $10x^2-16x+1$. ```R formula <- expression( 10*x^2 - 16*x + 1 ) ``` We can compute its derivative using the `D` function. ```R D( formula, \"x\" ) # derivative with respect to x ``` 10 * (2 * x) - 16 R does not simplify the output, but if we do so ourselves, we find that $f'(x)=20x-16$. If it had been a multi-variable function, we would need to specify the variable with respect to which we wanted to compute a derivative. ```R formula2 <- expression( x^2-y^2 ) # consider the formula x^2 - y^2 D( formula2, \"y\" ) # differentiate with respect to y ``` -(2 * y) That output says that $\\frac{\\partial}{\\partial y}(x^2-y^2)=-2y$. We can compute the second derivative by using the `D` function twice and specifying the variables with respect to which we are computing the derivative. ```R D( D( formula2, \"x\" ), \"x\" ) # second derivative with respect to x ``` [1] 2 ```R D( D( formula2, \"x\" ), \"y\" ) # mixed partial derivative ``` [1] 0 Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the derivative of a function/R.Rmd). Contributed by Debayan Sen (DSEN@bentley.edu) ",
    "url": "/how-to-compute-the-derivative-of-a-function-in-r/",
    "relUrl": "/how-to-compute-the-derivative-of-a-function-in-r/"
  },"280": {
    "doc": "How to compute the derivative of a function",
    "title": "How to compute the derivative of a function",
    "content": " ",
    "url": "/how-to-compute-the-derivative-of-a-function/",
    "relUrl": "/how-to-compute-the-derivative-of-a-function/"
  },"281": {
    "doc": "How to compute the derivative of a function",
    "title": "Description",
    "content": "Given a mathematical function $f(x)$, we write $f’(x)$ or $\\frac{d}{dx}f(x)$ to represent its derivative, or the rate of change of $f$ with respect to $x$. How can we compute $f’(x)$ using mathematical software? . ",
    "url": "/how-to-compute-the-derivative-of-a-function/#description",
    "relUrl": "/how-to-compute-the-derivative-of-a-function/#description"
  },"282": {
    "doc": "How to compute the derivative of a function",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . In SymPy, we tend to work with formulas (that is, mathematical expressions) rather than functions (like $f(x)$). So if we wish to compute the derivative of $f(x)=10x^2-16x+1$, we will focus on just the $10x^2-16x+1$ portion. | 1 2 3 . | var( 'x' ) formula = 10*x**2 - 16*x + 1 formula . | . $\\displaystyle 10 x^{2} - 16 x + 1$ . We can compute its derivative by using the diff function. | 1 . | diff( formula ) . | . $\\displaystyle 20 x - 16$ . If it had been a multi-variable function, we would need to specify the variable with respect to which we wanted to compute a derivative. | 1 2 3 . | var( 'y' ) # introduce a new variable formula2 = x**2 - y**2 # consider the formula x^2 + y^2 diff( formula2, y ) # differentiate with respect to y . | . $\\displaystyle - 2 y$ . We can compute second or third derivatives by repeating the variable with respect to which we’re differentiating. To do partial derivatives, use multiple variables. | 1 . | diff( formula, x, x ) # second derivative with respect to x . | . $\\displaystyle 20$ . | 1 . | diff( formula2, x, y ) # mixed partial derivative . | . $\\displaystyle 0$ . Content last modified on 31 August 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-derivative-of-a-function/#using-sympy-in-python",
    "relUrl": "/how-to-compute-the-derivative-of-a-function/#using-sympy-in-python"
  },"283": {
    "doc": "How to compute the derivative of a function",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s consider the function $f(x)=10x^2-16x+1$. We focus not on the whole function, but just the expression on the right-hand side, $10x^2-16x+1$. | 1 . | formula &lt;- expression( 10*x^2 - 16*x + 1 ) . | . We can compute its derivative using the D function. | 1 . | D( formula, \"x\" ) # derivative with respect to x . | . | 1 . | 10 * (2 * x) - 16 . | . R does not simplify the output, but if we do so ourselves, we find that $f’(x)=20x-16$. If it had been a multi-variable function, we would need to specify the variable with respect to which we wanted to compute a derivative. | 1 2 . | formula2 &lt;- expression( x^2-y^2 ) # consider the formula x^2 - y^2 D( formula2, \"y\" ) # differentiate with respect to y . | . | 1 . | -(2 * y) . | . That output says that $\\frac{\\partial}{\\partial y}(x^2-y^2)=-2y$. We can compute the second derivative by using the D function twice and specifying the variables with respect to which we are computing the derivative. | 1 . | D( D( formula2, \"x\" ), \"x\" ) # second derivative with respect to x . | . | 1 . | [1] 2 . | . | 1 . | D( D( formula2, \"x\" ), \"y\" ) # mixed partial derivative . | . | 1 . | [1] 0 . | . Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-derivative-of-a-function/#solution-in-r",
    "relUrl": "/how-to-compute-the-derivative-of-a-function/#solution-in-r"
  },"284": {
    "doc": "How to compute the derivative of a function",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-compute-the-derivative-of-a-function/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-the-derivative-of-a-function/#topics-that-include-this-task"
  },"285": {
    "doc": "How to compute the derivative of a function",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-the-derivative-of-a-function/#opportunities",
    "relUrl": "/how-to-compute-the-derivative-of-a-function/#opportunities"
  },"286": {
    "doc": "How to compute the domain of a function (in Python, using SymPy)",
    "title": "How to compute the domain of a function (in Python, using SymPy)",
    "content": "# How to compute the domain of a function (in Python, using SymPy) [See all solutions.](../how-to-compute-the-domain-of-a-function) ## Task Given a mathematical function $f(x)$, we often want to know the set of $x$ values for which the function is defined. That set is called its domain. How can we compute the domain of $f(x)$ using mathematical software? ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` We also need to import another tool that SymPy doesn't pull in by default. ```python from sympy.calculus.util import continuous_domain ``` We can then ask about a function's domain. We provide the function, the variable we're asking about, and the set of numbers we're working inside of. For a simple one-variable function, we're typically working in just the real numbers. ```python var( 'x' ) formula = 1 / ( x + 1 ) continuous_domain( formula, x, S.Reals ) ``` $\\displaystyle \\left(-\\infty, -1\\right) \\cup \\left(-1, \\infty\\right)$ It's sometimes easier to instead ask where the function is *not* defined. We can just ask for the complement of the domain. ```python domain = continuous_domain( formula, x, S.Reals ) Complement( S.Reals, domain ) ``` $\\displaystyle \\left\\\\{-1\\right\\\\}$ The function is *undefined* only at $x=-1$. Content last modified on 13 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the domain of a function/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-the-domain-of-a-function-in-python-using-sympy/",
    "relUrl": "/how-to-compute-the-domain-of-a-function-in-python-using-sympy/"
  },"287": {
    "doc": "How to compute the domain of a function",
    "title": "How to compute the domain of a function",
    "content": " ",
    "url": "/how-to-compute-the-domain-of-a-function/",
    "relUrl": "/how-to-compute-the-domain-of-a-function/"
  },"288": {
    "doc": "How to compute the domain of a function",
    "title": "Description",
    "content": "Given a mathematical function $f(x)$, we often want to know the set of $x$ values for which the function is defined. That set is called its domain. How can we compute the domain of $f(x)$ using mathematical software? . ",
    "url": "/how-to-compute-the-domain-of-a-function/#description",
    "relUrl": "/how-to-compute-the-domain-of-a-function/#description"
  },"289": {
    "doc": "How to compute the domain of a function",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . We also need to import another tool that SymPy doesn’t pull in by default. | 1 . | from sympy.calculus.util import continuous_domain . | . We can then ask about a function’s domain. We provide the function, the variable we’re asking about, and the set of numbers we’re working inside of. For a simple one-variable function, we’re typically working in just the real numbers. | 1 2 3 . | var( 'x' ) formula = 1 / ( x + 1 ) continuous_domain( formula, x, S.Reals ) . | . $\\displaystyle \\left(-\\infty, -1\\right) \\cup \\left(-1, \\infty\\right)$ . It’s sometimes easier to instead ask where the function is not defined. We can just ask for the complement of the domain. | 1 2 . | domain = continuous_domain( formula, x, S.Reals ) Complement( S.Reals, domain ) . | . $\\displaystyle \\left\\{-1\\right\\}$ . The function is undefined only at $x=-1$. Content last modified on 13 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-domain-of-a-function/#using-sympy-in-python",
    "relUrl": "/how-to-compute-the-domain-of-a-function/#using-sympy-in-python"
  },"290": {
    "doc": "How to compute the domain of a function",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-compute-the-domain-of-a-function/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-the-domain-of-a-function/#topics-that-include-this-task"
  },"291": {
    "doc": "How to compute the domain of a function",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-the-domain-of-a-function/#opportunities",
    "relUrl": "/how-to-compute-the-domain-of-a-function/#opportunities"
  },"292": {
    "doc": "How to compute the error bounds on a Taylor approximation (in Python, using SymPy)",
    "title": "How to compute the error bounds on a Taylor approximation (in Python, using SymPy)",
    "content": "# How to compute the error bounds on a Taylor approximation (in Python, using SymPy) [See all solutions.](../how-to-compute-the-error-bounds-on-a-taylor-approximation) ## Task A Taylor series approximation of degree $n$ to the function $f(x)$, centered at the point $x=a$, has an error bounded by the following formula, where $c$ ranges over all points between $x=a$ and the point $x=x_0$ at which we will be applying the approximation. $$ \\frac{|x_0-a|^{n+1}}{(n+1)!}\\max|f^{(n+1)}(c)| $$ How can we compute this error bound using mathematical software? Related tasks: * [How to compute the Taylor series for a function](../how-to-compute-the-taylor-series-for-a-function) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's create a simple example. We'll be approximating $f(x)=\\sin x$ centered at $a=0$ with a Taylor series of degree $n=5$. We will be applying our approximation at $x_0=1$. What is the error bound? ```python var( 'x' ) formula = sin(x) a = 0 x_0 = 1 n = 5 ``` We will not ask SymPy to compute the formula exactly, but will instead have it sample a large number of $c$ values from the interval in question, and compute the maximum over those samples. (The exact solution can be too hard for SymPy to compute.) ```python # Get 1000 evenly-spaced c values: cs = [ Min(x_0,a) + abs(x_0-a)*i/1000 for i in range(1001) ] # Create the formula |f^(n+1)(x)|: formula2 = abs( diff( formula, x, n+1 ) ) # Find the max of it on all the 1000 values: m = Max( *[ formula2.subs(x,c) for c in cs ] ) # Compute the error bound: N( abs(x_0-a)**(n+1) / factorial(n+1) * m ) ``` $\\displaystyle 0.00116870970112208$ The error is at most $0.00116871\\ldots$. Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the error bounds on a Taylor approximation/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-the-error-bounds-on-a-taylor-approximation-in-python-using-sympy/",
    "relUrl": "/how-to-compute-the-error-bounds-on-a-taylor-approximation-in-python-using-sympy/"
  },"293": {
    "doc": "How to compute the error bounds on a Taylor approximation",
    "title": "How to compute the error bounds on a Taylor approximation",
    "content": " ",
    "url": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/",
    "relUrl": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/"
  },"294": {
    "doc": "How to compute the error bounds on a Taylor approximation",
    "title": "Description",
    "content": "A Taylor series approximation of degree $n$ to the function $f(x)$, centered at the point $x=a$, has an error bounded by the following formula, where $c$ ranges over all points between $x=a$ and the point $x=x_0$ at which we will be applying the approximation. \\[\\frac{|x_0-a|^{n+1}}{(n+1)!}\\max|f^{(n+1)}(c)|\\] How can we compute this error bound using mathematical software? . Related tasks: . | How to compute the Taylor series for a function | . ",
    "url": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/#description",
    "relUrl": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/#description"
  },"295": {
    "doc": "How to compute the error bounds on a Taylor approximation",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s create a simple example. We’ll be approximating $f(x)=\\sin x$ centered at $a=0$ with a Taylor series of degree $n=5$. We will be applying our approximation at $x_0=1$. What is the error bound? . | 1 2 3 4 5 . | var( 'x' ) formula = sin(x) a = 0 x_0 = 1 n = 5 . | . We will not ask SymPy to compute the formula exactly, but will instead have it sample a large number of $c$ values from the interval in question, and compute the maximum over those samples. (The exact solution can be too hard for SymPy to compute.) . | 1 2 3 4 5 6 7 8 . | # Get 1000 evenly-spaced c values: cs = [ Min(x_0,a) + abs(x_0-a)*i/1000 for i in range(1001) ] # Create the formula |f^(n+1)(x)|: formula2 = abs( diff( formula, x, n+1 ) ) # Find the max of it on all the 1000 values: m = Max( *[ formula2.subs(x,c) for c in cs ] ) # Compute the error bound: N( abs(x_0-a)**(n+1) / factorial(n+1) * m ) . | . $\\displaystyle 0.00116870970112208$ . The error is at most $0.00116871\\ldots$. Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/#using-sympy-in-python",
    "relUrl": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/#using-sympy-in-python"
  },"296": {
    "doc": "How to compute the error bounds on a Taylor approximation",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/#topics-that-include-this-task"
  },"297": {
    "doc": "How to compute the error bounds on a Taylor approximation",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/#opportunities",
    "relUrl": "/how-to-compute-the-error-bounds-on-a-taylor-approximation/#opportunities"
  },"298": {
    "doc": "How to compute the limit of a function (in Python, using SymPy)",
    "title": "How to compute the limit of a function (in Python, using SymPy)",
    "content": "# How to compute the limit of a function (in Python, using SymPy) [See all solutions.](../how-to-compute-the-limit-of-a-function) ## Task In mathematics, we write $$\\lim_{x\\to a} f(x)$$ to refer to the value that $f$ approaches as $x$ gets close to $a$, called \"the limit of $f(x)$ as $x$ approaches $a$.\" How can we use software to compute such limits? ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Here we define a simple mathematical formula, $\\frac{x^2-x-2}{x-2}$, and compute the limit as $x$ approaches 2. We use SymPy's built-in `limit` function, which takes the formula $f(x)$, the variable $x$, and the value $a$. ```python var( 'x' ) formula = ( x**2 - x - 2 ) / ( x - 2 ) limit( formula, x, 2 ) ``` $\\displaystyle 3$ You can also compute one-sided limits. For instance, the limit of $\\frac{\\vert x\\vert}{x}$ is $1$ as $x$ approaches 0 from the right, but it is $-1$ as $x$ approaches 0 from the left. ```python limit( abs(x)/x, x, 0, \"-\" ) # \"-\" means from the left ``` $\\displaystyle -1$ ```python limit( abs(x)/x, x, 0, \"+\" ) # \"+\" means from the right ``` $\\displaystyle 1$ Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the limit of a function/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-the-limit-of-a-function-in-python-using-sympy/",
    "relUrl": "/how-to-compute-the-limit-of-a-function-in-python-using-sympy/"
  },"299": {
    "doc": "How to compute the limit of a function",
    "title": "How to compute the limit of a function",
    "content": " ",
    "url": "/how-to-compute-the-limit-of-a-function/",
    "relUrl": "/how-to-compute-the-limit-of-a-function/"
  },"300": {
    "doc": "How to compute the limit of a function",
    "title": "Description",
    "content": "In mathematics, we write . \\[\\lim_{x\\to a} f(x)\\] to refer to the value that $f$ approaches as $x$ gets close to $a$, called “the limit of $f(x)$ as $x$ approaches $a$.” . How can we use software to compute such limits? . ",
    "url": "/how-to-compute-the-limit-of-a-function/#description",
    "relUrl": "/how-to-compute-the-limit-of-a-function/#description"
  },"301": {
    "doc": "How to compute the limit of a function",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Here we define a simple mathematical formula, $\\frac{x^2-x-2}{x-2}$, and compute the limit as $x$ approaches 2. We use SymPy’s built-in limit function, which takes the formula $f(x)$, the variable $x$, and the value $a$. | 1 2 3 . | var( 'x' ) formula = ( x**2 - x - 2 ) / ( x - 2 ) limit( formula, x, 2 ) . | . $\\displaystyle 3$ . You can also compute one-sided limits. For instance, the limit of $\\frac{\\vert x\\vert}{x}$ is $1$ as $x$ approaches 0 from the right, but it is $-1$ as $x$ approaches 0 from the left. | 1 . | limit( abs(x)/x, x, 0, \"-\" ) # \"-\" means from the left . | . $\\displaystyle -1$ . | 1 . | limit( abs(x)/x, x, 0, \"+\" ) # \"+\" means from the right . | . $\\displaystyle 1$ . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-limit-of-a-function/#using-sympy-in-python",
    "relUrl": "/how-to-compute-the-limit-of-a-function/#using-sympy-in-python"
  },"302": {
    "doc": "How to compute the limit of a function",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-compute-the-limit-of-a-function/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-the-limit-of-a-function/#topics-that-include-this-task"
  },"303": {
    "doc": "How to compute the limit of a function",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-the-limit-of-a-function/#opportunities",
    "relUrl": "/how-to-compute-the-limit-of-a-function/#opportunities"
  },"304": {
    "doc": "How to compute the power of a test comparing two population means (in Python, using statsmodels)",
    "title": "How to compute the power of a test comparing two population means (in Python, using statsmodels)",
    "content": "# How to compute the power of a test comparing two population means (in Python, using statsmodels) [See all solutions.](../how-to-compute-the-power-of-a-test-comparing-two-population-means) ## Task When creating a factorial design, it is important that it has adequate power to detect significant main effects and interaction effects of interest. How can we calculate the power of a two-sample $t$ test that we aim to perform in such a situation? Related tasks: * [How to choose the sample size in a study with two population means](../how-to-choose-the-sample-size-in-a-study-with-two-population-means) ## Solution From `statsmodels`, we use the `solve_power` function in the `TTestIndPower` class. That function embodies a relationship among five variables; you provide any four of them and it will compute the fifth to be consistent with the first four, regarding the two-sample $t$-test you plan to perform. Let's get started by importing the package and create a `TTestIndPower` object. ```python from statsmodels.stats.power import TTestIndPower analysis = TTestIndPower() ``` For this example, let's say that: * You plan to create a balanced $4\\times2$ factorial experiment with 32 subjects. * You expect the effect size for the main effect of factor A to be medium (0.25 according to Cohen's 1988 text). * You want to know the expected power for the test of a main effect of factor A. * Your significance level is $\\alpha=0.05$. We proceed as follows. ```python obs = 32 # number of subjects (or observations) effect = 0.25 # effect size alpha = 0.05 # significance level ratio = 1 # ratio of the number of observations in one sample to the other # We leave power unspecified, so that solve_power will compute it for us: analysis.solve_power( effect_size=effect, power=None, nobs1=obs, ratio=ratio, alpha=alpha ) ``` 0.1662985260871502 The power is 0.1663, which means that the probability of rejecting the null hypothesis when in fact it is false OR the probability of avoiding a Type II error is 0.1663. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the power of a test comparing two population means/Python, using statsmodels.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-compute-the-power-of-a-test-comparing-two-population-means-in-python-using-statsmodels/",
    "relUrl": "/how-to-compute-the-power-of-a-test-comparing-two-population-means-in-python-using-statsmodels/"
  },"305": {
    "doc": "How to compute the power of a test comparing two population means (in R)",
    "title": "How to compute the power of a test comparing two population means (in R)",
    "content": "# How to compute the power of a test comparing two population means (in R) [See all solutions.](../how-to-compute-the-power-of-a-test-comparing-two-population-means) ## Task When creating a factorial design, it is important that it has adequate power to detect significant main effects and interaction effects of interest. How can we calculate the power of a two-sample $t$ test that we aim to perform in such a situation? Related tasks: * [How to choose the sample size in a study with two population means](../how-to-choose-the-sample-size-in-a-study-with-two-population-means) ## Solution We use the `power.t.test` function in R. It embodies a relationship among five variables; you provide any four of them and it will compute the fifth to be consistent with the first four, regarding the two-sample $t$-test you plan For this example, let's say that: * You plan to create a balanced $4\\times2$ factorial experiment with 32 subjects. * You wish to be able to detect a difference * You want to know the expected power for the test of a main effect of factor A. * Your significance level is $\\alpha=0.05$. We proceed as follows. ```R # install.packages('pwr') # if you have not already installed it library(pwr) obs <- 32 # number of subjects (or observations) effect <- 0.25 # effect size alpha <- 0.05 # significance level ratio <- 1 # ratio of the number of observations in one sample to the other # We leave power unspecified, so that power.t2n.test will compute it for us: pwr.t2n.test(n1=obs, n2=obs, d=effect, sig.level=alpha, power=NULL) ``` t test power calculation n1 = 32 n2 = 32 d = 0.25 sig.level = 0.05 power = 0.1662985 alternative = two.sided The power is 0.1663, which means that the probability of rejecting the null hypothesis when in fact it is false OR the probability of avoiding a Type II error is 0.1663. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the power of a test comparing two population means/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-the-power-of-a-test-comparing-two-population-means-in-r/",
    "relUrl": "/how-to-compute-the-power-of-a-test-comparing-two-population-means-in-r/"
  },"306": {
    "doc": "How to compute the power of a test comparing two population means",
    "title": "How to compute the power of a test comparing two population means",
    "content": " ",
    "url": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/",
    "relUrl": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/"
  },"307": {
    "doc": "How to compute the power of a test comparing two population means",
    "title": "Description",
    "content": "When creating a factorial design, it is important that it has adequate power to detect significant main effects and interaction effects of interest. How can we calculate the power of a two-sample $t$ test that we aim to perform in such a situation? . Related tasks: . | How to choose the sample size in a study with two population means | . ",
    "url": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#description",
    "relUrl": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#description"
  },"308": {
    "doc": "How to compute the power of a test comparing two population means",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. From statsmodels, we use the solve_power function in the TTestIndPower class. That function embodies a relationship among five variables; you provide any four of them and it will compute the fifth to be consistent with the first four, regarding the two-sample $t$-test you plan to perform. Let’s get started by importing the package and create a TTestIndPower object. | 1 2 . | from statsmodels.stats.power import TTestIndPower analysis = TTestIndPower() . | . For this example, let’s say that: . | You plan to create a balanced $4\\times2$ factorial experiment with 32 subjects. | You expect the effect size for the main effect of factor A to be medium (0.25 according to Cohen’s 1988 text). | You want to know the expected power for the test of a main effect of factor A. | Your significance level is $\\alpha=0.05$. | . We proceed as follows. | 1 2 3 4 5 6 7 . | obs = 32 # number of subjects (or observations) effect = 0.25 # effect size alpha = 0.05 # significance level ratio = 1 # ratio of the number of observations in one sample to the other # We leave power unspecified, so that solve_power will compute it for us: analysis.solve_power( effect_size=effect, power=None, nobs1=obs, ratio=ratio, alpha=alpha ) . | . | 1 . | 0.1662985260871502 . | . The power is 0.1663, which means that the probability of rejecting the null hypothesis when in fact it is false OR the probability of avoiding a Type II error is 0.1663. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#using-statsmodels-in-python",
    "relUrl": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#using-statsmodels-in-python"
  },"309": {
    "doc": "How to compute the power of a test comparing two population means",
    "title": "Solution, in R",
    "content": "View this solution alone. We use the power.t.test function in R. It embodies a relationship among five variables; you provide any four of them and it will compute the fifth to be consistent with the first four, regarding the two-sample $t$-test you plan . For this example, let’s say that: . | You plan to create a balanced $4\\times2$ factorial experiment with 32 subjects. | You wish to be able to detect a difference | You want to know the expected power for the test of a main effect of factor A. | Your significance level is $\\alpha=0.05$. | . We proceed as follows. | 1 2 3 4 5 6 7 8 9 10 . | # install.packages('pwr') # if you have not already installed it library(pwr) obs &lt;- 32 # number of subjects (or observations) effect &lt;- 0.25 # effect size alpha &lt;- 0.05 # significance level ratio &lt;- 1 # ratio of the number of observations in one sample to the other # We leave power unspecified, so that power.t2n.test will compute it for us: pwr.t2n.test(n1=obs, n2=obs, d=effect, sig.level=alpha, power=NULL) . | . | 1 2 3 4 5 6 7 8 . | t test power calculation n1 = 32 n2 = 32 d = 0.25 sig.level = 0.05 power = 0.1662985 alternative = two.sided . | . The power is 0.1663, which means that the probability of rejecting the null hypothesis when in fact it is false OR the probability of avoiding a Type II error is 0.1663. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#solution-in-r",
    "relUrl": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#solution-in-r"
  },"310": {
    "doc": "How to compute the power of a test comparing two population means",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#topics-that-include-this-task"
  },"311": {
    "doc": "How to compute the power of a test comparing two population means",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#opportunities",
    "relUrl": "/how-to-compute-the-power-of-a-test-comparing-two-population-means/#opportunities"
  },"312": {
    "doc": "How to compute the residuals of a linear model (in Python, using statsmodels)",
    "title": "How to compute the residuals of a linear model (in Python, using statsmodels)",
    "content": "# How to compute the residuals of a linear model (in Python, using statsmodels) [See all solutions.](../how-to-compute-the-residuals-of-a-linear-model) ## Task If a model has been fit to a dataset, the *residuals* are the differences between the actual data points and the results the model would predict. Given a linear model and a dataset, how can we compute those residuals? ## Solution Let’s assume that you’ve already built a linear model similar to the one below. This one uses a small amount of fake data, but it’s just an example. ```python import statsmodels.api as sm xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] xs = sm.add_constant( xs ) reg = sm.OLS( ys, xs ).fit() ``` We can extract the residuals of the model by calling the model's `resid` attribute. ```python reg.resid ``` array([ 9.16263041, 2.19945659, -9.07249979, -16.79516483, -4.43114302, 6.04718527, 12.88953537]) The result is an array of the residuals for every value in the data set. Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the residuals of a linear model/Python, using statsmodels.ipynb). Contributed by Andrew Quagliaroli (aquagliaroli@falcon.bentley.edu) ",
    "url": "/how-to-compute-the-residuals-of-a-linear-model-in-python-using-statsmodels/",
    "relUrl": "/how-to-compute-the-residuals-of-a-linear-model-in-python-using-statsmodels/"
  },"313": {
    "doc": "How to compute the residuals of a linear model (in R)",
    "title": "How to compute the residuals of a linear model (in R)",
    "content": "# How to compute the residuals of a linear model (in R) [See all solutions.](../how-to-compute-the-residuals-of-a-linear-model) ## Task If a model has been fit to a dataset, the *residuals* are the differences between the actual data points and the results the model would predict. Given a linear model and a dataset, how can we compute those residuals? ## Solution Let's assume that you've already built a linear model similar to the one below. This one uses a small amount of fake data, but it's just an example. See also [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data). ```R xs <- c( 393, 453, 553, 679, 729, 748, 817 ) ys <- c( 24, 25, 27, 36, 55, 68, 84 ) model <- lm(ys ~ xs) ``` We can extract the residuals of the model in either of two ways. R has a built-in `residuals()` function for this purpose. ```R residuals(model) ``` 1 2 3 4 5 6 7 9.162630 2.199457 -9.072500 -16.795165 -4.431143 6.047185 12.889535 The model itself has a `$residuals` attribute. ```R model$residuals ``` 1 2 3 4 5 6 7 9.162630 2.199457 -9.072500 -16.795165 -4.431143 6.047185 12.889535 Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the residuals of a linear model/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-compute-the-residuals-of-a-linear-model-in-r/",
    "relUrl": "/how-to-compute-the-residuals-of-a-linear-model-in-r/"
  },"314": {
    "doc": "How to compute the residuals of a linear model",
    "title": "How to compute the residuals of a linear model",
    "content": " ",
    "url": "/how-to-compute-the-residuals-of-a-linear-model/",
    "relUrl": "/how-to-compute-the-residuals-of-a-linear-model/"
  },"315": {
    "doc": "How to compute the residuals of a linear model",
    "title": "Description",
    "content": "If a model has been fit to a dataset, the residuals are the differences between the actual data points and the results the model would predict. Given a linear model and a dataset, how can we compute those residuals? . ",
    "url": "/how-to-compute-the-residuals-of-a-linear-model/#description",
    "relUrl": "/how-to-compute-the-residuals-of-a-linear-model/#description"
  },"316": {
    "doc": "How to compute the residuals of a linear model",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. Let’s assume that you’ve already built a linear model similar to the one below. This one uses a small amount of fake data, but it’s just an example. | 1 2 3 4 5 6 7 . | import statsmodels.api as sm xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] xs = sm.add_constant( xs ) reg = sm.OLS( ys, xs ).fit() . | . We can extract the residuals of the model by calling the model’s resid attribute. | 1 . | reg.resid . | . | 1 2 . | array([ 9.16263041, 2.19945659, -9.07249979, -16.79516483, -4.43114302, 6.04718527, 12.88953537]) . | . The result is an array of the residuals for every value in the data set. Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-residuals-of-a-linear-model/#using-statsmodels-in-python",
    "relUrl": "/how-to-compute-the-residuals-of-a-linear-model/#using-statsmodels-in-python"
  },"317": {
    "doc": "How to compute the residuals of a linear model",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s assume that you’ve already built a linear model similar to the one below. This one uses a small amount of fake data, but it’s just an example. See also how to fit a linear model to two columns of data. | 1 2 3 . | xs &lt;- c( 393, 453, 553, 679, 729, 748, 817 ) ys &lt;- c( 24, 25, 27, 36, 55, 68, 84 ) model &lt;- lm(ys ~ xs) . | . We can extract the residuals of the model in either of two ways. R has a built-in residuals() function for this purpose. | 1 . | residuals(model) . | . | 1 2 . | 1 2 3 4 5 6 7 9.162630 2.199457 -9.072500 -16.795165 -4.431143 6.047185 12.889535 . | . The model itself has a $residuals attribute. | 1 . | model$residuals . | . | 1 2 . | 1 2 3 4 5 6 7 9.162630 2.199457 -9.072500 -16.795165 -4.431143 6.047185 12.889535 . | . Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-residuals-of-a-linear-model/#solution-in-r",
    "relUrl": "/how-to-compute-the-residuals-of-a-linear-model/#solution-in-r"
  },"318": {
    "doc": "How to compute the residuals of a linear model",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-compute-the-residuals-of-a-linear-model/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-the-residuals-of-a-linear-model/#topics-that-include-this-task"
  },"319": {
    "doc": "How to compute the residuals of a linear model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-the-residuals-of-a-linear-model/#opportunities",
    "relUrl": "/how-to-compute-the-residuals-of-a-linear-model/#opportunities"
  },"320": {
    "doc": "How to compute the standard error of the estimate for a model (in Python, using statsmodels)",
    "title": "How to compute the standard error of the estimate for a model (in Python, using statsmodels)",
    "content": "# How to compute the standard error of the estimate for a model (in Python, using statsmodels) [See all solutions.](../how-to-compute-the-standard-error-of-the-estimate-for-a-model) ## Task One measure of the goodness of fit of a model is the standard error of its estimates. If the actual values are $y_i$ and the estimates are $\\hat y_i$, the definition of this quantity is as follows, for $n$ data points. $$ \\sigma_{\\text{est}} = \\sqrt{ \\frac{ \\sum (y_i-\\hat y_i)^2 }{ n } } $$ If we've fit a linear model, how do we compute the standard error of its estimates? ## Solution Let's assume that you already fit the linear model, as shown in the code below. This one uses a small amount of fake data, but it's just an example. See also [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data). ```python # Below is the fake data as an example. You can replace with your real data. x = [ 34, 9, 78, 60, 22, 45, 83, 59, 25 ] y = [ 126, 347, 298, 309, 450, 187, 266, 385, 400 ] # Use statsmodels to build a linear regression model import statsmodels.api as sm x = sm.add_constant( x ) model = sm.OLS( y, x ).fit() ``` The standard error is shown as part of the model summary, reported by statsmodels's built-in `summary` function. See the column entitled \"std err\" in the output below. ```python model.summary() ``` /opt/conda/lib/python3.10/site-packages/scipy/stats/_stats_py.py:1772: UserWarning: kurtosistest only valid for n>=20 ... continuing anyway, n=9 warnings.warn(\"kurtosistest only valid for n>=20 ... continuing \" OLS Regression Results | Dep. Variable: | y | R-squared: | 0.063 | . | Model: | OLS | Adj. R-squared: | -0.071 | . | Method: | Least Squares | F-statistic: | 0.4693 | . | Date: | Tue, 08 Nov 2022 | Prob (F-statistic): | 0.515 | . | Time: | 21:56:16 | Log-Likelihood: | -53.705 | . | No. Observations: | 9 | AIC: | 111.4 | . | Df Residuals: | 7 | BIC: | 111.8 | . | Df Model: | 1 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P>|t| | [0.025 | 0.975] | . | const | 354.0822 | 76.733 | 4.614 | 0.002 | 172.638 | 535.526 | . | x1 | -1.0090 | 1.473 | -0.685 | 0.515 | -4.492 | 2.474 | . | Omnibus: | 2.324 | Durbin-Watson: | 1.618 | . | Prob(Omnibus): | 0.313 | Jarque-Bera (JB): | 1.079 | . | Skew: | -0.832 | Prob(JB): | 0.583 | . | Kurtosis: | 2.674 | Cond. No. | 112. | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified. If we need to extract just the estimates or their standard errors, we can use code like the following. ```python model.params # just the model coefficients ``` array([354.0822479 , -1.00901261]) ```python model.bse # just the standard errors of those estimates ``` array([76.73277161, 1.47293931]) The standard error of the estimate for the intercept is is 76.73277161 and the standard error of the estimate for the slope is 1.47293931. Content last modified on 08 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the standard error of the estimate for a model/Python, using statsmodels.ipynb). Contributed by: * Ni Shi (shi_ni@bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model-in-python-using-statsmodels/",
    "relUrl": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model-in-python-using-statsmodels/"
  },"321": {
    "doc": "How to compute the standard error of the estimate for a model (in R)",
    "title": "How to compute the standard error of the estimate for a model (in R)",
    "content": "# How to compute the standard error of the estimate for a model (in R) [See all solutions.](../how-to-compute-the-standard-error-of-the-estimate-for-a-model) ## Task One measure of the goodness of fit of a model is the standard error of its estimates. If the actual values are $y_i$ and the estimates are $\\hat y_i$, the definition of this quantity is as follows, for $n$ data points. $$ \\sigma_{\\text{est}} = \\sqrt{ \\frac{ \\sum (y_i-\\hat y_i)^2 }{ n } } $$ If we've fit a linear model, how do we compute the standard error of its estimates? ## Solution Let's assume that you already fit the linear model, as shown in the code below. This one uses a small amount of fake data, but it's just an example. See also [how to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data). ```R x |t|) (Intercept) 354.082 76.733 4.614 0.00244 ** x -1.009 1.473 -0.685 0.51536 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 107.1 on 7 degrees of freedom Multiple R-squared: 0.06283, Adjusted R-squared: -0.07106 F-statistic: 0.4693 on 1 and 7 DF, p-value: 0.5154 If we need to extract just the model coefficients table, or even just the \"Std. Error\" column of it, we can use code like the following. ```R coef(summary(model)) coef(summary(model))[,2] ``` Estimate Std. Error t value Pr(>|t|) (Intercept) 354.082248 76.732772 4.6144853 0.002441995 x -1.009013 1.472939 -0.6850334 0.515358250 (Intercept) x 76.732772 1.472939 The standard error of the estimate for the intercept is is 76.733 and the standard error of the estimate for the slope is 1.473. Content last modified on 08 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the standard error of the estimate for a model/R.md). Contributed by: * Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model-in-r/",
    "relUrl": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model-in-r/"
  },"322": {
    "doc": "How to compute the standard error of the estimate for a model",
    "title": "How to compute the standard error of the estimate for a model",
    "content": " ",
    "url": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/",
    "relUrl": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/"
  },"323": {
    "doc": "How to compute the standard error of the estimate for a model",
    "title": "Description",
    "content": "One measure of the goodness of fit of a model is the standard error of its estimates. If the actual values are $y_i$ and the estimates are $\\hat y_i$, the definition of this quantity is as follows, for $n$ data points. \\[\\sigma_{\\text{est}} = \\sqrt{ \\frac{ \\sum (y_i-\\hat y_i)^2 }{ n } }\\] If we’ve fit a linear model, how do we compute the standard error of its estimates? . ",
    "url": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#description",
    "relUrl": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#description"
  },"324": {
    "doc": "How to compute the standard error of the estimate for a model",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. Let’s assume that you already fit the linear model, as shown in the code below. This one uses a small amount of fake data, but it’s just an example. See also how to fit a linear model to two columns of data. | 1 2 3 4 5 6 7 8 . | # Below is the fake data as an example. You can replace with your real data. x = [ 34, 9, 78, 60, 22, 45, 83, 59, 25 ] y = [ 126, 347, 298, 309, 450, 187, 266, 385, 400 ] # Use statsmodels to build a linear regression model import statsmodels.api as sm x = sm.add_constant( x ) model = sm.OLS( y, x ).fit() . | . The standard error is shown as part of the model summary, reported by statsmodels’s built-in summary function. See the column entitled “std err” in the output below. | 1 . | model.summary() . | . | 1 2 . | /opt/conda/lib/python3.10/site-packages/scipy/stats/_stats_py.py:1772: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=9 warnings.warn(\"kurtosistest only valid for n&gt;=20 ... continuing \" . | . OLS Regression Results | Dep. Variable: | y | R-squared: | 0.063 | . | Model: | OLS | Adj. R-squared: | -0.071 | . | Method: | Least Squares | F-statistic: | 0.4693 | . | Date: | Tue, 08 Nov 2022 | Prob (F-statistic): | 0.515 | . | Time: | 21:56:16 | Log-Likelihood: | -53.705 | . | No. Observations: | 9 | AIC: | 111.4 | . | Df Residuals: | 7 | BIC: | 111.8 | . | Df Model: | 1 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P&gt;|t| | [0.025 | 0.975] | . | const | 354.0822 | 76.733 | 4.614 | 0.002 | 172.638 | 535.526 | . | x1 | -1.0090 | 1.473 | -0.685 | 0.515 | -4.492 | 2.474 | . | Omnibus: | 2.324 | Durbin-Watson: | 1.618 | . | Prob(Omnibus): | 0.313 | Jarque-Bera (JB): | 1.079 | . | Skew: | -0.832 | Prob(JB): | 0.583 | . | Kurtosis: | 2.674 | Cond. No. | 112. | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified. If we need to extract just the estimates or their standard errors, we can use code like the following. | 1 . | model.params # just the model coefficients . | . | 1 . | array([354.0822479 , -1.00901261]) . | . | 1 . | model.bse # just the standard errors of those estimates . | . | 1 . | array([76.73277161, 1.47293931]) . | . The standard error of the estimate for the intercept is is 76.73277161 and the standard error of the estimate for the slope is 1.47293931. Content last modified on 08 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#using-statsmodels-in-python",
    "relUrl": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#using-statsmodels-in-python"
  },"325": {
    "doc": "How to compute the standard error of the estimate for a model",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s assume that you already fit the linear model, as shown in the code below. This one uses a small amount of fake data, but it’s just an example. See also how to fit a linear model to two columns of data. | 1 2 3 . | x &lt;- c(34, 9, 78, 60, 22, 45, 83, 59, 25) y &lt;- c(126, 347, 298, 309, 450, 187, 266, 385, 400) model &lt;- lm(y ~ x) . | . The standard error for each estimate is shown as part of the model summary, reported by R’s built-in summary function. See the column entitled “Std. Error” in the output below. | 1 . | summary(model) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | Call: lm(formula = y ~ x) Residuals: Min 1Q Median 3Q Max -193.776 -4.334 15.459 71.143 118.116 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 354.082 76.733 4.614 0.00244 ** x -1.009 1.473 -0.685 0.51536 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 107.1 on 7 degrees of freedom Multiple R-squared: 0.06283, Adjusted R-squared: -0.07106 F-statistic: 0.4693 on 1 and 7 DF, p-value: 0.5154 . | . If we need to extract just the model coefficients table, or even just the “Std. Error” column of it, we can use code like the following. | 1 2 . | coef(summary(model)) coef(summary(model))[,2] . | . | 1 2 3 4 5 6 7 8 . | Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 354.082248 76.732772 4.6144853 0.002441995 x -1.009013 1.472939 -0.6850334 0.515358250 (Intercept) x 76.732772 1.472939 . | . The standard error of the estimate for the intercept is is 76.733 and the standard error of the estimate for the slope is 1.473. Content last modified on 08 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#solution-in-r",
    "relUrl": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#solution-in-r"
  },"326": {
    "doc": "How to compute the standard error of the estimate for a model",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#topics-that-include-this-task"
  },"327": {
    "doc": "How to compute the standard error of the estimate for a model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#opportunities",
    "relUrl": "/how-to-compute-the-standard-error-of-the-estimate-for-a-model/#opportunities"
  },"328": {
    "doc": "How to compute the Taylor series for a function (in Python, using SymPy)",
    "title": "How to compute the Taylor series for a function (in Python, using SymPy)",
    "content": "# How to compute the Taylor series for a function (in Python, using SymPy) [See all solutions.](../how-to-compute-the-taylor-series-for-a-function) ## Task Any function that has arbitrarily many derivatives at a given point can have a Taylor series computed for the function centered at that point. How can we ask symbolic mathematics software to do this for us? Related tasks: * [How to compute the error bounds on a Taylor approximation](../how-to-compute-the-error-bounds-on-a-taylor-approximation) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's define an example function whose Taylor series we'd like to compute. ```python var( 'x' ) formula = exp( 2*x + 1 ) formula ``` $\\displaystyle e^{2 x + 1}$ Let's ask for a degree-5 Taylor series centered at $x=2$. From the code below, you can tell that the third parameter is the center point and the fourth parameter is the degree. ```python series( formula, x, 2, 5 ) ``` $\\displaystyle e^{5} + 2 \\left(x - 2\\right) e^{5} + 2 \\left(x - 2\\right)^{2} e^{5} + \\frac{4 \\left(x - 2\\right)^{3} e^{5}}{3} + \\frac{2 \\left(x - 2\\right)^{4} e^{5}}{3} + O\\left(\\left(x - 2\\right)^{5}; x\\rightarrow 2\\right)$ The final term (starting with O---oh, not zero) means that there are more terms in the infinite Taylor series not shown in this finite approximation. If you want to show just the approximation, you can tell it to remove the O term. ```python series( formula, x, 2, 5 ).removeO() ``` $\\displaystyle \\frac{2 \\left(x - 2\\right)^{4} e^{5}}{3} + \\frac{4 \\left(x - 2\\right)^{3} e^{5}}{3} + 2 \\left(x - 2\\right)^{2} e^{5} + 2 \\left(x - 2\\right) e^{5} + e^{5}$ You can also compute individual coefficients in a Taylor series by remembering the formula for the $n^\\text{th}$ term in the series and applying it, as follows. The formula for a series centered on $x=a$ is $\\frac{f^{(n)}(a)}{n!}$. From the answer above, we can see that the coefficient on the $n=3$ term is $\\frac43e^5$. ```python n = 3 a = 2 diff( formula, x, n ).subs( x, a ) / factorial( n ) ``` $\\displaystyle \\frac{4 e^{5}}{3}$ Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to compute the Taylor series for a function/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-compute-the-taylor-series-for-a-function-in-python-using-sympy/",
    "relUrl": "/how-to-compute-the-taylor-series-for-a-function-in-python-using-sympy/"
  },"329": {
    "doc": "How to compute the Taylor series for a function",
    "title": "How to compute the Taylor series for a function",
    "content": " ",
    "url": "/how-to-compute-the-taylor-series-for-a-function/",
    "relUrl": "/how-to-compute-the-taylor-series-for-a-function/"
  },"330": {
    "doc": "How to compute the Taylor series for a function",
    "title": "Description",
    "content": "Any function that has arbitrarily many derivatives at a given point can have a Taylor series computed for the function centered at that point. How can we ask symbolic mathematics software to do this for us? . Related tasks: . | How to compute the error bounds on a Taylor approximation | . ",
    "url": "/how-to-compute-the-taylor-series-for-a-function/#description",
    "relUrl": "/how-to-compute-the-taylor-series-for-a-function/#description"
  },"331": {
    "doc": "How to compute the Taylor series for a function",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s define an example function whose Taylor series we’d like to compute. | 1 2 3 . | var( 'x' ) formula = exp( 2*x + 1 ) formula . | . $\\displaystyle e^{2 x + 1}$ . Let’s ask for a degree-5 Taylor series centered at $x=2$. From the code below, you can tell that the third parameter is the center point and the fourth parameter is the degree. | 1 . | series( formula, x, 2, 5 ) . | . $\\displaystyle e^{5} + 2 \\left(x - 2\\right) e^{5} + 2 \\left(x - 2\\right)^{2} e^{5} + \\frac{4 \\left(x - 2\\right)^{3} e^{5}}{3} + \\frac{2 \\left(x - 2\\right)^{4} e^{5}}{3} + O\\left(\\left(x - 2\\right)^{5}; x\\rightarrow 2\\right)$ . The final term (starting with O—oh, not zero) means that there are more terms in the infinite Taylor series not shown in this finite approximation. If you want to show just the approximation, you can tell it to remove the O term. | 1 . | series( formula, x, 2, 5 ).removeO() . | . $\\displaystyle \\frac{2 \\left(x - 2\\right)^{4} e^{5}}{3} + \\frac{4 \\left(x - 2\\right)^{3} e^{5}}{3} + 2 \\left(x - 2\\right)^{2} e^{5} + 2 \\left(x - 2\\right) e^{5} + e^{5}$ . You can also compute individual coefficients in a Taylor series by remembering the formula for the $n^\\text{th}$ term in the series and applying it, as follows. The formula for a series centered on $x=a$ is $\\frac{f^{(n)}(a)}{n!}$. From the answer above, we can see that the coefficient on the $n=3$ term is $\\frac43e^5$. | 1 2 3 . | n = 3 a = 2 diff( formula, x, n ).subs( x, a ) / factorial( n ) . | . $\\displaystyle \\frac{4 e^{5}}{3}$ . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-compute-the-taylor-series-for-a-function/#using-sympy-in-python",
    "relUrl": "/how-to-compute-the-taylor-series-for-a-function/#using-sympy-in-python"
  },"332": {
    "doc": "How to compute the Taylor series for a function",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-compute-the-taylor-series-for-a-function/#topics-that-include-this-task",
    "relUrl": "/how-to-compute-the-taylor-series-for-a-function/#topics-that-include-this-task"
  },"333": {
    "doc": "How to compute the Taylor series for a function",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-compute-the-taylor-series-for-a-function/#opportunities",
    "relUrl": "/how-to-compute-the-taylor-series-for-a-function/#opportunities"
  },"334": {
    "doc": "How to conduct a mixed designs ANOVA (in Python, using pandas and pingouin)",
    "title": "How to conduct a mixed designs ANOVA (in Python, using pandas and pingouin)",
    "content": "# How to conduct a mixed designs ANOVA (in Python, using pandas and pingouin) [See all solutions.](../how-to-conduct-a-mixed-designs-anova) ## Task When you have a dataset that includes the responses of a mixed design test, where one factor is a within-subjects factor and the other is a between-subjects factor, and you wish check if there is a significant difference for both factors, this requires a Mixed Design ANOVA. How can we conduct one? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-way ANOVA test with interaction](../how-to-do-a-two-way-anova-test-with-interaction) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) using ANOVA * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution We create the data for a hypothetical $2\\times2$ mixed design with the following attributes. * Between-subjects treatment factor: Type of music played (classical vs. rock) * Within-subjects treatment factor: Type of room (light vs. no light) * Outcome variable: Heart rate of subject ```python import pandas as pd df = pd.DataFrame( { 'Subject' : [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10], 'Music' : ['Classical','Rock','Classical','Rock','Classical','Rock','Classical', 'Rock','Classical','Rock','Classical','Rock','Classical','Rock','Classical', 'Rock','Classical','Rock','Classical','Rock'], 'Room Type' : ['Light','Light','Light','Light','Light','Light','Light','Light','Light', 'Light','No Light','No Light','No Light','No Light','No Light','No Light', 'No Light','No Light','No Light','No Light'], 'Heart Rate' : [78,60,85,75,99,94,75,84,100,76,90,109,99,94,113,92,91,88,89,90] } ) df.head() ``` | | Subject | Music | Room Type | Heart Rate | . | 0 | 1 | Classical | Light | 78 | . | 1 | 2 | Rock | Light | 60 | . | 2 | 3 | Classical | Light | 85 | . | 3 | 4 | Rock | Light | 75 | . | 4 | 5 | Classical | Light | 99 | . We will use the `pingouin` statistics package to conduct a two-way mixed-design ANOVA. The parameters are as follows: 1. `dv`: name of the column containing the dependant variable 2. `within`: name of the column containing the within-group factor 3. `between`: name of the column containing the between-group factor 4. `subject`: name of the column identifying each subject 5. `data`: the pandas DataFrame containing all the data ```python import pingouin as pg pg.mixed_anova( dv='Heart Rate', within='Room Type', between='Music', subject='Subject', data=df ) ``` | | Source | SS | DF1 | DF2 | MS | F | p-unc | np2 | eps | . | 0 | Music | 162.45 | 1 | 8 | 162.45 | 1.586813 | 0.243288 | 0.165520 | NaN | . | 1 | Room Type | 832.05 | 1 | 8 | 832.05 | 6.416426 | 0.035088 | 0.445077 | 1.0 | . | 2 | Interaction | 76.05 | 1 | 8 | 76.05 | 0.586466 | 0.465781 | 0.068301 | NaN | . The output informs us that, on average, the subjects that listened to classical music did not significantly differ ($p = 0.243288 > 0.05$) from those that listened to rock music. However, there is, on average, a significant difference ($p = 0.035088 0.05$), we can use the additive (no interaction) model. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to conduct a mixed designs ANOVA/Python, using pandas and pingouin.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-conduct-a-mixed-designs-anova-in-python-using-pandas-and-pingouin/",
    "relUrl": "/how-to-conduct-a-mixed-designs-anova-in-python-using-pandas-and-pingouin/"
  },"335": {
    "doc": "How to conduct a mixed designs ANOVA (in R)",
    "title": "How to conduct a mixed designs ANOVA (in R)",
    "content": "# How to conduct a mixed designs ANOVA (in R) [See all solutions.](../how-to-conduct-a-mixed-designs-anova) ## Task When you have a dataset that includes the responses of a mixed design test, where one factor is a within-subjects factor and the other is a between-subjects factor, and you wish check if there is a significant difference for both factors, this requires a Mixed Design ANOVA. How can we conduct one? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-way ANOVA test with interaction](../how-to-do-a-two-way-anova-test-with-interaction) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) using ANOVA * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution We create the data for a hypothetical $2\\times2$ mixed design with the following attributes. * Between-subjects treatment factor: Type of music played (classical vs. rock) * Within-subjects treatment factor: Type of room (light vs. no light) * Outcome variable: Heart rate of subject ```R subject F) music 1 162.4 162.4 1.587 0.243 Residuals 8 819.0 102.4 Error: subject:room.type Df Sum Sq Mean Sq F value Pr(>F) room.type 1 832.1 832.1 6.416 0.0351 * room.type:music 1 76.0 76.0 0.586 0.4658 Residuals 8 1037.4 129.7 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 The output informs us that, on average, the subjects that listened to classical music did not significantly differ ($p = 0.243 > 0.05$) from those that listened to rock music. However, there is, on average, a significant difference ($p = 0.0351 0.05$), we can use the additive (no interaction) model. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to conduct a mixed designs ANOVA/R.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-conduct-a-mixed-designs-anova-in-r/",
    "relUrl": "/how-to-conduct-a-mixed-designs-anova-in-r/"
  },"336": {
    "doc": "How to conduct a mixed designs ANOVA",
    "title": "How to conduct a mixed designs ANOVA",
    "content": " ",
    "url": "/how-to-conduct-a-mixed-designs-anova/",
    "relUrl": "/how-to-conduct-a-mixed-designs-anova/"
  },"337": {
    "doc": "How to conduct a mixed designs ANOVA",
    "title": "Description",
    "content": "When you have a dataset that includes the responses of a mixed design test, where one factor is a within-subjects factor and the other is a between-subjects factor, and you wish check if there is a significant difference for both factors, this requires a Mixed Design ANOVA. How can we conduct one? . Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to do a two-way ANOVA test with interaction | How to do a two-way ANOVA test without interaction | How to compare two nested linear models using ANOVA | How to conduct a repeated measures ANOVA | How to perform an analysis of covariance (ANCOVA) | . ",
    "url": "/how-to-conduct-a-mixed-designs-anova/#description",
    "relUrl": "/how-to-conduct-a-mixed-designs-anova/#description"
  },"338": {
    "doc": "How to conduct a mixed designs ANOVA",
    "title": "Using pandas and pingouin, in Python",
    "content": "View this solution alone. We create the data for a hypothetical $2\\times2$ mixed design with the following attributes. | Between-subjects treatment factor: Type of music played (classical vs. rock) | Within-subjects treatment factor: Type of room (light vs. no light) | Outcome variable: Heart rate of subject | . | 1 2 3 4 5 6 7 8 9 10 11 12 . | import pandas as pd df = pd.DataFrame( { 'Subject' : [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10], 'Music' : ['Classical','Rock','Classical','Rock','Classical','Rock','Classical', 'Rock','Classical','Rock','Classical','Rock','Classical','Rock','Classical', 'Rock','Classical','Rock','Classical','Rock'], 'Room Type' : ['Light','Light','Light','Light','Light','Light','Light','Light','Light', 'Light','No Light','No Light','No Light','No Light','No Light','No Light', 'No Light','No Light','No Light','No Light'], 'Heart Rate' : [78,60,85,75,99,94,75,84,100,76,90,109,99,94,113,92,91,88,89,90] } ) df.head() . | . | | Subject | Music | Room Type | Heart Rate | . | 0 | 1 | Classical | Light | 78 | . | 1 | 2 | Rock | Light | 60 | . | 2 | 3 | Classical | Light | 85 | . | 3 | 4 | Rock | Light | 75 | . | 4 | 5 | Classical | Light | 99 | . We will use the pingouin statistics package to conduct a two-way mixed-design ANOVA. The parameters are as follows: . | dv: name of the column containing the dependant variable | within: name of the column containing the within-group factor | between: name of the column containing the between-group factor | subject: name of the column identifying each subject | data: the pandas DataFrame containing all the data | . | 1 2 . | import pingouin as pg pg.mixed_anova( dv='Heart Rate', within='Room Type', between='Music', subject='Subject', data=df ) . | . | | Source | SS | DF1 | DF2 | MS | F | p-unc | np2 | eps | . | 0 | Music | 162.45 | 1 | 8 | 162.45 | 1.586813 | 0.243288 | 0.165520 | NaN | . | 1 | Room Type | 832.05 | 1 | 8 | 832.05 | 6.416426 | 0.035088 | 0.445077 | 1.0 | . | 2 | Interaction | 76.05 | 1 | 8 | 76.05 | 0.586466 | 0.465781 | 0.068301 | NaN | . The output informs us that, on average, the subjects that listened to classical music did not significantly differ ($p = 0.243288 &gt; 0.05$) from those that listened to rock music. However, there is, on average, a significant difference ($p = 0.035088 &lt; 0.05$) between each of the subject’s heart rate when put in a room with or without light. Additionally, since the interaction term is not significant ($p = 0.465781 &gt; 0.05$), we can use the additive (no interaction) model. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-conduct-a-mixed-designs-anova/#using-pandas-and-pingouin-in-python",
    "relUrl": "/how-to-conduct-a-mixed-designs-anova/#using-pandas-and-pingouin-in-python"
  },"339": {
    "doc": "How to conduct a mixed designs ANOVA",
    "title": "Solution, in R",
    "content": "View this solution alone. We create the data for a hypothetical $2\\times2$ mixed design with the following attributes. | Between-subjects treatment factor: Type of music played (classical vs. rock) | Within-subjects treatment factor: Type of room (light vs. no light) | Outcome variable: Heart rate of subject | . | 1 2 3 4 5 6 7 8 9 10 . | subject &lt;- as.factor(c(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10)) music &lt;- c('Classical','Rock','Classical','Rock','Classical','Rock','Classical', 'Rock','Classical','Rock','Classical','Rock','Classical','Rock','Classical', 'Rock','Classical','Rock','Classical','Rock') room.type &lt;- c('Light','Light','Light','Light','Light','Light','Light','Light','Light', 'Light','No Light','No Light','No Light','No Light','No Light','No Light', 'No Light','No Light','No Light', 'No Light') heart.rate &lt;- c(78,60,85,75,99,94,75,84,100,76,90,109,99,94,113,92,91,88,89,90) df &lt;- data.frame(subject,music,room.type,heart.rate) head(df) . | . | 1 2 3 4 5 6 7 . | subject music room.type heart.rate 1 1 Classical Light 78 2 2 Rock Light 60 3 3 Classical Light 85 4 4 Rock Light 75 5 5 Classical Light 99 6 6 Rock Light 94 . | . We conduct a two-way mixed-design ANOVA as shown below. The specific parameters have these meanings: . | The dependent variable is heart.rate. | The within-group factor is room.type. | The between-group factor is music. | The Error() term is critical in differentiating between a between subjects and within subjects model. It tells R that there is one observation per subject for each level of room.type. | . | 1 2 . | aov_mixed &lt;- aov(heart.rate ~ room.type*music + Error(subject/room.type), data=df) summary(aov_mixed) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 . | Error: subject Df Sum Sq Mean Sq F value Pr(&gt;F) music 1 162.4 162.4 1.587 0.243 Residuals 8 819.0 102.4 Error: subject:room.type Df Sum Sq Mean Sq F value Pr(&gt;F) room.type 1 832.1 832.1 6.416 0.0351 * room.type:music 1 76.0 76.0 0.586 0.4658 Residuals 8 1037.4 129.7 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . The output informs us that, on average, the subjects that listened to classical music did not significantly differ ($p = 0.243 &gt; 0.05$) from those that listened to rock music. However, there is, on average, a significant difference ($p = 0.0351 &lt; 0.05$) between each of the subject’s heart rate when put in a room with or without light. Additionally, since the interaction term is not significant ($p = 0.4658 &gt; 0.05$), we can use the additive (no interaction) model. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-conduct-a-mixed-designs-anova/#solution-in-r",
    "relUrl": "/how-to-conduct-a-mixed-designs-anova/#solution-in-r"
  },"340": {
    "doc": "How to conduct a mixed designs ANOVA",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-conduct-a-mixed-designs-anova/#topics-that-include-this-task",
    "relUrl": "/how-to-conduct-a-mixed-designs-anova/#topics-that-include-this-task"
  },"341": {
    "doc": "How to conduct a mixed designs ANOVA",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-conduct-a-mixed-designs-anova/#opportunities",
    "relUrl": "/how-to-conduct-a-mixed-designs-anova/#opportunities"
  },"342": {
    "doc": "How to conduct a repeated measures ANOVA (in Python, using pandas and pingouin)",
    "title": "How to conduct a repeated measures ANOVA (in Python, using pandas and pingouin)",
    "content": "# How to conduct a repeated measures ANOVA (in Python, using pandas and pingouin) [See all solutions.](../how-to-conduct-a-repeated-measures-anova) ## Task In a repeated measures test, the same subject receives multiple treatments. When you have a dataset that includes the responses of a repeated measures test where the measurements are dependent (within subjects design), you may wish to check if there is a difference in the treatment effects. How would you conduct a repeated measures ANOVA to answer that question? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-way ANOVA test with interaction](../how-to-do-a-two-way-anova-test-with-interaction) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) using ANOVA * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution We create a hypothetical repeated measures dataset where the 5 subjects undergo all 4 skin treatments and their rating of the treatment is measured. ```python import pandas as pd df = pd.DataFrame( { 'Subject': [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5], 'Skin Treatment': ['W','X','Y','Z','W','X','Y','Z','W','X', 'Y','Z','W','X','Y','Z','W','X','Y','Z'], 'Rating': [7,5,8,4,8,10,7,5,7,6,5,4,7,7,4,5,8,8,6,6] } ) df.head() ``` | | Subject | Skin Treatment | Rating | . | 0 | 1 | W | 7 | . | 1 | 1 | X | 5 | . | 2 | 1 | Y | 8 | . | 3 | 1 | Z | 4 | . | 4 | 2 | W | 8 | . Before we conduct a repeated measures ANOVA, we need to decide which approach to use - Univariate or Multivariate. We decide this using Mauchly's test of sphericity. If we fail to reject the null hypothesis then we use the univariate approach. * $H_0 =$ the sphericity assumption holds * $H_A =$ the sphericity assumption is violated We use the `pingouin` statistics package to conduct the test. Most of the parameters below are self-explanatory, except that `dv` stands for dependent variable. ```python import pingouin as pg pg.sphericity( dv='Rating', within='Skin Treatment', subject='Subject', method='mauchly', data=df ) ``` /opt/conda/lib/python3.9/site-packages/outdated/utils.py:14: OutdatedPackageWarning: The package pingouin is out of date. Your version is 0.4.0, the latest is 0.5.0. Set the environment variable OUTDATED_IGNORE=1 to disable these warnings. return warn( SpherResults(spher=True, W=0.06210054956238558, chi2=7.565056754547507, dof=5, pval=0.20708214225927316) Since the $p$ value of `skin_treatment` is about $0.2071$, we fail to reject the sphericity assumption at a 5% significance level and use the univariate approach to conduct the repeated measures ANOVA. ```python # Compute a repeated measures ANOVA using a function pingouin adds to our DataFrame: df.rm_anova( dv='Rating', within='Skin Treatment', subject='Subject', detailed=False ) ``` | | Source | ddof1 | ddof2 | F | p-unc | np2 | eps | . | 0 | Skin Treatment | 3 | 12 | 5.117647 | 0.016501 | 0.56129 | 0.541199 | . Since the $p$ value of about $0.017$ is less than 0.05, we conclude that there is significant evidence of a treatment effect. Note: If there is more than 1 repeated measures factor, you can add a list of them to the `within` parameter and conduct the test. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to conduct a repeated measures ANOVA/Python, using pandas and pingouin.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-conduct-a-repeated-measures-anova-in-python-using-pandas-and-pingouin/",
    "relUrl": "/how-to-conduct-a-repeated-measures-anova-in-python-using-pandas-and-pingouin/"
  },"343": {
    "doc": "How to conduct a repeated measures ANOVA (in R, using rstatix and tidyr and car)",
    "title": "How to conduct a repeated measures ANOVA (in R, using rstatix and tidyr and car)",
    "content": "# How to conduct a repeated measures ANOVA (in R, using rstatix and tidyr and car) [See all solutions.](../how-to-conduct-a-repeated-measures-anova) ## Task In a repeated measures test, the same subject receives multiple treatments. When you have a dataset that includes the responses of a repeated measures test where the measurements are dependent (within subjects design), you may wish to check if there is a difference in the treatment effects. How would you conduct a repeated measures ANOVA to answer that question? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-way ANOVA test with interaction](../how-to-do-a-two-way-anova-test-with-interaction) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) using ANOVA * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution We create a hypothetical repeated measures dataset where the 5 subjects undergo all 4 skin treatments and their rating of the treatment is measured. ```R subject F) Residuals 4 11.8 2.95 Error: subject:skin.treatment Df Sum Sq Mean Sq F value Pr(>F) skin.treatment 3 21.75 7.250 5.118 0.0165 * Residuals 12 17.00 1.417 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 You can find the $p$-value at the end of the row of output marked for `skin.treatment`; it is 0.0165. This is less than 0.05, so we conclude that there is significant evidence of a treatment effect. ### Repeated measures ANOVA - multivariate If instead the first test had rejected the sphericity assumption, we would have used a multivariate approach for the repeated measures ANOVA. We show here how to do such a test, even though it does not apply to this situation. We must first reorganize the data into a matrix where each row represents a single subject, and columns represent levels of the treatment factor. This is possible using the `tidyr` package. ```R # install.packages(\"tidyr\") # If you have not already installed it library(tidyr) multi.data F) (Intercept) 806.45 1 11.8 4 273.3729 7.837e-05 *** rfactor 21.75 3 17.0 12 5.1176 0.0165 * --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Mauchly Tests for Sphericity Test statistic p-value rfactor 0.062101 0.20708 Greenhouse-Geisser and Huynh-Feldt Corrections for Departure from Sphericity GG eps Pr(>F[GG]) rfactor 0.5412 0.05068 . --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 HF eps Pr(>F[HF]) rfactor 0.858156 0.02319302 Although this test was run just as an example, and does not actually apply in this dataset, the output shows a $p$-value of 0.0165, at the end of the first `rfactor` row. That $p$-value could be compared to a chosen $\\alpha$. (We also see that Mauchly’s test was performed, which is not significant, and is the reason this data actually demands a univariate approach.) Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to conduct a repeated measures ANOVA/R, using rstatix and tidyr and car.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-conduct-a-repeated-measures-anova-in-r-using-rstatix-and-tidyr-and-car/",
    "relUrl": "/how-to-conduct-a-repeated-measures-anova-in-r-using-rstatix-and-tidyr-and-car/"
  },"344": {
    "doc": "How to conduct a repeated measures ANOVA",
    "title": "How to conduct a repeated measures ANOVA",
    "content": " ",
    "url": "/how-to-conduct-a-repeated-measures-anova/",
    "relUrl": "/how-to-conduct-a-repeated-measures-anova/"
  },"345": {
    "doc": "How to conduct a repeated measures ANOVA",
    "title": "Description",
    "content": "In a repeated measures test, the same subject receives multiple treatments. When you have a dataset that includes the responses of a repeated measures test where the measurements are dependent (within subjects design), you may wish to check if there is a difference in the treatment effects. How would you conduct a repeated measures ANOVA to answer that question? . Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to do a two-way ANOVA test with interaction | How to do a two-way ANOVA test without interaction | How to compare two nested linear models using ANOVA | How to conduct a mixed designs ANOVA | How to perform an analysis of covariance (ANCOVA) | . ",
    "url": "/how-to-conduct-a-repeated-measures-anova/#description",
    "relUrl": "/how-to-conduct-a-repeated-measures-anova/#description"
  },"346": {
    "doc": "How to conduct a repeated measures ANOVA",
    "title": "Using pandas and pingouin, in Python",
    "content": "View this solution alone. We create a hypothetical repeated measures dataset where the 5 subjects undergo all 4 skin treatments and their rating of the treatment is measured. | 1 2 3 4 5 6 7 8 . | import pandas as pd df = pd.DataFrame( { 'Subject': [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5], 'Skin Treatment': ['W','X','Y','Z','W','X','Y','Z','W','X', 'Y','Z','W','X','Y','Z','W','X','Y','Z'], 'Rating': [7,5,8,4,8,10,7,5,7,6,5,4,7,7,4,5,8,8,6,6] } ) df.head() . | . | | Subject | Skin Treatment | Rating | . | 0 | 1 | W | 7 | . | 1 | 1 | X | 5 | . | 2 | 1 | Y | 8 | . | 3 | 1 | Z | 4 | . | 4 | 2 | W | 8 | . Before we conduct a repeated measures ANOVA, we need to decide which approach to use - Univariate or Multivariate. We decide this using Mauchly’s test of sphericity. If we fail to reject the null hypothesis then we use the univariate approach. | $H_0 =$ the sphericity assumption holds | $H_A =$ the sphericity assumption is violated | . We use the pingouin statistics package to conduct the test. Most of the parameters below are self-explanatory, except that dv stands for dependent variable. | 1 2 . | import pingouin as pg pg.sphericity( dv='Rating', within='Skin Treatment', subject='Subject', method='mauchly', data=df ) . | . | 1 2 3 4 5 6 7 8 9 . | /opt/conda/lib/python3.9/site-packages/outdated/utils.py:14: OutdatedPackageWarning: The package pingouin is out of date. Your version is 0.4.0, the latest is 0.5.0. Set the environment variable OUTDATED_IGNORE=1 to disable these warnings. return warn( SpherResults(spher=True, W=0.06210054956238558, chi2=7.565056754547507, dof=5, pval=0.20708214225927316) . | . Since the $p$ value of skin_treatment is about $0.2071$, we fail to reject the sphericity assumption at a 5% significance level and use the univariate approach to conduct the repeated measures ANOVA. | 1 2 . | # Compute a repeated measures ANOVA using a function pingouin adds to our DataFrame: df.rm_anova( dv='Rating', within='Skin Treatment', subject='Subject', detailed=False ) . | . | | Source | ddof1 | ddof2 | F | p-unc | np2 | eps | . | 0 | Skin Treatment | 3 | 12 | 5.117647 | 0.016501 | 0.56129 | 0.541199 | . Since the $p$ value of about $0.017$ is less than 0.05, we conclude that there is significant evidence of a treatment effect. Note: If there is more than 1 repeated measures factor, you can add a list of them to the within parameter and conduct the test. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-conduct-a-repeated-measures-anova/#using-pandas-and-pingouin-in-python",
    "relUrl": "/how-to-conduct-a-repeated-measures-anova/#using-pandas-and-pingouin-in-python"
  },"347": {
    "doc": "How to conduct a repeated measures ANOVA",
    "title": "Using rstatix and tidyr and car, in R",
    "content": "View this solution alone. We create a hypothetical repeated measures dataset where the 5 subjects undergo all 4 skin treatments and their rating of the treatment is measured. | 1 2 3 4 5 6 . | subject &lt;- as.factor(c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5)) skin.treatment &lt;- c('W','X','Y','Z','W','X','Y','Z','W','X', 'Y','Z','W','X','Y','Z','W','X','Y','Z') rating &lt;- c(7,5,8,4,8,10,7,5,7,6,5,4,7,7,4,5,8,8,6,6) df &lt;- data.frame(subject,skin.treatment,rating) head(df) . | . | 1 2 3 4 5 6 7 . | subject skin.treatment rating 1 1 W 7 2 1 X 5 3 1 Y 8 4 1 Z 4 5 2 W 8 6 2 X 10 . | . Before we conduct a repeated measures ANOVA, we need to decide which approach to use - Univariate or Multivariate. We decide this using Mauchly’s test of sphericity. If we fail to reject the null hypothesis then we use the univariate approach. | $H_0 =$ the sphericity assumption holds | $H_A =$ the sphericity assumption is violated | . We use the rstatix package to conduct the test. | The dependent variable is rating. | The within-group factor is skin.treatment. | The Error() term is critical in differentiating between a between subjects and within subjects model. It tells R that there is one observation per subject for each level of skin.treatment. | . | 1 2 3 . | # install.packages(\"rstatix\") # If you have not already installed it library(rstatix) anova_test(rating ~ skin.treatment + Error(subject/skin.treatment), data=df) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 . | Attaching package: ‘rstatix’ The following object is masked from ‘package:stats’: filter ANOVA Table (type III tests) $ANOVA Effect DFn DFd F p p&lt;.05 ges 1 skin.treatment 3 12 5.118 0.017 * 0.43 $`Mauchly's Test for Sphericity` Effect W p p&lt;.05 1 skin.treatment 0.062 0.207 $`Sphericity Corrections` Effect GGe DF[GG] p[GG] p[GG]&lt;.05 HFe DF[HF] p[HF] 1 skin.treatment 0.541 1.62, 6.49 0.051 0.858 2.57, 10.3 0.023 p[HF]&lt;.05 1 * . | . The $p$-value we care about in the output is under “Macuhly’s test for sphericity,” for the variable skin.treatment. Because the $p$-value is 0.207, we fail to reject the sphericity assumption at a 5% significance level and use the univariate approach. to conduct the repeated measures ANOVA. Repeated measures ANOVA - univariate . | 1 2 . | aov1 &lt;- aov(rating ~ skin.treatment + Error(subject/skin.treatment), data=df) summary(aov1) . | . | 1 2 3 4 5 6 7 8 9 10 . | Error: subject Df Sum Sq Mean Sq F value Pr(&gt;F) Residuals 4 11.8 2.95 Error: subject:skin.treatment Df Sum Sq Mean Sq F value Pr(&gt;F) skin.treatment 3 21.75 7.250 5.118 0.0165 * Residuals 12 17.00 1.417 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . You can find the $p$-value at the end of the row of output marked for skin.treatment; it is 0.0165. This is less than 0.05, so we conclude that there is significant evidence of a treatment effect. Repeated measures ANOVA - multivariate . If instead the first test had rejected the sphericity assumption, we would have used a multivariate approach for the repeated measures ANOVA. We show here how to do such a test, even though it does not apply to this situation. We must first reorganize the data into a matrix where each row represents a single subject, and columns represent levels of the treatment factor. This is possible using the tidyr package. | 1 2 3 4 5 . | # install.packages(\"tidyr\") # If you have not already installed it library(tidyr) multi.data &lt;- spread(df, skin.treatment, rating) multi.data &lt;- as.matrix(multi.data[,-c(1)]) multi.data . | . | 1 2 3 4 5 6 . | W X Y Z [1,] 7 5 8 4 [2,] 8 10 7 5 [3,] 7 6 5 4 [4,] 7 7 4 5 [5,] 8 8 6 6 . | . We then create a multivariate model and also set up a variable that defines the design of the study. | 1 2 3 4 . | # In this model there are no between-subjects factors, so we write ~ 1: multi.ml &lt;- lm(multi.data ~ 1) # The design of the study is a single factor with four levels: rfactor &lt;- factor(c(\"f1\", \"f2\", \"f3\", \"f4\")) . | . Conduct the repeated measures ANOVA using a multivariate approach. This requires creating a new model using the Anova() function that calculates ANOVA tables. The car package provides the Anova() function. The parameters have the following meanings. | idata includes information about the number of levels, in this case four. | idesign states that rfactor describes a repeated-measures variable. | type tells Anova() to calculate the “Type-III” sums of squares when forming the ANOVA table. | multivariate suppresses output about multivariate statistical tests, which are relevant only when the experimental design includes multiple dependent variables. | . | 1 2 3 4 . | # install.packages(\"car\") # If you have not already installed it library(car) multi.ml &lt;- Anova(multi.ml, idata=data.frame(rfactor), idesign = ~rfactor, type=\"III\") summary(multi.ml, multivariate=FALSE) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . | Loading required package: carData Univariate Type III Repeated-Measures ANOVA Assuming Sphericity Sum Sq num Df Error SS den Df F value Pr(&gt;F) (Intercept) 806.45 1 11.8 4 273.3729 7.837e-05 *** rfactor 21.75 3 17.0 12 5.1176 0.0165 * --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Mauchly Tests for Sphericity Test statistic p-value rfactor 0.062101 0.20708 Greenhouse-Geisser and Huynh-Feldt Corrections for Departure from Sphericity GG eps Pr(&gt;F[GG]) rfactor 0.5412 0.05068 . --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 HF eps Pr(&gt;F[HF]) rfactor 0.858156 0.02319302 . | . Although this test was run just as an example, and does not actually apply in this dataset, the output shows a $p$-value of 0.0165, at the end of the first rfactor row. That $p$-value could be compared to a chosen $\\alpha$. (We also see that Mauchly’s test was performed, which is not significant, and is the reason this data actually demands a univariate approach.) . Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-conduct-a-repeated-measures-anova/#using-rstatix-and-tidyr-and-car-in-r",
    "relUrl": "/how-to-conduct-a-repeated-measures-anova/#using-rstatix-and-tidyr-and-car-in-r"
  },"348": {
    "doc": "How to conduct a repeated measures ANOVA",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-conduct-a-repeated-measures-anova/#topics-that-include-this-task",
    "relUrl": "/how-to-conduct-a-repeated-measures-anova/#topics-that-include-this-task"
  },"349": {
    "doc": "How to conduct a repeated measures ANOVA",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-conduct-a-repeated-measures-anova/#opportunities",
    "relUrl": "/how-to-conduct-a-repeated-measures-anova/#opportunities"
  },"350": {
    "doc": "How to convert a text column into dates (in Python, using pandas)",
    "title": "How to convert a text column into dates (in Python, using pandas)",
    "content": "# How to convert a text column into dates (in Python, using pandas) [See all solutions.](../how-to-convert-a-text-column-into-dates) ## Task When loading data, many software systems make intelligent guesses about the format and data type of each column, but sometimes that is not sufficient. If you have a column of text that should be interpreted as dates, how can we ask the software to convert it? ## Solution Let's create a small example DataFrame to use here (using the method from [how to create a data frame from scratch](../how-to-create-a-data-frame-from-scratch)). Naturally, you would apply this solution to your own data instead. ```python import pandas as pd df = pd.DataFrame( { 'Date' : [ '5/7/19', '5/10/19', '5/11/19' ], 'Event' : [ 'Work', 'Party', 'More work' ] } ) df ``` | | Date | Event | . | 0 | 5/7/19 | Work | . | 1 | 5/10/19 | Party | . | 2 | 5/11/19 | More work | . If you've already got the data in a DataFrame column, and you wish to convert it to dates, use the `pd.to_datetime` function, which will do its best to read whatever format your dates are in: ```python df['Date'] = pd.to_datetime( df['Date'] ) df ``` | | Date | Event | . | 0 | 2019-05-07 | Work | . | 1 | 2019-05-10 | Party | . | 2 | 2019-05-11 | More work | . But if they aren't in a standard format, you can specify just about any format as in the following example. [See the Python documentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) for format details. ~~~python # If the dates had been, for example, 5-7-2019 10:15:00 df['Date'] = pd.to_datetime( df['Date'], format=\"%m-%d-%Y %H:%M:%S\" ) ~~~ It's often easier to handle date conversions while reading the data. You can tell pandas to read dates in most of the common date formats using any of the following methods. ~~~python # Any columns that look like dates, treat as dates: df = pd.read_csv( \"example.csv\", parse_dates=True ) # Convert the specific columns you name into dates: df = pd.read_csv( \"example.csv\", parse_dates=['col1','col2'] ) # If the date is spread over multiple columns, do this: # (Let's say the year, month, and day are in columns, 4, 5, and 6.) df = pd.read_csv( \"example.csv\", parse_dates=[[4,5,6]] ) # Note the double brackets, and indices start counting at zero. ~~~ Content last modified on 10 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to convert a text column into dates/Python, using pandas.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-convert-a-text-column-into-dates-in-python-using-pandas/",
    "relUrl": "/how-to-convert-a-text-column-into-dates-in-python-using-pandas/"
  },"351": {
    "doc": "How to convert a text column into dates (in R)",
    "title": "How to convert a text column into dates (in R)",
    "content": "# How to convert a text column into dates (in R) [See all solutions.](../how-to-convert-a-text-column-into-dates) ## Task When loading data, many software systems make intelligent guesses about the format and data type of each column, but sometimes that is not sufficient. If you have a column of text that should be interpreted as dates, how can we ask the software to convert it? ## Solution Let's create a small example DataFrame to use here (using the method from [how to create a data frame from scratch](../how-to-create-a-data-frame-from-scratch)). Naturally, you would apply this solution to your own data instead. ```R df <- data.frame( Date = c( '5/7/19', '5/10/19', '5/11/19' ), Event = c( 'Work', 'Party', 'More work' ) ) df ``` Date Event 1 5/7/19 Work 2 5/10/19 Party 3 5/11/19 More work We use the `as.Date()` function to convert a text column into dates. If the input dates are not in the standard format, we can use the `format=` argument to change the format. Note the difference between `%y` and `%Y`: The `%y` code means a 2-digit year, but the `%Y` code means a 4-digit year. ```R df$Date = as.Date( df$Date, format='%m/%d/%y' ) df ``` Date Event 1 2019-05-07 Work 2 2019-05-10 Party 3 2019-05-11 More work It's often easier to handle date conversions while reading the data file. You can use the `read_csv()` function in the `readr` package, which will automatically recognize dates in some common formats. Additionaly, you can use the `anytime()` function in the `anytime` package to automatically parse strings as dates regardless of the format. ```R # Use anytime() to attempt to parse various formats: library(anytime) examples <- c( \"Nov 01 2022\", \"2022-11-01\", \"22-11-01\" ) anytime( examples ) ``` [1] \"2022-11-01 UTC\" \"2022-11-01 UTC\" NA Note that it succeeded in two cases, but not the third. Content last modified on 10 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to convert a text column into dates/R.Rmd). Contributed by Ni Shi (shi_ni@bentley.edu) ",
    "url": "/how-to-convert-a-text-column-into-dates-in-r/",
    "relUrl": "/how-to-convert-a-text-column-into-dates-in-r/"
  },"352": {
    "doc": "How to convert a text column into dates",
    "title": "How to convert a text column into dates",
    "content": " ",
    "url": "/how-to-convert-a-text-column-into-dates/",
    "relUrl": "/how-to-convert-a-text-column-into-dates/"
  },"353": {
    "doc": "How to convert a text column into dates",
    "title": "Description",
    "content": "When loading data, many software systems make intelligent guesses about the format and data type of each column, but sometimes that is not sufficient. If you have a column of text that should be interpreted as dates, how can we ask the software to convert it? . ",
    "url": "/how-to-convert-a-text-column-into-dates/#description",
    "relUrl": "/how-to-convert-a-text-column-into-dates/#description"
  },"354": {
    "doc": "How to convert a text column into dates",
    "title": "Using pandas, in Python",
    "content": "View this solution alone. Let’s create a small example DataFrame to use here (using the method from how to create a data frame from scratch). Naturally, you would apply this solution to your own data instead. | 1 2 3 4 . | import pandas as pd df = pd.DataFrame( { 'Date' : [ '5/7/19', '5/10/19', '5/11/19' ], 'Event' : [ 'Work', 'Party', 'More work' ] } ) df . | . | | Date | Event | . | 0 | 5/7/19 | Work | . | 1 | 5/10/19 | Party | . | 2 | 5/11/19 | More work | . If you’ve already got the data in a DataFrame column, and you wish to convert it to dates, use the pd.to_datetime function, which will do its best to read whatever format your dates are in: . | 1 2 . | df['Date'] = pd.to_datetime( df['Date'] ) df . | . | | Date | Event | . | 0 | 2019-05-07 | Work | . | 1 | 2019-05-10 | Party | . | 2 | 2019-05-11 | More work | . But if they aren’t in a standard format, you can specify just about any format as in the following example. See the Python documentation for format details. | 1 2 . | # If the dates had been, for example, 5-7-2019 10:15:00 df['Date'] = pd.to_datetime( df['Date'], format=\"%m-%d-%Y %H:%M:%S\" ) . | . It’s often easier to handle date conversions while reading the data. You can tell pandas to read dates in most of the common date formats using any of the following methods. | 1 2 3 4 5 6 7 8 9 10 . | # Any columns that look like dates, treat as dates: df = pd.read_csv( \"example.csv\", parse_dates=True ) # Convert the specific columns you name into dates: df = pd.read_csv( \"example.csv\", parse_dates=['col1','col2'] ) # If the date is spread over multiple columns, do this: # (Let's say the year, month, and day are in columns, 4, 5, and 6.) df = pd.read_csv( \"example.csv\", parse_dates=[[4,5,6]] ) # Note the double brackets, and indices start counting at zero. | . Content last modified on 10 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-convert-a-text-column-into-dates/#using-pandas-in-python",
    "relUrl": "/how-to-convert-a-text-column-into-dates/#using-pandas-in-python"
  },"355": {
    "doc": "How to convert a text column into dates",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s create a small example DataFrame to use here (using the method from how to create a data frame from scratch). Naturally, you would apply this solution to your own data instead. | 1 2 3 4 5 . | df &lt;- data.frame( Date = c( '5/7/19', '5/10/19', '5/11/19' ), Event = c( 'Work', 'Party', 'More work' ) ) df . | . | 1 2 3 4 . | Date Event 1 5/7/19 Work 2 5/10/19 Party 3 5/11/19 More work . | . We use the as.Date() function to convert a text column into dates. If the input dates are not in the standard format, we can use the format= argument to change the format. Note the difference between %y and %Y: The %y code means a 2-digit year, but the %Y code means a 4-digit year. | 1 2 . | df$Date = as.Date( df$Date, format='%m/%d/%y' ) df . | . | 1 2 3 4 . | Date Event 1 2019-05-07 Work 2 2019-05-10 Party 3 2019-05-11 More work . | . It’s often easier to handle date conversions while reading the data file. You can use the read_csv() function in the readr package, which will automatically recognize dates in some common formats. Additionaly, you can use the anytime() function in the anytime package to automatically parse strings as dates regardless of the format. | 1 2 3 4 . | # Use anytime() to attempt to parse various formats: library(anytime) examples &lt;- c( \"Nov 01 2022\", \"2022-11-01\", \"22-11-01\" ) anytime( examples ) . | . | 1 . | [1] \"2022-11-01 UTC\" \"2022-11-01 UTC\" NA . | . Note that it succeeded in two cases, but not the third. Content last modified on 10 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-convert-a-text-column-into-dates/#solution-in-r",
    "relUrl": "/how-to-convert-a-text-column-into-dates/#solution-in-r"
  },"356": {
    "doc": "How to convert a text column into dates",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA346 | . ",
    "url": "/how-to-convert-a-text-column-into-dates/#topics-that-include-this-task",
    "relUrl": "/how-to-convert-a-text-column-into-dates/#topics-that-include-this-task"
  },"357": {
    "doc": "How to convert a text column into dates",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-convert-a-text-column-into-dates/#opportunities",
    "relUrl": "/how-to-convert-a-text-column-into-dates/#opportunities"
  },"358": {
    "doc": "How to create a box (and whisker) plot (in Python, using Matplotlib)",
    "title": "How to create a box (and whisker) plot (in Python, using Matplotlib)",
    "content": "# How to create a box (and whisker) plot (in Python, using Matplotlib) [See all solutions.](../how-to-create-a-box-and-whisker-plot) ## Task A box plot, or a box and whisker plot, shows the quartiles of a single variable from a dataset (one of which is the median) and may also show the outliers. It is a simplified way to see the distribution of a variable. Sometimes multiple box plots (one for each of several variables) are shown side-by-side on a plot, to compare the variables. How can we create such graphs? Related topics: * [How to create basic plots](../how-to-create-basic-plots) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create a histogram](../how-to-create-a-histogram) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some fake data using Python lists, for simplicity. But everything we show below works also if your data is in columns of a DataFrame, such as `df['age']`. ```python patient_id = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] patient_height = [ 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ] patient_weight = [ 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ] ``` The conventional way to import matplotlib in Python is as follows. ```python import matplotlib.pyplot as plt ``` To create a box-and-whisker plot, sometimes called just a box plot requires just one line of code, plus one to show the plot. ```python plt.boxplot( patient_height ) plt.show() ``` ![png](data:image/png;base64,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 ) You can show more than one variable's box plot side-by-side by forming a list of the data. ```python plt.boxplot( [ patient_height, patient_weight ] ) plt.show() ``` ![png](data:image/png;base64,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 ) Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a box (and whisker) plot/Python, using Matplotlib.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-create-a-box-and-whisker-plot-in-python-using-matplotlib/",
    "relUrl": "/how-to-create-a-box-and-whisker-plot-in-python-using-matplotlib/"
  },"359": {
    "doc": "How to create a box (and whisker) plot (in R)",
    "title": "How to create a box (and whisker) plot (in R)",
    "content": "# How to create a box (and whisker) plot (in R) [See all solutions.](../how-to-create-a-box-and-whisker-plot) ## Task A box plot, or a box and whisker plot, shows the quartiles of a single variable from a dataset (one of which is the median) and may also show the outliers. It is a simplified way to see the distribution of a variable. Sometimes multiple box plots (one for each of several variables) are shown side-by-side on a plot, to compare the variables. How can we create such graphs? Related topics: * [How to create basic plots](../how-to-create-basic-plots) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create a histogram](../how-to-create-a-histogram) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some fake data using vectors, for simplicity. But everything we show below works also if your data is in columns of a DataFrame. ```R patient_id <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) patient_height <- c(60, 64, 64, 65, 66, 66, 70, 72, 72, 76) patient_weight <- c(141, 182, 169, 204, 138, 198, 180, 175, 244, 196) ``` We can use R's boxplot() function to make the plot. ```R boxplot(patient_weight) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAACdlBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMVFRUWFhYX FxcYGBgZGRkaGhocHBwdHR0eHh4fHx8gICAhISEiIiIjIyMlJSUpKSkqKiosLCwtLS0vLy8w MDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFC QkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tNTU1OTk5PT09RUVFTU1NUVFRVVVVWVlZX V1dYWFhZWVlaWlpcXFxeXl5fX19gYGBiYmJjY2NlZWVmZmZpaWlqampra2tsbGxtbW1ubm5v b29wcHBxcXFycnJzc3N0dHR1dXV3d3d5eXl6enp8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OE hISFhYWHh4eIiIiKioqLi4uNjY2Ojo6RkZGTk5OVlZWYmJiZmZmampqbm5udnZ2fn5+goKCh oaGioqKjo6OoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCzs7O0tLS1tbW2tra3t7e4uLi5 ubm7u7u9vb2+vr6/v7/AwMDBwcHExMTFxcXGxsbHx8fIyMjJycnLy8vMzMzNzc3Q0NDR0dHS 0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd3d3e3t7f39/i4uLj4+Pk5OTl5eXm 5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4 +Pj5+fn6+vr7+/v8/Pz9/f3+/v7///9YNvAxAAAACXBIWXMAABJ0AAASdAHeZh94AAAYq0lE QVR4nO3d/5ddVXnA4TOESUwkKCimMV8oVJsA2tIqGovaNiJVwWgzRAVMsOBYmiAKBKNpabVU UWKp1hJrxSqMaEUlomBjVUxEIyQxzPxHZWaSzMhinSxu3nfv3HOe54e5e627vbkrbz6LmXO2 d5op4KQ1td8AdIGQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIICQIICQIECBkL75AAyVbz7/f+X5Id3fwJC5/3n/M88P6b7m UPqfAYEONfc97/+NkOBZhAQBhAQBhAQBhAQBhAQBhAQBhAQBhAQBhAQBhAQBhAQBhAQBhAQB hAQBhAQBhNQnD46vXz/+YO130UlC6pFbF7zugx983YJba7+PLhJSf3x24a7ph10LP1f7nXSQ kPrjghtmH2+4sO776CQh9cavm/+eXXxt5EDdd9JFQuqNvc33Zxffa/bWfSddJKTeOPyCL8wu /u0Fh+u+ky4SUn+87c2T0w9Pv+lttd9JBwmpP773onf9ZGrqJ+960fdrv5MOElKPTLyyWb26 eeVE7ffRRaVDmnzk3l27dj96gl1CyvH0xKc+9cDTtd9FJ5UNad/158x+4PjKm59s2yckhkzR kPae25w/tm379hs3LG/W7GvZKCSGTNGQNo3edXR1ZOfIlpaNQmLIFA1p2VVz6ytXtGwUEkOm aEijt8ytb1rYslFIDJmiIa26Ym59+eqWjUJiyBQNacvI7QdnVwe2NuMtG4XEkCka0v4Lm6WX jl17zcZ1S5pLft2yUUgMmbL3kQ7tWLtg+jbS6MV3HGnbJySGTPEjQk89PDGx50SZCIkhU+es 3RPj3219XkgMmTohPdbc0/q8kBgyZU82HLOhefOmTS0bhcSQKRpS8ztaNgqJIVM0pA8sWPul /dO+03x6//6WjUJiyJT9Gen+tSPv++XUc/+M9Pi733HcJUJiuBS+2PDb2xYv/9xzh7T/2vce d0nTdrsWTjnFr9r94NLmskdPdNXu74XEcKlw+fuTZ5+xTUh0S437SD99ZyMkuqXODdkvXv9Q 6/NCYshU+ziufT9qeVJIDJmyIT24ftVrd86e+x5vexUhMWSKhvTVRc2S0eb1M58fJCS6pGhI bxn9/OTBHaOvnv6tIkKiS4qGtOLd0193L1x/REh0S9lPEdo683Bns1lIdEvRkF7+1tnHDzXb hUSnFA1p88gnZn7F1eTG5rr3C4kOKRrS4yubN84sJje3//+RhMSQKXsf6edXX3d0dfd5QqJD Ts1fNCYkhoyQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQIICQ IICQIICQIICQIICQIICQIICQIEDpkCYfuXfXrt2PnmCXkBgyZUPad/05zYyVNz/Ztk9IDJmi Ie09tzl/bNv27TduWN6s2deyUUgMmaIhbRq96+jqyM6RLS0bhcSQKRrSsqvm1leuaNkoJIZM 0ZBGb5lb37SwZaOQGDJFQ1p1xdz68tUtG4XEkCka0paR2w/Org5sbcZbNgqJIVM0pP0XNksv Hbv2mo3rljSXtKUiJIZM2ftIh3asXTB9G2n04juOtO0TEkOm+BGhpx6emNhz6ASbhMSQqXbW bt+PWp4UEkOmbEgPrl/12p2z39SNt72KkBgyRUP66qJmyWjz+pnDQUKiS4qG9JbRz08e3DH6 6gNTQqJbioa04t3TX3cvXH/kOUL6zcduO+6vhMRwKXtEaOvMw53N5ucIae9rLzpuZfOrQf8M qKFoSC9/6+zjh5rtvrWjU4qGtHnkE4enHyc3Nte9X0h0SNGQHl/ZvHFmMbm5aYREh5S9j/Tz q687urr7PCHRIT5FCAI4IgQBHBGCAI4IQQBHhCDAqXNEaD4hMWROnSNC8wmJIeOIEARwRAgC OCIEARwRggCOCEEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEA IUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEA IUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEA IUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEAIUEA 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 VUsXveSizROt24SUxcmGJD5FqF9c/k5SLaTH97Q8KaQsQkpSLaTxtlcRUhYhJRFSvwgpiZD6 xcmGJEVDumieZUKqwcmGJEVDOu20RcctEBIdUjSk8aVzl+p8a0eXFA3p8AWvOnxsLSS6pOzF hocW33BsKaQqnGxIUviq3RO/OLb6yq0t24SUxeXvJI4I9YuQkgipX4SUREj9IqQkQuoXJxuS CKlfnGxIIiQIICQIICQIIKR+cbIhiZD6xeXvJELqFyElEVK/CCmJkPpFSEmE1C9ONiQRUr84 2ZBESBBASBBASBBASP3iZEMSIfWLy99JhNQvQkoipH4RUhIh9YuQkgipX5xsSCKkfnGyIYmQ IICQIICQIICQ+sXJhiRC6heXv5MIqV+ElERI/SKkJELqFyElEVK/ONmQREj94mRDEiFBACFB ACFBACH1i5MNSYTULy5/JxFSvwgpiZD6RUhJhNQvQkoipH5xsiGJkPrFyYYkQoIAQoIAQoIA QuoXJxuSCKlfXP5OIqR+EVISIfWLkJIIqV+ElERI/eJkQxIh9YuTDUmEBAGEBAGEBAGE1C9O NiQRUr+4/J1ESP0ipCRC6hchJRFSvwgpiZD6xcmGJELqFycbkggJAggJAggJAgipX5xsSCKk fnH5O4mQ+kVISYTUL0JKIqR+EVISIfWLkw1JhNQvTjYkERIEKB3S5CP37tq1+9ET7BISQ6Zs SPuuP6eZsfLmJ9v2CYkhUzSkvec2549t2779xg3LmzX7WjYKKYuTDUmKhrRp9K6jqyM7R7a0 bBRSFpe/kxQNadlVc+srV7RsFFIWISUpGtLoLXPrmxa2bBRSFiElKRrSqivm1pevbtkopCxC SlI0pC0jtx+cXR3Y2oy3bBRSFicbkhQNaf+FzdJLx669ZuO6Jc0lbakIKYuTDUnK3kc6tGPt gunbSKMX33GkbZ+QGDLFjwg99fDExJ5DJ9gkJIZMnbN2T4x/t/V5ITFk6oT0WHNP6/NCyuJk Q5KyJxuO2dC8ufXykZCyuPydpGhIze9o2SikLEJKUjSkDyxY+6X9077TfHr//paNQsoipCRl f0a6f+3I+3459dw/I/3vay46bpWQkggpSeGLDb+9bfHyzz13SE9+7Lbj3tOc6AI5g3GyIUnx q3Y/uLS57NETXbW7T0hJnGxIUuHy9yfPPmObkOiWGveRfvrORkh0S50bsl+8/qHW54XEkKn2 cVyP72l5UkhZnGxIUi2k8bZXEVIWl7+TCKlfhJRESP0ipCRFQ7ponmVCqkFISYqGdNppi45b IKRBfOSsk7No0Um+wEdq/w2cooqGNL507lKdb+0Gsvfek/OZz5zkCzgZ8dyKhnT4glcdPrYW El1S9mLDQ4tvOLYUEl1S+KrdE784tvrKrS3bhMSQOTV/0ZiQGDJCggBCggBCggBCggBCggBC ggBCggBCggBCggBCggBCggBCggBCggBCggBCggBCggBCggCnZkj3NzBk7n/e/8zzQ5r65gMw VL75/P+VFwgJuk9IEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBI EEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBI EEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBI EEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBI EEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBI EEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBI EEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEEBIEOD/AbewPbJ0 bhTaAAAAAElFTkSuQmCC) You can show more than one variable’s box plot side-by-side by passing both variables into the boxplot() function. ```R boxplot(patient_height, patient_weight) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAACN1BMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsNDQ0ODg4PDw8RERESEhITExMUFBQWFhYYGBgaGhob GxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYpKSksLCwvLy8wMDAxMTEyMjIz MzM0NDQ1NTU4ODg6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBDQ0NERERFRUVGRkZISEhKSkpLS0tN TU1OTk5PT09QUFBRUVFTU1NUVFRVVVVWVlZXV1dZWVlaWlpbW1tcXFxfX19gYGBhYWFiYmJj Y2NlZWVmZmZnZ2dpaWlqampra2tsbGxtbW1ubm5vb29wcHBzc3N0dHR1dXV3d3d4eHh5eXl6 enp8fHx9fX1+fn5/f3+AgICCgoKDg4OFhYWGhoaHh4eIiIiKioqLi4uOjo6Pj4+RkZGTk5OU lJSVlZWWlpaXl5eYmJiZmZmampqbm5ufn5+goKCioqKjo6OlpaWmpqapqamqqqqrq6usrKyt ra2urq6vr6+zs7O0tLS1tbW4uLi7u7u9vb2+vr7AwMDBwcHExMTFxcXGxsbHx8fKysrLy8vM zMzNzc3Pz8/Q0NDR0dHS0tLT09PW1tbX19fY2NjZ2dna2trb29vc3Nzd3d3e3t7f39/i4uLm 5ubn5+fq6urr6+vs7Ozt7e3u7u7v7+/x8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7 +/v8/Pz9/f3+/v7////zt+WFAAAACXBIWXMAABJ0AAASdAHeZh94AAAVH0lEQVR4nO3d+5dd ZX3H8R3SSeTSoOUiSajGChIFBYOtqEEroGYIonIJ4IhIuJQGrEYtXiuFoJVAtQIRKioRJQoE BYWkIfPHNZlAZsNidibP+WTvs89+vX6Y2WvNM2ee+c55L87a8zCpZoGRVV1vACaBkCBASBAg JAgQEgQICQKEBAFCggAhQYCQIEBIECAkCBASBAgJAoQEAUKCACFBgJAgQEgQICQIEBIECAkC hAQBQoIAIUGAkCBASBAgJAgQEgQICQKEBAFCggAhQYCQIEBIECAkCBASBAgJAoQEAUKCACFB gJAgQEgQICQIEBIECAkChAQBQoIAIUGAkCBASBAgJAgQEgQICQKEBAFCggAhQYCQIEBIECAk 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 he3e3fUO+m1Q8xMSBAgJAoQEAUKCACFBgJAgQEgQICQIEBIECAkChAQBQoIAIUGAkCBASBAg JAgQ0oL2fum4tV3vocd2X79y2er1P+96G20R0kKeOOckIZV7bnX1ka98+m/e8r9db6QlQlrA n45/787lQip2VfW1A2/vqy7qeiMtEdICnrt+76yQyl134d4Db/cfv6rrjbRESA2ENKqXp97f 9RZaIqQGQhrVv829wBsCITUQ0ogeWvaB/+t6Dy0RUgMhjeY/lp/zXNd7aIuQGghpFPtvrj78 56430RohNRDSCPZvrK7Z1/Um2iOkBkIawabqX7reQpuE1EBI5e6rNnW9hVYJaQEPzczMLD31 wJtnu95JP72jumZmzkD+kr6QFnBH9aqdXe+kn14bX/X7rnfSDiFBgJAgQEgQICQIEBIECAkC hAQBQoIAIUGAkCBASBAgJAgQEgQICQKEBAFCggAhQYCQIEBIECAkCBASBAgJAoQEAUKCACFB gJAgQEgQICQIEBIECAkChAQBQoIAIUGAkCBASBAgJAgQEgQICQKEBAFCggAhQYCQIEBIECAk CBASBAgJAoQEAUKCACFBgJAgQEgQICQIEBIECAkChAQBQoIAIUGAkCBASBAgJAgQEgQICQKE BAFCggAhQYCQIEBIECAkCBASBAgJAoQEAUKCACFBgJAgQEgQICQIEBIECAkChAQB/w+sJLiq zkZ8mwAAAABJRU5ErkJggg==) Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a box (and whisker) plot/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-create-a-box-and-whisker-plot-in-r/",
    "relUrl": "/how-to-create-a-box-and-whisker-plot-in-r/"
  },"360": {
    "doc": "How to create a box (and whisker) plot",
    "title": "How to create a box (and whisker) plot",
    "content": " ",
    "url": "/how-to-create-a-box-and-whisker-plot/",
    "relUrl": "/how-to-create-a-box-and-whisker-plot/"
  },"361": {
    "doc": "How to create a box (and whisker) plot",
    "title": "Description",
    "content": "A box plot, or a box and whisker plot, shows the quartiles of a single variable from a dataset (one of which is the median) and may also show the outliers. It is a simplified way to see the distribution of a variable. Sometimes multiple box plots (one for each of several variables) are shown side-by-side on a plot, to compare the variables. How can we create such graphs? . Related topics: . | How to create basic plots | How to add details to a plot | How to create a histogram | How to change axes, ticks, and scale in a plot | How to create bivariate plots to compare groups | How to plot interaction effects of treatments | . ",
    "url": "/how-to-create-a-box-and-whisker-plot/#description",
    "relUrl": "/how-to-create-a-box-and-whisker-plot/#description"
  },"362": {
    "doc": "How to create a box (and whisker) plot",
    "title": "Using Matplotlib, in Python",
    "content": "View this solution alone. We will create some fake data using Python lists, for simplicity. But everything we show below works also if your data is in columns of a DataFrame, such as df['age']. | 1 2 3 . | patient_id = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] patient_height = [ 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ] patient_weight = [ 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ] . | . The conventional way to import matplotlib in Python is as follows. | 1 . | import matplotlib.pyplot as plt . | . To create a box-and-whisker plot, sometimes called just a box plot requires just one line of code, plus one to show the plot. | 1 2 . | plt.boxplot( patient_height ) plt.show() . | . You can show more than one variable’s box plot side-by-side by forming a list of the data. | 1 2 . | plt.boxplot( [ patient_height, patient_weight ] ) plt.show() . | . Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-box-and-whisker-plot/#using-matplotlib-in-python",
    "relUrl": "/how-to-create-a-box-and-whisker-plot/#using-matplotlib-in-python"
  },"363": {
    "doc": "How to create a box (and whisker) plot",
    "title": "Solution, in R",
    "content": "View this solution alone. We will create some fake data using vectors, for simplicity. But everything we show below works also if your data is in columns of a DataFrame. | 1 2 3 . | patient_id &lt;- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) patient_height &lt;- c(60, 64, 64, 65, 66, 66, 70, 72, 72, 76) patient_weight &lt;- c(141, 182, 169, 204, 138, 198, 180, 175, 244, 196) . | . We can use R’s boxplot() function to make the plot. | 1 . | boxplot(patient_weight) . | . You can show more than one variable’s box plot side-by-side by passing both variables into the boxplot() function. | 1 . | boxplot(patient_height, patient_weight) . | . Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-box-and-whisker-plot/#solution-in-r",
    "relUrl": "/how-to-create-a-box-and-whisker-plot/#solution-in-r"
  },"364": {
    "doc": "How to create a box (and whisker) plot",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA346 | . ",
    "url": "/how-to-create-a-box-and-whisker-plot/#topics-that-include-this-task",
    "relUrl": "/how-to-create-a-box-and-whisker-plot/#topics-that-include-this-task"
  },"365": {
    "doc": "How to create a box (and whisker) plot",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-create-a-box-and-whisker-plot/#opportunities",
    "relUrl": "/how-to-create-a-box-and-whisker-plot/#opportunities"
  },"366": {
    "doc": "How to create a data frame from scratch (in Python)",
    "title": "How to create a data frame from scratch (in Python)",
    "content": "# How to create a data frame from scratch (in Python) [See all solutions.](../how-to-create-a-data-frame-from-scratch) ## Task Sometimes it is useful to create a small table of data directly in code, without first needing to store the data in a file and load it from there. This can be useful for creating small tables for testing purposes, or for creating small lookup tables that hold abbreviations, IDs, etc. What's the easiest way to build such a table? ## Solution In pandas, the `pd.DataFrame` function can construct new DataFrames. Just provide it with a dictionary whose keys are the column headers and whose values are the column contents. Here's an example: ```python import pandas as pd df = pd.DataFrame( { 'Last name' : [ 'Potter', 'Weasley', 'Granger', 'Malfoy' ], 'First name' : [ 'Harry', 'Ron', 'Hermione', 'Draco' ], 'House' : [ 'Gryffindor', 'Gryffindor', 'Gryffindor', 'Slytherin' ] } ) df ``` | | Last name | First name | House | . | 0 | Potter | Harry | Gryffindor | . | 1 | Weasley | Ron | Gryffindor | . | 2 | Granger | Hermione | Gryffindor | . | 3 | Malfoy | Draco | Slytherin | . Content last modified on 26 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a data frame from scratch/Python.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-create-a-data-frame-from-scratch-in-python/",
    "relUrl": "/how-to-create-a-data-frame-from-scratch-in-python/"
  },"367": {
    "doc": "How to create a data frame from scratch (in R)",
    "title": "How to create a data frame from scratch (in R)",
    "content": "# How to create a data frame from scratch (in R) [See all solutions.](../how-to-create-a-data-frame-from-scratch) ## Task Sometimes it is useful to create a small table of data directly in code, without first needing to store the data in a file and load it from there. This can be useful for creating small tables for testing purposes, or for creating small lookup tables that hold abbreviations, IDs, etc. What's the easiest way to build such a table? ## Solution In R, the `data.frame` function can be used to build data frames. Each column in your data should be a separate parameter, with its name provided, followed by an equals sign, followed by the vector of column contents, as shown in the example below. ```R data <- data.frame( last.name = c( 'Potter', 'Weasley', 'Granger', 'Malfoy' ), first.name = c( 'Harry', 'Ron', 'Hermione', 'Draco' ), house = c( 'Griffindor', 'Griffindor', 'Griffindor', 'Slytherin' ) ) data ``` last.name first.name house 1 Potter Harry Griffindor 2 Weasley Ron Griffindor 3 Granger Hermione Griffindor 4 Malfoy Draco Slytherin Content last modified on 26 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a data frame from scratch/R.Rmd). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-create-a-data-frame-from-scratch-in-r/",
    "relUrl": "/how-to-create-a-data-frame-from-scratch-in-r/"
  },"368": {
    "doc": "How to create a data frame from scratch",
    "title": "How to create a data frame from scratch",
    "content": " ",
    "url": "/how-to-create-a-data-frame-from-scratch/",
    "relUrl": "/how-to-create-a-data-frame-from-scratch/"
  },"369": {
    "doc": "How to create a data frame from scratch",
    "title": "Description",
    "content": "Sometimes it is useful to create a small table of data directly in code, without first needing to store the data in a file and load it from there. This can be useful for creating small tables for testing purposes, or for creating small lookup tables that hold abbreviations, IDs, etc. What’s the easiest way to build such a table? . ",
    "url": "/how-to-create-a-data-frame-from-scratch/#description",
    "relUrl": "/how-to-create-a-data-frame-from-scratch/#description"
  },"370": {
    "doc": "How to create a data frame from scratch",
    "title": "Solution, in Python",
    "content": "View this solution alone. In pandas, the pd.DataFrame function can construct new DataFrames. Just provide it with a dictionary whose keys are the column headers and whose values are the column contents. Here’s an example: . | 1 2 3 4 5 6 7 . | import pandas as pd df = pd.DataFrame( { 'Last name' : [ 'Potter', 'Weasley', 'Granger', 'Malfoy' ], 'First name' : [ 'Harry', 'Ron', 'Hermione', 'Draco' ], 'House' : [ 'Gryffindor', 'Gryffindor', 'Gryffindor', 'Slytherin' ] } ) df . | . | | Last name | First name | House | . | 0 | Potter | Harry | Gryffindor | . | 1 | Weasley | Ron | Gryffindor | . | 2 | Granger | Hermione | Gryffindor | . | 3 | Malfoy | Draco | Slytherin | . Content last modified on 26 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-data-frame-from-scratch/#solution-in-python",
    "relUrl": "/how-to-create-a-data-frame-from-scratch/#solution-in-python"
  },"371": {
    "doc": "How to create a data frame from scratch",
    "title": "Solution, in R",
    "content": "View this solution alone. In R, the data.frame function can be used to build data frames. Each column in your data should be a separate parameter, with its name provided, followed by an equals sign, followed by the vector of column contents, as shown in the example below. | 1 2 3 4 5 6 . | data &lt;- data.frame( last.name = c( 'Potter', 'Weasley', 'Granger', 'Malfoy' ), first.name = c( 'Harry', 'Ron', 'Hermione', 'Draco' ), house = c( 'Griffindor', 'Griffindor', 'Griffindor', 'Slytherin' ) ) data . | . | 1 2 3 4 5 . | last.name first.name house 1 Potter Harry Griffindor 2 Weasley Ron Griffindor 3 Granger Hermione Griffindor 4 Malfoy Draco Slytherin . | . Content last modified on 26 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-data-frame-from-scratch/#solution-in-r",
    "relUrl": "/how-to-create-a-data-frame-from-scratch/#solution-in-r"
  },"372": {
    "doc": "How to create a data frame from scratch",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA346 | . ",
    "url": "/how-to-create-a-data-frame-from-scratch/#topics-that-include-this-task",
    "relUrl": "/how-to-create-a-data-frame-from-scratch/#topics-that-include-this-task"
  },"373": {
    "doc": "How to create a data frame from scratch",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-create-a-data-frame-from-scratch/#opportunities",
    "relUrl": "/how-to-create-a-data-frame-from-scratch/#opportunities"
  },"374": {
    "doc": "How to create a histogram (in Python, using Matplotlib)",
    "title": "How to create a histogram (in Python, using Matplotlib)",
    "content": "# How to create a histogram (in Python, using Matplotlib) [See all solutions.](../how-to-create-a-histogram) ## Task A histogram is a very common and useful data visualization. It displays an approximation of the distribution in single series of data points (one variable) by grouping the data into bins, each bin draw as a vertical bar. How can we create such a visualization? Related topics: * [How to create basic plots](../how-to-create-basic-plots) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some random data using NumPy, but that's just for demonstration purposes. You can apply the answer below to any data, even if it's stored just in plain Python lists. ```python import numpy as np data = np.random.normal( size=1000 ) ``` The conventional way to import matplotlib in Python is as follows. ```python import matplotlib.pyplot as plt ``` To create a histogram with 10 bins (the default): ```python plt.hist( data ) # or plt.hist( bins=20 ), or any number plt.show() ``` ![png](data:image/png;base64,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 ) The $y$ axis in a histogram is frequency, or number of occurrences. You can change it to probabilities instead. ```python plt.hist( data, density=True ) plt.show() ``` ![png](data:image/png;base64,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 ) You can also choose your own bin boundaries. ```python plt.hist( data, bins=range(-10,10,1) ) plt.show() ``` ![png](data:image/png;base64,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 ) Content last modified on 23 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a histogram/Python, using Matplotlib.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-create-a-histogram-in-python-using-matplotlib/",
    "relUrl": "/how-to-create-a-histogram-in-python-using-matplotlib/"
  },"375": {
    "doc": "How to create a histogram (in R)",
    "title": "How to create a histogram (in R)",
    "content": "# How to create a histogram (in R) [See all solutions.](../how-to-create-a-histogram) ## Task A histogram is a very common and useful data visualization. It displays an approximation of the distribution in single series of data points (one variable) by grouping the data into bins, each bin draw as a vertical bar. How can we create such a visualization? Related topics: * [How to create basic plots](../how-to-create-basic-plots) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some random data, but that’s just for demonstration purposes. You can apply the answer below to any data. Simply replace the data variable with your real data (a list, a column of a dataframe, etc.). ```R data <- rnorm(1000) ``` We can use R's hist() function to create the histogram. ```R hist(data) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAAC/VBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKD g4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSV lZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqan p6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5 ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrL y8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd 3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v 7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///9B8z1b AAAACXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3dC5xU5Xn48XdZhmWXIGKEIHe81DT9 pyBopImkVIwakYA1VTGmrJBqFHUTbIkJipJ4CVRNS9CoNbaxMQYVm2g1lRJtSWOjUtNotBXR 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 wTOaL1o4b3qTmbY94kRC6tWNTEg60v870p4bJtUX/hkpN/XWtqjzCKlXNzIh6ajqJUK7Xtiw YeP+Mnnnr6/rcgEh9eZGJiQd1b7Wbs8TP37pvfduOfmELseY3VXOcAohaa+AjtQhffXHhbff Ghp8cjfl6agT+dSuVzcyIelIHVLxO3UPmobTzv+YGfJixImE1KsbmZB0VBfSEUOeC97eV3du xImE1KsbmZB0VBXSG+bLxeM5oyJOJKRe3ciEpKOqkDabO4vHS3IRJ3oR0srFcX2akPqkqkJq G3Jt8Xj+QREnehHSoA9OjWk0IfVJ6UOa++TGNy87/J3g8PlBsyJO9CMkZzay9nxCSvrAknvz +e8O6vdExImEZENIHkkd0h03Lm2ZN2f6unx+1agHok4kJBtC8ojATxHavi/yrwnJhpA8wo/j ioWQ4p55Xf/zYntYe1kFEVIshBR7fv2JcY1s1l5WQYQUCyHVYP5sQkqCkGy0N7L2fEJKhJBs tDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2 fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqE kGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3 svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxC SoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBs tDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2 fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqE kGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3 svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxC SoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBs tDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2 fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqE kGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3 svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxC SoSQbLQ3svZ8QkqEkGy0N7L2fEJKhJBstDey9nxCSiS7If3iltgafNzI2vP/5KOx3/+3bdfe LJX05ZDOPfBDcXm5kdXnx3//93tIe7NU0pdDatbeSMyPq/FB7c1SCSHFor2R+vp8QiIkO4c2 svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2 svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2 svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2 svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2 svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2 svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8QiIkO4c2svZ8Qur1kJ7/yJS43u/ORurr 8wmp10N6MPfFuA50ZyP19fmE1PshebmR+vp8QhIK6ZOHxjXCy43U1+cTklBIg+YujWm6lxup r88nJKmQ+vhG6uvzCYmQmC8wv9+I2J/bz6h+t6VBSLFob6Q+Pz/2p/ZnN1W/29IgpHgLyXxH 5t9ESFEIifnxuBhS+0+q9xUAAAa9SURBVKa1a9as21zhLEJifi/Ody+k1kXDTdHYZTujziMk 5vfifOdC2jLBHNG8dPnyJXNHmomtESfaQ/ra0NjqnFlI5uvO/3Jd/F31tbSbfz9Sh7Qgt7rj qG1VXUvEifaQmo+5Pi53FpL5yvMHxN5UxzSn3fz7kTqkEfO7j88cE3FiREheLiTzXZk/OxMh 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) The y axis in a histogram is frequency, or the number of occurences. You can change it to probabilities instead. ```R hist(data, prob = TRUE) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAAC9FBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFycnJzc3N0dHR1dXV3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKD g4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSV lZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqan p6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5 ubm6urq7u7u8vLy9vb2/v7/AwMDCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrLy8vMzMzN zc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fZ2dna2trb29vc3Nzd3d3e3t7f39/g 4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy 8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///8WthuzAAAACXBIWXMA ABJ0AAASdAHeZh94AAAgAElEQVR4nO3df5yVZZ3/8WuAA8wgIpmEyC9/rW2bC6EmZbRu46r5 IyxNRW2ZoNUUk1yKLAV1UwxS2xRddc3N9luGimv5VVcil8r8wdJGWiL5XS3UUtAgUBzm/ud7 nzO/zhy97nPfZ64z7/u6zuv5eDRzONzn/tw71/XaMz/OoIkA9JtRXwAQAkICHCAkwAFCAhwg JMABQgIcICTAAUICHCAkwAFCAhwgJMABQgIcICTAAUICHCAkwAFCAhwgJMABQgIcICTAAUIC HCAkwAFCAhwgJMABQgIcICTAAUICHCAkwAFCAhwgJMABQgIcICTAAUICHCAkwAFCAhwgJMAB QgIcICTAAUICHCAkwAFCGiB3GjNMNnzFtOHN+22vuPMeYwZLriZIhFQftxhjtnTebDXmGG1I PzdFWyvuJSSXCKk+3hLShmuvve4tR7042Px6AC7mHGNGXXv7zop73zakAbqi8BBSfbwlpLf1 TTMg2/ajxpzz1nvfNqQBuqLwEFJ9pAvpiIHZtvEVLHjrvW8b0gBdUXgIqT6sXyO9eVPrXkP2 OvTKP0bR8aUvXcz8+N7Xrjh8dGHM0d9q73zItw5pecfxj/82/ssdUXSrMR9+84J3jomiju8d vdeQke//ZvGo+N4Z0Z1Tmyd9ZWf01Il7jPi7X5WPLz/fOZ1jyr5Guu2QltHHPf4fXSGVnbX3 ispHIQVCqg9bSDuP7NrW+z1Ttm1/sU/XvR94ufiIC0u3hy2P38R/+q4xf311adOf2XXUCR1R dIcx713RVPzTvN++s/hur1d7p/c531tCWtB5+ou7Qio7a+8VlY9CCoRUH7aQbjTm3d/72YMn G/M30ZP3xgf9nzW/jTbH+37fG/9j4RBjjo+PeSy+e+ot3/ngbp07PX7k5AmFqQdFPzRm0A3r b42PWlG6d+/xHzt/VHzaj46bf3j8kGt7hvc93zNrDjXm9DVrdnX97aPxsR9Z+YNjh3Sevvys PVfUZxRSIKT6uMWU6w2pzZir43c7Z51/1a7oBdP5Fcllxuz++/j9d+I/PxFFZxuzR/xMsn1S T0jmwOfjG9cff3zx08CPGfP3nfd+Morujt8N3xi9cZAxJ/YMrzhfxddI/xA/e22LP8d8d+fp +5y1+4r63IkUCKk+bCFdYMzE21/sOqh7204xpq345/bRxlweRe8x5lPFP17SG9J3y079OWOO 7rz3sbjIYcbMiu/8Qvwk1nNExfkqQvpLY+YU3/9Tn282dJ61+4r63IkUCKk+iiFNmFQyvDyk dS3FsPafe3fxq/iubdsxpPNpKoo+UKoiPuTK4p/u6g2pM71VM/cbVgqztfPe4msVxhuzJH4X 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 6v+LfUADqP8v9gENoP6/2Ac0gPr/Yh/QAOr/i31AA+C1doADhAQ4QEiAA4QEOEBIgAOEBDhA SIADhAQ4oAxpukFDmy7cfK4pQzrjxCd80fwN9RWk9Y1m9RWkduIZws3nmjKkNpf/0mV9jcj9 f3qx230j1FeQmkfrXx0hpUJIdeDR+ldHSKkQUh14tP7VEVIqhFQHHq1/dYSUCiHVgUfrXx0h pUJIdeDR+ldHSKkQUh14tP7VEVIqhFQHHq1/dYSUCiHVgUfrXx0hpUJIdeDR+lenDOnss4XD sxn9kPoK0npotPoKUvNo/atThrTZn/+IxbO71FeQ1q5n1VeQmkfrXx2/RgE4QEiAA4QEOEBI gAOEBDhASIADhAQ4QEiAA4QEOEBIgAOEBDhASIADhAQ4QEiAA4QEOEBIgAPykC40c9WXkMbm BROHTp75iPoyqtkyf1Jh77mb1JeRhicf0bTUIT0+2IuQXplsjr/kzCHDf6m+kGRvTDMnXzGn sK8Hv3rqyUc0NXFIb06d4kVI88x18du7zXHqC0l2jfla/Pb7ZoH6Qqrz5COamjikq5oe8CKk z7fujN92NE9SX0iyqSNfL747YEyH+kqq8uQjmpo2pGeaz93iRUidXi8cob6ERDsGt5bet5mN 4itJK+8f0fS0IbXu/apPIf1z6dOR/HradP5LcYvNKvGVpJX3j2h60pBuM3dFHoX08NAPvam+ hkRrzbzS+2VmpfhKUsr9RzQ9RUhbzokti6KX3nFClPOQui+16LvDpr2ivZpq1przS++XmnvE V5JO/j+i6SlCer74X7Q+IopO3+1/8x5S96XGXxYvMsf+SXw11Wwws0vvLzY/0l5IKj58RNMT fmp3v7nk+eeff9LMev413UWk1THHfK5dfRHVvDHkyNL7WeZ/xVeSghcf0fSEIS0w3RbqLiKt +eZK9SWkcHjLn+O3u8ZNUF9ICn58RFMThvTUD4vuMEf/8Ne6i0jpbjNffQlp3Gwujd/eaC5T X0h1nnxEU1O/RCjnXyN12998bmFJvl980z7DzLzs9KaD/6y+kOo8+YimRkip9HwW+qz6SpJt /cKkwj7zfPhWmC8f0bTkIQEhICTAAUICHCAkwAFCAhwgJMABQgIcICTAAUICHCAkwAFCAhwg JMABQgIcICTAAUICHCAkwAFCAhwgJMABQgIcICTAAUICHCAkwAFCAhwgJMABQgIcICTAAUIC HCAkwAFCAhwgJMABQgIcICTAAUICHCAk3ww+XH0FeBuE5JvKkJZs0FwH+iAk31SEtMk8ILoQ lCMk31SEdC8h5QIh+eO+acP3mrulFNKjJ+1ZmHTWs1F0fPE/DL6m7A5oEJI31gwed+UtZ80o xCE9MXzc5Td/aeSYl6NHPmUW3fNK2R3QICRvHGsei9+eZ+KQbpj24/jmdea6KFpS+tSu7A5I EJIvdjXvX3y3znR9jbRzx2qzoDuksjsgQUi++J35u+K7HaWQbv/wHsUvjub3hNR7ByQIyRdP mxNL75vikC4yh9728CP/2htS2R2QICRfPN/5jLQ1fkba0Txha3zzwZ6Qyu+ABCH54s2hBxTf /TQO6Vnz8eLNi3pCKr8DEoTkjSNL37U7Iw5pe9P74lvr9jHnRNFSszLqcwckCMkb9zeN+dKy Ez4yKv4a6QRzzvcuGX3/kPHf3XaXef/Vj5Xfob7MBkVI/rjj4KF7zdkyIX7y+cMZe436yJro st3GvrDz5ObRd5bfob7KBkVIgAOEBDhASIADhAQ4QEiAA4QEOEBIgAOEBDhASIADhAQ4QEiA A4QEOEBIgAOEBDhASIADhAQ4QEiAA4QEOEBIgAOEBDhASIADhAQ4QEiAA4QEOEBIgAOEBDhA SIADhAQ4QEiAA4QEOEBIgAP/H5CxBC+G8taQAAAAAElFTkSuQmCC) You can also choose your own bin boundaries. You might specify the number of bin breaks you want, or you can choose the exact bin breaks that you want. ```R hist(data, breaks = 8) # Specify number of bin breaks hist(data, breaks = c(seq(-5, 5, 1))) # Choose exact bin breaks ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAAC+lBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKD g4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSV lZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqan p6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5 ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrL y8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd 3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w 8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////Z7SHyAAAA CXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3dD5iVZZ3w8XsYDiMgTlgi8m8gZW0rFwJN SjFeITWRwEwJpRihVRN0jHYJI0BcpOAV310ji7Zsc/tHMq7Za72xqO9SWSjrthm+MaKhkn+H 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) ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAAC+lBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKD g4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSV lZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqan p6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5 ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnKysrL y8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd 3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w 8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////Z7SHyAAAA CXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3dC3xV1Z3o8RXCITzEiAoiEAIqY6etA4JW WsVyhaoVEaxVitISoSMqaCzOIBYBcZA2XOHOWKriqB0drUWJ4+NarwzqHWxt0YzT0eItAS0q 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 hAQ48P8BPRUyInVLSvsAAAAASUVORK5CYII=) Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a histogram/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-create-a-histogram-in-r/",
    "relUrl": "/how-to-create-a-histogram-in-r/"
  },"376": {
    "doc": "How to create a histogram",
    "title": "How to create a histogram",
    "content": " ",
    "url": "/how-to-create-a-histogram/",
    "relUrl": "/how-to-create-a-histogram/"
  },"377": {
    "doc": "How to create a histogram",
    "title": "Description",
    "content": "A histogram is a very common and useful data visualization. It displays an approximation of the distribution in single series of data points (one variable) by grouping the data into bins, each bin draw as a vertical bar. How can we create such a visualization? . Related topics: . | How to create basic plots | How to create a box (and whisker) plot | How to add details to a plot | How to create bivariate plots to compare groups | How to plot interaction effects of treatments | . ",
    "url": "/how-to-create-a-histogram/#description",
    "relUrl": "/how-to-create-a-histogram/#description"
  },"378": {
    "doc": "How to create a histogram",
    "title": "Using Matplotlib, in Python",
    "content": "View this solution alone. We will create some random data using NumPy, but that’s just for demonstration purposes. You can apply the answer below to any data, even if it’s stored just in plain Python lists. | 1 2 . | import numpy as np data = np.random.normal( size=1000 ) . | . The conventional way to import matplotlib in Python is as follows. | 1 . | import matplotlib.pyplot as plt . | . To create a histogram with 10 bins (the default): . | 1 2 . | plt.hist( data ) # or plt.hist( bins=20 ), or any number plt.show() . | . The $y$ axis in a histogram is frequency, or number of occurrences. You can change it to probabilities instead. | 1 2 . | plt.hist( data, density=True ) plt.show() . | . You can also choose your own bin boundaries. | 1 2 . | plt.hist( data, bins=range(-10,10,1) ) plt.show() . | . Content last modified on 23 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-histogram/#using-matplotlib-in-python",
    "relUrl": "/how-to-create-a-histogram/#using-matplotlib-in-python"
  },"379": {
    "doc": "How to create a histogram",
    "title": "Solution, in R",
    "content": "View this solution alone. We will create some random data, but that’s just for demonstration purposes. You can apply the answer below to any data. Simply replace the data variable with your real data (a list, a column of a dataframe, etc.). | 1 . | data &lt;- rnorm(1000) . | . We can use R’s hist() function to create the histogram. | 1 . | hist(data) . | . The y axis in a histogram is frequency, or the number of occurences. You can change it to probabilities instead. | 1 . | hist(data, prob = TRUE) . | . You can also choose your own bin boundaries. You might specify the number of bin breaks you want, or you can choose the exact bin breaks that you want. | 1 2 . | hist(data, breaks = 8) # Specify number of bin breaks hist(data, breaks = c(seq(-5, 5, 1))) # Choose exact bin breaks . | . Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-histogram/#solution-in-r",
    "relUrl": "/how-to-create-a-histogram/#solution-in-r"
  },"380": {
    "doc": "How to create a histogram",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA346 | . ",
    "url": "/how-to-create-a-histogram/#topics-that-include-this-task",
    "relUrl": "/how-to-create-a-histogram/#topics-that-include-this-task"
  },"381": {
    "doc": "How to create a histogram",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-create-a-histogram/#opportunities",
    "relUrl": "/how-to-create-a-histogram/#opportunities"
  },"382": {
    "doc": "How to create a QQ-plot (in Python, using SciPy)",
    "title": "How to create a QQ-plot (in Python, using SciPy)",
    "content": "# How to create a QQ-plot (in Python, using SciPy) [See all solutions.](../how-to-create-a-qq-plot) ## Task We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is a QQ plot. How do we make and interpret one? Related tasks: * [How to test data for normality with Pearson's chi-squared test](../how-to-test-data-for-normality-with-pearson-s-chi-squared-test) * [How to test data for normality with the D'Agostino-Pearson test](../how-to-test-data-for-normality-with-the-d-agostino-pearson-test) * [How to test data for normality with the Jarque-Bera test](../how-to-test-data-for-normality-with-the-jarque-bera-test) ## Solution We're going to use some fake data here by generating random numbers, but you can replace our fake data with your real data in the code below. ```python # Replace this with your data, such as a variable or column in a DataFrame import numpy as np values = np.random.normal(0, 1, 50) # 50 random values ``` If the data is normally distributed, then we expect that the QQ plot will show the observed values (blue dots) falling very clsoe to the red line (the quantiles for the normal distribution). ```python from scipy import stats import matplotlib.pyplot as plt stats.probplot(values, dist=\"norm\", plot=plt) plt.show() ``` ![png](data:image/png;base64,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 ) Our observed values fall pretty close to the reference line. In this case, we expected that, because we created fake data that was normally distributed. But for real data, it may not stay so close to the red line. Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a QQ-plot/Python, using SciPy.ipynb). Contributed by: * Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-create-a-qq-plot-in-python-using-scipy/",
    "relUrl": "/how-to-create-a-qq-plot-in-python-using-scipy/"
  },"383": {
    "doc": "How to create a QQ-plot (in Python, using statsmodels)",
    "title": "How to create a QQ-plot (in Python, using statsmodels)",
    "content": "# How to create a QQ-plot (in Python, using statsmodels) [See all solutions.](../how-to-create-a-qq-plot) ## Task We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is a QQ plot. How do we make and interpret one? Related tasks: * [How to test data for normality with Pearson's chi-squared test](../how-to-test-data-for-normality-with-pearson-s-chi-squared-test) * [How to test data for normality with the D'Agostino-Pearson test](../how-to-test-data-for-normality-with-the-d-agostino-pearson-test) * [How to test data for normality with the Jarque-Bera test](../how-to-test-data-for-normality-with-the-jarque-bera-test) ## Solution We're going to use some fake data here by generating random numbers, but you can replace our fake data with your real data in the code below. ```python # Replace this with your data, such as a variable or column in a DataFrame import numpy as np values = np.random.normal(0, 1, 50) # 50 random values ``` If the data is normally distributed, then we expect that the QQ plot will show the observed values (blue dots) falling very clsoe to the red line (the quantiles for the normal distribution). ```python import statsmodels.api as sm import matplotlib.pyplot as plt sm.qqplot(values, line = '45') plt.show() ``` /opt/conda/lib/python3.9/site-packages/statsmodels/graphics/gofplots.py:993: UserWarning: marker is redundantly defined by the 'marker' keyword argument and the fmt string \"bo\" (-> marker='o'). The keyword argument will take precedence. ax.plot(x, y, fmt, **plot_style) ![png](data:image/png;base64,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 ) Our observed values fall pretty close to the reference line. In this case, we expected that, because we created fake data that was normally distributed. But for real data, it may not stay so close to the red line. Content last modified on 16 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a QQ-plot/Python, using statsmodels.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-create-a-qq-plot-in-python-using-statsmodels/",
    "relUrl": "/how-to-create-a-qq-plot-in-python-using-statsmodels/"
  },"384": {
    "doc": "How to create a QQ-plot (in R)",
    "title": "How to create a QQ-plot (in R)",
    "content": "# How to create a QQ-plot (in R) [See all solutions.](../how-to-create-a-qq-plot) ## Task We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is a QQ plot. How do we make and interpret one? Related tasks: * [How to test data for normality with Pearson's chi-squared test](../how-to-test-data-for-normality-with-pearson-s-chi-squared-test) * [How to test data for normality with the D'Agostino-Pearson test](../how-to-test-data-for-normality-with-the-d-agostino-pearson-test) * [How to test data for normality with the Jarque-Bera test](../how-to-test-data-for-normality-with-the-jarque-bera-test) ## Solution We're going to use some fake data here by generating random numbers, but you can replace our fake data with your real data in the code below. ```R # Replace this with your data, such as a variable or column in a DataFrame values <- c(4, 90, 85, 49, 34, 23, 17, 10, 20, 59, 100, 112, 46, 10, 4, 39, 24, 77, 63, 23, 67, 109, 70) ``` If the data is normally distributed, then we expect that the QQ plot will show the observed values (black circles) falling very clsoe to the red line (the quantiles for the normal distribution). ```R # Make a QQ plot for the data qqnorm(values, pch = 1) # Add the reference line representing what the data should look like if normally distributed qqline(values, col = \"red\", lwd = 2) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAIAAAByhViMAAAACXBIWXMAABJ0AAASdAHeZh94 AAAgAElEQVR4nOzdZ2AU1cLG8WfTgdBrQEINSK8CgoiCEpEeIDQjiOiFhKqgoPSmUqRIEVE6 CAGiKFxFkCqgQelFpPfQS0Iqyb4fljcXQ0hCyO6wm//v0+zM2ckTV+Tx7MwZk9lsFgAAAOyf k9EBAAAAkDEodgAAAA6CYgcAAOAgKHYAAAAOgmIHAADgICh2AAAADoJiBwAA4CAodgAAAA6C YgcAAOAgKHYAAAAOgmIHAADgICh2AAAADoJiBwAA4CAodgAAAA6CYgcAAOAgKHYAAAAOgmIH AADgICh2AAAADoJiBwAA4CAodgAAAA6CYgcAAOAgKHYAAAAOgmIHAADgICh2AAAADoJiBwAA 4CAodgAAAA6CYgcAAOAgKHYAAAAOgmIHAADgICh2AAAADoJiBwAA4CAodgAAAA6CYgcAAOAg KHYAAAAOgmIHAADgICh2AAAADoJiBwAA4CAodgAAAA6CYgcAAOAgKHYAMqmVK1eaTCaTyeTh 4WF0FpvKtL84kBlQ7AAk7+uvvzb9v0qVKsXHxycZsHjxYsvR1157zZCEhti0aVOPHj3Kly+f O3dud3d3Ly+v+vXrjx49+uLFi0ad8MFP6kFZsmQpVqyYv7//L7/8kr5sAOwOxQ5A6g4ePDh/ /nyjUxjs8uXLr7zySsOGDWfPnn3kyJFbt27FxsaGhYX99ttvw4YNK1269KeffmrsCZOIjo4+ e/bsihUrfH193377bbPZ/CRnS+Ly5csuLi4mk+nvv//OwNMCeEIuRgcAYB+GDh3aoUOHbNmy GR3EGFeuXKldu/aZM2csL52dnStWrJg9e/YzZ86cO3dOUlRU1ODBgy9cuPDFF18YckILX19f FxcXSQkJCRcuXDh48GBCQoKkuXPnVqhQ4b333nucXzolwcHBD0/iAjAcM3YA0uTSpUuTJk0y OoVhunbtmljCunfvHhYWtnfv3m3btp09e3bLli1lypSxHJo+ffqKFSsMOaHFsmXL1qxZs2bN mv/+97/79u3bu3dv/vz5LYcmT56c9vOkavny5Rl4NgAZhWIHIBUNGzY0mUySJkyYEBYWlur4 O3fujBs3rk6dOnny5HFzcytYsKCvr++8efOSTPDMnTvXcilYgwYN7t2717dv3/z58xcsWPDB Qy+++KKklStXVqtWLWvWrMWLFx8yZEhcXJykI0eOtGjRInfu3J6eno0bNz506NCDJzebzcuW LfP19S1QoICrq2uOHDlq1679xRdfpG+SKTQ09KeffrJsd+/efc6cOfny5Us8+uKLL27evDlx z/Dhw1P90jPDT/golSpVev/99y3b58+fP3/+fMrj0/LZNWvWzGQybd++3fKyXLlyJpOpX79+ 6UsIIIOZASA5c+bMsfxX4u23327fvr1l+913300csGjRIstOX1/fxJ179+4tUqRIsv+1ef75 569du5Y4cunSpZb9lStXTpwLdHZ2NpvNy5Yts7ysWLFicHCwpVYmCgoKOnny5INNSFL+/Plv 3bqVePLOnTsnm6FZs2YJCQmWMYkzYe7u7in/o+jVq5dlpIeHx40bN5Id8/nnnyf+lNDQUFue MPGTknTz5s0kRx+cWjt06JD50b94Gj+7pk2bPjygb9++Kf/KAGyDGTsAqYiIiBg3bpybm5uk b7755vDhw48aefPmzaZNm164cEFSiRIlZs2a9f3333/44YeWq7527tzZpUuXxMGurq6WjTt3 7kyZMsXV1bVq1aqlS5eW5OzsbDl0/fr19957r3nz5r169cqZM6dl59dffx0UFOTm5ta3b9/a tWtbdl69enXevHmW7TVr1ixZskSSk5PTzJkzDxw48M0331gyrFmzZuXKlY/7T2Dbtm2WjYYN G+bOnTvZMe3atUvc3rp1q41PmIKjR49aNkwmU6FChR41LO2f3fjx41evXp34xiVLlmzbtq1v 377pTgggA3HzBIBU3Lt3r2TJkoGBgVOmTImPj//ggw/WrFmT7MgvvvjC0gxy5Mjx22+/FS5c WFLLli0rVqwYEBAgae3atX/99VeNGjUefNfp06d9fHxOnjz5zDPPJDnhpUuX2rVrFxwcLOnl l19u06aNpJiYmE2bNh06dKhkyZKxsbGVK1e2dJeNGzdavhA8c+aMZVapdOnSPXv2lFSxYsXV q1f/8MMPktasWfNgZ0qLxIvhKlSo8KgxzzzzTK5cuW7duvXgeJud8FH2798/depUy3b16tXz 5MnzqJFp/+zKly//4HmqV6/+7LPPpi8egAzHjB2ANBk6dGiuXLkkrV27duPGjcmOCQkJsWz4 +flZmoFFx44dE+el/vvf/z78xpEjRz7c6iwGDhxo2WjevLm7u7tlu3Xr1iVLlpTk5ubWvHlz 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 UmkJHUCN5Ofn37lz56+//gLQuHHjFi1aaGioeLGOjY29devWq1evGjZs6ODgYGhoKHSiD7dx I/z8AKBLF8yfL3QaIiKisrDYycnt27dHjBjx119/WVtbA3j69Gnjxo337t3bUkWXzEhKSho/ fnxgYGDlypVr1Kjx5MkTIyOjH3/80dPTU+hoH+LaNXz3HQBYWCAgAJqaQgciIiIqi4ofMVIQ //nPfzp37ty0adP4+PiYmJiYmJj4+PimTZt27tz50aNHQqeTvry8vL59+967d+/atWsJCQmR kZFpaWmLFi2aMGHCzp07hU5XYa9ewdkZYjG0tREQgGrVhA5ERERUDh6xk4e5c+e2adNm3759 ov89fqpmzZp+fn69evWaO3fu4cOHhY0ndfv27YuMjIyMjKxVq1bBiK6u7uTJk0Ui0cyZM93d 3ZXgnGx+PoYOxbNnALBpE9q1EzoQERFR+XjETuZycnJOnDhRUGveH9fQ0Jg0aVJoaGhOTo5Q 2WTkyJEjLi4uha2u0JgxY8Ri8fnz5wVJ9WHmzcPp0wAweDDGjRM6DRERUYWw2MncmzdvsrKy bG1ti2+ytbXNysp68+aN/FPJ1LNnz0r8ffX09CwsLOLi4uQf6cMcP45VqwCgSRPs2CF0GiIi oopisZM5Y2NjAImJicU3JSYmikQiExMTuYeSLRMTk6SkpBI3JSYmKvrv++QJhg2DRAJjYwQG wsBA6EBEREQVxWInc0ZGRi1btgwODi6+KTg4uEWLFkpwwdkH6tix45EjR/Ly8oqMX7x48c2b Nx06dBAkVYVkZcHVFcnJEImwezc++0zoQERERB+AxU4e5syZs3HjxpCQkPcHQ0JCNm3aNHfu XKFSyY6Xl9fz588nT56cm5tbOBgdHe3h4TFs2DALCwsBs5XDywu3bwPAd99h0CCh0xAREX0Y 3hUrD05OTk+ePHF2dm7fvn2bNm0AXL9+/fLly0uXLh2kiu3BzMzs2LFjgwYN+v3337t06VKz Zs379++HhoZ++eWX27ZtEzpd6Xx8sHs3AHTqhKVLhU5DRET0wXjETk5mz559+/bttm3b3r9/ //79+23btr19+/bs2bOFziUrHTt2jIyMHDt2bHJy8oULF6pVq+bv73/y5EnFPe8cHo5p0wCg Zk34+0OL/5uHiIiUD7+95Kdp06ZNmzYVOoX8VKtWzdvbW+gUFZOUBEdHvH0LLS0EBqLYQi1E RERKgUfsSO3l52PIEMTEAMCaNejYUehAREREH4nFjtTekiU4eRIAXFwwZYrQaYiIiD4eix2p tzNn3t0n0aAB1yImIiJlx2JHauzvv+Hujrw8GBkhOBgKvnIyERFReVjsSF1lZ8PJCQXPc9u+ HZ9/LnQgIiKiT8ViR+pq8mTcuAEAU6di6FCh0xAREUkBix2ppf378fPPAPDFF1i1Sug0RERE 0sFiR+rn3j18+y0AmJnh8GHo6AgdiIiISDpY7EjNpKXBxQWZmdDUxL59qF1b6EBERERSo3xP npBIJDExMdHR0WlpaQBMTU1tbW0V+rnypDgkEowciYcPAWDZMnTrJnQgIiIiaVKmYpeUlLRs 2TI/P79Xr14V2WRpaenp6ent7a2vry9INlIOK1ciOBgAvvkG330ndBoiIiIpU5piFx8f3759 +5iYGFtb2969e1tZWRU8Tj41NTUqKur8+fMLFiwICgo6e/Zs5cqVhQ5LCunsWSxYAAD168PX FyKR0IGIiIikTGmK3fz58589exYYGOjs7Fx8a15eno+Pz8SJExcvXrxhwwb5xyNF9+IFhgxB bi709BAYiEqVhA5EREQkfUpz80RoaOiwYcNKbHUANDU1vby8XFxcggtOtBG9LycHzs6IjweA 7dvRooXQgYiIiGRCaY7YJSQk1KtXr+w5dnZ2ISEhH/S2L1++HD16dHZ2dhlz/vnnHwASieSD 3pkUiLc3Ll0CgHHjMHKkwGGIiIhkRmmKnbm5eURERNlz7ty5Y25u/kFva2ho2LJlS7FYXMac qlWrPnjwQFdX94PemRTFwYPYtAkAmjfHunVCpyEiIpIliZKYMmWKSCRavXp1VlZW8a3p6ekL FiwAMGvWLKnv+kbBg6dICekAawEfwAewEjoMERGpkhs3bki9cnw6kURJzjAmJyd36dLl9u3b xsbGDg4OFhYWRkZGEokkPT09NjY2LCwsMzOzY8eOJ06cMNCoV5AAABKbSURBVDIykvreIyIi cnNzpfueixcvTkhIGD9+vHTflgSXmJg4ZcqUtWvXmpmZCZ2FpGzHjh0AxowZI3QQkrJXr17N mDFj48aNVapUEToLSdn27durVq26cOFC6b6tlpZWs2bNpPueUqE0xQ6AWCzeunWrr6/vvXv3 8vLyCse1tbXt7e09PDw8PDw0NTUFTPhBxo4dm56evn//fqGDkJTFxcVZWlo+efKk3KtCSemM GjUKwO7du4UOQlIWFRVVv379v//+m8vdq54hQ4YYGRn5+PgIHUROlOYaOwA6OjrTpk2bNm1a VlZWXFxcwZMnTExMLC0tdfi4TyIiIlJ7ylTsCunp6dna2gqdgoiIiEixKM06dkRERERUNhY7 IiIiIhXBYkdERESkIljsiIiIiFQEix0RERGRimCxIyIiIlIRLHZEREREKkIp17FTDTo6OlxX WSUV/LPyH1cl8Z9VVfHPVoWp27etMj1STMUkJyfn5+fzuYQqKTo6um7dukKnIOlLSkoCULly ZaGDkPTxz1ZVJSYmamhoVKpUSeggcsJiR0RERKQieI0dERERkYpgsSMiIiJSESx2RERERCqC xY6IiIhIRbDYEREREakIFjsiIiIiFcFiR0RERKQiWOyIiIiIVASLHREREZGKYLEjIiIiUhEs dkREREQqgsWOiIiISEWw2BERERGpCBY7IiIiIhXBYkdERESkIljshJSUlOTt7W1lZaWrq2tj YzNgwIBr164JHYqkJicnZ86cOZqamq1atRI6C32q5OTkqVOnWltb6+jomJube3p6xsfHCx2K pIN/qipJbb9hRRKJROgMaioxMdHe3v7p06d9+vRp2bJldHT0wYMHtbS0wsLCmjRpInQ6+lQP HjwYOnTo48ePMzIyWrRocfPmTaET0ccTi8Vt27a9ffv2oEGDWrZsGRUV5efnV6dOnVu3blWu XFnodPRJ+KeqktT6G1ZCApkwYQKAzZs3F44EBQUB6N27t4CpSCpSUlL09fVbtWr1+PFjXV1d e3t7oRPRJ1m3bh2AVatWFY4cPHgQwIwZMwRMRZ+Of6qqSp2/YXkqVjDa2tpdunQZO3Zs4cjA gQP19fXv378vYCqSitzcXC8vrytXrtSvX1/oLCQFvr6+xsbGU6ZMKRxxcXGpX7++n5+fhCc9 lBn/VFWVOn/D8lSsAsnOzjY2NnZwcLh06ZLQWUhq9PT0GjduzPM7yisrK8vIyKhTp05nzpx5 f3zUqFF79uyJioqqW7euUNlIivinqtrU5xuWR+wUiI+PT05Ojpubm9BBiOj/4uLi8vLyLCws ioxbWVkBiI6OFiIUEX0Y9fmGZbFTFOfPn585c2aHDh3GjRsndBYi+r+0tDQAhoaGRcaNjIwK txKRIlOrb1gtoQOovuTk5NmzZxf+WL9+fW9v7yJzDhw4MGrUqMaNGx89elRLi/8oSqMi/7ik GkQiUZGRgutYio8TkUJRt29Y1f8NBZeenu7j41P4Y/v27d//7pdIJIsWLVqyZEnPnj0DAwON jY2FyEgfqex/XFINJiYmKOnIXGpqKgD+zRIpLPX8hmWxk7k6deqUdoeKRCLx9PTctWvXpEmT 1q9fr6mpKeds9InK+McllWFpaamlpRUbG1tkPCoqCoCtra0QoYioHGr7Dctr7IQ0bdq0Xbt2 LV++fNOmTerz/3NEykVHR8fe3j4sLCwzM7NwMD8///z58xYWFpaWlgJmI6LSqO03LIudYIKD gzdu3DhlypQ5c+YInYWIyjJ69OjMzMz/tnfvQVHV/x/HPwd2Wa6ByGUVECScSklRGVAHZSTB KAONLGVMxMhkUtE0b1MMaONlNrMA+cNxxgt2MdSpZoqB8TpaGYxFF6FSUyFZBbdwxJDrfv84 vzmzoe6uIuzP0/Px155zPvs57/PZQV6cz9mPBoNB2bN9+/aGhoasrCwHVgXgbv7Lv2FZx85h IiIizp8/v3jxYnd39x6HVq1axf9T9FA7fvx4WVmZ/Prdd9/19/fPyMiQN998882BAwc6rjTc j66ursmTJ584cSI1NXXMmDG1tbX79u2LjIw8derU7T+/eIjwo6pW/+XfsAQ7h7HyZboLFy6E hYX1Yy14wDZt2nS3PxPPnj3LGvcPo5aWlvz8/NLS0oaGhoCAgOnTp69bt87X19fRdaFX+FFV q//yb1iCHQAAgErwjB0AAIBKEOwAAABUgmAHAACgEgQ7AAAAlSDYAQAAqATBDgAAQCUIdgAA ACpBsAMAAFAJgh0AAIBKEOwAAABUgmAHAACgEgQ7AAAAlSDYAQAAqATBDgAAQCUIdgAAACpB sAMAAFAJgh0AAIBKEOwAAABUgmAHAACgEgQ7AAAAlSDYAQAAqATBDgAAQCUIdgAAACpBsAMA AFAJgh0AAIBKEOwAAABUgmAHAACgEgQ7AAAAlSDYAQAAqATBDgAAQCUIdgAAACpBsAMAAFAJ gh2A+5eVlSVJ0rlz5xxdiG2zZs2SJOnKlSsPqqs///yz9105iuVoqOByACgIdgDuYMWKFZJV cXFxjq7Rhk2bNlkmzqioqKlTp+p0uv45u9ls3r9//4wZM4KDg3U6nY+PT1RU1MqVK+vr6/un gB4cOxoA+o3G0QUA+P9o0qRJnZ2dyubevXtNJtOiRYucnZ3lPeHh4Q4qzS5Go3HNmjVRUVER ERHyntWrV69evbp/zv7XX3+lpaUdO3bM09Nz8uTJoaGhra2tVVVVBoOhoKBg+/btc+fO7Z9K ZI4dDQD9iWAH4A5SUlJSUlKUzUOHDplMJoPB4Orq6sCq7FdVVeWoU3d3d8+cOfPYsWOzZ88u Kiry9fVVDlVUVKSnp8+bN8/f3z85ObnfSnLgaADoZ0zFAugtJyenzZs3h4eH63S6IUOGrF+/ 3mw2K0evXr36+uuvh4aGuri4+Pv7T58+vUfOuHTpUmZmZlBQkIuLi5+fX0pKSmVlpXJUfgKs sbExMTHRzc3tiy++sNnttGnTUlNThRDJycmSJJ08eVLc9ozdlStXsrKygoKCPDw8Ro0a9cEH H1jeoaysrJwxY4afn5+Li0tYWNjLL7988eJFO0fjwIEDR44ciY+P//DDDy1TnRAiKSnpwIED QoicnJzu7m6lWkmSmpublWadnZ2SJE2ZMsXOetLT0yVJamlpWbVqVVhYmE6nCwkJ2bp1q/wp 2DMalqx/Xm1tbQaDYdSoUd7e3l5eXiNHjjQYDMq1AHA47tgB6K133nmnurp6wYIFzs7OhYWF ubm5ERERs2fPFkI0NTXFxsY2NzcvXLgwMjKyvr6+uLh44sSJ5eXl8fHxQoj6+vqYmJh//vkn Ozt7xIgRly9fLi4unjRp0qFDh+TH+FxcXIQQy5Yt02q1ubm58hSw9W7feustX1/fkpKS3Nzc 0aNHDx8+vEfBTU1N0dHRLS0tc+fODQ0NPXbs2NKlS3/++ecdO3YIIU6fPh0fH+/r65uTk6PX 6//4449t27ZVVFTU1NQMHDjQ5mjs2bNHCJGXlydJ0u1H4+PjExISDh8+/M0339j5nKLNeuQh euGFF4YOHfrJJ590d3fn5+e/8cYbPj4+mZmZNkejx8hY/7yys7N37tyZnp6enZ0tSVJ5efnK lSsvXbpUVFRkz7UA6HNmALBlxIgRQojW1tYe+1955RUhRFxcXHt7u7zn9OnTQoiUlBR5Mzs7 W6PRVFVVKW+pq6vz8vKKjo6WNzMyMoQQBw8eVBrU1NQ4OzuPGzdO3pw/f74QIikpqaurS2lj s9uNGzcKIcrKypQGL730khDCaDTKbxdClJeXK0efffZZIcQvv/xiNpuLi4vHjBlz9OhR5Whh YaEQorCw0LKr+vr6O46Vn5+fq6trR0fHnYfSbDYYDEKIzZs3W57677//Vhp0dHQIIZ566il5 02Y98qcwe/ZspcH58+eFENOmTbNnNCwvx+bAuru7jx8/3vJyli1blpaW1tnZebfrBdCfuGMH oLeWL1+u1Wrl16NHj3Z2dm5oaBBCmM3m0tLSkSNHBgcHK7N+Wq12woQJ5eXlLS0tHh4en332 WWBg4PTp05XennjiifHjx588edJkMg0cOFC+75WRkeHk9H+Pjtjs1tPT00q1ZrP5008/DQkJ SUxMVHYWFBQsX748MDBQCJGdnS0nPyFER0dHV1eXfJfLntnYrq4uk8kUGhqq0dz1X9ewsDAh hP0Lr9hZjxyRZeHh4e7u7ve6gok9A6vVai9dutTY2BgQECA3eO+99+7pLAD6FMEOQG8NGzZM eS1JkqenZ2trqxCisbHx2rVr165dGzRo0O3vqqurGzBgwPXr18eOHdtj1vKxxx47efLk77// Pn78eGWPctRmt9ZnG41Go8lkGjNmjOVJw8PDLb/nW1JSsmPHjp9++qnHo29WupUpfzRbb2Oz nx7sqWfIkCGWm1qtVr7zZz97BnbdunU5OTnDhg1LTU2dPHlyUlJSUFDQPZ0FQJ8i2AHorbst h3bjxg0hRFRUlDwV2MPgwYOvXbsmhPDw8OhxyM3NTQhx8+ZNZY+3t7f93VqvVg6dVpZwW7t2 7caNG6Ojo7du3Tp06FCdTnfmzJmsrCzr3co0Go2fn5/RaGxvb5cffbtdXV2dEOKO4ak39Sg3 Te+bPQO7ZMmSyMjIwsLCgwcPlpSUSJKUnJxcXFwcGhray7MDeCAIdgD6ipeXl/zi6aefvmOD W7duiX8HOJm8R3n7vXZrnV6vF0JY3vrqUdL7778fEhJy9OhRZUr3+vXr9vcfGxv75ZdfHj16 dOrUqXdscPjwYSHEhAkT7tZDe3v7A6zHfnYObEJCQkJCQltb24kTJ/bu3btnz54pU6acOXPm bkEWQH9iuRMAfSUwMNDPz+/XX3/tkaKamprkF3q93tfXt7a2tsfsZE1NjSRJltOv99StdR4e Hv7+/rW1tZYzlb/99ltRUdGZM2euXLnS2toaHR1t+aDe8ePH7elZNmfOHCHE+vXr77gIyPff f19RUTFs2DAl2Ml32iyLuXDhgvK69/XY754GVqfTTZkyZdeuXQsXLjx37lx1dXVflATgXhHs APShmTNn3rp1S/4eqKypqWnkyJHPPfecvPn8888bjcbPP/9caVBdXV1ZWZmQkODj43Pf3cr/ Q4Y863q71NRUk8m0e/duZU9eXt7ixYvb2toCAwMlSbL8XkJ1dbW8gol8f9GeS46Njf36668z MjLkyU3FDz/8kJqa2t3dXVBQoDzhJ8/J1tbWKs3k08l6X4+wNRo9ircysKdOnQoKCrIsTwgh f6ml9xPBAB4Mh3wXF8DDxfpyJ2fPnrXc6e3tPWLECPn11atX5Yf6MzMzd+3atWHDhiFDhmi1 2oqKCrnB5cuX9Xq9p6fn2rVrd+/enZ+fHxAQ4OXl9eOPP1o5hc1u9+/fL4SIiYnZsmVLZWWl +d8LfNTX1+v1eo1Gs2jRIoPBMG3aNCHE3Llz5ffKm6+99trHH3/89ttvDxgw4KuvvtJoNMHB wR999FFLS4v15U7MZnNDQ8OTTz4phPDz85s3b15eXt7q1asTExOdnJxcXV137txp2fjbb78V QowdO/bIkSOnTp1as2bNxIkTvby8lOVObNZj81OwPhqWl2N9YDs6OiIjI11cXF599dVt27YV FxfPnz/fyckpLi6uu7v7bqMBoD8R7ADYdt/Bzmw2G43G7OzskJAQjUbj4+OTkpLy3XffWbav q6vLzMwcNGiQRqMJCAiYNWtWTU2N9VPY7La9vT0tLc3NzW3AgAGlpaXmf0cZs9l88eLFOXPm BAQEaLXa8PDwLVu2KCuxNTY2pqen+/v7e3t7JyQknDhxwmw25+fne3p66vV6o9FoM9iZzea2 trYtW7bExMQ88sgj8l/Rjz/+eE5Ozrlz525vvGvXruHDh7u5uQUGBi5YsKC5uXnw4MFxcXF2 1mPzU7A+Gj0ux/rAmkympUuXPvroo+7u7t7e3qNGjdqwYcONGzesDAWA/iSZ7/2L9wAA+734 4oulpaUVFRWWK+cBQF/gGTsA6Fvz5s0TQqxfv76rq8vRtQBQOe7YAUCfe+aZZ8rKymJjY2fM mOHm5rZkyRJHVwRAnQh2ANDnbt68uWLFin379t28eXPcuHF9tF4JABDsAAAAVIJn7AAAAFSC YAcAAKASBDsAAACVINgBAACoBMEOAABAJQh2AAAAKkGwAwAAUAmCHQAAgEoQ7AAAAFSCYAcA AKASBDsAAACVINgBAACoBMEOAABAJQh2AAAAKkGwAwAAUAmCHQAAgEoQ7AAAAFSCYAcAAKAS BDsAAACVINgBAACoBMEOAABAJQh2AAAAKkGwAwAAUAmCHQAAgEoQ7AAAAFSCYAcAAKAS/wNx DBi4J96lkAAAAABJRU5ErkJggg==) Our observed values fall pretty close to the reference line. In this case, we expected that, because we created fake data that was normally distributed. But for real data, it may not stay so close to the red line. Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create a QQ-plot/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-create-a-qq-plot-in-r/",
    "relUrl": "/how-to-create-a-qq-plot-in-r/"
  },"385": {
    "doc": "How to create a QQ-plot",
    "title": "How to create a QQ-plot",
    "content": " ",
    "url": "/how-to-create-a-qq-plot/",
    "relUrl": "/how-to-create-a-qq-plot/"
  },"386": {
    "doc": "How to create a QQ-plot",
    "title": "Description",
    "content": "We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is a QQ plot. How do we make and interpret one? . Related tasks: . | How to test data for normality with Pearson’s chi-squared test | How to test data for normality with the D’Agostino-Pearson test | How to test data for normality with the Jarque-Bera test | . ",
    "url": "/how-to-create-a-qq-plot/#description",
    "relUrl": "/how-to-create-a-qq-plot/#description"
  },"387": {
    "doc": "How to create a QQ-plot",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’re going to use some fake data here by generating random numbers, but you can replace our fake data with your real data in the code below. | 1 2 3 . | # Replace this with your data, such as a variable or column in a DataFrame import numpy as np values = np.random.normal(0, 1, 50) # 50 random values . | . If the data is normally distributed, then we expect that the QQ plot will show the observed values (blue dots) falling very clsoe to the red line (the quantiles for the normal distribution). | 1 2 3 4 5 . | from scipy import stats import matplotlib.pyplot as plt stats.probplot(values, dist=\"norm\", plot=plt) plt.show() . | . Our observed values fall pretty close to the reference line. In this case, we expected that, because we created fake data that was normally distributed. But for real data, it may not stay so close to the red line. Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-qq-plot/#using-scipy-in-python",
    "relUrl": "/how-to-create-a-qq-plot/#using-scipy-in-python"
  },"388": {
    "doc": "How to create a QQ-plot",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. We’re going to use some fake data here by generating random numbers, but you can replace our fake data with your real data in the code below. | 1 2 3 . | # Replace this with your data, such as a variable or column in a DataFrame import numpy as np values = np.random.normal(0, 1, 50) # 50 random values . | . If the data is normally distributed, then we expect that the QQ plot will show the observed values (blue dots) falling very clsoe to the red line (the quantiles for the normal distribution). | 1 2 3 4 5 . | import statsmodels.api as sm import matplotlib.pyplot as plt sm.qqplot(values, line = '45') plt.show() . | . | 1 2 . | /opt/conda/lib/python3.9/site-packages/statsmodels/graphics/gofplots.py:993: UserWarning: marker is redundantly defined by the 'marker' keyword argument and the fmt string \"bo\" (-&gt; marker='o'). The keyword argument will take precedence. ax.plot(x, y, fmt, **plot_style) . | . Our observed values fall pretty close to the reference line. In this case, we expected that, because we created fake data that was normally distributed. But for real data, it may not stay so close to the red line. Content last modified on 16 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-qq-plot/#using-statsmodels-in-python",
    "relUrl": "/how-to-create-a-qq-plot/#using-statsmodels-in-python"
  },"389": {
    "doc": "How to create a QQ-plot",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use some fake data here by generating random numbers, but you can replace our fake data with your real data in the code below. | 1 2 . | # Replace this with your data, such as a variable or column in a DataFrame values &lt;- c(4, 90, 85, 49, 34, 23, 17, 10, 20, 59, 100, 112, 46, 10, 4, 39, 24, 77, 63, 23, 67, 109, 70) . | . If the data is normally distributed, then we expect that the QQ plot will show the observed values (black circles) falling very clsoe to the red line (the quantiles for the normal distribution). | 1 2 3 4 . | # Make a QQ plot for the data qqnorm(values, pch = 1) # Add the reference line representing what the data should look like if normally distributed qqline(values, col = \"red\", lwd = 2) . | . Our observed values fall pretty close to the reference line. In this case, we expected that, because we created fake data that was normally distributed. But for real data, it may not stay so close to the red line. Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-a-qq-plot/#solution-in-r",
    "relUrl": "/how-to-create-a-qq-plot/#solution-in-r"
  },"390": {
    "doc": "How to create a QQ-plot",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | Bentley University MA346 | . ",
    "url": "/how-to-create-a-qq-plot/#topics-that-include-this-task",
    "relUrl": "/how-to-create-a-qq-plot/#topics-that-include-this-task"
  },"391": {
    "doc": "How to create a QQ-plot",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-create-a-qq-plot/#opportunities",
    "relUrl": "/how-to-create-a-qq-plot/#opportunities"
  },"392": {
    "doc": "How to create basic plots (in Python, using Matplotlib)",
    "title": "How to create basic plots (in Python, using Matplotlib)",
    "content": "# How to create basic plots (in Python, using Matplotlib) [See all solutions.](../how-to-create-basic-plots) ## Task Plotting is a huge topic with many options and variations, but the most foundational types of plots are a line plot and a scatterplot. How can we create those? Related topics: * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some fake data using Python lists, for simplicity. But everything we show below works also if your data is in columns of a DataFrame, such as `df['age']`. ```python patient_id = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] patient_height = [ 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ] patient_weight = [ 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ] ``` The conventional way to import matplotlib in Python is as follows. ```python import matplotlib.pyplot as plt ``` Make a line plot by giving the $x$ and $y$​ data values in separate lists (or in this case pandas Series). This line plot is very jagged just because the data was random. ```python plt.plot( patient_id, patient_height ) # create plot plt.show() # display plot ``` ![png](data:image/png;base64,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 ) You can make a scatterplot as follows. ```python plt.scatter( patient_height, patient_weight ) # create plot plt.show() # display plot ``` ![png](data:image/png;base64,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 ) If your data is already in a pandas DataFrame, there are shortcuts: ~~~python # Plot all columns: df.plot() plt.show() # Plot all columns in separate subplots: df.plot( subplots = True ) plt.show() # Plot one column: df['column'].plot() plt.show() # Plot specific columns: df.plot( x='col name', y='other col name' ) plt.show() ~~~ Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create basic plots/Python, using Matplotlib.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-create-basic-plots-in-python-using-matplotlib/",
    "relUrl": "/how-to-create-basic-plots-in-python-using-matplotlib/"
  },"393": {
    "doc": "How to create basic plots (in R)",
    "title": "How to create basic plots (in R)",
    "content": "# How to create basic plots (in R) [See all solutions.](../how-to-create-basic-plots) ## Task Plotting is a huge topic with many options and variations, but the most foundational types of plots are a line plot and a scatterplot. How can we create those? Related topics: * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We will create some fake data using vectors, for simplicity. But everything we show below works also if your data is in columns of a DataFrame. ```R patient.id <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) patient.height <- c(60, 64, 64, 65, 66, 66, 70, 72, 72, 76) patient.weight <- c(141, 182, 169, 204, 138, 198, 180, 175, 244, 196) ``` We can make a line plot if we use the `type=\"l\"` option (which is an \"ell,\" not a number one). ```R plot(patient.id, patient.height, main=\"Patient heights\", type=\"l\") ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAADAFBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGC goKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OU lJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWm pqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4 uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnK ysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc 3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u 7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////i sF19AAAACXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3dCZyV8/7A8d/Mmb2madc+RVmy lCJLJBWhUi5JkqK/3Apx42YpyVKpi3C5ZU9cbirXchVpIUkqoRRNSmLatNA+pnn+zzmzb895 Zp7f8/ye5fN+vcycen7nN1/jfDwzZ86cIzQAlgnVAwB+QEiABIQESEBIgASEBEhASIAEhARI QEiABIQESEBIgASEBEhASIAEhARIQEiABIQESEBIgASEBEhASIAEhARIQEiABIQESEBIgASE BEhASIAEhARIQEiABIQESEBIgASEBEhASIAEhARIQEiABIQESEBIgASEBEhASIAEhARIQEiA BIQESEBILvKWEInyrlH2sYp/DJhBSM54XuRKatL7w3IXEZJ3EZIz8kMKuzGn5NFtIbFOf5fx xBNPR9sob2keoyzK3q3kNYrvh8oiJGeEQ+rardulp8XqFx4refQpYfrWXHyp9XNYBT40DBCS M8Ih7Qlf+LaOEI1KHm1v/tbcXnJIFfjQMEBIzigISZugX9qiaTlvXFwnLrXdU9ma1i33K77h hTfy729unph6xpN/6hdfFOJ87dMu1aucN08rsjSPfo3kwqPFr1mw20ttU2p2W75Rv96hktco 3O/PqZ3rxNU5Y9xOBz8pfkJIzigM6T/6pe80rV/eN0zdc0qHNCsp92866Tf8N4U45cOE8J9C H5cZUo28ox+VvGb+bndE/ibxGf1NqWsU7JfVMW+eYzc4/8nxA0JyRmFIDwoRs0t7T4jYZ1e/ GCfEDO27d/SDry/emH/T35gsxF0/LL9AiHsiN/z6TVvfc7G+pJ1WuDSPfrR23tEzy7hmeLcv 9WOtn59+blU9nVLXKNjvX0Kc+Mbnc68U4gIVnx7vIyRnFIT0TS0h2mraP7t1C59WLhfiek3b KnK/Ucm76d8iREf93c6qIvVQ+O/E+YciZ7DYrMKlecJHOxwuOFrymuHdBgtR/TdNO5heEFLR a+TvNzD3LpCsvrdMOOrwp8YfCMkZ4ZAu69nz8jb6OUi8XfDXtwpxcamQjhPivkO6DkJ8HLnh L9D/8mP9/U9lhpR/dFPpa4Z3aylE//DS0YUhFblG/n63CdHk1W0OfTL8iJCcUeTnSDGPhP9i Xs9jEyN/7FwypJzYwrVPRm74f+jHMvT3q8sMqfBoqWuGQ0oRYlx46czCkMrYb1VK+ErHDZqV 7fAnxi8IyRn5ISU07rcs/Odn9ctVTmpVu4yQ9hfWIMYU3GWwpbyQihwt65o5kah0cwtCKnO/ hSfnXq/p505+WvyDkJxReGdDxD79BHDtQU0bWtYZKSTE5IKVFQmpzGvq573xeX80CknL+fzB S9L0P9XZb89nwOcIyRklQvpU/+Mq/X3nMkLSji9y/3aFQirzms3zvkcaFSWksOx3agjxgex/ 90AgJGeUCGme/scvNe07/ZuaDpq2Tf/TYq3gRn6rEA0O6Lfqa2+4+5eSN/z8pXlKHC3rmtcJ kbZTPwc2LjOkvP0Ojht4eeTeuouL3hUC8wjJGSVC+lUvqMfqdxueIES1pduz44U4f8aH+Tfy H5OFaP+/D/8ixMnZJW/4+UvzlDha1jXn64dOe+XFM6uUGVL+fq2FuPKDFZ+OjReJ2x38tPgH ITmjREjhc4euwaYGkfsFLg3/oVvBjfyt3PvzRMN1pW74+UvzlDxa1jUHRP4m5dEyQ8rfb3Wj vDspYl905PPhO4TkjJIhZT3aMrnh//2qzTshrtGb2i+9qic1e6Tw0XFrb2yWmHLKfbu10jf8 vKV5Sh4t65pHJ52QWPeqbz/I/WN5+2176Ixj4lNOHPyN7Z8KfyKkoJimnwBVz+BjhOR3a8cP vSb8YPDLheilehYfIyS/y4jRC1r02e36l3IfqZ7FxwjJ9x7If7DDaNWT+Bkh+d/8qxrFJ6b3 WaR6Dl8jJEACQgIkICRAAkICJCAkQAJCAiQgJEACQgIkICRAAkICJCAkQAJCAiQgJEACQgIk ICRAAkICJCAkQAJCAiQgJEACQgIkICRAAkICJCAkQAJCAiQgJEACQgIkICRAAkICJCAkQAJC AiQgJEACQgIkICRAAkICJHAgpK9XAJ7ydcVv5faHtFwAHrO8wjdz+0NaIo7Y/jEAiY6IJRW+ DiEBJRASIAEhARIQEiABIQESEBIgASEBEhASIAEhARIQEiABIQESEBIgASEBEhASIAEhARIQ EiABIQESEBIgASEBEhASIAEhAeZlZpZzgJAA887+ezkHCAkwbW5ofTlHCAkw7bwbyjtCSIBZ H4V+KO8QIQFmnT+g3EOEBJj0cej7co8REmBSh/7lHyMkwJwFBickQgJMuqCfwUFCAkz5LLTO 4CghAaZc2NfoKCEBZiyJXW10mJAAMzr3MTxMSIAJn8d+a3ickAATLuptfJyQgOiWxn5jvICQ gOi6XhllASEBUa2I/TrKCkICorr0imgrCAmIZkXM8mhLCAmIplvPqEsICYhiZcyXUdcQEhBF jx7R1xASYOwrEyckQgKi6NnNxCIVIR35csFG4xWEBNdYFbPMxCpHQ3poQfjtlBpCiLarjBYS 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) We can create a scatterplot if we have two numerical columns, such as the height and weight in the data above. ```R plot(patient.height, patient.weight, main = \"Height vs. Weight\") ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAADAFBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGC goKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OU lJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWm pqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4 uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnK ysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc 3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u 7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////i sF19AAAACXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3dCXxU5bn48SckkwASWRSMQBJw v9aWsLjcKoigYHHBVktEbUG54l+gYC9gXBBExdjQ0mu9eC1eN9xaRKw7FlHctRARRVwi+i9o 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 QEiAAkICFPwf247m848mnPgAAAAASUVORK5CYII=) Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create basic plots/R.md). Contributed by: * Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-create-basic-plots-in-r/",
    "relUrl": "/how-to-create-basic-plots-in-r/"
  },"394": {
    "doc": "How to create basic plots",
    "title": "How to create basic plots",
    "content": " ",
    "url": "/how-to-create-basic-plots/",
    "relUrl": "/how-to-create-basic-plots/"
  },"395": {
    "doc": "How to create basic plots",
    "title": "Description",
    "content": "Plotting is a huge topic with many options and variations, but the most foundational types of plots are a line plot and a scatterplot. How can we create those? . Related topics: . | How to add details to a plot | How to create a histogram | How to create a box (and whisker) plot | How to change axes, ticks, and scale in a plot | How to create bivariate plots to compare groups | How to plot interaction effects of treatments | . ",
    "url": "/how-to-create-basic-plots/#description",
    "relUrl": "/how-to-create-basic-plots/#description"
  },"396": {
    "doc": "How to create basic plots",
    "title": "Using Matplotlib, in Python",
    "content": "View this solution alone. We will create some fake data using Python lists, for simplicity. But everything we show below works also if your data is in columns of a DataFrame, such as df['age']. | 1 2 3 . | patient_id = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] patient_height = [ 60, 64, 64, 65, 66, 66, 70, 72, 72, 76 ] patient_weight = [ 141, 182, 169, 204, 138, 198, 180, 175, 244, 196 ] . | . The conventional way to import matplotlib in Python is as follows. | 1 . | import matplotlib.pyplot as plt . | . Make a line plot by giving the $x$ and $y$​ data values in separate lists (or in this case pandas Series). This line plot is very jagged just because the data was random. | 1 2 . | plt.plot( patient_id, patient_height ) # create plot plt.show() # display plot . | . You can make a scatterplot as follows. | 1 2 . | plt.scatter( patient_height, patient_weight ) # create plot plt.show() # display plot . | . If your data is already in a pandas DataFrame, there are shortcuts: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | # Plot all columns: df.plot() plt.show() # Plot all columns in separate subplots: df.plot( subplots = True ) plt.show() # Plot one column: df['column'].plot() plt.show() # Plot specific columns: df.plot( x='col name', y='other col name' ) plt.show() . | . Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-basic-plots/#using-matplotlib-in-python",
    "relUrl": "/how-to-create-basic-plots/#using-matplotlib-in-python"
  },"397": {
    "doc": "How to create basic plots",
    "title": "Solution, in R",
    "content": "View this solution alone. We will create some fake data using vectors, for simplicity. But everything we show below works also if your data is in columns of a DataFrame. | 1 2 3 . | patient.id &lt;- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) patient.height &lt;- c(60, 64, 64, 65, 66, 66, 70, 72, 72, 76) patient.weight &lt;- c(141, 182, 169, 204, 138, 198, 180, 175, 244, 196) . | . We can make a line plot if we use the type=\"l\" option (which is an “ell,” not a number one). | 1 . | plot(patient.id, patient.height, main=\"Patient heights\", type=\"l\") . | . We can create a scatterplot if we have two numerical columns, such as the height and weight in the data above. | 1 . | plot(patient.height, patient.weight, main = \"Height vs. Weight\") . | . Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-basic-plots/#solution-in-r",
    "relUrl": "/how-to-create-basic-plots/#solution-in-r"
  },"398": {
    "doc": "How to create basic plots",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA346 | . ",
    "url": "/how-to-create-basic-plots/#topics-that-include-this-task",
    "relUrl": "/how-to-create-basic-plots/#topics-that-include-this-task"
  },"399": {
    "doc": "How to create basic plots",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-create-basic-plots/#opportunities",
    "relUrl": "/how-to-create-basic-plots/#opportunities"
  },"400": {
    "doc": "How to create bivariate plots to compare groups (in Python, using Matplotlib and Seaborn)",
    "title": "How to create bivariate plots to compare groups (in Python, using Matplotlib and Seaborn)",
    "content": "# How to create bivariate plots to compare groups (in Python, using Matplotlib and Seaborn) [See all solutions.](../how-to-create-bivariate-plots-to-compare-groups) ## Task Suppose we have a dataset with different treatment conditions and an outcome variable, and we want to perform exploratory data analysis. How would we visually compare the treatment conditions with regards to the outcome variable? Related tasks: * [How to create basic plots](../how-to-create-basic-plots) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data('ToothGrowth') ``` If you wish to understand the distribution of a numeric variable (here \"len\") compared across different values of a categorical variable (here \"supp\"), you can construct a bivariate histogram. We use Seaborn and Matplotlib to do so. ```python import seaborn as sns import matplotlib.pyplot as plt sns.displot(df, x=\"len\", col=\"supp\", stat=\"density\") plt.show() ``` ![png](data:image/png;base64,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 ) To visualize the same information summarized using quartiles only, you can construct a bivariate box plot. ```python sns.boxplot(x=\"supp\", y=\"len\", data = df, order = ['OJ','VC']) plt.show() ``` ![png](data:image/png;base64,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 ) Even more simply, we may wish to plot just the means and 95% confidence intervals around the mean for the quantitative variable, for each of the values of the categorical variable. We do so with a point plot. ```python sns.pointplot(x = 'supp', y = 'len', data = df, ci = 95, # Which confidence interval? Here 95%. capsize = 0.1) # Size of \"cap\" drawn on each confidence interval. plt.show() ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAX4AAAEGCAYAAABiq/5QAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/MnkTPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAZ3UlEQVR4nO3deXxX9Z3v8dcnCxC2sCSsCQRC4oJg1ahUUdlinerUW/vQah9aq45aq5WlnelM5/GY3jv3cR+301oQR6ulF7Ra62ht1anV1iAg4gKCC6iUJOxhTdhDFpJfPvePxCxAIArnd5LfeT//IXzP+eX3eWh4cTg5OcfcHRERiY6ksAcQEZH4UvhFRCJG4RcRiRiFX0QkYhR+EZGISQl7gI7IyMjwnJycsMcQEelSVq1aVeHumUevd4nw5+TksHLlyrDHEBHpUsxs8/HWdapHRCRiFH4RkYhR+EVEIkbhFxGJGIVfRCRiFH4RkYhR+EVEIqZLXMcvIl3fLfOXU7avut3tOw9UUxdzUpONIelp7e6X1T+Np+64OIgRI0PhF5G4KNtXzcaKwyfdr77BO7SffHEKv4jERVb/9o/iAbburaK+wUlJMrIH9PzCn0dOTuEXkbg42emZyQ8sYWPFYbIH9GTxDyfFZ6iI0jd3RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiJrDwm1m2mS02s7Vm9omZTW9a/7mZ/c3MVpvZC2bWL6gZRETkWEEe8dcDP3D3s4AJwL1mdjZQBJzj7uOBYuBfApxBRESOElj43X2Hu7/f9PEhYC0w3N1fc/f6pt3eBbKCmkFERI4Vl3P8ZpYDnAcsP2rT7cCr7bzmLjNbaWYry8vLA55QRCQ6Ag+/mfUG/gDMcPeDrdb/lcbTQU8f73XuPs/dC9y9IDMzM+gxRUQiI9BHL5pZKo3Rf9rd/9hq/VbgGmCqu3uQM4iISFuBhd/MDJgPrHX32a3WrwJ+BFzh7lVBvb+IiBxfkEf8lwK3AGvM7MOmtR8DDwHdgaLGvxt4192/G+AcIiLSSmDhd/dlgB1n0ytBvaeIiJycfnJXRCRiFH4RkYhR+EVEIkbhFxGJGIVfRCRiFH4RkYhR+EVEIkbhFxGJGIVfRCRiFH4RkYhR+EVEIkbhFxGJGIVfRCRiFH4RkYhR+EVEIkbhFxGJGIVfRCRiFH4RkYhR+EVEIkbhFxGJGIVfREIVa3CKPt1FRWUtAJW19Rypbwh5qsSm8ItIaPYdPsJ1j77NnU+u5FBNPQDlh2q5au5Stu2vDnm6xKXwi0ho/vH5j/ho6/5j1jeUH+ae367C3eM/VAQo/CISik0Vh1m4dne721eXHWDV5n1xnCg6FH4RCcWnOw6edJ812w7EYZLoUfhFJO5q6mIsKyk/6X69uqfEYZro0X9VEYmb2voYz60s45FFpew8WHPCfbulJDHtrMFxmixaFH4RCVxdrIE/rCrjPxeVtrlaJ9mMWDvfwJ0+NY8BvbrFa8RIUfhFJDD1sQZe+nA7c18vYcvequb15CTj+guyuG/KGD7cup8HF5ZQursSgJQk49+vPYebLsoOa+yEp/CLyGkXa3BeXt0Y/A3lh5vXkwy+fl4W908dw8iBvQDI6t+Tq8cN5bKfLaZsXzVZ/dP41sUjwho9EhR+ETltGhqcv3yykwcXFlO8q7J53Qz+fvwwpk/LIzez9zGvMzNSk5OaP5ZgKfwicsrcnYVrdzO7qJi1R12m+dVxQ5gxLZ/8wX1Cmk6OpvCLyBfm7iwpLmdOUTGry9pec1949mBmTMtj7LD0kKaT9ij8IvK5uTtvr9/DL15bx/tb9rfZNumMTGYV5jM+q18os8nJKfwi8rks37CHXxQVs2Lj3jbrE8dkMLMwnwtG9g9pMukohV9EOmTV5n3MKSpmWWlFm/WLRg1gVmE+E0YPDGky+bwUfhE5odVl+5ldVMySdW1vsXD+iH784MozuCR3oK7E6WICC7+ZZQNPAkOABmCeu881swHAs0AOsAm4wd11Cz6RTubT7QeZs7CYok93tVkfn5XOzMJ8JuVnKvhdVJBH/PXAD9z9fTPrA6wysyLgO8Dr7v5TM/tn4J+BHwU4R2TcMn85ZftO/PCKnQeqqYs5qcnGkPS0dvfL6p/GU3dcfLpHlC6geNchHlxYzCtrdrZZP2toX2YV5jPtrEEKfhcXWPjdfQewo+njQ2a2FhgOXAtMatrtN8ASFP7TomxfNRsrDp98R6C+wTu8r0TD+vJKHnq9hP/+aDutb5+TN6g3MwvzuWrsEJKSFPxEEJdz/GaWA5wHLAcGN/2lgLvvMLNB7bzmLuAugBEj9OPbHZHVv/0j+M9s3VtFfYOTkmRkD+h5Sp9LEsPmPYd56PVSXvigjIZWwR+d0Yvp0/K4ZvwwkhX8hBJ4+M2sN/AHYIa7H+zoPxHdfR4wD6CgoEDPX+uAjpyamfzAEjZWHCZ7QE8W/3BS8ENJp1W2r4qHF5Xy/Koy6lsVf8SAnkyfmse1XxpGSrIe2ZGIAg2/maXSGP2n3f2PTcu7zGxo09H+UKD9Z6+JyGm380ANjywu5b/e20JdrCX4w/ul8f0pY/jGBVnN982RxBTkVT0GzAfWuvvsVpv+G7gV+GnTry8FNYOItNh9qIZHl6zn6eVbOFLf0Lw+pG8P7p0yhm8WZNMtRcGPgiCP+C8FbgHWmNmHTWs/pjH4z5nZHcAW4PoAZxCJvD2VtcxbuoHfvLOJmrqW4Gf07s73JuXyrYtH0CM1OcQJJd6CvKpnGdDeCf2pQb2viDTaX3WEX7+5gcff2kTVkVjz+oBe3fjuFaO5ZUIOad0U/CjST+6KJJiDNXXMf3MjC5Zt5FBtffN6eloqd10+mlsvyaG3HmIeafq/L5IgKmvr+c3bm5i3dAMHquua1/t0T+GOy0Zx+8RR9O2RGuKE0lko/CJdXPWRGE++s4lfLd3A3sNHmtd7dUvmtktHcedlo0nvqeBLC4VfpIuqqYvxu+Vb+OWS9VRU1jav90hN4tZLcrj78lwG9OoW4oTSWSn8Il1MbX2M597bysOLS9l1sCX43VKSuPnikdwzKZfMPt1DnFA6O4VfpIuoizXw/KoyHl5Uyrb9LTfjS002brxwBPdOHsOQ9B4hTihdhcIv0snVxxp48cPtPPR6CVv2VjWvpyQZ1xdkcd+UPIb3072VpOMUfpFOKtbgvLx6O3MXlrCh1Z1UkwyuOz+L+6fkMWJg+zfaE2mPwi/SyTQ0OH/5ZCdzioop2V3ZvG4G1547jPun5jE6s3eIE0pXp/CLdBLuTtGnu5izsIS1Ow622Xb1uKHMmJZH3uA+IU0niUThFwmZu7OkuJw5RcWsLjvQZlvh2YOZOS2fs4f1DWk6SUQKv0hI3J23Svcwu2gd72/Z32bb5DMymVV4BuOy0sMZThKawi8Sgnc37GF2UTErNu5ts35ZXgYzpuVzwcj+IU0mUaDwi8TRqs37mF20jrdK97RZv3jUAGYV5nPx6IEhTSZRovCLxMFHW/czZ2ExS9aVt1m/YGR/flCYz5dzB9LRx5KKnCqFXyRAn2w/wJyiEhau3dVmfXxWOrMK87kiP1PBl7hT+EUCULzrEHOKinn1451t1s8e2pdZhflMPWuQgi+hUfhFTqP15ZXMXVjCn1Zvx1ueY07+4N7MnJbPV8YOISlJwZdwKfwip8HmPYeZ+3oJL36wjYZWwR+d2YsZ0/K5ZtxQBV86DYVf5BSU7avi4UWl/H5VGbFWxR85sCfTp+bxtXOHkZKcFOKEIsdS+EW+gJ0Hanh4cQnPvreVulhL8If3S+P+qWO47vwsUhV86aQUfpHPYfehGh5dsp6nl2/hSH1D8/qQvj24b8oYbijIpluKgi+dm8Iv0gF7Kmv51dINPPnOJmrqWoKf0bs7907O5aaLRtAjNTnECUU6TuEXOYH9VUeYt3QDT7y9iaojseb1Ab26cc8Vudw8YSRp3RR86Vo6FH4z6w58A8hp/Rp3//dgxhIJ14HqOhYs28iCZRs5VFvfvJ6elsrdV4zm1i/n0Ku7jpuka+roV+5LwAFgFVB7kn1FuqzK2nqeeGsj85Zu4GBNS/D79EjhHyaO5vaJOfTpkRrihCKnrqPhz3L3qwKdRCREVUfqeeqdzTz2xnr2VdU1r/fqlsztE0fxDxNHk95TwZfE0NHwv21m49x9TaDTiMRZTV2Mp5dv4dEl66mobPnHbFpqMt++ZCR3X57LgF7dQpxQ5PTraPgnAt8xs400nuoxwN19fGCTiQSotj7Gs+9t5ZHFpew62BL87ilJ3DxhJN+9IpfMPt1DnFAkOB0N/98FOoVInNTFGnh+VRkPLypl2/7q5vVuyUnceFE2904ew+C+PUKcUCR4HQq/u282s4lAnrs/bmaZQO9gRxM5fepjDbzwwTYeWlTC1r0twU9JMq4vyOa+KWMY3i8txAlF4qejl3P+BCgAzgAeB1KB3wKXBjeayKmLNTgvr97O3IUlbKg43LyenGRcd95w7p+aR/aAniFOKBJ/HT3V83XgPOB9AHffbmZ9AptK5BQ1NDivfryTBxcWU7K7snndDK49dxjTp+UzKqNXiBOKhKej4T/i7m5mDmBm+hMjnZK789qnu5hTVMzfdh5qs+3q8UOZMTWPvME6ZpFo62j4nzOzXwH9zOxO4Hbg18GNJfL5uDtL1pUzu6iYNdsOtNl25dmDmVmYz1lD+4Y0nUjn0tFv7j5gZoXAQRrP8/+buxcFOplIB7g7y0ormF1UzAdb9rfZNuXMQcycls+4rPRwhhPppDp8s5Gm0Cv20mm8u2EPs18rZsWmvW3WL8vLYGZhPueP6B/SZHI8t8xfTtm+6na3b91b1fzr5AeWtLtfVv80nrrj4tM9XqScMPxmdgjw422i8Qe42v23s5ktAK4Bdrv7OU1rXwIeA3oA9cD33H3FFxtdomrV5r3MLirmrdI9bdYnjB7ArMIzuGjUgJAmkxMp21fNxlZXVrWnvsE7tJ98cScMv7ufynfBngAeBp5stfYz4H+5+6tm9tWm3086hfeQCPlo635mFxXzRnF5m/WCkf2ZdWU+l+RmhDSZdERW/xP/nMTOA9XUxZzUZGNIevv7nuzzyMkFdl9Zd19qZjlHLwOf/SshHdge1PtL4vhk+wHmFBWzcO3uNuvnZqUz68ozuDwvAzM9yLyz0+mZziPeNxSfAfzVzB4AkoBL2tvRzO4C7gIYMWJEXIaTzmXdzkM8uLCYVz/e2WZ97LC+zCrMZ8qZgxR8kS8g3uG/B5jp7n8wsxuA+cC04+3o7vOAeQAFBQXH+z6DJKj15ZU8uLCEl1dvx1v9nz9jcB9mFubxlbFDFHyRUxDv8N8KTG/6+PfA/4vz+0sntqniMA8tKuHFD7bR0Cr4uZm9mDEtn6vHDSUpScEXOVXxDv924ApgCTAFKInz+0snVLaviv98vZTn3y8j1qr4OQN7Mn1aHl87dzjJCr7IaRNY+M3sGRqv2MkwszLgJ8CdwFwzSwFqaDqHL9G040A1Dy8q5bmVW6mLtQR/eL80pk/N47rzh5OSnBTihCKJKcirem5qZ9MFQb2ndA27D9bwyyXr+d2KLRypb2heH5reg/umjOH6C7LplqLgiwQl3qd6JML2VNby2BvreerdzdTUtQQ/s0937p2Uy40XjaBHanKIE4pEg8Ivgdt3+Ai/fnMDT7y9iaojseb1gb26cc+kXG6eMFLBF4kjhV8Cc6C6jvnLNrJg2UYqa+ub1/v1TOXuy3P59pdH0qu7vgRF4k1/6uS0q6yt5/FlG/n1mxs4WNMS/D49UrjzstHcdmkOfXqkhjihSLQp/HLaVB2p58l3NvOrN9azr6queb139xRuvzSHOyaOJr2ngi8SNoVfTllNXYzfvruZx95YT0Xlkeb1tNRkbr0kh7svH03/Xt1CnFBEWlP45QurrY/x7HtbeWRxKbsO1javd09J4pYJI/nupFwyencPcUIROR6FXz63ulgDv19ZxsOLSth+oKZ5vVtyEjddlM33Jo9hcN8eIU4oIiei8EuH1ccaeOGDbTy0qISte1uepJSSZNxwYTb3TR7DsH66V7pIZ6fwy0nFGpw/fbSdua+XtHkyUnKS8Y3zh/P9KXlkD+gZ4oQi8nko/NKuhgbnlY938ODCEkp3Vzavm8H/+NJw7p+ax6iMXiFOKCJfhMIvx3B3Xvt0F3OKivnbzkNttl0zfigzpuUxZtCpPJVTRMKk8Eszd2fxut3MLirm420H22z7ytjBzCzM58whfdt5tYh0FQp/hFQfiVEXazhm3d1ZVlrBL14r5sOt+9tsm3rmIGYW5nPO8PQ4TSkiQVP4I+BwbT0//+s6fr9yK4ebbpK280ANJbsOUVF5hDlFxazYtLfNay7Pz2TmtDzOG9E/jJFFJEAKf4KrizVw2+PvHRP26roYV819s80TrwC+PHogs67M58KcAfEcU0TiSOFPcK+s2XFM9D/TOvoFI/sz68p8LsnNiNdoIhIShT/BvbJmxwm3G/DEbRdyeX4mZnqurUgU6Pl2Ce5wbeyE2x2YkDtQ0ReJEIU/wY0dfuLLL/MG9aZ7ip5+JRIlCn+Cu/nikSd8cPntE0fFcRoR6QwU/gSXPaAnj3zrfHqkHvu/+rZLc7jxwuwQphKRMCn8EVB49mCW/WgK//J3Z9K76Rm3w/ql8ZO/H6tz+yIRpPBHREbv7tx9RS6ZfRofjNL9BKd/RCSx6U+/iEjEKPwiIhGj8IuIRIzCLyISMQq/iEjEKPwiIhGj8IuIRIzCLyISMQq/iEjEKPwiIhGj8IuIRIzCLyISMQq/iEjEBBZ+M1tgZrvN7OOj1r9vZuvM7BMz+1lQ7y8iIscX5BH/E8BVrRfMbDJwLTDe3ccCDwT4/iIichyBhd/dlwJ7j1q+B/ipu9c27bM7qPcXEZHji/c5/nzgMjNbbmZvmNmF7e1oZneZ2UozW1leXh7HEUVEElu8w58C9AcmAP8IPGftPPvP3ee5e4G7F2RmZsZzRhGRhBbv8JcBf/RGK4AGICPOM4iIRFq8w/8iMAXAzPKBbkBFnGcQEYm0lKA+sZk9A0wCMsysDPgJsABY0HSJ5xHgVnf3oGYQEZFjBRZ+d7+pnU03B/WeIiJycvrJXRGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiRuEXEYkYhV9EJGIUfhGRiFH4RUQiJiXsAeT0uWX+csr2VZ9wn617q5p/nfzAknb3y+qfxlN3XHw6xxORTkLhTyBl+6rZWHG4Q/vWN3iH9xWRxKLwJ5Cs/mkn3WfngWrqYk5qsjEkvf39O/K5RKRrUvgTiE7NiEhHBPbNXTNbYGa7zezj42z7oZm5mWUE9f4iInJ8QV7V8wRw1dGLZpYNFAJbAnxvERFpR2Dhd/elwN7jbJoD/BPgQb23iIi0L67X8ZvZ14Bt7v5RB/a9y8xWmtnK8vLyOEwnIhINcQu/mfUE/hX4t47s7+7z3L3A3QsyMzODHU5EJELiecSfC4wCPjKzTUAW8L6ZDYnjDCIikRe3yzndfQ0w6LPfN8W/wN0r4jWDiIiAuQfzPVYzewaYBGQAu4CfuPv8Vts30cHwm1k5sDmQQaMpA9BfuNIZ6Wvz9Brp7secKw8s/NJ5mdlKdy8Iew6Ro+lrMz50d04RkYhR+EVEIkbhj6Z5YQ8g0g59bcaBzvGLiESMjvhFRCJG4RcRiRiFP0GZ2RIz+8pRazPM7Jdmlm9mr5hZqZmtNbPnzGxwWLNKdJlZlpm9ZGYlZrbezOaaWTczm2RmL4c9X6JS+BPXM8CNR63d2LT+Z+BRdx/j7mcBjwK6IZLElZkZ8EfgRXfPA/KB3sD/CXWwCFD4E9fzwDVm1h3AzHKAYTT+4XrH3f/02Y7uvtjdj3lgjkjApgA17v44gLvHgJnA7UDPMAdLdAp/gnL3PcAKWh6GcyPwLDAWWBXWXCKtHPO16O4HaXxI05hQJooIhT+xtT7d89lpHpHOwjj+A5naW5fTROFPbC8CU83sfCDN3d8HPgEuCHUqkUafAG3uy2NmfYFsYH0oE0WEwp/A3L0SWAIsoOVo/3fAJWZ29Wf7mdlVZjYu/hNKxL0O9DSzbwOYWTLwCxqf110V4lwJT+FPfM8A5wL/BeDu1cA1wPebLqH7FPgOsDu0CSWSvPG2AV8HrjezEqAYqAF+TOOzQmpDHC+h6ZYNItLpmNl0YLi7/1PYsySiuD2BS0SkI8xsPnAOcEPYsyQqHfGLiESMzvGLiESMwi8iEjEKv4hIxCj8IiIRo/CLiESMwi9yFDPrZWZ/NrOPzOxjM/ummW0ys4ym7QVmtqTp4/9pZk+Z2aKmH4i7s2l9kpktNbMXzOxTM3vMzPTnTToFXccvcqyrgO3ufjWAmaUD/3GC/ccDE4BewAdm9uem9YuAs4HNwF+A62i8XbZIqHQEInKsNcA0M/sPM7vM3Q+cZP+X3L3a3SuAxTQGH2CFu29ous/8M8DEAGcW6TAd8Yscxd2LzewC4KvA/zWz14B6Wg6Uehz9knZ+3966SKh0xC9yFDMbBlS5+2+BB4DzgU203M76G0e95Foz62FmA4FJwHtN6xeZ2aimc/vfBJYFPbtIR+iIX+RY44Cfm1kDUAfcA6QB883sx8Dyo/ZfQeNzjEcA/9vdt5tZPvAO8NOmz7cUeCFO84uckMIvchR3/yvw1+Nsym/nJcXuftdx1qvc/ZunbzKR00OnekREIkZ35xQRiRgd8YuIRIzCLyISMQq/iEjEKPwiIhGj8IuIRMz/B7kWXNfQH1QxAAAAAElFTkSuQmCC ) Content last modified on 26 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create bivariate plots to compare groups/Python, using Matplotlib and Seaborn.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-create-bivariate-plots-to-compare-groups-in-python-using-matplotlib-and-seaborn/",
    "relUrl": "/how-to-create-bivariate-plots-to-compare-groups-in-python-using-matplotlib-and-seaborn/"
  },"401": {
    "doc": "How to create bivariate plots to compare groups (in R, using lattice and gplots)",
    "title": "How to create bivariate plots to compare groups (in R, using lattice and gplots)",
    "content": "# How to create bivariate plots to compare groups (in R, using lattice and gplots) [See all solutions.](../how-to-create-bivariate-plots-to-compare-groups) ## Task Suppose we have a dataset with different treatment conditions and an outcome variable, and we want to perform exploratory data analysis. How would we visually compare the treatment conditions with regards to the outcome variable? Related tasks: * [How to create basic plots](../how-to-create-basic-plots) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to plot interaction effects of treatments](../how-to-plot-interaction-effects-of-treatments) ## Solution We use a built-in dataset called `ToothGrowth` that discusses the length of the teeth (`len`) in each of 10 guinea pigs at three Vitamin C dosage levels ($0.5$, $1$, and $2$ mg) with two delivery methods - orange juice or ascorbic acid (`supp`). ```R # You can replace this example data frame with your own data df <- ToothGrowth ``` If you wish to understand the distribution of the length of the tooth based on the delivery methods, you can construct a bivariate histogram plot. ```R # install.packages( \"lattice\" ) # if you have not already done this library(lattice) histogram( ~ len | supp, data = df) ``` ![png](data:image/png;base64,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 DgAgEsKOo1oqlZr1q4WXjhzT4fQLszv1zet27ikX/Nt/3P7gG39/a38/0qhjr4xP96z5Z8Ld 0+pzWuCwGnz1NzM+3XPJslfqPFpdXd3xc4Obdj7jvS1ba1ZqfgO55NrRx536hexOfdv+ywU9 B109+cGfvvXO5nqcGj5A2HH0endz+bnDvvalr459/sVlp/Xo9tWrLh120edTqdQP/mtG0ZmX PvrUL+v8qW+OvOKbX7li0Pln1PO0wOH2tau/GEJ4+Gdz6jz620VL3/j7W18cfP6nWrcKIZRv 2z7gihu/9NWxCxa/1PPk7l+96tL+Z/Uq37p9wt3Tenz+8hdfWlWvo8P/412xHKWqqqq/eN1/ LF668opLBv5o8thj8lrWHvrtoqX/duP4a79z67HH5F3U/6wP/eC9N387hPDknN/+usQbqCEq gz/f79P5bZ+e+/yDt303N6f5h47WBN9Xr/zXml9eeeOE519cNnTgOT/+wYQ2n2pds1hdXT39 8dn/Pv7uoV8e/efFs9oee7R/9iH1zzN2HKWenvv84qUrz+17+uM/un3fqgshDDinz7M/+UEI 4VuT7q2urk5oQKC+ZWVljrxi6M5dFU/O+c2HDr23Zesvfru4a2HBOX1PCyHM/9/fzyv53Wk9 us2a/v3aqgshZGZmXn/1F28dc/1pPbr9ZeOb9To9hBCEHUetGbPmhhC+N/prGRkZHz16dp/T Pt/vc3/Z+Ob+rrYBovSVf7skMzPzo6/Gzpz1qz179371qv/7dN2MWb8KIYz/xrWNGtXxlQP/ +Y1rn//5tL6n/8vhnhY+SthxlHpp5WvNmmaf+bmT93eHL5x3RgjhDy//sR6HAhJ2/HHtBp13 xkurXvvT2r/uu/7TJ3+R3aTJiC9dVPPLl1a9lpGR0f+s3knMCAci7DgaVVZWbS7f1q7Np+r8 23aNgg7tQwib3nmvHucCklfztNzDP3uudmX5K6v/+Of1wy76fM3bJkIIb72zuVVuTsvcFsmM CPsn7DgaZWRkZGRkHPj6uZqjWZn+G4Gjy+DP9+vQvu3MZ+bt2bu3ZqUm8r565aW198nMzKiq rkpmPjggf2hxNMrKymx7bOuyt97d/f6e/d1n45tlIYTj8tvU41xA8rKyMkdeccm7m8t/8dvF IYSK3e8/Oee33bp0OrvPabX3Oa5dm+07dr27uTy5MaFuwo6j1Bk9T95bWfn8iy/t7w6/XbQ0 hHBWr1PrPJpKpUIImZ7Pgxh95d8uycr6v2+heOZXC7du31H7tokaZ/Q8OYTwywWL6/zxVCr1 /60prYc54aP8scRR6trhQ0IIN9/z0N7Kyo8eXbLslYVLlv/LiUWfO6V7CGHKT39+0nmX/e/v V9Teoeztd0MIH/qcFCAOHdq3HXTemQsWL313c/n/PPvrptn/eNtEjS9ffnEI4dYf/mT7jl0f /fFpjz19cv8rpj76VD2NC/sQdhylLup/1kX9z1r5xz9feu2Yt9/9wPf/LFyy7JJrR2dlZf5o 8n/UrLRulbt63V9/8F8zai6827N37/88My+EsO9LM0BMvnrVpVVV1T9+fPbCJcu+OPjzH/pb 3Fm9T718yIDX3/j7BcNH7ft5dZWVVQ8+/OQ3J93Tvu2x/3bpF+p9avDNExzFnpg6+fIbbvrV wiWd+ww5/8zPdTq+/e7397z8/61Z9dranBbNn/rvu87q/X9fh7186IAf/viJX5f8/rSBV/U9 vcfil1atXvfXL13U/7Qe3ZL9nwAcJhee3+/449rddv9PKiurvvbB12Fr/PS+Se/v2fPc/Be6 nf3Fs3qd+pkTOpZv27F05R83vll2QsGn5z8+pXUrz+iTAM/YcfTKzWk+b+aDsx++5wvnnbHq tbXT/2f2U79ckEqlxn39y+t/99ylg86rvWfjRo0WPvVfY66/evvOnT998hc7d1XcOe7ffzbt jgSHBw6rmm+hqNj9/olFnWv/jrev5s2azn74nl88et+QAees/cvGnz75i3klS/LbfGranTe9 VvJUUeeO9T8zhBAyaq4BJ4Twm9/8ZuiQIbs3+AJQ4AOKzry0X69THvnhzUkPAjQsTTufMecX vxg4cGDSg/yDZ+wAACIh7AAAIiHsAAAi4V2x/1BdXV1dXf38i8uSHgRoWHbs3PX3t97xmwPw ITXlkPQUHyDs/uGNN96oqqq6YPiopAcBGpxNi96r+TISgFqZGRlvvPFG0lN8gLD7h4KCgsZN muzevTvpQYCGpaioKIRQWupLooAPaNq0aUFBQdJTfIBr7AAAIiHsAAAiIewAACIh7AAAIiHs AAAiIewAACIh7AAAIiHsAAAiIewAACIh7AAAIiHsAAAiIewAACIh7AAAIiHsAAAiIewAACIh 7AAAIiHsAAAiIewAACIh7AAAIiHsAAAiIewAACIh7AAAIiHsAAAiIewAACIh7AAAIiHsAAAi IewAACIh7AAAIiHsAAAiIewAACIh7AAAIiHsAAAiIewAACIh7AAAIiHsAAAiIewAACIh7AAA ItEo6QEgWqtWrXrvvfeSnaFx48Znn312RkZGsmMAUD+EHRwuZ555ZkVWVmjcOLEJUqlQXv7y yy+fdtppic0AQD0SdnC4VFZWhjlzwgUXJDbBrl2hRYvKysrEBgCgfrnGDgAgEsIOACASwg4A IBLCDgAgEsIOACASwg4AIBLCDgAgEsIOACASwg4AIBLCDgAgEsIOACASwg4AIBLCDgAgEsIO ACASwg4AIBLCDgAgEsIOACASwg4AIBLCDgAgEsIOACASwg4AIBLCDgAgEsIOACASwg4AIBLC DgAgEsIOACASwg4AIBLCDgAgEsIOACASwg4AIBLCDgAgEsIOACASwg4AIBLCDgAgEsIOACAS wg4AIBLCDgAgEsIOACASwg4AIBLCDgAgEsIOACASwg4AIBLCDgAgEsIOACASwg4AIBLCDgAg EsIOACASwg4AIBLCDgAgEkdA2FVUVIwdO7agoCA7O7tTp0533XVXZWVl7dEHH3ywsLAwOzu7 W7duM2fOTHBOAIBkNUp6gH/u2muvLSkpufPOO4uKil588cXx48fv3bt34sSJIYTp06ePGTNm 8uTJvXv3LikpGTFiRKtWrYYMGZL0yAAACWjoYVdeXj5//vwHHniguLg4hHDWWWetWrXq2Wef nThxYiqVuuOOO2688cbvfve7IYSzzz57zZo1kydPFnYAwNGpoYddXl7eli1b9l1p1KhRo0aN QgilpaUbN24cOnRo7aGLL7746quv3rZtW8uWLet7UACApB0B19jVqKio2LRp00MPPTRnzpzR o0eHENatWxdCKCwsrL1Pze3S0tKkhgQASFBDf8au1qBBgxYtWtS6deuHH354+PDhIYRt27aF EPZ9ci43N7d2fX+2b9/+zjvv1HmorKwslUqlc2gAIF6pVKqsrOyvf/1rnUfbtGlTUyb16YgJ uylTppSVlZWUlFxzzTXl5eU33HDDwT3OjTfeeIA3z2ZkZBzsgADA0WXv3r1f/vKX93f06quv njFjRn3OE46gsOvRo0ePHj0GDBiQm5s7evTo4uLivLy8EMLWrVtbtWpVc5/y8vIQQs36/vzk Jz954IEH6jxUUlJy5ZVXpntwACBOTZo0efzxx88///w6j7Zo0aKe5wkNP+z+9re/lZSUXHrp pTk5OTUrJ598ckVFxRtvvNG1a9cQQmlpaceOHWsOrV27Nisrq2Z9f5o0adKkSZM6D9VuAQDw ceTk5LRu3TrpKf6hob95YtOmTcXFxXPmzKldWblyZWZmZkFBQWFhYVFR0ezZs2sPPffcc+ec c07z5s2TmBQAIGEN/Rm7008/fcCAAd/4xje2b99+0kknrVix4u677x45cmSzZs1CCBMmTBg5 cmSHDh369u07d+7cefPmLVy4MOmRAQCS0dDDLoTwzDPPTJo06ZZbbtm8eXNBQcHo0aPHjRtX c6i4uHjHjh333HPPpEmTioqKnnrqqXPPPTfRYQEAEnMEhF1OTs59991333331Xl01KhRo0aN queRAAAaoIZ+jR0AAB+TsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCI hLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMA iISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLAD AIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISw AwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiE sAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCI hLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMA iISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLAD AIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISw AwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiE sAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCI hLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMA iISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLAD AIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISw AwCIhLADAIiEsAMAiISwAwCIRKOD/sk333zz49+5Q4cOB70RAAAfx8GH3fHHH//x75xKpQ56 IwAAPo6DD7vLL788jXMAAHCIDj7snnzyyY9zt507d27fvv2gdwEA4GM67G+emDNnzmmnnXa4 dwEA4OCfsfuQd99998knn3z99dcrKytrF3fv3j137twdO3akaxcAAPYnPWH3+uuv9+rV6513 3qljg0aNJk6ceCgPXlVV9cADDzz88MOvv/768ccff+21144ePTorK6vm6IMPPvjAAw+8+eab nTt3Hj9+/NVXX30oewEAHLnSE3YTJkzYvXv3j370oxNPPPHzn//8T37ykw4dOrzwwgszZ858 +OGHBw4ceCgPPnHixHvvvfe2227r3bv34sWLx40bl5mZOWbMmBDC9OnTx4wZM3ny5N69e5eU lIwYMaJVq1ZDhgxJy/8oAIAjTCodOnbseNNNN6VSqYqKihDCH/7wh5r1VatWHXPMMUuWLDno R96zZ09OTs7YsWNrV4YNG9azZ89UKlVdXV1QUPCtb32r9tBll13Wq1evg95r/vz52dnZB/3j 8CGNGzcOv/1tSKUS+2fnzhDCSy+9lPSZOOJ16dKlS5cuSU8BNDjZ2dnz589PeooPSM+bJ8rK yk444YQQQmZmZghhz549NeunnHLKjTfeePPNNx/0I2dlZa1atWrs2LG1Kx07dty8eXMIobS0 dOPGjUOHDq09dPHFFy9btmzbtm0HvR0AwJErPWGXm5v71ltvhRCaNGmSk5Pz17/+tfZQ9+7d V6xYcdCPnJmZ2aVLl9atW9f8srKycsGCBf369QshrFu3LoRQWFhYe+ea26WlpQe9HQDAkSs9 19idddZZ//3f/92vX79zzz23R48eU6dOHTZsWE5OTgihpKQkOzs7LbuEEMaNG7dhw4Znnnkm hFDzzFzLli1rj+bm5tau7899993361//us5D77333r5v6YUjXnV1COHrX//6vv+Z1L/s7OzH H3+8VatWCc6QrPfff//yyy/fuXNnsmO0aNHiySefbNq0aVIDvPXWW9dcc03iv822b99+xowZ yc5ANCorK8eNG3fPPffUeXTQoEHf+c536nmk9ITdf/7nf55zzjljxoxZsWLFddddd+2113bv 3r1nz54bNmx45ZVXrrzyyrTsctNNN02ZMuXZZ58tKio66Ac55ZRT9u7dW+ehdevW/fGPfzzo R4YGZ/fuEMKyz30ufJIvAEyz7dvD5MmbNm06msNuy5Ytc+bMCaNHhzZtEhvinXfCvfdu2bKl ffv2SY2wcePG+fPnh9tuC40bJzVDKC1tPGOGsCNdMjIyTj311M985jN1Hj3llFPqeZ6QrrDr 1avXkiVLli1bFkK45pprSktL77///tmzZ2dkZAwZMuT+++8/xMevrq7+2te+9vOf/3zevHnn n39+zWJeXl4IYevWrbV/YJSXl9eu78/5559f+wgf8pvf/Obxxx8/xFGhwSkuDr16JbZ7WVmY PDmx3RuUr3wldOuW2O5r14Z7701s93195zuhefPEdl+wIKg60icrK+uyyy47xE//SK+0fUDx 6aeffvrpp4cQMjIy7rjjjkmTJm3atKldu3bNmjU79Af/+te/Pnv27JKSkp49e9Yudu3aNYRQ WlrasWPHmpW1a9dmZWXVrAMAHG3S8+aJJUuW1LxTtVbTpk07derUrFmzZcuW1VwSd9BmzJjx yCOPzJ8/f9+qCyEUFhYWFRXNnj27duW5554755xzmif4d0EAgOSk7c0Ts2fPvuSSSz566MUX X5w8efIXv/jFg3vkioqK8ePHDxo0aMeOHS+88ELt+hlnnNGkSZMJEyaMHDmyQ4cOffv2nTt3 7rx58xYuXHhwGwEAHOkOKezWr1+/fv36mturVq366JutKioqnnrqqffff/+gt1i7du2bb775 5ptvPvvss/uul5WV5efnFxcX79ix45577pk0aVJRUdFTTz117rnnHvReAABHtEMKu1mzZo0b N67m9q233rq/uw0bNuygtzjllFNSqdQB7jBq1KhRo0Yd9OMDAETjkMLupptuGjFixPLly4cO HXr11Vd37979Q3fIyso64YQTfHkrAEA9ONRr7Nq3bz9kyJDBgwePGjWqT58+aZkJAICDkJ43 T8ydO7fmxrvvvltaWrpz587c3NyuXbse+CPlAABIo/R83EkIYcmSJX369GnTps0ZZ5xxwQUX 9OnT55hjjunfv/9rr72Wri0AADiA9Dxjt2zZsv79+1dWVvbr169r167NmjXbuXPn6tWrS0pK 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 WFiYnZ3drVu3mTNnJjIeAEBD0CjpAf65srKyK6644u23387KyvrQoenTp48ZM2by5Mm9e/cu KSkZMWJEq1athgwZksicAADJOgLC7vHHH2/Tps3cuXOPPfbYfddTqdQdd9xx4403fve73w0h nH322WvWrJk8ebKwAwCOTkfAS7HDhw9/+umnc3JyPrReWlq6cePGoUOH1q5cfPHFy5Yt27Zt W/0OCADQIBwBYdehQ4c619etWxdCKCwsrF2puV1aWlo/gwEANChHwEux+1PzzFzLli1rV3Jz c2vX9+dPf/rT6tWr6zz06quvVldXp3VGAGh4Kip27Njx9NNPJztFYWHhaaedluwMh6i6uvrF F1/cX3h07979pJNOqueRjuCwOzgzZsyYNWtWnYcqKiqqqqrqeR4AqG8rV761efNlN92U5Axb t/bs3Hn58uVJznDIqqqqfvrTnzZr1qzOo8OGDbv77rvreaQjOOzy8vJCCFu3bm3VqlXNSnl5 ee36/tx99937O8u/+c1v9r1iDwDiVF0dOnYM69cnOcN991U//niSA6RD48aNH3nkkYEDByY9 yD8cAdfY7U/Xrl3DB6+oW7t2bVZWVs06AMDR5ggOu8LCwqKiotmzZ9euPPfcc+ecc07z5s0T nAoAIClHwEuxK1eurLkssbq6ev369S+88EIIoU+fPk2bNp0wYcLIkSM7dOjQt2/fuXPnzps3 b+HChQmPCwCQkCMg7EaNGvXSSy/V3J46derUqVNDCBs2bOjUqVNxcfGOHTvuueeeSZMmFRUV PfXUU+eee26SswIAJOcICLulS5ce4OioUaNGjRpVb8MAADRYR/A1dgAA7EvYAQBEQtgBAERC 2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBE QtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEA RELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgB AERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELY AQBEQtgBAERC2AEARKJR0gMAAEefyspdu3a9/PLLyU7x6U9/Oj8/P9kZ0kvYAQD1bunSP//5 zz179kx2ioEDB86fPz/ZGdLLS7EAQL2rqgqnnRZSqST/ufnmPXv2JH0i0kzYAQBEQtgBAERC 2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBE QtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEA RELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgB AERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELY AQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARKJR0gMA8du2bduW LVsSHKBx48Y5OTkJDgBQP4QdcDht2xZC6NWrV7JTNG7c+O23387Ly0t2DIDDTdgBh1NFRQgh LFgQTjghsRn+8pe9Awbs3r07sQEA6ouwAw6/449PMuz27Elsa4D65c0TAACREHYAAJEQdgAA kRB2AACREHYAAJEQdgAAkRB2AACREHYAAJEQdgAAkRB2AACREHYAAJEQdgAAkRB2AACREHYA AJEQdgAAkRB2AACREHYAAJEQdgAAkRB2AACREHYAAJEQdgAAkRB2AACREHYAAJEQdgAAkRB2 AACREHYAAJEQdgAAkRB2AACREHYAAJEQdgAAkRB2AACREHYAAJEQdgAAkRB2AACREHYAAJEQ dgAAkRB2AACREHYAAJEQdgAAkRB2AACREHYAAJEQdgAAkRB2AACREHYAAJEQdgAAkRB2AACR EHYAAJEQdgAAkRB2AACROOLD7sEHHywsLMzOzu7WrdvMmTOTHgcAIDGNkh7gkEyfPn3MmDGT J0/u3bt3SUnJiBEjWrVqNWTIkKTnAgBIwBEcdqlU6o477rjxxhu/+93vhhDOPvvsNWvWTJ48 WdgBAEenI/il2NLS0o0bNw4dOrR25eKLL162bNm2bdsSnAoAIClHcNitW7cuhFBYWFi7UnO7 tLQ0sZkAAJKTkUqlkp7hID3xxBNXXnlleXl5q1atalZee+21Hj16lJSUnHfeefv7qRtvvPFn P/tZnYf27t27c+fO6urqTzTGV7/61VmzZtXc3rVr1549ez7Rj6ddKpUKzZqFpk2THGLLltC8 ecjOTniGFi1CkyYJz5CTExo3TmyAVCqUl4fc3NAouYsuqqrCtm2hZcuQlZXsDHl5eRkZGSGE 5s2br1+/vukn+W+kqKgofMK/NO7evbtLly67du0KIaRSqfLy8oRPwt69YceO0KpVyEzu7/Pv vx927Qp5eSEjI7EZdu8OFRWhdevEBgghVFSE998PeXlJzrBzZ6isDP/vT89k7NgRqqtDy5ZJ zlBR0biqKicnp+ZXw4YNmz59+id6gMzMzBYtWjTez+/zV1xxxdSpUw91yE/oCL7G7uD8x3/8 x6WXXlrnoRUrVtx8882f9AHHjRt32WWX1dzetGnT3//+90Oa75C9++67LVu2bJJo0Lzzzjt5 eXn7+xe9frz11lvHHntsVoJ/joZQVlaWn5+fkeCfYQ1jhr///e/HHXdcggOEEJo1a3biiSfW 3M7JyflEVXdwmjZtOmvWrB07dtT8cs2aNRUVFYd70wNL/P+IVCpVVlaW7AzV1dVvv/12fn5+ gjNUVVW9++677dq1S3CGvXv3lpeXt2nTJsEZ9uzZs23btmOPPTbBGUIIxx13XO2/D/u+Bvgx NW7cePz48T179qzzaM3fCevZERx2eXl5IYStW7fWPmNXXl5eu74/BQUFBQUFdR6qqqo6iD// Onfu3Llz50/6U0D0+vTpU3u7f//+CU4CHCYZGRmnnnpqg/oP/Ai+xq5r167hgy+OrF27Nisr q2YdAOBocwSHXWFhYVFR0ezZs2tXnnvuuXPOOad58+YJTgUAkJQj+KXYEMKECRNGjhzZoUOH vn37zp07d968eQsXLkx6KACAZBzZYVdcXLxjx4577rln0qRJRUVFTz311Lnnnpv0UAAAyTiy wy6EMGrUqFGjRiU9BQBA8o7ga+wAANiXsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiE sAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCI hLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMAiISwAwCIhLADAIiEsAMA iISwAwCIhLADAIiEsAMAiESjpAdoQBo1avT+++9nZGQkPQjQEPnNAfioRo0aVkplpFKppGdo KKqqqhYvXlxVVZX0IMkbO3bsiSeeeM011yQ9SAN17bXX/uu//utFF12U9CAN1NChQ8eNG9en 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 8+AjAAAAAElFTkSuQmCC) To visualize the summary statistics of the length of the tooth based on the delivery methods, you can construct a bivariate box plot. ```R bwplot(df$len ~ df$supp) # Or the following code produces a similar figure, using the mosaic package: # boxplot(len ~ supp, data = df) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAIAAAByhViMAAAACXBIWXMAABJ0AAASdAHeZh94 AAAgAElEQVR4nO3deZRU9Z3w/28vgs0ioCE2HYIty0jCk0EGR3BBmDgqaIAclzOYGCByNIBK 5IARVMigYpBojoho9MQ4EWKCRHBhDARlEM2440IIYXnCT8CBURTsJjYK3fX7o/O0iA1Kc+lb 9a3X6y/q3qLq4znm5O2tW/UpyGQyAQCA3FeY9gAAACRD2AEARELYAQBEQtgBAERC2AEARELY AQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC 2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBE QtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEA RELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARKI47QGyyFtv vTVq1Kjdu3enPQgAkAOKi4vvueee8vLytAf5hLD7xF/+8pc//OEP48ePT3sQACAH3H777X/5 y1+EXfYqLi6eNm1a2lMAADlgxowZaY+wL/fYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEA RELYAQBEQtgBAERC2AEARELYAQBEQtgBAERC2AEARELYAQBEIgfCrqqq6tprrz3uuOOaNm1a Xl4+bdq0PXv21J4aOHBgwaeNHDky3WkBANJSnPYAn+/SSy9dunTpT37yky5dujz77LPXX3/9 7t27J02aFEKorKwcNGjQ2LFj655cVlaW3qQAAGnK9rDbsWPHokWLZsyYMXTo0BBCnz59Xnvt tfnz59eFXc+ePfv165fylAAAWSDbw65169bbt2/f+0hxcXFx8d/HrqioaNGiRRpzAQBknWwP uzpVVVUffPDBY4899thjj/3yl7+sPVhZWdm8efN0BwMAyBIFmUwm7Rm+kH79+j3zzDNt2rSZ NWvWxRdfXHuwefPm55577qZNm1atWlVaWnrRRRdNmjSppKTkAK8zbty4Bx54oN5Tu3fv/vDD D6urq5OfHgCITlFRUbNmzY444oh6z37/+9+//fbbG3mknLliN3PmzC1btixdunT48OE7duwY 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 AABwAMmEXWlp6erVq+s9tXz58rKyskTeBQCAA0gm7M4999y77757xYoVex/cvn379ddf/8AD D5x33nmJvAsAAAeQTNhNmTKlRYsWvXr1qm24iRMn9ujRo127drfcckuHDh0mT56cyLsAAHAA iX0U+8orr1x22WVvvfVWCOH1119//fXXW7ZsOWrUqJdffvnYY49N5F0AADiAxH6g+Mtf/vLd d989a9asd955p7KysmXLlnoOAKAxNTzsNm/evL9TRx555O7du/d+wmd/CQUAgGQ1POz29/sm 9cpkMg1+IwAAvoiGh92//du/JTgHAACHqOFh99vf/jbBOQAAOEQJfCv25Zdf/utf/1r38KOP PpoxY8Z5553Xp0+fH/3oR++8886hvwUAAJ/rkMJu165dQ4YMOfnkkx9//PG6g9/5zneuvvrq xYsXr1y58qc//enJJ5+s7QAAGsEhhd1tt902d+7c888//6yzzqo98tRTT82fP/9b3/rW9u3b d+zY8Zvf/Gbjxo033XRTEqMCAHAghxR2999//6mnnvrII49069at9sjs2bOLiop+/vOft2zZ MoQwZMiQ/v37L1y4MIFJAQA4oIZ/eeKpp57avHlzv379nnrqqbqDixcvPv7441evXr169era I61bt3777befeuqpjh07duzY8VDnBQBgPxoedhdeeOGePXvmzp27YMGC2iN79uz529/+VlFR ceGFF9Y97aOPPtq9e/eFF144YcKECRMmHOq8AADsR8M/it2xY0ebNm2uu+66Hf/PtGnTQgiL Fi3asZdRo0YdffTRO3bsUHUAAIfVId1j17Vr1//8z/+s3SpRVVV11113tWvX7vTTT697Qk1N zdNPP+0TWACARnBIYXfFFVe88MILffr0ufrqq0866aQ1a9ZMnDixsPDvr7ljx47LL7/8zTff HD58eAKTAgBwQA2/xy6E8N3vfnfjxo1Tpkz54x//2LRp08mTJ1955ZV1Z7/2ta9t3br1vPPO u+yyyw55TgAAPschhV0IYeLEiT/84Q+3bt1aWlrarFmzvU+NHDmyvLz8kksuKSoqOsR3AQDg czX8o9hx48YtXbo0hNCsWbPp06evW7dunyf8+Mc/HjZsmKoDAGgcDQ+7O+6446WXXqr98733 3rthw4aERgIAoCEa/lHssccee+utt27atKl2ycTs2bNfeOGF/T259pdQAAA4fBoedtOnT7/s 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 unbtevbZZ7/66qtpDwIA5IB//dd/7dq1a9pTfEpBJpNJewYAABLgHjsAgEgIOwCASAg7AIBI CDsAgEgIOwCASAg7AIBICDsAgEgIOwCASAg7OGiZTObBBx/s27dvmzZtjjzyyM6dO//whz/8 n//5n32e1rt374KCgoKCghNPPDGVOYEQwplnntm9e/fPHl+7dm1BQcGsWbNqH2YymdmzZ/ft 27d169bNmzf/2te+dsMNN7z//vuNOywcKmEHB6empmbIkCHDhw9v3779Pffc88gjj4wYMWLe vHknnnjim2++ufczZ86cuWTJkj59+qQ1KhBCGD58+JtvvrnP/zxDCHPmzGnSpMnFF19c+3Do 0KHDhg1r167dz3/+8zlz5nz729++6667TjnllK1btzb6yNBwVorBwbnrrruuuuqqX//619/5 znfqDm7btu20004rKChYtWpVUVHR3s+/8MIL169f//rrrzf6pEAIIXz44YelpaUjR46cPn36 3sc7der0T//0T/PmzQshPPDAA5deeum99957+eWX1z1h9erVvXr1GjJkyH333dfYQ0NDCTs4 OF26dDn++OP/8Ic/7HP88ccfHzx48OOPPz5w4MC9jws7SN2ll176hz/8YePGjYWFf/+c6r// +79PO+20hQsXnnfeeSGEHj16NGnS5MUXX9znL7722msnnHBCs2bNGntiaCgfxcJB2LJly/r1 688666zPnqo9+MwzzzT6UMDnGD58+Ntvv/1f//VfdUfmzJlTWlrav3//EMIHH3zwxhtv1Pu/ 6x49eqg6couwg4Pw9ttvhxDKy8s/e6qkpKS0tLT2CUBW6dOnT8eOHWfPnl37cPfu3Q8//PAl l1xSe+PEli1bMplMx44dU50RkiHs4CDUfo6ze/fues/W1NTUfdADZI+CgoKhQ4fOnz+/qqoq hPD73//+vffeGz58eN3ZEMIRRxyR4oSQFP8nBAfhq1/9aghhw4YNnz1VVVX1zjvvdOjQodGH Aj7fsGHDdu7c+eijj4YQ5syZc9JJJ3Xr1q32VFlZWWFh4bp161IdEJIh7OAgtG3btlu3br/9 7W8/+62jp556KoRw5plnbtq0ae9bsD/++GP36EDqysvL+/bt+9BDD1VWVj7xxBN1l+tCCC1b tuzRo8evfvWrjz76aJ+/9bvf/e6JJ55o1EHh0Ag7ODhjx47905/+dM899+x98L333rvmmmt6 9Ohx5pln/vSnPx0wYMCHH34YQshkMn/+8587d+6c0rDAJ4YNG/bUU0/Nmzevpqam7ufrao0d O3bjxo033njj3gdXrVp1+eWXP/744407JhwSP3cCByeTyQwbNmz27NlDhgz59re/3aJFiz/9 6U8zZ87MZDJLly494YQT3njjjX/+538+66yzLr/88oULF/7iF7947rnnTjvttLQHh3z3t7/9 rbS0tEWLFqeffnrtz9ft7bLLLvvFL37Rv3//IUOGtGjR4tVXX501a9bXv/71RYsWtWrVKpWB oQGEHRy0TCbzm9/85r777nv99dd37dr11a9+ddCgQRMmTGjbtm3tE5544onJkyevXbv2+OOP //GPf3zRRRelOzBQa/jw4b/61a/qfr5uH3Pnzr3nnntef/31PXv2dOzY8ZJLLrnyyivdSkFu EXYAAJFwjx0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAkhB0A QCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQd AEAkhB0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAkhB0AQCSE HQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAk hB0AQCSEHQBAJIQdAEAkhB0AQCSEHQBAJIQdAEAk/n96VZ517jc6HwAAAABJRU5ErkJggg==) To plot the means for both treatment levels of `supp` for the `len` column, we load the `gplots` package and use the `plotmeans` function. ```R # install.packages( \"gplots\" ) # if you have not already done this library(gplots) plotmeans(df$len ~ df$supp) ``` Attaching package: ‘gplots’ The following object is masked from ‘package:stats’: lowess ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAIAAAByhViMAAAACXBIWXMAABJ0AAASdAHeZh94 AAAgAElEQVR4nOzdeXhVhYH//xNZAsqqQEQF2axSo95iCCAwSNqAKBZkq9oaLCoKqLhAWVwa hFYpU8eAWkFaFQEF3FndQDQBwnoRqIMFrVWU0YdFNtkCvz8yX36ORXZyck9er2f+SM49ST/z zJPpm3vPuTdp//79AQAAie+UsAcAAHBiCDsAgIgQdgAAESHsAAAiQtgBAESEsAMAiAhhBwAQ EcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARISwAwCICGEHABARwg4AICKEHQBARAg7 AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHsAAAi QtgBAESEsAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARISwAwCICGEH ABARwg4AICKEHQBARAg7AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBE CDsAgIgQdgAAESHsAAAiQtgBAESEsAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewA ACJC2AEARISwAwCICGEHABARwg4AICKEHQBARAg7AICIEHYAABEh7AAAIkLYAQBEhLADAIgI YQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHsAAAiQtgBAESEsAMAiAhhBwAQEcIOACAihB0A QEQIOwCAiBB2AAARIewAACJC2AEARISwAwCICGEHABARwg4AICKEHQBARAg7AICIEHYAABEh 7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIkqHPSAxLF++fO/evWGvAACKhdKlS19yySVhrzgI YXd4ixcvbty4cdgrAIBiZNGiRWlpaWGv+CFhd3i7d+8OgmDXrl1ly5YNewsAELLdu3cnJycX 5kFx4xo7AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAA ESHsAAAiQtgBAESEsAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARETp sAdAQvrqq2DVqoMc37gxCILg9NMP8tCFFwY1a57cVQCUcMIOjsVf/xo8+uhBju/YEQRBcOqp B3nonnuC++8/uasAKOGEHRyL++8/eKX99rdBEATPPFPEcwAgCFxjBwAQGcIOACAihB0AQEQI OwCAiBB2AAARIewAACJC2AEARISwAwCICGEHABARwg4AICKEHQBARAg7AICIEHYAABEh7AAA IkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHsAAAiQtgBAESEsAMAiAhh BwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARISwAwCICGEHABARwg4AICKEHQBA RAg7AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHs AAAiQtgBAESEsAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARISwAwCI CGEHABARkQq7TZs2/fOf/wx7BQBAOBIp7D788MOrrrqqTp06LVu2fPLJJwsKCn5wwvDhw+vW rRvKNgCA0JUOe8CRysvL+/nPf75r165TTz31yy+/zM3NnTx58quvvlq1atWwpwEAFAsJ84zd ww8/vG/fvldffXXbtm1bt2599NFH582b17Zt2+3bt4c9DQCgWEiYsPvwww9/9atfdezYMSkp KTk5+e677541a9by5cu7dev276/JAgCUQAkTduvXr69Xr973j2RkZIwdO3bGjBn33HNPWKsA AIqPhLnGLiUlJR6P/+DgDTfc8NFHHz388MPnnHNO//79QxkGAFBMJEzYderUadSoUY8//vit t95apkyZA8f/8Ic/fPnll7/73e++/PJLr8kCACVZwoTdgw8++Nprr91xxx2vv/7622+/feB4 UlLSM888U7ly5cceeyzEeQAAoUuYa+zOOOOMJUuW9O7dOzU19QcPJSUl5eTkvPzyy/Xr1w9l GwBAcZAwz9gFQVCtWrUnnnjixx7t1KlTp06djvZ37tu374MPPtizZ88hzlm1atXR/loAgKKX SGF3WJs2bfr222/r1Klz5D/y2WeftWvX7rvvvjvsmXv37i1btuyxjwMAOMkS5qXY4OR8pFjd unV37Nix/5CeeuqpIAj27dt3wv43AQA4CRLmGTsfKQYAcGgJ84ydjxQDADi0hAk7HykGAHBo CRN2PlIMAODQEuYaOx8pBgBwaAkTdj5SDADg0BIm7HykGADAoSXMNXY+UgwA4NAS5hm74OR8 pBgAQGQkzDN2AAAcmrADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHsAAAiQtgBAESE sAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARISwAwCICGEHABARwg4A ICKEHQBARAg7AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQ dgAAESHsAAAiQtgBAESEsAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEA RISwAwCICGEHABARwg4AICKEHQBARAg7AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHC DgAgIoQdAEBECDsAgIgQdgAAESHsAAAionTYAyBSLr887AUAlGDCDk6k7t3DXgBACealWACA iBB2AAARIewAACJC2AEARISwAwCICGEHABARwg4AICKEHQBARAg7AICIEHZwYkyePLl9+/Z1 69atW7du+/btJ0+eHPYiAEocHykGx2vfvn3du3d/5ZVXunfv3qVLlyAIFi5ceOONN06bNu3Z Z5895RT/fAKgiAg7OF6PP/74tGnT5s2bd8kllxQeufHGG2+99dbLL7/8iSeeuOOOO8KdB0DJ 4bkEOF4jR44cOHDggaordMkllwwYMGDkyJFhrQKgBBJ2cFw2b968du3aNm3aFH67dOnSvLy8 wq/btGmzZs2azZs3h7cOgJJF2MFx2bVrVxAE5cuXL/x2wYIFrVq1GjRo0J49ewoPFp4AAEVA 2MFxqVatWuXKlZcvX174be/evWfOnPncc89ddtllb775ZuXKlatVqxbuQgBKDmEHx6VUqVK/ +tWvHnnkke+++67wSGZmZjwer1at2r333nvhhReWKlUq3IUAlBzCDo7X0KFDv/3224yMjNmz Z2/dunXr1q0rVqzYtGnT6aefvmzZss6dO2/cuDHsjQCUCMIOjleNGjXy8vJq1aqVmZlZuXLl ypUrt2nTpnbt2itWrFi0aNGaNWtisdjcuXPDnglA9HkfOzgBatasOXny5B07dvz9738PgqBh w4annXZaEARnnnlmfn7+gAEDMjIybr/99hEjRpQtWzbssQBElmfs4IQ59dRT09LS0tLSCquu ULly5XJycmbMmDF58uQWLVqsWbMmxIUARJuwg6LQtm3beDxevXr1Ro0ajRkzJuw5AESTsIMi kpKSMm3atKFDh955551du3bdtGlT2IsAiBphB0UnKSmpb9++ixcvXr16dSwW++CDD8JeBECk CDsoaqmpqfn5+R07dszIyBg4cOCePXvCXgRARAg7CEH58uVzcnKmTJkyduzYli1brl27NuxF AESBsIPQdOzYcdWqVVWrVm3UqNH48ePDngNAwhN2EKaUlJQZM2Y89NBDN910U7du3TZv3hz2 IgASmLCDkBXeUZGXl7d8+fJYLJabmxv2IgASlbCDE2nlymDlymP5wbS0tHg83qFDh9atW2dn ZxcUFJzoaQBEn7CDE+nRR4NHHz3Gny28o2LSpEmjRo1q0aLFJ598ckKnARB9wg5OpP37g/37 j+s3dOrUKR6PJycnN2rUaMKECSdoFwAlgrCDYqdWrVpz5swZMmRIjx49srKytm3bFvYiABKD sIPiqPCOitzc3AULFlx00UXz5s0LexEACUDYQfHVuHHjJUuWtGnTplWrVu6oAOCwhB0UaxUr Vhw9evQLL7wwcuTIzMzML774IuxFABRfwg4SQJcuXeLxeEFBQWpq6osvvhj2HACKKWEHiaF2 7dqzZ88eNGhQVlaWOyoAOChhBwmjVKlSAwYMyM3NnTdvXlpa2tKlS8NeBEDxIuwgwaSnpy9d ujQ9Pb1JkybZ2dn79u0LexEAxYWwg8RTqVKlcePGTZw4MScnJzMzc926dWEvAqBYEHaQqLp2 7RqPx3fv3h2LxV5//fWw5wAQPmEHCezcc8+dM2dOnz59OnfunJWVtX379rAXARAmYQeJrXTp 0tnZ2bm5uXl5eWlpacuWLQt7EQChKR32gKO2f//+Tz/99JNPPtm6dWsQBJUrVz7vvPNq1aoV 9i4IU9OmTZctW9a7d+9mzZoNGTKkf//+p5zin20AJU4ihd2mTZv+8Ic/PP/8819//fUPHqpd u/bNN9/cr1+/8uXLh7INQlepUqXx48e3adOmT58+77zzznPPPXfWWWeFPQqAIpUwYffVV181 b978008/Pe+886688spzzz33tNNOC4Jgy5Yta9eunTt37oMPPvjyyy/PmTOnatWqYY+F0GRl Zf3Hf/zHr3/961gs9te//vXqq68OexEARSdhwu6BBx744osvJk+e3LVr139/tKCgYPTo0bff fvuQIUMee+yxop8HxUedOnXmzp07bNiwa6655vrrr3/qqadOPfXUsEcBUBQS5iqc6dOn33DD DQetuiAISpUq1bt3727dur3yyitFPAyKocI7Kt5+++05c+Y0btx4+fLlYS8CoCgkTNht2LCh fv36hz6nYcOG//M//1M0e6D4a9269cqVKy+55JKmTZsOHz7cZ1QARF7ChN1ZZ5112Gcdli1b 5mpx+L7KlStPnDhx9OjRw4YNu+KKK7766quwFwFwEiXMNXYdO3YcOXJk48aN77jjjuTk5B88 un379j/96U+vv/76gAEDQpkHxVlWVlaTJk2uv/76WCz2t7/97aqrrgp7EYRp2bLgrbcOcvzL L4MgCA76/ECbNsHPfnZyV8EJkTBhl52d/cEHH/Tv3/+hhx5KT0+vVatWhQoV9u/fv23bts8+ +2zhwoU7duxo2bLl/fffH/ZSKI7OP//8/Pz8YcOGdejQ4aabbvqv//ovd1RQYi1aFEyZcpDj //xnEARBnToHeahqVWFHYkiYsKtSpcr8+fOfeOKJcePGvffeewUFBQceKlOmzKWXXtqjR48e PXqUKlUqxJFQnBXeUfEf//EfWVlZeXl5EydOvPjii8MeBSHo2TPo2fMgx3/72yAIgmeeKeI5 cCIlTNgFQVC2bNm777777rvv3rlz5+eff174yROVKlWqXbt22bJlj+137t27d+rUqXv37j3E OUuWLDm2Xw7FUEZGRjwev/nmm5s0afLII4/ceeedSUlJYY8C4MRIpLA7oFy5cuedd96/H9+0 adO3335b56BPo/+IL7/8cuDAgYcOuy1btgRBsH///qOcCcVUtWrVXnvttXHjxvXu3XvmzJnP PvvsmWeeGfYoAE6AhLkrNgiCDz/88KqrrqpTp07Lli2ffPLJ778aW2j48OF169Y9qt9Zu3bt 1atXrz2kYcOGBUHgWQ0iJisra/HixV9//XUsFps5c2bYcwA4ARIm7PLy8tLT02fMmPHNN9/k 5+f36dPn5z//+aZNm8LeBQnsggsuyM/Pv+22266++uq+ffvu2rUr7EUAHJeECbuHH3543759 r7766rZt27Zu3froo4/Omzevbdu227dvD3saJLAyZcpkZ2fPmjXrpZdeSktLW7FiRdiLADh2 CRN2H3744a9+9auOHTsmJSUlJyfffffds2bNWr58ebdu3f79NVngqPziF7+Ix+N169Zt0qRJ Tk5O2HMAOEYJE3br16+vV6/e949kZGSMHTt2xowZ99xzT1irIDKqV6/+xhtvPPXUU4MHD+7U qdOGDRvCXgTAUUuYsEtJSYnH4z84eMMNNwwaNGjkyJEjRowIZRVETOEdFZ9++mlqauqsWbPC ngPA0UmYsOvUqdPUqVMff/zxPXv2fP/4H/7wh+7du//ud7+7++67d+zYEdY8iIyGDRvOnz+/ e/fu7du379u37+7du8NeBMCRSpiwe/DBB2vVqnXHHXdceeWV3z+elJT0zDPP3HnnnY899tio UaPCmgdRUq5cuUceeWTmzJlTpkxp3rz5xx9/HPYiAI5IwoTdGWecsWTJkt69e6empv7goaSk pJycnJdffrl+/fqhbINIyszMjMfjKSkpsVjMHRUACSGRPnmiWrVqTzzxxI892qlTp06dOhXl Hoi8GjVqTJ069emnn7777rvff//9p59++vTTTw97FAA/KmGesQNCkZSU1LNnz4ULF65ZsyYW i82dOzfsRQD8KGEHHN6FF16Yn59/zTXXZGRkuKMCoNgSdsARKVeuXE5OzowZMyZPntyiRYs1 a9aEvQiAHxJ2wFFo27ZtPB6vXr16o0aNxowZE/YcAP4PYQccnZSUlGnTpg0dOvTOO+/s2rXr pk2bwl4EwP8SdsBRS0pK6tu37+LFi1evXh2LxT744IOwFwEQBMIOOGapqan5+fkdO3bMyMgY OHDgDz4VBoCiJ+yAY1e+fPmcnJwpU6aMHTu2ZcuWa9euDXsRQIkm7IDj1bFjx1WrVlWtWrVR o0bjx48Pew5AySXsgBMgJSVlxowZDz300E033dStW7fNmzeHvQigJBJ2wIlReEdFXl7e8uXL Y7FYbm5u2IsAShxhB5xIaWlp8Xi8Q4cOrVu3zs7OLigoCHsRQAki7IATrPCOikmTJo0aNapF ixaffPJJ2IsASgphB5wUnTp1isfjycnJjRo1mjBhQthzAEoEYQecLLVq1ZozZ86QIUN69OiR lZW1bdu2sBcBRJywA06iwjsqcnNzFyxYcNFFF82bNy/sRQBRJuyAk65x48ZLlixp06ZNq1at 3FEBcPIIO6AoVKxYcfTo0S+88MLIkSMzMzO/+OKLsBcBRJCwA4pOly5d4vF4QUFBamrqiy++ GPYcgKgRdkCRql279uzZswcNGpSVleWOCoATS9gBRa1UqVIDBgzIzc2dN29eWlra0qVLw14E EBHCDghHenr60qVL09PTmzRpkp2dvW/fvrAXASQ8YQeEplKlSuPGjZs4cWJOTk5mZua6devC XgSQ2IQdELKuXbvG4/Hdu3fHYrHXX3897DkACUzYAeE799xz58yZ06dPn86dO2dlZW3fvj3s RQAJSdgBxULp0qWzs7Nzc3Pz8vLS0tKWLVsW9iKAxCPsgGKkadOmy5Ytu/TSS5s1azZ8+HB3 VAAcFWEHFC+VKlUaP378mDFjhg0b1rZt2y+//DLsRQAJQ9gBxVFWVtaKFSt27NgRi8WmTp0a 9hyAxCDsgGKqTp06c+fO7d279zXXXJOVlbVjx46wFwEUd8IOKL4K76h4++2358yZ07hx4+XL l4e9CKBYE3ZAcde6deuVK1decsklTZs2dUcFwCEIOyABVK5ceeLEiaNHjx42bNgVV1zx1Vdf hb0IoDgSdkDCyMrKWrx48YYNG2Kx2PTp08OeA1DsCDsgkZx//vn5+fm9evXq0KHDrbfe6o4K gO8TdkCCKbyj4q233po+fXp6evqHH34Y9iKA4kLYAQkpIyMjHo83aNCgSZMmOTk5+/fvD3sR QPiEHZCoqlWr9tprr40ePfq+++5r167d+vXrw14EEDJhByS2wjsqvv7661gsNnPmzLDnAIRJ 2AEJ74ILLsjPz7/tttuuvvrqvn377tq1K+xFAOEQdkAUlClTJjs7e9asWS+99FJaWtqKFSvC XgQQAmEHRMcvfvGLeDxet27dwjsqwp4DUNSEHRAp1atXf+ONN5566qnBgwd36tRpw4YNYS8C KDrCDoigwjsqPv3009TU1FmzZoU9B6CICDsgmho2bDh//vzu3bu3b9++b9++u3fvDnsRwEkn 7IDIKleu3COPPDJz5swpU6Y0b978448/DnsRwMkl7ICIy8zMjMfjKSkpsVjMHRVAtAk7IPpq 1KgxderUxx57bPDgwZ07d964cWPYiwBOCmEHlAhJSUk9e/ZcuHDhmjVrYrHY3Llzw14EcOIJ O6AEufDCC/Pz86+55pqMjAx3VADRI+yAkqVcuXI5OTkzZsyYPHlyixYt1qxZE/YigBNG2AEl Udu2bePxePXq1Rs1ajRmzJiw5wCcGMIOKKFSUlKmTZs2dOjQO++8s2vXrps2bQp7EcDxEnZA yZWUlNS3b9/FixevXr06Fot98MEHYS8COC7CDijpUlNT8/PzO3bsmJGRMXDgwD179oS9COAY CTuAoHz58jk5OVOmTBk7dmzLli3Xrl0b9iKAY1H6sGfs37//pZdeGjdu3BdffHHQf8iuXLny JAwDKGodO3Zs1qzZjTfe2KhRoyeeeOI3v/lN2IsAjs7hw+7Pf/5z//79gyA49dRTy5Qpc/In AYQmJSVlxowZI0eOvOmmm954440xY8ZUqVIl7FEAR+rwL8Xm5OS0bdt27dq127dv33wwRbAS oMgU3lGRl5e3fPnyWCyWm5sb9iKAI3X4sPuf//mfIUOG1KtXrwjWABQTaWlp8Xi8Q4cOrVu3 zs7OLigoCHsRwOEdPuxSUlL2799fBFMAipXCOyomTZo0atSoFi1afPLJJ2EvAjiMw4fddddd 9/zzzxfBFIBiqFOnTvF4PDk5uVGjRhMmTAh7DsChHP7miQcffLBLly6//vWvs7Kyateu/e/3 TzRo0ODkbAMoFmrVqjVnzpyRI0f26NHjzTfffPLJJytUqBD2KICDOHzYVaxYsfCLiRMnHvQE L9QCkVd4R8Vll13261//+qKLLpowYcJll10W9iiAHzp82F133XVly5YtXfrwZwJEW+PGjZcs WdKvX79WrVrdd999DzzwQKlSpcIeBfD/O3yu/dgTdQAlUMWKFUePHp2ZmdmzZ8/3339/3Lhx 55xzTtijAP7XUXyk2NatW1etWuWN6wC6dOkSj8cLCgpSU1NffPHFsOcA/K8jCru5c+empaVV qlQpNTV1wYIFhQd/+ctfvvvuuydzG0DxVbt27dmzZw8aNCgrKysrK2vbtm1hLwI4grBbuHBh mzZtPv7447Zt2x44+M033yxatOjKK69csmTJyZwHUHyVKlVqwIABubm58+bNS0tLW7p0adiL gJLu8GH30EMPnXnmmX//+9+fffbZAwerV6++fPnyM888c+jQoSdxHUCxl56evnTp0vT09CZN mmRnZ+/bty/sRUDJdfiwW7BgQa9evf796uAaNWrcdttt77///skZBpAwKlWqNG7cuIkTJ+bk 5GRmZq5bty7sRUAJdfiw+/bbb2vVqnXQh2rWrOmyEoBCXbt2jcfju3fvjsVir7/+ethzgJLo 8GF35plnfvTRRwd96P333z/rrLNO9CSARHXuuefOmTOnT58+nTt3zsrK2r59e9iLgJLl8GF3 5ZVXPvnkkz+4KHjTpk333XffM888c9VVV520bQCJp3Tp0tnZ2bm5uXl5eWlpacuWLQt7EVCC HD7shgwZUqFChSZNmhQ23KBBg372s5/VrFnzj3/8Y+3atR988MGTPxIgwTRt2nTZsmWXXnpp s2bNhg8f7o4KoGgc0UuxixcvvuWWWz777LMgCOLxeDwer1ixYq9evRYtWpSSknLyRwIknkqV Ko0fP37MmDHDhg1r27btl19+GfYiIPqO6A2Ka9So8eSTT37zzTfr16//xz/+sX79+m+++ebJ J5+sUaPGyd4HkNCysrJWrFixY8eOWCw2derUsOcAEXfwz4r94osvfuwHypUrt2fPnu+f4HMS AQ6hTp06c+fOHTZs2DXXXHP99dc/9dRTp556atijgGg6eNj92PubHNT+/ftP0BiAaCq8o6JV q1ZZWVmNGzeeOHHiJZdcEvYoIIIOHna/+tWvingHQOS1bt165cqVvXr1atq0aXZ2dv/+/U85 5YiuhwE4QgcPuxdffLGIdwCUBJUrV544ceK4ceP69Onz7rvvPvfcczVr1gx7FBAdh/nH4qJF iz755JMD3+7atSsnJ+eqq65q2bLl7373u6+//vokzwOIoKysrMWLF2/YsCEWi02fPj3sOUB0 /GjY7dy589prr01PT3/jjTcOHLz++uvvuuuuN998c8WKFSNGjEhPT9d2AMfg/PPPz8/P79Wr V4cOHW699dYdO3aEvQiIgh8Nu//8z/+cNGlSp06dMjMzC4+88847r7zySvv27Tdt2rR58+YX XnjhX//619ChQ4tqKkCkFN5R8dZbb02fPj09Pf3DDz8MexGQ8H407P76179edtllL7/88oUX Xlh45Pnnny9VqtRTTz1VsWLFIAiuvfbaK664Ytq0aUW0FCCKMjIy4vF4gwYNmjRpkpOT430G gONx8Jsn3nnnnS+++OLyyy9/5513Dhx8880369at+9FHH3300UeFR6pUqbJu3bp33nmnXr16 9erVK4q9AJFTrVq11157bdy4cb179545c+azzz575plnhj0KSEgHD7suXbrs3bt30qRJr776 auGRvXv3bt++fcuWLV26dDlw2q5du/bs2dOlS5eBAwcOHDiwKPYCRFRWVlZ6evr1118fi8We eeaZdu3ahb0ISDwHfyl28+bNVatWHTx48Ob/55FHHgmCYNasWZu/p1evXqeffvrmzZtVHcDx u+CCC/Lz82+77barr766b9++u3btCnsRkGB+9Bq7Cy64YPr06YVXe3z33XePP/54zZo1W7Ro ceCEffv2vfvuu16BBTiBypQpk52dPWvWrJdeeiktLW3FihVhLwISyY+GXZ8+fa8V5TQAACAA SURBVBYsWNCyZcu77rorLS1t9erVgwYNOvAm6Zs3b+7Zs+eHH3544403FtFSgBLjF7/4RTwe r1u3buEdFWHPARLGwa+xC4Lg17/+9b/+9a8hQ4bk5eUlJyc/+OCDt99++4FHGzZsuH79+quu uuqWW24pkp0AJUv16tXfeOONcePG9erVa+7cuU8//fQZZ5wR9iiguDvUJ08MGjRo48aNa9eu 3bhx45AhQ5KSkg48dNtttz377LOvv/562bJlT/5IgBKq8DMqPv3009TU1FmzZoU9ByjuDh52 99577+zZs4MgOPXUU//0pz/94x//+MEJv//977t3716qVKmTPhCgZGvYsOH8+fO7d+/evn37 vn377t69O+xFQPF18LB77LHHFi5cWPj16NGjP/300yKcBMD/Ua5cuUceeWTmzJlTpkxp3rz5 xx9/HPYioJg6+DV2KSkpw4cP//zzzws/ZOL5559fsGDBj/2KwndCAeCkyszMjMfjPXr0iMVi Dz/8cN++fcNeBBQ7Bw+7P/3pT7fccsuTTz5Z+O0rr7xyiF8h7ACKRo0aNaZOnfr000/ffffd 77///tNPP3366aeHPQooRg4edr/5zW/at2+/Zs2anTt3tmzZ8o9//GPLli2LeBkA/y4pKaln z57Nmzcv/IyK559/vlWrVmGPAoqLH327kypVqqSlpQVB0LZt28svv7xZs2ZFuAqAQ7nwwgvz 8/MHDBiQkZFx++23jxgxwnsUAMGh3+6k0KxZs1QdQHFTrly5nJycGTNmTJ48uUWLFmvWrAl7 ERC+gz9j17Rp0yP8+d27dy9duvTE7QHgKLRt27bwjopGjRr953/+Z8+ePcNeBITp4GG3ePHi 7397yimn7Nmzp/DrpKSkwg+QDYKgcuXKlSpVOqn7oHiaNi2YOvUgx+fNC4IguPXWgzx09dVB +/YndxUlU0pKyrRp00aOHHnnnXe+/fbbY8aMqVq1atijgHAc/KXYvd/zzTffNG3atE+fPvF4 /Lvvvtu3b9+WLVtyc3OvvfbaSy+91AdUUzKd8iNXMdSrF9Srd3Q/AscvKSmpb9++ixcvXr16 dSwW++CDD8JeBITjR2+eOKBfv341a9Z8/PHHDxypWLFi8+bNmzdv3r59+3vvvXfs2LEnc+Fh 7Nmz5+OPP965c2dqampycnKISyhRrrwyuPLKsEfA/5Wampqfnz9w4MCMjIx777136NChZcqU CXsUUKQO/xzC1KlT27Zte9CHLr/88jfeeONET/pRs2fPbt26dd26da+88sr8/PwgCN588806 deqkpqampaXVqFHjwBvvAZRM5cuXz8nJmTJlytixY1u2bLl27dqwFwFF6vBht2XLlm+++eag D23YsGHLli0netLBzZ8/v23btu+9997GjRvffPPNn//85/Pnz+/WrVupUqWysrIKv+jTp48P yQbo2LHjqlWrqlat2qhRo/Hjx4c9Byg6hw+7n/70p6NGjVq0aNEPji9cuPBvf/vbBRdccHKG /dDDDz9crVq15cuXf/vtt+vXr09PT7/22mvr1q27evXq5557btKkSWvXrq1Tp05OTk7R7AEo zlJSUmbMmPHQQw/ddNNN3bp127x5c9iLgKJw+LB76KGHCkPqvPPOa9OmzS9/+cs2bdqcd955 TZo0+eabb+67774iWBkEwbx58/r06XPxxRcHQVC9evU//elP//rXv+6+++7y5csXnlC1atWb b7554cKFRbMHoJgrvKMiLy9v+fLlsVgsNzc37EXASXf4sGvfvv177713xRVXfPHFF2+//fbU qVPffvvtf/3rX5dffvnMmTO7du1aBCuDIPj222/PPffcA9+effbZQRBUr179++fUrFmzyF4a BkgIaWlp8Xi8Q4cOrVu3zs7OLigoCHsRcBId/q7YIAhatGgxc+bMffv2ffXVVzt27ChfvvyZ Z55ZuvQR/eyJcsYZZ3z/KuCPP/44CIIfvNP62rVrzzjjjKJcBVD8Fd5R0apVq1tuueXNN9+c MGFCvR97Vx4gwR3FO2udcsopZ5999nnnnXfOOecUcdUFQdC6detRo0bNmTNn9+7dK1asuOOO Oxo2bPjnP/953bp1hSd89NFHf/nLX1q2bFnEwwASQqdOneLxeHJycqNGjSZMmBD2HOCkSJi3 TP3973+/Z8+ejIyM5OTkiy++eN26dS+//HJSUtJPfvKTjIyMyy677OKLL96yZUv//v3DXgpQ TNWqVWvOnDlDhgzp0aNHVlbWtm3bwl4EnGAJE3YXXHDBvHnzrrvuuiZNmtx4443z5s1r2LDh tGnTUlNT33vvvfnz59euXfvll19OT08PeylA8VV4R0Vubu6CBQsuuuiieYWfggdERVG/ono8 UlNTJ06c+IMj+fn527Zt++67735wI8UR2rlz55gxY7777rtDnFP4ZsgAkdG4ceMlS5b069ev VatW99133wMPPFCqVKmwRwEnQCKF3Y+pUKFChQoVgiDYsGHDpk2bGjRocOQ/u2HDhhdeeGHP nj2HOKfw/Zn3799/nDsBio+KFSuOHj06MzOzZ8+e77///rhx484555ywRwHHKwphd8CIESOG Dx9+VAV29tlnz58//9DnjB49+rbbbktKSjq+dQDFTpcuXdLT02+44YbU1NSnnnrq2muvDXsR cFwS5ho7AE6G2rVrz549e9CgQVlZWe6ogEQn7ABKulKlSg0YMCA3N3fevHlpaWlLly4NexFw jBLmpdi0tLTDnnPgPe0AOFrp6elLly69/fbbmzRpct999z344IOnnOIf/5BgEibsli1bFgRB mTJlDnHO3r17i2oOQARVqlRp3LhxV199dc+ePT/44INx48YVfn4jkCgS5l9j/fv3P+2001au XLnzx/Xr1y/smQAJr2vXrvF4fPfu3bFY7PXXXw97DnAUEibshg4d2qBBg+uuu+7Qb00CwPE7 99xz58yZ06dPn86dO2dlZW3fvj3sRcARSZiwK1OmzIQJE1atWjV48OCwtwBEX+nSpbOzs3Nz c/Py8tLS0gqvhwGKuYS5xi4IgoYNG65fv/4QF9K1a9euSpUqRTkJINqaNm26bNmy3r17N2vW bMiQIf3793dHBRRniRR2QRBUqlTpEI+2atWqVatWRTYGoCSoVKnS+PHj27Rp06dPn3feeee5 554766yzwh4FHJx/eAFweFlZWStWrNixY0csFps6dWrYc4CDE3YAHJE6derMnTu3d+/e11xz TVZW1o4dO8JeBPyQsAPgSBXeUfH222/PmTOncePGy5cvD3sR8H8IOwCOTuvWrVeuXHnJJZc0 bdp0+PDh+/btC3sR8L+EHQBHrXLlyhMnThw9evSwYcOuuOKKr776KuxFQBAIOwCOWVZW1uLF izds2BCLxaZPnx72HEDYAXAczj///Pz8/F69enXo0OHWW291RwWES9gBcFwK76h46623pk+f np6e/uGHH4a9CEouYQfACZCRkRGPxxs0aNCkSZOcnJz9+/eHvQhKImEHwIlRrVq11157bfTo 0ffdd1+7du3Wr18f9iIocYQdACdS4R0VX3/9dSwWmzlzZthzoGQRdgCcYBdccEF+fv5tt912 9dVX9+3bd9euXWEvgpJC2AFw4pUpUyY7O3vWrFkvvfRSWlraihUrwl4EJYKwA+Bk+cUvfhGP x+vWrVt4R0XYcyD6hB0AJ1H16tXfeOONp556avDgwZ06ddqwYUPYiyDKhB0AJ13hHRWffvpp amrqrFmzwp4DkSXsACgKDRs2nD9/fvfu3du3b9+3b9/du3eHvQgiSNgBUETKlSv3yCOPzJw5 c8qUKc2bN//444/DXgRRI+wAKFKZmZnxeDwlJSUWi7mjAk4sYQdAUatRo8bUqVMfe+yxwYMH d+7ceePGjWEvgogQdgCEICkpqWfPngsXLlyzZk0sFps7d27YiyAKhB0Aobnwwgvz8/Ovueaa jIwMd1TA8RN2AISpXLlyOTk5M2bMmDx5cosWLdasWRP2Ikhgwg6A8LVt2zYej1evXr1Ro0Zj xowJew4kKmEHQLGQkpIybdq0oUOH3nnnnV27dt20aVPYiyDxCDsAioukpKS+ffsuXrx49erV sVjsgw8+CHsRJBhhB0Dxkpqamp+f37Fjx4yMjIEDB+7ZsyfsRZAwhB0AxU758uVzcnKmTJky duzYli1brl27NuxFkBiEHQDFVMeOHVetWlW1atVGjRqNHz8+7DmQAIQdAMVXSkrKjBkzHnro oZtuuqlbt26bN28OexEUa8IOgGKt8I6KvLy85cuXx2Kx3NzcsBdB8SXsAEgAaWlp8Xi8Q4cO rVu3zs7OLigoCHsRFEfCDoDEUHhHxaRJk0aNGtWiRYtPPvkk7EVQ7Ag7ABJJp06d4vF4cnJy o0aNJkyYEPYcKF6EHQAJplatWnPmzBkyZEiPHj2ysrK2bdsW9iIoLoQdAImn8I6K3NzcBQsW XHTRRfPmzQt7ERQLwg6ARNW4ceMlS5a0adOmVatW7qiAQNgBkNAqVqw4evToF154YeTIkZmZ mV988cUx/6qUlCAl5QROgxAIOwASXpcuXeLxeEFBQWpq6osvvnhsv+SRR4JHHjmxu6CoCTsA oqB27dqzZ88eNGhQVlaWOyoosYQdABFRqlSpAQMG5Obmzps3Ly0tbenSpWEvgqIm7ACIlPT0 9KVLl6anpzdp0iQ7O3vfvn1hL4KiI+wAiJpKlSqNGzdu4sSJOTk5mZmZ69atC3sRFBFhB0A0 de3aNR6P7969OxaLvf7662HPgaIg7ACIrHPPPXfOnDl9+vTp3LlzVlbW9u3bw14EJ5ewAyDK SpcunZ2dnZubm5eXl5aWtmzZsrAXwUkk7ACIvqZNmy5btuzSSy9t1qzZ8OHD3VFBVAk7AEqE SpUqjR8/fsyYMcOGDWvbtu2XX34Z9iI48YQdACVIVlbWihUrduzYEYvFpk6dWnjw888///Of /9yjR48ePXr8+c9//vzzz8MdCcdM2AFQstSpU2fu3Lm9e/e+5pprsrKynnzyyZ/85Cdjx47d t2/fvn37xo4dW/ht2DPhWJQOewAAFLXCOypatWrVrVu38ePH33///Q899NCBR0ePHt2rV6/a tWu3adMmxJFwDDxjB0AJ1bp163r16jVo0GDEiBHfv6Pi1ltvveWWW7Kzs0NdB8dC2AFQQu3Y sWPRokV/+9vfRo4cOXTo0F/+8pfffPNN4UPXXXddfn7+d999F+5COFrCDoASavPmzfv3769R o8Ytt9yyZMmSr7766r/+678KH0pJSdm3b9+mTZvCXQhHyzV2AJRQZ5xxRpkyZT777LOf/OQn 559//uLFiw889M9//rNMmTLVqlULcR4cA8/YAVBCJScnZ2Zmjh49uvDbpKSkpKSkwq9Hjx6d mZlZtmzZ8NbBsRB2AJRcw4YNmzFjxl133bVt27bCI9u2bbvrrrtmzpz5hz/8IdxtcAy8FAtA yfWzn/1s+vTpN9xww9NPP33hhRfu37//73//++mnnz59+vRYLBb2Ojhqwg6AEq1169Zr166d PXv2ypUrgyBITU3NyMhITk4OexccC2EHQEmXnJzcrl27du3ahT0Ejpdr7AAAIkLYAQBEhLAD AIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHsACAIgmD79mD79rBHwPHxyRMAEARB0K9f EATBX/4S9g44DsIOAIIgCHbuDHsBHDcvxQIARISwAwCICGEHABARwg4AICKEHQBARAg7AICI EHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHsAAAiQtgB AESEsAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARISwAwCICGEHABAR wg4AICKEHQBARAg7AICIEHYAABFROuwBx6WgoODvf//71q1ba9WqVatWrbDnAACEKZGesZs3 b97tt99+4Nvx48efffbZF198cfPmzWvXrh2Lxd5///0Q5wEAhCthnrF777332rZtW7Zs2VGj RiUlJb300ks33HBDhQoVunbtWr169X/84x/vvvtumzZt8vLyLr300rDHAgCEIGHCbsiQIVWq VMnLy0tKSgqC4He/+9255547f/78mjVrFp6Qn5/funXrIUOGvPHGG6EuBQAIR8K8FLt06dKs rKwGDRoEQfDtt99++umn99xzz4GqC4KgSZMmv/nNbz744IPwNgIAhClhwq6goKB8+fKFX5cr Vy4pKemcc875wTnnnHPOzp07i3waAECxkDBhF4vFXnzxxR07dgRBkJyc3KxZs/nz53//hF27 dr3yyivnn39+SAMBAEKWMGE3cODAf/zjHy1btnzrrbf27t07atSoCRMmjBs3bseOHXv27MnP z7/yyiuXL1/eu3fvsJcCAIQjYW6eaN++/dNPP33XXXe1bdu2fPnydevWLVu2bPfu3Xv06BEE QUFBQVJS0j333HPLLbeEvRQAIBwJE3ZBENx8881XX331888//8477/z3f//3xo0bk5OTK1So UKdOnebNm3fv3r1Ro0ZhbwQACE0ihV0QBCkpKf369evXr9+J+oXbt28fMWLEoW+5iMfjJ+o/ DgDg5EmwsDu0DRs2bNq0qfAtUY7Qtm3bFi1atHv37kOcs27duiAI9u/ff7z7AABOpkiF3YgR I4YPH35UBZaSkjJ9+vRDnzN69Ojbbrut8I2RAQCKrYS5KxYAgEMTdgAAEZEwL8WmpaUd9pzC i+EAAEqmhAm7ZcuWBUFQpkyZQ5yzd+/eopoDAFDsJMxLsf379z/ttNNWrly588edwLdBAQBI OAkTdkOHDm3QoMF11123Z8+esLcAABRHCRN2ZcqUmTBhwqpVqwYPHhz2FgCA4ihhrrELgqBh w4br168/xIV07dq1q1KlSlFOAgAoPhIp7IIgqFSp0iEebdWqVatWrYpsDABAsZIwL8UCAHBo wg4AICKEHQBARAg7AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsA gIgQdgAAESHsAAAiQtgBAESEsAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC 2AEARISwAwCICGEHABARwg4AICKEHQBARAg7AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcA EBHCDgAgIoQdAEBECDsAgIgQdgAAESHsAAAiQtgBAESEsAMAiAhhBwAQEcIOACAihB0AQEQI OwCAiBB2AAARIewAACJC2AEARISwAwCICGEHABARwg4AICKEHQBARAg7AICIEHYAABEh7AAA IkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHsAAAiQtgBAESEsAMAiAhh BwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARISwAwCICGEHABARwg4AICKEHQBA RAg7AICIEHYAABEh7AAAIkLYAQBEhLADAIgIYQcAEBHCDgAgIoQdAEBECDsAgIgQdgAAESHs AAAiQtgBAESEsAMAiAhhBwAQEcIOACAihB0AQEQIOwCAiBB2AAARIewAACJC2AEARISwAwCI CGEHABARwg4AICKEHQBARAg7AICIEHYAABEh7AAAIiIKYbdly5aBAwf+93//d9hDAADCFJGw Gz58+Jo1a8IeAgAQptJhDzhSN9988489tGPHjiAIRo0a9dprrwVBMHbs2KKbBQBQbCRM2P31 r3899AlvvfVW4RfCDgAomRLmpdi77767VKlSsVhs1qxZm/6vVatWBUHw4osvFn4b9lIAgHAk TNg9+uijCxYsCIKgXbt2gwcPTkpKqvL/VKpUKQiC0047rfDbsJcCAIQjYcIuCIK0tLRFixY9 /PDDzz777E9/+tOXX3457EUAAMVIIoVdEASlS5ceMGDAihUrGjZs2KVLl1/+8peff/552KMA AIqFBAu7QvXr13/nnXeeeeaZvLy8n/70p+6WAAAIEjTsCt14440fffRR+/bthwwZEvYWAIDw JczbnRxUjRo1XnjhhaysrHfffbd+/frH8Bs2b978wAMP7N69+xDnfPTRR8c6EACg6CR22BVq 165du3btgiDYsGHDpk2bGjRocOQ/W1BQsHnz5l27dh32zLJlyx77RACAky8KYXfAiBEjhg8f vn///iP/kTPOOOP5558/9Dnz5s1r3rz58U0DADjpEvgaOwAAvk/YAQBERMK8FJuWlnbYc9at W1cESwAAiqeECbtly5YFQVCmTJlDnLN3796imgMAUOwkzEux/fv3P+2001auXLnzx/Xr1y/s mQAAoUmYsBs6dGiDBg2uu+66PXv2hL0FgAQ2bFhw+ukH+Z8XXgheeOHgDw0bFvZoODIJ81Js mTJlJkyYcOmllw4ePHjEiBFhzwEgUd10U9C06UGOb9wYBEFw+ukHeejCC0/uJDhREibsgiBo 2LDh+vXrD3EhXbt27apUqVKUkwBIODVrBjVrhj0CTo5ECrsgCCpVqnSIR1u1atWqVasiGwMA UKwkzDV2AAAcmrCDk+WTTz7p2bNn/fr1k5OTq1ev3rFjx4ULF37/hM2bN99111116tQpW7bs WWeddfPNN3/11VdhrQW+z98vCSrBXoqFRLF69ermzZtv3bq1W7du9evXX7NmzeTJk2fMmDF3 7txmzZoFQbB79+6f//znS5cu7dy5c6NGjdauXTtu3LjZs2cvWbKkatWqYc+HEs3fLwlsP4eT l5cXBMGuXbvCHkIiyczMTEpKmjt37oEjr7zyShAE3bp1K/z20UcfDYJg+PDhB06YNGlSEAT3 3ntvUW8F/i9/vxzarl27giDIy8sLe8hBJO3fvz+8qkwM8+bNa968+a5du8qWLRv2ForC9ddf /8ILL2zdunXo0KGTJk366quvatSocc8999x1111JSUlBEKxZs+bHfrZChQpnnnlmEAQPPPBA QUHBH//4xwMPFRQUlC9f/qc//Wk8Hg+C4Gc/+9natWu/+eab5OTkA+ecd955W7ZsWb9+feF/ EHC0/P1SBHbv3p2cnJyXl3fZZZeFveWHvBQLP1RY8F26dKlbt+6LL764b9++IUOG3HPPPVWq VPntb3+7d+/e884778d+tkOHDq+99loQBEOHDv3BQ+vXr9+zZ0/dunWDINi5c+eKFSsuv/zy 7/+3QhAELVq0ePbZZz/99NN69eqd+P/FoATw90sJJ+zgh0qXLh0Ewemnn/6Xv/yl8Mhf/vKX +vXrv/LKK7/97W9LlSo1ZcqUH/vZs88++98P7tixY+HChX379q1YseJ9990XBMHnn39eUFBQ q1atH5x57rnnBkHwySef+C8GODb+finhhB0cXPfu3Q98Xa9evVNPPfWLL74IgiApKalLly5H /nuqVKny7bffBkHwm9/85tVXXy38//hbt24NguC00077wckVKlQ48ChwzPz9UmIJOzi42rVr f//bMmXKHNvnFPfq1Wvjxo0rV66cOHHiP//5z+eee+7Av+b//UKcwmteXaADx8nfLyWWsIOD K1OmzI89dCQXXx/w8MMPF37x3nvvtW/f/pprrlm2bFnhZ6j8+7/st2zZEgRBxYoVj3k2EPj7 pQQTdnB0jvDi6393+eWXd+jQYeLEiatXr65fv37p0qU/++yzH5yzdu3aIAgO8fuB4+Hvl8gT dnB0juTi63Xr1l155ZWXXHLJuHHjvv/ozp07gyDYvn172bJlL7300oULF+7YsePUU08tfHTf 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) Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create bivariate plots to compare groups/R, using lattice and gplots.md). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-create-bivariate-plots-to-compare-groups-in-r-using-lattice-and-gplots/",
    "relUrl": "/how-to-create-bivariate-plots-to-compare-groups-in-r-using-lattice-and-gplots/"
  },"402": {
    "doc": "How to create bivariate plots to compare groups",
    "title": "How to create bivariate plots to compare groups",
    "content": " ",
    "url": "/how-to-create-bivariate-plots-to-compare-groups/",
    "relUrl": "/how-to-create-bivariate-plots-to-compare-groups/"
  },"403": {
    "doc": "How to create bivariate plots to compare groups",
    "title": "Description",
    "content": "Suppose we have a dataset with different treatment conditions and an outcome variable, and we want to perform exploratory data analysis. How would we visually compare the treatment conditions with regards to the outcome variable? . Related tasks: . | How to create basic plots | How to add details to a plot | How to create a histogram | How to create a box (and whisker) plot | How to change axes, ticks, and scale in a plot | How to plot interaction effects of treatments | . ",
    "url": "/how-to-create-bivariate-plots-to-compare-groups/#description",
    "relUrl": "/how-to-create-bivariate-plots-to-compare-groups/#description"
  },"404": {
    "doc": "How to create bivariate plots to compare groups",
    "title": "Using Matplotlib and Seaborn, in Python",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 2 . | from rdatasets import data df = data('ToothGrowth') . | . If you wish to understand the distribution of a numeric variable (here “len”) compared across different values of a categorical variable (here “supp”), you can construct a bivariate histogram. We use Seaborn and Matplotlib to do so. | 1 2 3 4 . | import seaborn as sns import matplotlib.pyplot as plt sns.displot(df, x=\"len\", col=\"supp\", stat=\"density\") plt.show() . | . To visualize the same information summarized using quartiles only, you can construct a bivariate box plot. | 1 2 . | sns.boxplot(x=\"supp\", y=\"len\", data = df, order = ['OJ','VC']) plt.show() . | . Even more simply, we may wish to plot just the means and 95% confidence intervals around the mean for the quantitative variable, for each of the values of the categorical variable. We do so with a point plot. | 1 2 3 4 . | sns.pointplot(x = 'supp', y = 'len', data = df, ci = 95, # Which confidence interval? Here 95%. capsize = 0.1) # Size of \"cap\" drawn on each confidence interval. plt.show() . | . Content last modified on 26 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-bivariate-plots-to-compare-groups/#using-matplotlib-and-seaborn-in-python",
    "relUrl": "/how-to-create-bivariate-plots-to-compare-groups/#using-matplotlib-and-seaborn-in-python"
  },"405": {
    "doc": "How to create bivariate plots to compare groups",
    "title": "Using lattice and gplots, in R",
    "content": "View this solution alone. We use a built-in dataset called ToothGrowth that discusses the length of the teeth (len) in each of 10 guinea pigs at three Vitamin C dosage levels ($0.5$, $1$, and $2$ mg) with two delivery methods - orange juice or ascorbic acid (supp). | 1 2 . | # You can replace this example data frame with your own data df &lt;- ToothGrowth . | . If you wish to understand the distribution of the length of the tooth based on the delivery methods, you can construct a bivariate histogram plot. | 1 2 3 . | # install.packages( \"lattice\" ) # if you have not already done this library(lattice) histogram( ~ len | supp, data = df) . | . To visualize the summary statistics of the length of the tooth based on the delivery methods, you can construct a bivariate box plot. | 1 2 3 . | bwplot(df$len ~ df$supp) # Or the following code produces a similar figure, using the mosaic package: # boxplot(len ~ supp, data = df) . | . To plot the means for both treatment levels of supp for the len column, we load the gplots package and use the plotmeans function. | 1 2 3 . | # install.packages( \"gplots\" ) # if you have not already done this library(gplots) plotmeans(df$len ~ df$supp) . | . | 1 2 3 4 5 6 . | Attaching package: ‘gplots’ The following object is masked from ‘package:stats’: lowess . | . Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-bivariate-plots-to-compare-groups/#using-lattice-and-gplots-in-r",
    "relUrl": "/how-to-create-bivariate-plots-to-compare-groups/#using-lattice-and-gplots-in-r"
  },"406": {
    "doc": "How to create bivariate plots to compare groups",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-create-bivariate-plots-to-compare-groups/#topics-that-include-this-task",
    "relUrl": "/how-to-create-bivariate-plots-to-compare-groups/#topics-that-include-this-task"
  },"407": {
    "doc": "How to create bivariate plots to compare groups",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-create-bivariate-plots-to-compare-groups/#opportunities",
    "relUrl": "/how-to-create-bivariate-plots-to-compare-groups/#opportunities"
  },"408": {
    "doc": "How to create symbolic variables (in Python, using SymPy)",
    "title": "How to create symbolic variables (in Python, using SymPy)",
    "content": "# How to create symbolic variables (in Python, using SymPy) [See all solutions.](../how-to-create-symbolic-variables) ## Task The word \"variable\" does not mean the same thing in mathematics as it does in computer programming. In mathematics, we often use it to mean an unknown for which we might solve; but in programming, variables typically have known values. If we want to do symbolic mathematics in a software package, how can we tell the computer that we want to use variables in the mathematical sense, as symbols whose value may be unknown? Related tasks: * [How to substitute a value for a symbolic variable](../how-to-substitute-a-value-for-a-symbolic-variable) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` You can define any number of variables as follows. Here we define $x$, $y$, and $z$. ```python var( 'x y z' ) ``` $\\displaystyle \\left( x, \\ y, \\ z\\right)$ You can tell that they are variables, because when you ask Python to print them out, it does not print a value (such as a number) but rather just the symbol itself. ```python x ``` $\\displaystyle x$ And when you use a symbol inside a larger formula, it doesn't attempt to compute a result, but stores the entire formula symbolically. ```python formula = sqrt(x) + 5 formula ``` $\\displaystyle \\sqrt{x} + 5$ Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to create symbolic variables/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-create-symbolic-variables-in-python-using-sympy/",
    "relUrl": "/how-to-create-symbolic-variables-in-python-using-sympy/"
  },"409": {
    "doc": "How to create symbolic variables",
    "title": "How to create symbolic variables",
    "content": " ",
    "url": "/how-to-create-symbolic-variables/",
    "relUrl": "/how-to-create-symbolic-variables/"
  },"410": {
    "doc": "How to create symbolic variables",
    "title": "Description",
    "content": "The word “variable” does not mean the same thing in mathematics as it does in computer programming. In mathematics, we often use it to mean an unknown for which we might solve; but in programming, variables typically have known values. If we want to do symbolic mathematics in a software package, how can we tell the computer that we want to use variables in the mathematical sense, as symbols whose value may be unknown? . Related tasks: . | How to substitute a value for a symbolic variable | . ",
    "url": "/how-to-create-symbolic-variables/#description",
    "relUrl": "/how-to-create-symbolic-variables/#description"
  },"411": {
    "doc": "How to create symbolic variables",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . You can define any number of variables as follows. Here we define $x$, $y$, and $z$. | 1 . | var( 'x y z' ) . | . $\\displaystyle \\left( x, \\ y, \\ z\\right)$ . You can tell that they are variables, because when you ask Python to print them out, it does not print a value (such as a number) but rather just the symbol itself. | 1 . | x . | . $\\displaystyle x$ . And when you use a symbol inside a larger formula, it doesn’t attempt to compute a result, but stores the entire formula symbolically. | 1 2 . | formula = sqrt(x) + 5 formula . | . $\\displaystyle \\sqrt{x} + 5$ . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-create-symbolic-variables/#using-sympy-in-python",
    "relUrl": "/how-to-create-symbolic-variables/#using-sympy-in-python"
  },"412": {
    "doc": "How to create symbolic variables",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-create-symbolic-variables/#topics-that-include-this-task",
    "relUrl": "/how-to-create-symbolic-variables/#topics-that-include-this-task"
  },"413": {
    "doc": "How to create symbolic variables",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-create-symbolic-variables/#opportunities",
    "relUrl": "/how-to-create-symbolic-variables/#opportunities"
  },"414": {
    "doc": "How to define a mathematical sequence (in Python, using SymPy)",
    "title": "How to define a mathematical sequence (in Python, using SymPy)",
    "content": "# How to define a mathematical sequence (in Python, using SymPy) [See all solutions.](../how-to-define-a-mathematical-sequence) ## Task In mathematics, a sequence is an infinite list of values, typically real numbers, often written $a_0,a_1,a_2,\\ldots$, or collectively as $a_n$. (Let's assume that sequences are indexed starting with index 0, at $a_0$, even though some definitions start with index 1, at $a_1$, instead.) How can we express sequences in mathematical software? Related tasks: * [How to define a mathematical series](../how-to-define-a-mathematical-series) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Sequences are typically written in terms of an independent variable $n$, so we will tell SymPy to use $n$ as a symbol, then define our sequence in terms of $n$. We define a term of an example sequence as $a_n=\\frac{1}{n+1}$, then build a sequence from that term. The code `(n,0,oo)` means that $n$ starts counting at $n=0$ and goes on forever (with `oo` being the SymPy notation for $\\infty$). ```python var( 'n' ) # use n as a symbol a_n = 1 / ( n + 1 ) # formula for a term seq = sequence( a_n, (n,0,oo) ) # build the sequence seq ``` $\\displaystyle \\left[1, \\frac{1}{2}, \\frac{1}{3}, \\frac{1}{4}, \\ldots\\right]$ You can ask for specific terms in the sequence, or many terms in a row, as follows. ```python seq[20] ``` $\\displaystyle \\frac{1}{21}$ ```python seq[:10] ``` $\\displaystyle \\left[ 1, \\ \\frac{1}{2}, \\ \\frac{1}{3}, \\ \\frac{1}{4}, \\ \\frac{1}{5}, \\ \\frac{1}{6}, \\ \\frac{1}{7}, \\ \\frac{1}{8}, \\ \\frac{1}{9}, \\ \\frac{1}{10}\\right]$ You can compute the limit of a sequence, $$ \\lim_{n\\to\\infty} a_n. $$ ```python limit( a_n, n, oo ) ``` $\\displaystyle 0$ Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to define a mathematical sequence/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-define-a-mathematical-sequence-in-python-using-sympy/",
    "relUrl": "/how-to-define-a-mathematical-sequence-in-python-using-sympy/"
  },"415": {
    "doc": "How to define a mathematical sequence",
    "title": "How to define a mathematical sequence",
    "content": " ",
    "url": "/how-to-define-a-mathematical-sequence/",
    "relUrl": "/how-to-define-a-mathematical-sequence/"
  },"416": {
    "doc": "How to define a mathematical sequence",
    "title": "Description",
    "content": "In mathematics, a sequence is an infinite list of values, typically real numbers, often written $a_0,a_1,a_2,\\ldots$, or collectively as $a_n$. (Let’s assume that sequences are indexed starting with index 0, at $a_0$, even though some definitions start with index 1, at $a_1$, instead.) . How can we express sequences in mathematical software? . Related tasks: . | How to define a mathematical series | . ",
    "url": "/how-to-define-a-mathematical-sequence/#description",
    "relUrl": "/how-to-define-a-mathematical-sequence/#description"
  },"417": {
    "doc": "How to define a mathematical sequence",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Sequences are typically written in terms of an independent variable $n$, so we will tell SymPy to use $n$ as a symbol, then define our sequence in terms of $n$. We define a term of an example sequence as $a_n=\\frac{1}{n+1}$, then build a sequence from that term. The code (n,0,oo) means that $n$ starts counting at $n=0$ and goes on forever (with oo being the SymPy notation for $\\infty$). | 1 2 3 4 . | var( 'n' ) # use n as a symbol a_n = 1 / ( n + 1 ) # formula for a term seq = sequence( a_n, (n,0,oo) ) # build the sequence seq . | . $\\displaystyle \\left[1, \\frac{1}{2}, \\frac{1}{3}, \\frac{1}{4}, \\ldots\\right]$ . You can ask for specific terms in the sequence, or many terms in a row, as follows. | 1 . | seq[20] . | . $\\displaystyle \\frac{1}{21}$ . | 1 . | seq[:10] . | . $\\displaystyle \\left[ 1, \\ \\frac{1}{2}, \\ \\frac{1}{3}, \\ \\frac{1}{4}, \\ \\frac{1}{5}, \\ \\frac{1}{6}, \\ \\frac{1}{7}, \\ \\frac{1}{8}, \\ \\frac{1}{9}, \\ \\frac{1}{10}\\right]$ . You can compute the limit of a sequence, . \\[\\lim_{n\\to\\infty} a_n.\\] | 1 . | limit( a_n, n, oo ) . | . $\\displaystyle 0$ . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-define-a-mathematical-sequence/#using-sympy-in-python",
    "relUrl": "/how-to-define-a-mathematical-sequence/#using-sympy-in-python"
  },"418": {
    "doc": "How to define a mathematical sequence",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-define-a-mathematical-sequence/#topics-that-include-this-task",
    "relUrl": "/how-to-define-a-mathematical-sequence/#topics-that-include-this-task"
  },"419": {
    "doc": "How to define a mathematical sequence",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-define-a-mathematical-sequence/#opportunities",
    "relUrl": "/how-to-define-a-mathematical-sequence/#opportunities"
  },"420": {
    "doc": "How to define a mathematical series (in Python, using SymPy)",
    "title": "How to define a mathematical series (in Python, using SymPy)",
    "content": "# How to define a mathematical series (in Python, using SymPy) [See all solutions.](../how-to-define-a-mathematical-series) ## Task In mathematics, a series is a sum of values from a sequence, typically real numbers. Finite series are written as $a_0+a_1+\\cdots+a_n$, or $$\\sum_{i=0}^n a_i.$$ Infinite series are written as $a_0+a_1+a_2+\\cdots$, or $$\\sum_{n=0}^\\infty a_n.$$ How can we express series in mathematical software? Related tasks: * [How to define a mathematical series](../how-to-define-a-mathematical-series) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` We define here the same sequence we defined in the task entitled [how to define a mathematical sequence](../how-to-define-a-mathematical-sequence). ```python var( 'n' ) # use n as a symbol a_n = 1 / ( n + 1 ) # formula for a term seq = sequence( a_n, (n,0,oo) ) # build the sequence seq ``` $\\displaystyle \\left[1, \\frac{1}{2}, \\frac{1}{3}, \\frac{1}{4}, \\ldots\\right]$ We can turn it into a mathematical series by simply replacing the word `sequence` with the word `Sum`. This does not compute the answer, but just writes the series for us to view. In this case, it is an infinite series. ```python Sum( a_n, (n,0,oo) ) ``` $\\displaystyle \\sum_{n=0}^{\\infty} \\frac{1}{n + 1}$ You can compute the answer by appending the code `.doit()` to the above code, which asks SymPy to \"do\" (or evaluate) the sum. ```python Sum( a_n, (n,0,oo) ).doit() ``` $\\displaystyle \\infty$ In this case, the series diverges. We can also create and evaluate finite series by replacing the `oo` with a number. ```python Sum( a_n, (n,0,10) ).doit() ``` $\\displaystyle \\frac{83711}{27720}$ Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to define a mathematical series/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-define-a-mathematical-series-in-python-using-sympy/",
    "relUrl": "/how-to-define-a-mathematical-series-in-python-using-sympy/"
  },"421": {
    "doc": "How to define a mathematical series",
    "title": "How to define a mathematical series",
    "content": " ",
    "url": "/how-to-define-a-mathematical-series/",
    "relUrl": "/how-to-define-a-mathematical-series/"
  },"422": {
    "doc": "How to define a mathematical series",
    "title": "Description",
    "content": "In mathematics, a series is a sum of values from a sequence, typically real numbers. Finite series are written as $a_0+a_1+\\cdots+a_n$, or . \\[\\sum_{i=0}^n a_i.\\] Infinite series are written as $a_0+a_1+a_2+\\cdots$, or . \\[\\sum_{n=0}^\\infty a_n.\\] How can we express series in mathematical software? . Related tasks: . | How to define a mathematical series | . ",
    "url": "/how-to-define-a-mathematical-series/#description",
    "relUrl": "/how-to-define-a-mathematical-series/#description"
  },"423": {
    "doc": "How to define a mathematical series",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . We define here the same sequence we defined in the task entitled how to define a mathematical sequence. | 1 2 3 4 . | var( 'n' ) # use n as a symbol a_n = 1 / ( n + 1 ) # formula for a term seq = sequence( a_n, (n,0,oo) ) # build the sequence seq . | . $\\displaystyle \\left[1, \\frac{1}{2}, \\frac{1}{3}, \\frac{1}{4}, \\ldots\\right]$ . We can turn it into a mathematical series by simply replacing the word sequence with the word Sum. This does not compute the answer, but just writes the series for us to view. In this case, it is an infinite series. | 1 . | Sum( a_n, (n,0,oo) ) . | . $\\displaystyle \\sum_{n=0}^{\\infty} \\frac{1}{n + 1}$ . You can compute the answer by appending the code .doit() to the above code, which asks SymPy to “do” (or evaluate) the sum. | 1 . | Sum( a_n, (n,0,oo) ).doit() . | . $\\displaystyle \\infty$ . In this case, the series diverges. We can also create and evaluate finite series by replacing the oo with a number. | 1 . | Sum( a_n, (n,0,10) ).doit() . | . $\\displaystyle \\frac{83711}{27720}$ . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-define-a-mathematical-series/#using-sympy-in-python",
    "relUrl": "/how-to-define-a-mathematical-series/#using-sympy-in-python"
  },"424": {
    "doc": "How to define a mathematical series",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-define-a-mathematical-series/#topics-that-include-this-task",
    "relUrl": "/how-to-define-a-mathematical-series/#topics-that-include-this-task"
  },"425": {
    "doc": "How to define a mathematical series",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-define-a-mathematical-series/#opportunities",
    "relUrl": "/how-to-define-a-mathematical-series/#opportunities"
  },"426": {
    "doc": "How to do a goodness of fit test for a multinomial experiment (in Python, using SciPy)",
    "title": "How to do a goodness of fit test for a multinomial experiment (in Python, using SciPy)",
    "content": "# How to do a goodness of fit test for a multinomial experiment (in Python, using SciPy) [See all solutions.](../how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment) ## Task If we have historical values for multiple population proportions, plus more recent samples from those same populations, we may want to compare to see if the proportions appear to have changed. This is called a goodness of fit test for a multinomial experiment. How can we execute it? ## Solution Let's say we have a dataset with the previous population proportions for four categories. (This is contrived data, but the code below can be used on your actual data.) | Category | Frequency |Proportion |----------|-----------|------------| A | 43 | 0.25 | B | 62 | 0.36 | C | 52 | 0.30 | D | 16 | 0.09 | We have also taken a more recent sample and found the number of observations from it that belong to each category. We want to determine if the proportions coming from the recent sample are equal to the previous proportions. SciPy expects that we will have two lists, one with the expected number of observations in each group (from the previous, or hypothesized proportions) and the other with the actual number of observations in each group (from the more recent sample). SciPy also expects that the total number of observations in each list is the same. We'll create two lists below with the fake data from above, but you can replace them with your real data ```python # Replace your data in the next two lines old_observations = [43, 62, 52, 16] new_observations = [56, 80, 12, 25] ``` We set the null hypothesis to be that the proportions of each category from the recent sample are equal to the previous proportions $$H_0: p_A = 0.25\\text{ and }\\ p_B = 0.36\\text{ and }\\ p_C = 0.30\\text{ and }\\ p_D=0.09.$$ We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. We'll let $\\alpha$ be 0.05 here. ```python # Run the Chi-square test, giving the test statistic and p-value from scipy import stats stats.chisquare(f_obs=new_observations, f_exp=old_observations) ``` Power_divergenceResult(statistic=44.98776977898321, pvalue=9.30824439694332e-10) Our $p$-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. It does appear that the proportion of at least one of the four categories is significantly different now from what it was previously. Content last modified on 23 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a goodness of fit test for a multinomial experiment/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment-in-python-using-scipy/"
  },"427": {
    "doc": "How to do a goodness of fit test for a multinomial experiment (in R)",
    "title": "How to do a goodness of fit test for a multinomial experiment (in R)",
    "content": "# How to do a goodness of fit test for a multinomial experiment (in R) [See all solutions.](../how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment) ## Task If we have historical values for multiple population proportions, plus more recent samples from those same populations, we may want to compare to see if the proportions appear to have changed. This is called a goodness of fit test for a multinomial experiment. How can we execute it? ## Solution Let's say we have a dataset with the previous population proportions for four categories. (This is contrived data, but the code below can be used on your actual data.) | Category | Frequency | Proportion |----------|-----------|------------| A | 43 | 0.25 | B | 62 | 0.36 | C | 52 | 0.30 | D | 16 | 0.09 | We have also taken a more recent sample and found the number of observations from it that belong to each category. We want to determine if the proportions coming from the recent sample are equal to the previous proportions. R expects that we will have two vectors, one with the expected number of observations in each group (from the previous, or hypothesized proportions) and the other with the actual number of observations in each group (from the more recent sample). R also expects that the total number of observations in each vector is the same. We'll create two vectors below with the fake data from above, but you can replace them with your real data ```R # our fake data: old.observations <- c(43, 62, 52, 16) new.observations <- c(56, 80, 12, 25) # now organized into a data frame: categories <- c(\"A\", \"B\", \"C\", \"D\") data <- data.frame(categories, old.observations, new.observations) ``` We set the null hypothesis to be that the proportions of each category from the recent sample are equal to the previous proportions. $$H_0: p_A = 0.25\\text{ and }\\ p_B = 0.36\\text{ and }\\ p_C = 0.30\\text{ and }\\ p_D=0.09.$$ We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. We'll let $\\alpha$ be 0.05 here. ```R # Run the Chi-Square test, giving the test statistic and p-value chisq.test(data$new.observations, p=data$old.observations, rescale.p=TRUE) ``` Chi-squared test for given probabilities data: data$new.observations X-squared = 44.988, df = 3, p-value = 9.308e-10 Our $p$-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. It does appear that the proportion of at least one of the four categories is significantly different now from what it was previously. If instead you provided the population proportions as the old observations, that is, a vector of values that sum to 1, you can omit the `rescale.p` argument. Content last modified on 23 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a goodness of fit test for a multinomial experiment/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment-in-r/",
    "relUrl": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment-in-r/"
  },"428": {
    "doc": "How to do a goodness of fit test for a multinomial experiment",
    "title": "How to do a goodness of fit test for a multinomial experiment",
    "content": " ",
    "url": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/",
    "relUrl": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/"
  },"429": {
    "doc": "How to do a goodness of fit test for a multinomial experiment",
    "title": "Description",
    "content": "If we have historical values for multiple population proportions, plus more recent samples from those same populations, we may want to compare to see if the proportions appear to have changed. This is called a goodness of fit test for a multinomial experiment. How can we execute it? . ",
    "url": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#description",
    "relUrl": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#description"
  },"430": {
    "doc": "How to do a goodness of fit test for a multinomial experiment",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. Let’s say we have a dataset with the previous population proportions for four categories. (This is contrived data, but the code below can be used on your actual data.) . | Category | Frequency | Proportion | . | A | 43 | 0.25 | . | B | 62 | 0.36 | . | C | 52 | 0.30 | . | D | 16 | 0.09 | . We have also taken a more recent sample and found the number of observations from it that belong to each category. We want to determine if the proportions coming from the recent sample are equal to the previous proportions. SciPy expects that we will have two lists, one with the expected number of observations in each group (from the previous, or hypothesized proportions) and the other with the actual number of observations in each group (from the more recent sample). SciPy also expects that the total number of observations in each list is the same. We’ll create two lists below with the fake data from above, but you can replace them with your real data . | 1 2 3 . | # Replace your data in the next two lines old_observations = [43, 62, 52, 16] new_observations = [56, 80, 12, 25] . | . We set the null hypothesis to be that the proportions of each category from the recent sample are equal to the previous proportions . \\[H_0: p_A = 0.25\\text{ and }\\ p_B = 0.36\\text{ and }\\ p_C = 0.30\\text{ and }\\ p_D=0.09.\\] We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. We’ll let $\\alpha$ be 0.05 here. | 1 2 3 . | # Run the Chi-square test, giving the test statistic and p-value from scipy import stats stats.chisquare(f_obs=new_observations, f_exp=old_observations) . | . | 1 . | Power_divergenceResult(statistic=44.98776977898321, pvalue=9.30824439694332e-10) . | . Our $p$-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. It does appear that the proportion of at least one of the four categories is significantly different now from what it was previously. Content last modified on 23 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#using-scipy-in-python"
  },"431": {
    "doc": "How to do a goodness of fit test for a multinomial experiment",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s say we have a dataset with the previous population proportions for four categories. (This is contrived data, but the code below can be used on your actual data.) . | Category | Frequency | Proportion | . | A | 43 | 0.25 | . | B | 62 | 0.36 | . | C | 52 | 0.30 | . | D | 16 | 0.09 | . We have also taken a more recent sample and found the number of observations from it that belong to each category. We want to determine if the proportions coming from the recent sample are equal to the previous proportions. R expects that we will have two vectors, one with the expected number of observations in each group (from the previous, or hypothesized proportions) and the other with the actual number of observations in each group (from the more recent sample). R also expects that the total number of observations in each vector is the same. We’ll create two vectors below with the fake data from above, but you can replace them with your real data . | 1 2 3 4 5 6 . | # our fake data: old.observations &lt;- c(43, 62, 52, 16) new.observations &lt;- c(56, 80, 12, 25) # now organized into a data frame: categories &lt;- c(\"A\", \"B\", \"C\", \"D\") data &lt;- data.frame(categories, old.observations, new.observations) . | . We set the null hypothesis to be that the proportions of each category from the recent sample are equal to the previous proportions. \\[H_0: p_A = 0.25\\text{ and }\\ p_B = 0.36\\text{ and }\\ p_C = 0.30\\text{ and }\\ p_D=0.09.\\] We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. We’ll let $\\alpha$ be 0.05 here. | 1 2 . | # Run the Chi-Square test, giving the test statistic and p-value chisq.test(data$new.observations, p=data$old.observations, rescale.p=TRUE) . | . | 1 2 3 4 . | Chi-squared test for given probabilities data: data$new.observations X-squared = 44.988, df = 3, p-value = 9.308e-10 . | . Our $p$-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. It does appear that the proportion of at least one of the four categories is significantly different now from what it was previously. If instead you provided the population proportions as the old observations, that is, a vector of values that sum to 1, you can omit the rescale.p argument. Content last modified on 23 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#solution-in-r",
    "relUrl": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#solution-in-r"
  },"432": {
    "doc": "How to do a goodness of fit test for a multinomial experiment",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#topics-that-include-this-task"
  },"433": {
    "doc": "How to do a goodness of fit test for a multinomial experiment",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#opportunities",
    "relUrl": "/how-to-do-a-goodness-of-fit-test-for-a-multinomial-experiment/#opportunities"
  },"434": {
    "doc": "How to do a hypothesis test for a mean difference (matched pairs) (in Python, using SciPy)",
    "title": "How to do a hypothesis test for a mean difference (matched pairs) (in Python, using SciPy)",
    "content": "# How to do a hypothesis test for a mean difference (matched pairs) (in Python, using SciPy) [See all solutions.](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) ## Task Say we have two sets of data that are not independent of each other and come from a matched-pairs experiment, $(x_1,x'_1),(x_2,x'_2),\\ldots,(x_n,x'_n)$. We want to perform inference on the mean of the differences between these two samples, that is, the mean of $x_1-x'_1,x_2-x'_2,\\ldots,x_n-x'_n$, called $\\mu_D$. We want to determine if it is significantly different from, greater than, or less than zero (or any other hypothesized value). We can do so with a two-tailed, right-tailed, or left-tailed hypothesis test for matched pairs. Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error rate, and in this case we will set it to be 0.05. We're going to use fake fata here, but you can replace our fake data with your real data below. Because the data are matched pairs, the samples must be the same size. ```python # Replace the following example data with your real data sample1 = [15, 10, 7, 22, 17, 14] sample2 = [ 9, 1, 11, 13, 3, 6] ``` ### Two-tailed test In a two-sided hypothesis test, the null hypothesis states that the mean difference is equal to 0 (or some other hypothesized value), $H_0: \\mu_D = 0$. ```python from scipy import stats stats.ttest_rel(sample1, sample2, alternative = \"two-sided\") ``` Ttest_relResult(statistic=2.8577380332470415, pvalue=0.03550038112896236) Our $p$-value, 0.0355, is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis and conclude that the mean difference between the two samples is significantly different from zero. Note that the function above specifically tests whether the mean of $x_i-x'_i$ is zero. If we want instead to test whether it is some other value $d\\neq0$, then that's equivalent to testing whether the mean of $(x_i-d)-x'_i$ is zero. We could do so with the code below, which uses an example value of $d$. The null hypothesis is now $H_0: \\mu_D=d$. ```python d = 6 # as an example stats.ttest_rel([ x - d for x in sample1 ], sample2, alternative = \"two-sided\") ``` Ttest_relResult(statistic=0.4082482904638631, pvalue=0.6999865427788738) The above $p$-value is greater than $\\alpha=0.05$, so we could not conclude that the mean difference is significantly different from our chosen $d=6$. ### Right-tailed test If instead we want to test whether the mean difference is less than or equal to zero, $H_0: \\mu_D\\le0$, we can use a right-tailed test, as follows. ```python stats.ttest_rel(sample1, sample2, alternative = \"greater\") ``` Ttest_relResult(statistic=2.8577380332470415, pvalue=0.01775019056448118) Our $p$-value, 0.01775, is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis and conclude that the mean difference between the two samples is significantly greater than zero. A similar change could be made to the code above to test $H_0:\\mu_D\\le d$, as in the example code further above that uses $d=6$. ### Left-tailed test If instead we want to test whether the mean difference is greater than or equal to zero, $H_0: \\mu_D\\ge 0$, we can use a right-tailed test, as follows. ```python stats.ttest_rel(sample1, sample2, alternative = \"less\") ``` Ttest_relResult(statistic=2.8577380332470415, pvalue=0.9822498094355188) Our $p$-value, 0.98225, is larger than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis; we must continue to assume that the mean difference between the two samples is greater than or equal to zero. A similar change could be made to the code above to test $H_0:\\mu_D\\ge d$, as in the example code further above that uses $d=6$. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for a mean difference (matched pairs)/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs-in-python-using-scipy/"
  },"435": {
    "doc": "How to do a hypothesis test for a mean difference (matched pairs) (in R)",
    "title": "How to do a hypothesis test for a mean difference (matched pairs) (in R)",
    "content": "# How to do a hypothesis test for a mean difference (matched pairs) (in R) [See all solutions.](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) ## Task Say we have two sets of data that are not independent of each other and come from a matched-pairs experiment, $(x_1,x'_1),(x_2,x'_2),\\ldots,(x_n,x'_n)$. We want to perform inference on the mean of the differences between these two samples, that is, the mean of $x_1-x'_1,x_2-x'_2,\\ldots,x_n-x'_n$, called $\\mu_D$. We want to determine if it is significantly different from, greater than, or less than zero (or any other hypothesized value). We can do so with a two-tailed, right-tailed, or left-tailed hypothesis test for matched pairs. Related tasks: * [How to compute a confidence interval for a mean difference (matched pairs)](../how-to-compute-a-confidence-interval-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error rate, and in this case we will set it to be 0.05. We're going to use fake fata here, but you can replace our fake data with your real data below. Because the data are matched pairs, the samples must be the same size. ```R # Replace the following example data with your real data sample.1 <- c(15, 10, 7, 22, 17, 14) sample.2 <- c( 9, 1, 11, 13, 3, 6) ``` ### Two-tailed test In a two-sided hypothesis test, the null hypothesis states that the mean difference is equal to 0 (or some other hypothesized value), $H_0: \\mu_D = 0$. ```R alpha = 0.05 t.test(sample.1, sample.2, alternative = \"two.sided\", mu = 0, paired = TRUE, conf.level = 1-alpha) ``` Paired t-test data: sample.1 and sample.2 t = 2.8577, df = 5, p-value = 0.0355 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.7033862 13.2966138 sample estimates: mean of the differences 7 Our $p$-value, 0.0355, appears in the third line of the output. It is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis and conclude that the mean difference between the two samples is significantly different from zero. If we want instead to test whether it is some other value $d\\neq0$, then just use that value as the `mu` parameter to the `t.test` function instead of zero. ### Right-tailed test If instead we want to test whether the mean difference is less than or equal to zero, $H_0: \\mu_D\\le0$, we can use a right-tailed test, as follows. ```R t.test(sample.1, sample.2, alternative = \"greater\", mu = 0, paired = TRUE, conf.level = 1-alpha) ``` Paired t-test data: sample.1 and sample.2 t = 2.8577, df = 5, p-value = 0.01775 alternative hypothesis: true difference in means is greater than 0 95 percent confidence interval: 2.06416 Inf sample estimates: mean of the differences 7 Our $p$-value, 0.01775, is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis and conclude that the mean difference between the two samples is significantly greater than zero. Again, you can use another value $d\\neq0$ in place of `mu = 0` in the code. ### Left-tailed test If instead we want to test whether the mean difference is greater than or equal to zero, $H_0: \\mu_D\\ge0$, we can use a right-tailed test, as follows. ```R t.test(sample.1, sample.2, alternative = \"less\", mu = 0, paired = TRUE, conf.level = 1-alpha) ``` Paired t-test data: sample.1 and sample.2 t = 2.8577, df = 5, p-value = 0.9822 alternative hypothesis: true difference in means is less than 0 95 percent confidence interval: -Inf 11.93584 sample estimates: mean of the differences 7 Our $p$-value, 0.9822, is larger than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis; we must continue to assume that the mean difference between the two samples is greater than or equal to zero. Again, you can use another value $d\\neq0$ in place of `mu = 0` in the code. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for a mean difference (matched pairs)/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs-in-r/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs-in-r/"
  },"436": {
    "doc": "How to do a hypothesis test for a mean difference (matched pairs)",
    "title": "How to do a hypothesis test for a mean difference (matched pairs)",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/"
  },"437": {
    "doc": "How to do a hypothesis test for a mean difference (matched pairs)",
    "title": "Description",
    "content": "Say we have two sets of data that are not independent of each other and come from a matched-pairs experiment, $(x_1,x’_1),(x_2,x’_2),\\ldots,(x_n,x’_n)$. We want to perform inference on the mean of the differences between these two samples, that is, the mean of $x_1-x’_1,x_2-x’_2,\\ldots,x_n-x’_n$, called $\\mu_D$. We want to determine if it is significantly different from, greater than, or less than zero (or any other hypothesized value). We can do so with a two-tailed, right-tailed, or left-tailed hypothesis test for matched pairs. Related tasks: . | How to compute a confidence interval for a mean difference (matched pairs) | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | How to do a hypothesis test for population variance | How to do a hypothesis test for the difference between means when both population variances are known | How to do a hypothesis test for the difference between two proportions | How to do a hypothesis test for the mean with known standard deviation | How to do a hypothesis test for the ratio of two population variances | How to do a hypothesis test of a coefficient’s significance | How to do a one-sided hypothesis test for two sample means | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#description",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#description"
  },"438": {
    "doc": "How to do a hypothesis test for a mean difference (matched pairs)",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error rate, and in this case we will set it to be 0.05. We’re going to use fake fata here, but you can replace our fake data with your real data below. Because the data are matched pairs, the samples must be the same size. | 1 2 3 . | # Replace the following example data with your real data sample1 = [15, 10, 7, 22, 17, 14] sample2 = [ 9, 1, 11, 13, 3, 6] . | . Two-tailed test . In a two-sided hypothesis test, the null hypothesis states that the mean difference is equal to 0 (or some other hypothesized value), $H_0: \\mu_D = 0$. | 1 2 . | from scipy import stats stats.ttest_rel(sample1, sample2, alternative = \"two-sided\") . | . | 1 . | Ttest_relResult(statistic=2.8577380332470415, pvalue=0.03550038112896236) . | . Our $p$-value, 0.0355, is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis and conclude that the mean difference between the two samples is significantly different from zero. Note that the function above specifically tests whether the mean of $x_i-x’_i$ is zero. If we want instead to test whether it is some other value $d\\neq0$, then that’s equivalent to testing whether the mean of $(x_i-d)-x’_i$ is zero. We could do so with the code below, which uses an example value of $d$. The null hypothesis is now $H_0: \\mu_D=d$. | 1 2 . | d = 6 # as an example stats.ttest_rel([ x - d for x in sample1 ], sample2, alternative = \"two-sided\") . | . | 1 . | Ttest_relResult(statistic=0.4082482904638631, pvalue=0.6999865427788738) . | . The above $p$-value is greater than $\\alpha=0.05$, so we could not conclude that the mean difference is significantly different from our chosen $d=6$. Right-tailed test . If instead we want to test whether the mean difference is less than or equal to zero, $H_0: \\mu_D\\le0$, we can use a right-tailed test, as follows. | 1 . | stats.ttest_rel(sample1, sample2, alternative = \"greater\") . | . | 1 . | Ttest_relResult(statistic=2.8577380332470415, pvalue=0.01775019056448118) . | . Our $p$-value, 0.01775, is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis and conclude that the mean difference between the two samples is significantly greater than zero. A similar change could be made to the code above to test $H_0:\\mu_D\\le d$, as in the example code further above that uses $d=6$. Left-tailed test . If instead we want to test whether the mean difference is greater than or equal to zero, $H_0: \\mu_D\\ge 0$, we can use a right-tailed test, as follows. | 1 . | stats.ttest_rel(sample1, sample2, alternative = \"less\") . | . | 1 . | Ttest_relResult(statistic=2.8577380332470415, pvalue=0.9822498094355188) . | . Our $p$-value, 0.98225, is larger than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis; we must continue to assume that the mean difference between the two samples is greater than or equal to zero. A similar change could be made to the code above to test $H_0:\\mu_D\\ge d$, as in the example code further above that uses $d=6$. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#using-scipy-in-python"
  },"439": {
    "doc": "How to do a hypothesis test for a mean difference (matched pairs)",
    "title": "Solution, in R",
    "content": "View this solution alone. We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error rate, and in this case we will set it to be 0.05. We’re going to use fake fata here, but you can replace our fake data with your real data below. Because the data are matched pairs, the samples must be the same size. | 1 2 3 . | # Replace the following example data with your real data sample.1 &lt;- c(15, 10, 7, 22, 17, 14) sample.2 &lt;- c( 9, 1, 11, 13, 3, 6) . | . Two-tailed test . In a two-sided hypothesis test, the null hypothesis states that the mean difference is equal to 0 (or some other hypothesized value), $H_0: \\mu_D = 0$. | 1 2 3 . | alpha = 0.05 t.test(sample.1, sample.2, alternative = \"two.sided\", mu = 0, paired = TRUE, conf.level = 1-alpha) . | . | 1 2 3 4 5 6 7 8 9 10 . | Paired t-test data: sample.1 and sample.2 t = 2.8577, df = 5, p-value = 0.0355 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.7033862 13.2966138 sample estimates: mean of the differences 7 . | . Our $p$-value, 0.0355, appears in the third line of the output. It is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis and conclude that the mean difference between the two samples is significantly different from zero. If we want instead to test whether it is some other value $d\\neq0$, then just use that value as the mu parameter to the t.test function instead of zero. Right-tailed test . If instead we want to test whether the mean difference is less than or equal to zero, $H_0: \\mu_D\\le0$, we can use a right-tailed test, as follows. | 1 2 . | t.test(sample.1, sample.2, alternative = \"greater\", mu = 0, paired = TRUE, conf.level = 1-alpha) . | . | 1 2 3 4 5 6 7 8 9 10 . | Paired t-test data: sample.1 and sample.2 t = 2.8577, df = 5, p-value = 0.01775 alternative hypothesis: true difference in means is greater than 0 95 percent confidence interval: 2.06416 Inf sample estimates: mean of the differences 7 . | . Our $p$-value, 0.01775, is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis and conclude that the mean difference between the two samples is significantly greater than zero. Again, you can use another value $d\\neq0$ in place of mu = 0 in the code. Left-tailed test . If instead we want to test whether the mean difference is greater than or equal to zero, $H_0: \\mu_D\\ge0$, we can use a right-tailed test, as follows. | 1 2 . | t.test(sample.1, sample.2, alternative = \"less\", mu = 0, paired = TRUE, conf.level = 1-alpha) . | . | 1 2 3 4 5 6 7 8 9 10 . | Paired t-test data: sample.1 and sample.2 t = 2.8577, df = 5, p-value = 0.9822 alternative hypothesis: true difference in means is less than 0 95 percent confidence interval: -Inf 11.93584 sample estimates: mean of the differences 7 . | . Our $p$-value, 0.9822, is larger than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis; we must continue to assume that the mean difference between the two samples is greater than or equal to zero. Again, you can use another value $d\\neq0$ in place of mu = 0 in the code. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#solution-in-r",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#solution-in-r"
  },"440": {
    "doc": "How to do a hypothesis test for a mean difference (matched pairs)",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#topics-that-include-this-task"
  },"441": {
    "doc": "How to do a hypothesis test for a mean difference (matched pairs)",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#opportunities",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs/#opportunities"
  },"442": {
    "doc": "How to do a hypothesis test for a population proportion (in Python, using SciPy)",
    "title": "How to do a hypothesis test for a population proportion (in Python, using SciPy)",
    "content": "# How to do a hypothesis test for a population proportion (in Python, using SciPy) [See all solutions.](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Task When we have qualitative data, we're often interested in performing inference on population proportions. That is, the proportion (between 0.0 and 1.0) of the population that is in a certain category with respect to the qualitative variables. Given a sample proportion, $\\bar{p}$, how can we test whether the population proportion is equal to, greater than, or less than some hypothesized value? Related tasks: * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We're going to use fake data here for illustrative purposes, but you can replace our fake data with your real data in the code below. Let's say that we've hypothesized that about one-third of Bostonians are unhappy with the Red Sox' performance. To test this hypothesis, we surveyed 460 Bostonians and found that 76 of them were unhappy with the Red Sox' performance. We summarize this situation with the following variables. We will do a test with a Type I error rate of $\\alpha=0.05$. ```python n = 460 # Number of respondents in sample x = 76 # Number of respondents in chosen subset sample_prop = x/n # Proportion of sample in chosen subset population_prop = 1/3 # Hypothesized population proportion ``` ### Two-tailed test A two-tailed test is for the null hypothesis $H_0: p = \\frac13$. It can be done by directly computing the test statistic and $p$-value using tools from SciPy's `stats` module. ```python import numpy as np from scipy import stats test_stat = ( (sample_prop - population_prop) / np.sqrt(population_prop*(1 - population_prop)/n) ) stats.norm.sf(abs(test_stat))*2 # p-value ``` 2.0284218907806657e-14 The $p$-value is less than $\\alpha$, so we can reject the null hypothesis. The proportion of Bostonians unhappy with Red Sox performance is different from $\\frac13$. ### Right-tailed test A right-tailed test is for the null hypothesis $H_0: p \\le \\frac13$. Most of the code is the same as above, but the $p$-value is computed differently for a one-sided test. We repeat the re-used code to make it easy to copy and paste. ```python import numpy as np from scipy import stats test_stat = ( (sample_prop - population_prop) / np.sqrt(population_prop*(1 - population_prop)/n) ) stats.norm.sf(test_stat) ``` 0.9999999999999899 The $p$-value is greater than $\\alpha$, so we cannot reject the null hypothesis. We continue to assume that the proportion of Bostonians unhappy with Red Sox performance is less than or equal to $\\frac13$. ### Left-tailed test A left-tailed test is for the null hypothesis $H_0: p\\ge \\frac13$. Most of the code is the same as above, but the $p$-value is computed differently yet again. We repeat the re-used code to make it easy to copy and paste. ```python import numpy as np from scipy import stats test_stat = ( (sample_prop - population_prop) / np.sqrt(population_prop*(1 - population_prop)/n) ) stats.norm.sf(abs(test_stat)) ``` 1.0142109453903328e-14 The $p$-value is less than $\\alpha$, so we can reject the null hypothesis. The proportion of Bostonians unhappy with Red Sox performance is less than $\\frac13$. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for a population proportion/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-a-population-proportion-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-population-proportion-in-python-using-scipy/"
  },"443": {
    "doc": "How to do a hypothesis test for a population proportion (in R)",
    "title": "How to do a hypothesis test for a population proportion (in R)",
    "content": "# How to do a hypothesis test for a population proportion (in R) [See all solutions.](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Task When we have qualitative data, we're often interested in performing inference on population proportions. That is, the proportion (between 0.0 and 1.0) of the population that is in a certain category with respect to the qualitative variables. Given a sample proportion, $\\bar{p}$, how can we test whether the population proportion is equal to, greater than, or less than some hypothesized value? Related tasks: * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We're going to use fake data here for illustrative purposes, but you can replace our fake data with your real data in the code below. Let's say that we've hypothesized that about one-third of Bostonians are unhappy with the Red Sox' performance. To test this hypothesis, we surveyed 460 Bostonians and found that 76 of them were unhappy with the Red Sox' performance. We summarize this situation with the following variables. We will do a test with a Type I error rate of $\\alpha=0.05$. ```R n <- 460 # Number of respondents in sample x <- 76 # Number of respondents in chosen subset population_prop <- 1/3 # Hypothesized population proportion ``` ### Two-tailed test A two-tailed test is for the null hypothesis $H_0: p = \\frac13$. We use R's `prop.test()` function and provide it the data from above, requesting a two-tailed test. ```R prop.test(x = x, n = n, p = population_prop, alternative = \"two.sided\") ``` 1-sample proportions test with continuity correction data: x out of n, null probability population_prop X-squared = 57.75, df = 1, p-value = 2.976e-14 alternative hypothesis: true p is not equal to 0.3333333 95 percent confidence interval: 0.1330899 0.2030664 sample estimates: p 0.1652174 The $p$-value (shown at the end of the third line of the output) is less than $\\alpha$, so we can reject the null hypothesis. The proportion of Bostonians unhappy with Red Sox performance is different from $\\frac13$. R also has a `binom.test()` function that takes the same arguments. ### Right-tailed test A right-tailed test is for the null hypothesis $H_0: p \\le \\frac13$. We use R's `prop.test()` function and provide it the data from above, requesting a right-tailed test. ```R prop.test(x = x, n = n, p = population_prop, alternative = \"greater\") ``` 1-sample proportions test with continuity correction data: x out of n, null probability population_prop X-squared = 57.75, df = 1, p-value = 1 alternative hypothesis: true p is greater than 0.3333333 95 percent confidence interval: 0.1377034 1.0000000 sample estimates: p 0.1652174 The $p$-value (shown at the end of the third line of the output) is greater than $\\alpha$, so we cannot reject the null hypothesis. We continue to assume that the proportion of Bostonians unhappy with Red Sox performance is less than or equal to $\\frac13$. Again, `binom.test()` takes the same arguments. ### Left-tailed test A left-tailed test is for the null hypothesis $H_0: p\\ge \\frac13$. We use R's `prop.test()` function and provide it the data from above, requesting a left-tailed test. ```R prop.test(x = x, n = n, p = population_prop, alternative = \"less\") ``` 1-sample proportions test with continuity correction data: x out of n, null probability population_prop X-squared = 57.75, df = 1, p-value = 1.488e-14 alternative hypothesis: true p is less than 0.3333333 95 percent confidence interval: 0.0000000 0.1967951 sample estimates: p 0.1652174 The $p$-value (shown at the end of the third line of the output) is less than $\\alpha$, so we can reject the null hypothesis. The proportion of Bostonians unhappy with Red Sox performance is less than $\\frac13$. Again, `binom.test()` takes the same arguments. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for a population proportion/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-a-population-proportion-in-r/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-population-proportion-in-r/"
  },"444": {
    "doc": "How to do a hypothesis test for a population proportion",
    "title": "How to do a hypothesis test for a population proportion",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-for-a-population-proportion/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-population-proportion/"
  },"445": {
    "doc": "How to do a hypothesis test for a population proportion",
    "title": "Description",
    "content": "When we have qualitative data, we’re often interested in performing inference on population proportions. That is, the proportion (between 0.0 and 1.0) of the population that is in a certain category with respect to the qualitative variables. Given a sample proportion, $\\bar{p}$, how can we test whether the population proportion is equal to, greater than, or less than some hypothesized value? . Related tasks: . | How to compute a confidence interval for the population proportion | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for the difference between means when both population variances are known | How to do a hypothesis test for the difference between two proportions | How to do a hypothesis test for the mean with known standard deviation | How to do a hypothesis test for the ratio of two population variances | How to do a hypothesis test of a coefficient’s significance | How to do a one-sided hypothesis test for two sample means | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#description",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#description"
  },"446": {
    "doc": "How to do a hypothesis test for a population proportion",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’re going to use fake data here for illustrative purposes, but you can replace our fake data with your real data in the code below. Let’s say that we’ve hypothesized that about one-third of Bostonians are unhappy with the Red Sox’ performance. To test this hypothesis, we surveyed 460 Bostonians and found that 76 of them were unhappy with the Red Sox’ performance. We summarize this situation with the following variables. We will do a test with a Type I error rate of $\\alpha=0.05$. | 1 2 3 4 . | n = 460 # Number of respondents in sample x = 76 # Number of respondents in chosen subset sample_prop = x/n # Proportion of sample in chosen subset population_prop = 1/3 # Hypothesized population proportion . | . Two-tailed test . A two-tailed test is for the null hypothesis $H_0: p = \\frac13$. It can be done by directly computing the test statistic and $p$-value using tools from SciPy’s stats module. | 1 2 3 4 5 . | import numpy as np from scipy import stats test_stat = ( (sample_prop - population_prop) / np.sqrt(population_prop*(1 - population_prop)/n) ) stats.norm.sf(abs(test_stat))*2 # p-value . | . | 1 . | 2.0284218907806657e-14 . | . The $p$-value is less than $\\alpha$, so we can reject the null hypothesis. The proportion of Bostonians unhappy with Red Sox performance is different from $\\frac13$. Right-tailed test . A right-tailed test is for the null hypothesis $H_0: p \\le \\frac13$. Most of the code is the same as above, but the $p$-value is computed differently for a one-sided test. We repeat the re-used code to make it easy to copy and paste. | 1 2 3 4 5 . | import numpy as np from scipy import stats test_stat = ( (sample_prop - population_prop) / np.sqrt(population_prop*(1 - population_prop)/n) ) stats.norm.sf(test_stat) . | . | 1 . | 0.9999999999999899 . | . The $p$-value is greater than $\\alpha$, so we cannot reject the null hypothesis. We continue to assume that the proportion of Bostonians unhappy with Red Sox performance is less than or equal to $\\frac13$. Left-tailed test . A left-tailed test is for the null hypothesis $H_0: p\\ge \\frac13$. Most of the code is the same as above, but the $p$-value is computed differently yet again. We repeat the re-used code to make it easy to copy and paste. | 1 2 3 4 5 . | import numpy as np from scipy import stats test_stat = ( (sample_prop - population_prop) / np.sqrt(population_prop*(1 - population_prop)/n) ) stats.norm.sf(abs(test_stat)) . | . | 1 . | 1.0142109453903328e-14 . | . The $p$-value is less than $\\alpha$, so we can reject the null hypothesis. The proportion of Bostonians unhappy with Red Sox performance is less than $\\frac13$. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#using-scipy-in-python"
  },"447": {
    "doc": "How to do a hypothesis test for a population proportion",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use fake data here for illustrative purposes, but you can replace our fake data with your real data in the code below. Let’s say that we’ve hypothesized that about one-third of Bostonians are unhappy with the Red Sox’ performance. To test this hypothesis, we surveyed 460 Bostonians and found that 76 of them were unhappy with the Red Sox’ performance. We summarize this situation with the following variables. We will do a test with a Type I error rate of $\\alpha=0.05$. | 1 2 3 . | n &lt;- 460 # Number of respondents in sample x &lt;- 76 # Number of respondents in chosen subset population_prop &lt;- 1/3 # Hypothesized population proportion . | . Two-tailed test . A two-tailed test is for the null hypothesis $H_0: p = \\frac13$. We use R’s prop.test() function and provide it the data from above, requesting a two-tailed test. | 1 . | prop.test(x = x, n = n, p = population_prop, alternative = \"two.sided\") . | . | 1 2 3 4 5 6 7 8 9 10 . | 1-sample proportions test with continuity correction data: x out of n, null probability population_prop X-squared = 57.75, df = 1, p-value = 2.976e-14 alternative hypothesis: true p is not equal to 0.3333333 95 percent confidence interval: 0.1330899 0.2030664 sample estimates: p 0.1652174 . | . The $p$-value (shown at the end of the third line of the output) is less than $\\alpha$, so we can reject the null hypothesis. The proportion of Bostonians unhappy with Red Sox performance is different from $\\frac13$. R also has a binom.test() function that takes the same arguments. Right-tailed test . A right-tailed test is for the null hypothesis $H_0: p \\le \\frac13$. We use R’s prop.test() function and provide it the data from above, requesting a right-tailed test. | 1 . | prop.test(x = x, n = n, p = population_prop, alternative = \"greater\") . | . | 1 2 3 4 5 6 7 8 9 10 . | 1-sample proportions test with continuity correction data: x out of n, null probability population_prop X-squared = 57.75, df = 1, p-value = 1 alternative hypothesis: true p is greater than 0.3333333 95 percent confidence interval: 0.1377034 1.0000000 sample estimates: p 0.1652174 . | . The $p$-value (shown at the end of the third line of the output) is greater than $\\alpha$, so we cannot reject the null hypothesis. We continue to assume that the proportion of Bostonians unhappy with Red Sox performance is less than or equal to $\\frac13$. Again, binom.test() takes the same arguments. Left-tailed test . A left-tailed test is for the null hypothesis $H_0: p\\ge \\frac13$. We use R’s prop.test() function and provide it the data from above, requesting a left-tailed test. | 1 . | prop.test(x = x, n = n, p = population_prop, alternative = \"less\") . | . | 1 2 3 4 5 6 7 8 9 10 . | 1-sample proportions test with continuity correction data: x out of n, null probability population_prop X-squared = 57.75, df = 1, p-value = 1.488e-14 alternative hypothesis: true p is less than 0.3333333 95 percent confidence interval: 0.0000000 0.1967951 sample estimates: p 0.1652174 . | . The $p$-value (shown at the end of the third line of the output) is less than $\\alpha$, so we can reject the null hypothesis. The proportion of Bostonians unhappy with Red Sox performance is less than $\\frac13$. Again, binom.test() takes the same arguments. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#solution-in-r",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#solution-in-r"
  },"448": {
    "doc": "How to do a hypothesis test for a population proportion",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#topics-that-include-this-task"
  },"449": {
    "doc": "How to do a hypothesis test for a population proportion",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#opportunities",
    "relUrl": "/how-to-do-a-hypothesis-test-for-a-population-proportion/#opportunities"
  },"450": {
    "doc": "How to do a hypothesis test for population variance (in R)",
    "title": "How to do a hypothesis test for population variance (in R)",
    "content": "# How to do a hypothesis test for population variance (in R) [See all solutions.](../how-to-do-a-hypothesis-test-for-population-variance) ## Task Assume we want to estimate the variability of a quantity across a population, starting from a sample of data, $x_1, x_2, x_3, \\ldots x_k$. How might we test whether the population variance is equal to, greater than, or less than a hypothesized value? Related tasks: * [How to compute a confidence interval for the population proportion](../how-to-compute-a-confidence-interval-for-the-population-proportion) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We'll use R's dataset `EuStockMarkets` to do an example. This dataset has information on the daily closing prices of 4 European stock indices. We're going to look at the variability of Germany's DAX closing prices. Let's load the dataset. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) If using your own data, place it into the `values` variable instead of using the code below. ```R # install.packages(\"datasets\") # If you have not already done this library(datasets) EuStockMarkets <- data.frame(EuStockMarkets) values <- EuStockMarkets$DAX ``` ### Two-tailed test We may ask whether the population variance is significantly different from a hypothesized value. Let's test against a variance of 1,000,000. Our null hypothesis states that the population variance is equal to 1,000,000, $H_0: \\sigma^2 = 1,000,000$. We calculate the test statistic and $p$-value as follows, using a $\\chi^2$ distribution. We can use any $\\alpha$ between 0.0 and 1.0 as our Type I Error Rate; we will use $\\alpha=0.05$ here. ```R hyp.var <- 1000000 # hypothesized variance df <- length(values) - 1 # degrees of freedom test.statistic <- df*var(values)/hyp.var # test statistic 2*pchisq(test.statistic, df=df, lower.tail=FALSE) # two-tailed p-value ``` [1] 3.189769e-07 Our $p$-value, $3.189769\\times10^{-7}$, is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The variance of closing prices on Germany's DAX is signficantly different from 1,000,000. ### Left-tailed test What if we wanted to determine if the population variance were significantly less than 1,000,000? Our null hypothesis would therefore be $H_0: \\sigma^2 \\ge 1,000,000$. The computations are very similar to the previous case, but with a different formula for the $p$-value. We repeat the code that's in common, for ease of use when copying and pasting. ```R hyp.var <- 1000000 # hypothesized variance df <- length(values) - 1 # degrees of freedom test.statistic <- df*var(values)/hyp.var # test statistic pchisq(test.statistic, df=df, lower.tail=TRUE) # left-tailed p-value ``` [1] 0.9999998 Our p-value, 0.9999998, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We should continue to assume that the variance of closing prices on Germany's DAX is greater than or equal to 1,000,000. ### Right-tailed test What if we wanted to determine if the population variance were significantly less than 1,000,000? Our null hypothesis would therefore be $H_0: \\sigma^2 \\ge 1,000,000$. The computations are very similar to the previous case, but with a different formula for the $p$-value. We repeat the code that's in common, for ease of use when copying and pasting. ```R hyp.var <- 1000000 # hypothesized variance df <- length(values) - 1 # degrees of freedom test.statistic <- df*var(values)/hyp.var # test statistic pchisq(test.statistic, df=df, lower.tail=FALSE) # right-tailed p-value ``` [1] 1.594884e-07 Our p-value, $1.594884\\times10^{-7}$, is smaller than $\\alpha$, so have sufficient evidence to reject the null hypothesis. We conclude that the variance of closing prices on Germany's DAX is significantly greater than 1,000,000. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for population variance/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-population-variance-in-r/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-population-variance-in-r/"
  },"451": {
    "doc": "How to do a hypothesis test for population variance",
    "title": "How to do a hypothesis test for population variance",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-for-population-variance/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-population-variance/"
  },"452": {
    "doc": "How to do a hypothesis test for population variance",
    "title": "Description",
    "content": "Assume we want to estimate the variability of a quantity across a population, starting from a sample of data, $x_1, x_2, x_3, \\ldots x_k$. How might we test whether the population variance is equal to, greater than, or less than a hypothesized value? . Related tasks: . | How to compute a confidence interval for the population proportion | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | How to do a hypothesis test for the difference between means when both population variances are known | How to do a hypothesis test for the difference between two proportions | How to do a hypothesis test for the mean with known standard deviation | How to do a hypothesis test for the ratio of two population variances | How to do a hypothesis test of a coefficient’s significance | How to do a one-sided hypothesis test for two sample means | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/how-to-do-a-hypothesis-test-for-population-variance/#description",
    "relUrl": "/how-to-do-a-hypothesis-test-for-population-variance/#description"
  },"453": {
    "doc": "How to do a hypothesis test for population variance",
    "title": "Solution, in R",
    "content": "View this solution alone. We’ll use R’s dataset EuStockMarkets to do an example. This dataset has information on the daily closing prices of 4 European stock indices. We’re going to look at the variability of Germany’s DAX closing prices. Let’s load the dataset. (See how to quickly load some sample data.) If using your own data, place it into the values variable instead of using the code below. | 1 2 3 4 . | # install.packages(\"datasets\") # If you have not already done this library(datasets) EuStockMarkets &lt;- data.frame(EuStockMarkets) values &lt;- EuStockMarkets$DAX . | . Two-tailed test . We may ask whether the population variance is significantly different from a hypothesized value. Let’s test against a variance of 1,000,000. Our null hypothesis states that the population variance is equal to 1,000,000, $H_0: \\sigma^2 = 1,000,000$. We calculate the test statistic and $p$-value as follows, using a $\\chi^2$ distribution. We can use any $\\alpha$ between 0.0 and 1.0 as our Type I Error Rate; we will use $\\alpha=0.05$ here. | 1 2 3 4 . | hyp.var &lt;- 1000000 # hypothesized variance df &lt;- length(values) - 1 # degrees of freedom test.statistic &lt;- df*var(values)/hyp.var # test statistic 2*pchisq(test.statistic, df=df, lower.tail=FALSE) # two-tailed p-value . | . | 1 . | [1] 3.189769e-07 . | . Our $p$-value, $3.189769\\times10^{-7}$, is smaller than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The variance of closing prices on Germany’s DAX is signficantly different from 1,000,000. Left-tailed test . What if we wanted to determine if the population variance were significantly less than 1,000,000? Our null hypothesis would therefore be $H_0: \\sigma^2 \\ge 1,000,000$. The computations are very similar to the previous case, but with a different formula for the $p$-value. We repeat the code that’s in common, for ease of use when copying and pasting. | 1 2 3 4 . | hyp.var &lt;- 1000000 # hypothesized variance df &lt;- length(values) - 1 # degrees of freedom test.statistic &lt;- df*var(values)/hyp.var # test statistic pchisq(test.statistic, df=df, lower.tail=TRUE) # left-tailed p-value . | . | 1 . | [1] 0.9999998 . | . Our p-value, 0.9999998, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We should continue to assume that the variance of closing prices on Germany’s DAX is greater than or equal to 1,000,000. Right-tailed test . What if we wanted to determine if the population variance were significantly less than 1,000,000? Our null hypothesis would therefore be $H_0: \\sigma^2 \\ge 1,000,000$. The computations are very similar to the previous case, but with a different formula for the $p$-value. We repeat the code that’s in common, for ease of use when copying and pasting. | 1 2 3 4 . | hyp.var &lt;- 1000000 # hypothesized variance df &lt;- length(values) - 1 # degrees of freedom test.statistic &lt;- df*var(values)/hyp.var # test statistic pchisq(test.statistic, df=df, lower.tail=FALSE) # right-tailed p-value . | . | 1 . | [1] 1.594884e-07 . | . Our p-value, $1.594884\\times10^{-7}$, is smaller than $\\alpha$, so have sufficient evidence to reject the null hypothesis. We conclude that the variance of closing prices on Germany’s DAX is significantly greater than 1,000,000. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-population-variance/#solution-in-r",
    "relUrl": "/how-to-do-a-hypothesis-test-for-population-variance/#solution-in-r"
  },"454": {
    "doc": "How to do a hypothesis test for population variance",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-hypothesis-test-for-population-variance/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-hypothesis-test-for-population-variance/#topics-that-include-this-task"
  },"455": {
    "doc": "How to do a hypothesis test for population variance",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-hypothesis-test-for-population-variance/#opportunities",
    "relUrl": "/how-to-do-a-hypothesis-test-for-population-variance/#opportunities"
  },"456": {
    "doc": "How to do a hypothesis test for the difference between means when both population variances are known (in Python, using SciPy)",
    "title": "How to do a hypothesis test for the difference between means when both population variances are known (in Python, using SciPy)",
    "content": "# How to do a hypothesis test for the difference between means when both population variances are known (in Python, using SciPy) [See all solutions.](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) ## Task Assume we have two samples, $x_1, x_2, \\ldots, x_n$ and $x'_1, x'_2, \\ldots, x'_n$, that come from normally distributed populations with known variances, and the two sample means are $\\bar{x}$ and $\\bar{x}'$, respectively. We might want to ask whether the difference $\\bar{x}-\\bar{x}'$ is significantly different from, greater than, or less than zero. Related tasks: * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We're going to use fake data here, but you can replace our fake data with your real data below. You will need not only the samples but also the known population standard deviations. ```python sample1 = [ 5, 8, 10, 3, 6, 2] sample2 = [13, 20, 16, 12, 18, 15] population1_sd = 2.4 population2_sd = 3 ``` We must compute the sizes and means of the two samples. ```python import numpy as np n1 = len(sample1) n2 = len(sample2) sample1_mean = np.mean(sample1) sample2_mean = np.mean(sample2) ``` We choose a value $0 \\le \\alpha \\le 1$ as the probability of a Type I error (a false positive, finding we should reject $H_0$ when it’s actually true). We will use $\\alpha=0.05$ in this example. ### Two-tailed test In a two-tailed test, the null hypothesis is that the difference is zero, $H_0: \\bar{x} - \\bar{x}' = 0$. We compute a test statistic and $p$-value as follows. ```python from scipy import stats test_statistic = ( (sample1_mean - sample2_mean) / np.sqrt(population1_sd**2/n1 + population2_sd**2/n2) ) 2*stats.norm.sf(abs(test_statistic)) # two-tailed p-value ``` 1.8204936819059392e-10 Our p-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The difference between the means is significantly different from zero. ### Right-tailed test In the right-tailed test, the null hypothesis is $H_0: \\bar{x} - \\bar{x}' \\le 0$. That is, we are testing whether the difference is greater than zero. The code is very similar to the previous, except only in computing the $p$-value. We repeat the code that's in common, to make it easier to copy and paste the examples. ```python from scipy import stats test_statistic = ( (sample1_mean - sample2_mean) / np.sqrt(population1_sd**2/n1 + population2_sd**2/n2) ) stats.norm.sf(test_statistic) # right-tailed p-value ``` 0.9999999999089754 Our $p$-value is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We would continue to assume that the difference in means is less than or equal to zero. ### Left-tailed test In a left-tailed test, the null hypothesis is $H_0: \\bar{x} - \\bar{x}' \\ge 0$. That is, we are testing whether the difference is less than zero. The code is very similar to the previous, except only in computing the $p$-value. We repeat the code that's in common, to make it easier to copy and paste the examples. ```python from scipy import stats test_statistic = ( (sample1_mean - sample2_mean) / np.sqrt(population1_sd**2/n1 + population2_sd**2/n2) ) stats.norm.sf(-test_statistic) # left-tailed p-value ``` 9.102468409529696e-11 Our $p$-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The difference between the means is significantly less than zero. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for the difference between means when both population variances are known/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known-in-python-using-scipy/"
  },"457": {
    "doc": "How to do a hypothesis test for the difference between means when both population variances are known (in R)",
    "title": "How to do a hypothesis test for the difference between means when both population variances are known (in R)",
    "content": "# How to do a hypothesis test for the difference between means when both population variances are known (in R) [See all solutions.](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) ## Task Assume we have two samples, $x_1, x_2, \\ldots, x_n$ and $x'_1, x'_2, \\ldots, x'_n$, that come from normally distributed populations with known variances, and the two sample means are $\\bar{x}$ and $\\bar{x}'$, respectively. We might want to ask whether the difference $\\bar{x}-\\bar{x}'$ is significantly different from, greater than, or less than zero. Related tasks: * [How to compute a confidence interval for the difference between two means when both population variances are known](../how-to-compute-a-confidence-interval-for-the-difference-between-two-means-when-both-population-variances-are-known) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We're going to use fake data here, but you can replace our fake data with your real data below. You will need not only the samples but also the known population standard deviations. ```R sample1 <- c(5, 8, 10, 3, 6, 2) sample2 <- c(13, 20, 16, 12, 18, 15) population1_sd = 2.4 population2_sd = 3 ``` We must compute the sizes and means of the two samples. ```R n1 <- length(sample1) n2 <- length(sample2) sample1_mean <- mean(sample1) sample2_mean <- mean(sample2) ``` We choose a value $0 \\le \\alpha \\le 1$ as the probability of a Type I error (a false positive, finding we should reject $H_0$ when it’s actually true). We will use $\\alpha=0.05$ in this example. ### Two-tailed test In a two-tailed test, the null hypothesis is that the difference is zero, $H_0: \\bar{x} - \\bar{x}' = 0$. We compute a test statistic and $p$-value as follows. ```R test_statistic <- (sample1_mean - sample2_mean) / sqrt(population1_sd^2/n1 + population2_sd^2/n2) 2*pnorm(abs(test_statistic), lower.tail = FALSE) # two-tailed p-value ``` [1] 1.820494e-10 Our p-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The difference between the means is significantly different from zero. ### Right-tailed test In the right-tailed test, the null hypothesis is $H_0: \\bar{x} - \\bar{x}' \\le 0$. That is, we are testing whether the difference is greater than zero. The code is very similar to the previous, except only in computing the $p$-value. We repeat the code that's in common, to make it easier to copy and paste the examples. ```R test_statistic <- (sample1_mean - sample2_mean) / sqrt(population1_sd^2/n1 + population2_sd^2/n2) pnorm(test_statistic, lower.tail = FALSE) # right-tailed p-value ``` [1] 1 Our $p$-value is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We would continue to assume that the difference in means is less than or equal to zero. ### Left-tailed test In a left-tailed test, the null hypothesis is $H_0: \\bar{x} - \\bar{x}' \\ge 0$. That is, we are testing whether the difference is less than zero. The code is very similar to the previous, except only in computing the $p$-value. We repeat the code that's in common, to make it easier to copy and paste the examples. ```R test_statistic <- (sample1_mean - sample2_mean) / sqrt(population1_sd^2/n1 + population2_sd^2/n2) pnorm(test_statistic, lower.tail = TRUE) # left-tailed p-value ``` [1] 9.102468e-11 Our $p$-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The difference between the means is significantly less than zero. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for the difference between means when both population variances are known/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known-in-r/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known-in-r/"
  },"458": {
    "doc": "How to do a hypothesis test for the difference between means when both population variances are known",
    "title": "How to do a hypothesis test for the difference between means when both population variances are known",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/"
  },"459": {
    "doc": "How to do a hypothesis test for the difference between means when both population variances are known",
    "title": "Description",
    "content": "Assume we have two samples, $x_1, x_2, \\ldots, x_n$ and $x’_1, x’_2, \\ldots, x’_n$, that come from normally distributed populations with known variances, and the two sample means are $\\bar{x}$ and $\\bar{x}’$, respectively. We might want to ask whether the difference $\\bar{x}-\\bar{x}’$ is significantly different from, greater than, or less than zero. Related tasks: . | How to compute a confidence interval for the difference between two means when both population variances are known | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | How to do a hypothesis test for population variance | How to do a hypothesis test for the difference between two proportions | How to do a hypothesis test for the mean with known standard deviation | How to do a hypothesis test for the ratio of two population variances | How to do a hypothesis test of a coefficient’s significance | How to do a one-sided hypothesis test for two sample means | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#description",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#description"
  },"460": {
    "doc": "How to do a hypothesis test for the difference between means when both population variances are known",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’re going to use fake data here, but you can replace our fake data with your real data below. You will need not only the samples but also the known population standard deviations. | 1 2 3 4 . | sample1 = [ 5, 8, 10, 3, 6, 2] sample2 = [13, 20, 16, 12, 18, 15] population1_sd = 2.4 population2_sd = 3 . | . We must compute the sizes and means of the two samples. | 1 2 3 4 5 . | import numpy as np n1 = len(sample1) n2 = len(sample2) sample1_mean = np.mean(sample1) sample2_mean = np.mean(sample2) . | . We choose a value $0 \\le \\alpha \\le 1$ as the probability of a Type I error (a false positive, finding we should reject $H_0$ when it’s actually true). We will use $\\alpha=0.05$ in this example. Two-tailed test . In a two-tailed test, the null hypothesis is that the difference is zero, $H_0: \\bar{x} - \\bar{x}’ = 0$. We compute a test statistic and $p$-value as follows. | 1 2 3 4 . | from scipy import stats test_statistic = ( (sample1_mean - sample2_mean) / np.sqrt(population1_sd**2/n1 + population2_sd**2/n2) ) 2*stats.norm.sf(abs(test_statistic)) # two-tailed p-value . | . | 1 . | 1.8204936819059392e-10 . | . Our p-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The difference between the means is significantly different from zero. Right-tailed test . In the right-tailed test, the null hypothesis is $H_0: \\bar{x} - \\bar{x}’ \\le 0$. That is, we are testing whether the difference is greater than zero. The code is very similar to the previous, except only in computing the $p$-value. We repeat the code that’s in common, to make it easier to copy and paste the examples. | 1 2 3 4 . | from scipy import stats test_statistic = ( (sample1_mean - sample2_mean) / np.sqrt(population1_sd**2/n1 + population2_sd**2/n2) ) stats.norm.sf(test_statistic) # right-tailed p-value . | . | 1 . | 0.9999999999089754 . | . Our $p$-value is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We would continue to assume that the difference in means is less than or equal to zero. Left-tailed test . In a left-tailed test, the null hypothesis is $H_0: \\bar{x} - \\bar{x}’ \\ge 0$. That is, we are testing whether the difference is less than zero. The code is very similar to the previous, except only in computing the $p$-value. We repeat the code that’s in common, to make it easier to copy and paste the examples. | 1 2 3 4 . | from scipy import stats test_statistic = ( (sample1_mean - sample2_mean) / np.sqrt(population1_sd**2/n1 + population2_sd**2/n2) ) stats.norm.sf(-test_statistic) # left-tailed p-value . | . | 1 . | 9.102468409529696e-11 . | . Our $p$-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The difference between the means is significantly less than zero. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#using-scipy-in-python"
  },"461": {
    "doc": "How to do a hypothesis test for the difference between means when both population variances are known",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use fake data here, but you can replace our fake data with your real data below. You will need not only the samples but also the known population standard deviations. | 1 2 3 4 . | sample1 &lt;- c(5, 8, 10, 3, 6, 2) sample2 &lt;- c(13, 20, 16, 12, 18, 15) population1_sd = 2.4 population2_sd = 3 . | . We must compute the sizes and means of the two samples. | 1 2 3 4 . | n1 &lt;- length(sample1) n2 &lt;- length(sample2) sample1_mean &lt;- mean(sample1) sample2_mean &lt;- mean(sample2) . | . We choose a value $0 \\le \\alpha \\le 1$ as the probability of a Type I error (a false positive, finding we should reject $H_0$ when it’s actually true). We will use $\\alpha=0.05$ in this example. Two-tailed test . In a two-tailed test, the null hypothesis is that the difference is zero, $H_0: \\bar{x} - \\bar{x}’ = 0$. We compute a test statistic and $p$-value as follows. | 1 2 3 . | test_statistic &lt;- (sample1_mean - sample2_mean) / sqrt(population1_sd^2/n1 + population2_sd^2/n2) 2*pnorm(abs(test_statistic), lower.tail = FALSE) # two-tailed p-value . | . | 1 . | [1] 1.820494e-10 . | . Our p-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The difference between the means is significantly different from zero. Right-tailed test . In the right-tailed test, the null hypothesis is $H_0: \\bar{x} - \\bar{x}’ \\le 0$. That is, we are testing whether the difference is greater than zero. The code is very similar to the previous, except only in computing the $p$-value. We repeat the code that’s in common, to make it easier to copy and paste the examples. | 1 2 3 . | test_statistic &lt;- (sample1_mean - sample2_mean) / sqrt(population1_sd^2/n1 + population2_sd^2/n2) pnorm(test_statistic, lower.tail = FALSE) # right-tailed p-value . | . | 1 . | [1] 1 . | . Our $p$-value is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We would continue to assume that the difference in means is less than or equal to zero. Left-tailed test . In a left-tailed test, the null hypothesis is $H_0: \\bar{x} - \\bar{x}’ \\ge 0$. That is, we are testing whether the difference is less than zero. The code is very similar to the previous, except only in computing the $p$-value. We repeat the code that’s in common, to make it easier to copy and paste the examples. | 1 2 3 . | test_statistic &lt;- (sample1_mean - sample2_mean) / sqrt(population1_sd^2/n1 + population2_sd^2/n2) pnorm(test_statistic, lower.tail = TRUE) # left-tailed p-value . | . | 1 . | [1] 9.102468e-11 . | . Our $p$-value is less than $\\alpha$, so we have sufficient evidence to reject the null hypothesis. The difference between the means is significantly less than zero. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#solution-in-r",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#solution-in-r"
  },"462": {
    "doc": "How to do a hypothesis test for the difference between means when both population variances are known",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#topics-that-include-this-task"
  },"463": {
    "doc": "How to do a hypothesis test for the difference between means when both population variances are known",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#opportunities",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known/#opportunities"
  },"464": {
    "doc": "How to do a hypothesis test for the difference between two proportions (in Python, using SciPy)",
    "title": "How to do a hypothesis test for the difference between two proportions (in Python, using SciPy)",
    "content": "# How to do a hypothesis test for the difference between two proportions (in Python, using SciPy) [See all solutions.](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) ## Task When dealing with qualitative data, we typically measure what proportion of the population falls into various categories (e.g., which religion a survey respondent adheres to, if any). We might want to compare two proportions by measuring their difference, and asking whether it is equal, greater, or less than zero. How can we perform such a test? Related tasks: * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We will use some fake data in this example, but you can replace it with your real data. Imagine we conduct a survey of people in Boston and of people in Nashville and ask them if they prefer chocolate or vanilla ice cream. We get data like the following. | City | Prefer chocolate | Prefer vanilla | Total |-----------|------------------|----------------|-------| Boston | 60 | 90 | 150 | Nashville | 85 | 50 | 135 | We want to compare the proportions of people from the two cities who like vanilla. Let $\\bar{p}_1$ represent the proportion of people from Boston who like vanilla and $\\bar{p}_2$ represent the proportion of people from Nashville who like vanilla. ```python n1 = 150 # number of observations in sample 1 n2 = 135 # number of observations in sample 2 p_bar1 = 90/150 # proportion in sample 1 p_bar2 = 50/135 # proportion in sample 2 ``` We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. For this example, we will use $\\alpha=0.05$. ### Two-tailed test In a two-tailed test, the null hypothesis states that the difference between the two proportions equals a hypothesized value; let's choose zero, $H_0: \\bar{p}_1 - \\bar{p}_2 = 0$. We perform this test by computing a test statistic and $p$-value as shown below, then comparing the $p$-value to our chosen $\\alpha$. ```python import numpy as np p_bar = (90 + 50) / (150 + 135) # overall proportion std_error = np.sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic = (p_bar1 - p_bar2)/std_error # test statistic from scipy import stats 2*stats.norm.sf(abs(test_statistic)) # two-tailed p-value ``` 0.00010802693662804402 Our $p$-value, 0.000108, is smaller than $\\alpha$, so we can reject the null hypothesis and conclude that the difference between the two proportions is different from zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let's repeat the above test, comparing the difference to $0.15$ instead, as an example. ```python import numpy as np hyp_diff = 0.15 # hypothesized difference std_error = np.sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic = ((p_bar1 - p_bar2) - hyp_diff)/std_error # test statistic from scipy import stats 2*stats.norm.sf(abs(test_statistic)) # two-tailed p-value ``` 0.16744531573658772 Our $p$-value, 0.1674, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly different from 0.15. ### Right-tailed test In a right-tailed test, the null hypothesis states that the difference between the two proportions is less than or equal to a hypothesized value. Let's begin by using zero as our hypothesized value, $H_0: \\bar{p}_1 - \\bar{p}_2 \\le 0$. We repeat some code below that we've seen above, just to make it easy to copy and paste the example elsewhere. ```python import numpy as np p_bar = (90 + 50) / (150 + 135) # overall proportion std_error = np.sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic = (p_bar1 - p_bar2)/std_error # test statistic from scipy import stats stats.norm.sf(abs(test_statistic)) # right-tailed p-value ``` 5.401346831402201e-05 Our $p$-value is smaller than $\\alpha$, so we can reject the null hypothesis and conclude that the difference between the two proportions is significantly greater than zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let's repeat the above test, comparing the difference to $0.15$ instead, as an example. ```python import numpy as np hyp_diff = 0.15 # hypothesized difference std_error = np.sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic = ((p_bar1 - p_bar2) - hyp_diff)/std_error # test statistic from scipy import stats stats.norm.sf(abs(test_statistic)) # right-tailed p-value ``` 0.08372265786829386 Our $p$-value, 0.0837, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly greater than 0.15. ### Left-tailed test In a left-tailed test, the null hypothesis states that the difference between the two proportions is greater than or equal to a hypothesized value. Let's begin by using zero as our hypothesized value, $H_0: \\bar{p}_1 - \\bar{p}_2 \\ge 0$. We repeat some code below that we've seen above, just to make it easy to copy and paste the example elsewhere. ```python import numpy as np p_bar = (90 + 50) / (150 + 135) # overall proportion std_error = np.sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic = (p_bar1 - p_bar2)/std_error # test statistic from scipy import stats stats.norm.sf(-test_statistic) # left-tailed p-value ``` 0.999945986531686 Our $p$-value, 0.9999, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between the two proportions is significantly less than zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let's repeat the above test, comparing the difference to $0.15$ instead, as an example. ```python import numpy as np hyp_diff = 0.15 # hypothesized difference std_error = np.sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic = ((p_bar1 - p_bar2) - hyp_diff)/std_error # test statistic from scipy import stats stats.norm.sf(-test_statistic) # left-tailed p-value ``` 0.9162773421317061 Our $p$-value, 0.91627, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly less than 0.15. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for the difference between two proportions/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions-in-python-using-scipy/"
  },"465": {
    "doc": "How to do a hypothesis test for the difference between two proportions (in R)",
    "title": "How to do a hypothesis test for the difference between two proportions (in R)",
    "content": "# How to do a hypothesis test for the difference between two proportions (in R) [See all solutions.](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) ## Task When dealing with qualitative data, we typically measure what proportion of the population falls into various categories (e.g., which religion a survey respondent adheres to, if any). We might want to compare two proportions by measuring their difference, and asking whether it is equal, greater, or less than zero. How can we perform such a test? Related tasks: * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We will use some fake data in this example, but you can replace it with your real data. Imagine we conduct a survey of people in Boston and of people in Nashville and ask them if they prefer chocolate or vanilla ice cream. We get data like the following. | City | Prefer chocolate | Prefer vanilla | Total |-----------|------------------|----------------|-------| Boston | 60 | 90 | 150 | Nashville | 85 | 50 | 135 | We want to compare the proportions of people from the two cities who like vanilla. Let $\\bar{p}_1$ represent the proportion of people from Boston who like vanilla and $\\bar{p}_2$ represent the proportion of people from Nashville who like vanilla. ```R n1 <- 150 n2 <- 135 p_bar1 <- 90/150 p_bar2 <- 50/135 ``` We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. For this example, we will use $\\alpha=0.05$. ### Two-tailed test In a two-tailed test, the null hypothesis states that the difference between the two proportions equals a hypothesized value; let's choose zero, $H_0: \\bar{p}_1 - \\bar{p}_2 = 0$. We perform this test by computing a test statistic and $p$-value as shown below, then comparing the $p$-value to our chosen $\\alpha$. ```R p_bar <- (90 + 50) / (150 + 135) # overall proportion std_error <- sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic <- (p_bar1 - p_bar2)/std_error # test statistic 2*pnorm(q = test_statistic, lower.tail = FALSE) # two-tailed p-value ``` [1] 0.0001080269 Our $p$-value, 0.000108, is smaller than $\\alpha$, so we can reject the null hypothesis and conclude that the difference between the two proportions is different from zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let's repeat the above test, comparing the difference to $0.15$ instead, as an example. ```R hyp.diff = 0.15 # hypothesized difference std_error <- sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic <- ((p_bar1 - p_bar2) - hyp.diff)/std_error # test statistic 2*pnorm(q = test_statistic, lower.tail = FALSE) # two-tailed p-value ``` [1] 0.1674453 Our $p$-value, 0.1674, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly different from 0.15. ### Right-tailed test In a right-tailed test, the null hypothesis states that the difference between the two proportions is less than or equal to a hypothesized value. Let's begin by using zero as our hypothesized value, $H_0: \\bar{p}_1 - \\bar{p}_2 \\le 0$. We repeat some code below that we've seen above, just to make it easy to copy and paste the example elsewhere. ```R p_bar <- (90 + 50) / (150 + 135) # overall proportion std_error <- sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic <- (p_bar1 - p_bar2)/std_error # test statistic pnorm(q = test_statistic, lower.tail = FALSE) # right-tailed p-value ``` [1] 5.401347e-05 Our $p$-value is smaller than $\\alpha$, so we can reject the null hypothesis and conclude that the difference between the two proportions is significantly greater than zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let's repeat the above test, comparing the difference to $0.15$ instead, as an example. ```R hyp.diff = 0.15 # hypothesized difference std_error <- sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic <- ((p_bar1 - p_bar2) - hyp.diff)/std_error # test statistic pnorm(q = test_statistic, lower.tail = FALSE) # right-tailed p-value ``` [1] 0.08372266 Our $p$-value, 0.0837, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly greater than 0.15. ### Left-tailed test In a left-tailed test, the null hypothesis states that the difference between the two proportions is greater than or equal to a hypothesized value. Let's begin by using zero as our hypothesized value, $H_0: \\bar{p}_1 - \\bar{p}_2 \\ge 0$. We repeat some code below that we've seen above, just to make it easy to copy and paste the example elsewhere. ```R p_bar <- (90 + 50) / (150 + 135) # overall proportion std_error <- sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic <- (p_bar1 - p_bar2)/std_error # test statistic pnorm(q = test_statistic, lower.tail = TRUE) # left-tailed p-value ``` [1] 0.999946 Our $p$-value, 0.9999, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between the two proportions is significantly less than zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let's repeat the above test, comparing the difference to $0.15$ instead, as an example. ```R hyp.diff = 0.15 # hypothesized difference std_error <- sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic <- ((p_bar1 - p_bar2) - hyp.diff)/std_error # test statistic pnorm(q = test_statistic, lower.tail = TRUE) # left-tailed p-value ``` [1] 0.9162773 Our $p$-value, 0.91627, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly less than 0.15. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for the difference between two proportions/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions-in-r/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions-in-r/"
  },"466": {
    "doc": "How to do a hypothesis test for the difference between two proportions",
    "title": "How to do a hypothesis test for the difference between two proportions",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/"
  },"467": {
    "doc": "How to do a hypothesis test for the difference between two proportions",
    "title": "Description",
    "content": "When dealing with qualitative data, we typically measure what proportion of the population falls into various categories (e.g., which religion a survey respondent adheres to, if any). We might want to compare two proportions by measuring their difference, and asking whether it is equal, greater, or less than zero. How can we perform such a test? . Related tasks: . | How to compute a confidence interval for the difference between two proportions | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | How to do a hypothesis test for population variance | How to do a hypothesis test for the difference between means when both population variances are known | How to do a hypothesis test for the mean with known standard deviation | How to do a hypothesis test for the ratio of two population variances | How to do a hypothesis test of a coefficient’s significance | How to do a one-sided hypothesis test for two sample means | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#description",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#description"
  },"468": {
    "doc": "How to do a hypothesis test for the difference between two proportions",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We will use some fake data in this example, but you can replace it with your real data. Imagine we conduct a survey of people in Boston and of people in Nashville and ask them if they prefer chocolate or vanilla ice cream. We get data like the following. | City | Prefer chocolate | Prefer vanilla | Total | . | Boston | 60 | 90 | 150 | . | Nashville | 85 | 50 | 135 | . We want to compare the proportions of people from the two cities who like vanilla. Let $\\bar{p}_1$ represent the proportion of people from Boston who like vanilla and $\\bar{p}_2$ represent the proportion of people from Nashville who like vanilla. | 1 2 3 4 . | n1 = 150 # number of observations in sample 1 n2 = 135 # number of observations in sample 2 p_bar1 = 90/150 # proportion in sample 1 p_bar2 = 50/135 # proportion in sample 2 . | . We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. For this example, we will use $\\alpha=0.05$. Two-tailed test . In a two-tailed test, the null hypothesis states that the difference between the two proportions equals a hypothesized value; let’s choose zero, $H_0: \\bar{p}_1 - \\bar{p}_2 = 0$. We perform this test by computing a test statistic and $p$-value as shown below, then comparing the $p$-value to our chosen $\\alpha$. | 1 2 3 4 5 6 7 . | import numpy as np p_bar = (90 + 50) / (150 + 135) # overall proportion std_error = np.sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic = (p_bar1 - p_bar2)/std_error # test statistic from scipy import stats 2*stats.norm.sf(abs(test_statistic)) # two-tailed p-value . | . | 1 . | 0.00010802693662804402 . | . Our $p$-value, 0.000108, is smaller than $\\alpha$, so we can reject the null hypothesis and conclude that the difference between the two proportions is different from zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let’s repeat the above test, comparing the difference to $0.15$ instead, as an example. | 1 2 3 4 5 6 7 8 . | import numpy as np hyp_diff = 0.15 # hypothesized difference std_error = np.sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic = ((p_bar1 - p_bar2) - hyp_diff)/std_error # test statistic from scipy import stats 2*stats.norm.sf(abs(test_statistic)) # two-tailed p-value . | . | 1 . | 0.16744531573658772 . | . Our $p$-value, 0.1674, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly different from 0.15. Right-tailed test . In a right-tailed test, the null hypothesis states that the difference between the two proportions is less than or equal to a hypothesized value. Let’s begin by using zero as our hypothesized value, $H_0: \\bar{p}_1 - \\bar{p}_2 \\le 0$. We repeat some code below that we’ve seen above, just to make it easy to copy and paste the example elsewhere. | 1 2 3 4 5 6 7 . | import numpy as np p_bar = (90 + 50) / (150 + 135) # overall proportion std_error = np.sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic = (p_bar1 - p_bar2)/std_error # test statistic from scipy import stats stats.norm.sf(abs(test_statistic)) # right-tailed p-value . | . | 1 . | 5.401346831402201e-05 . | . Our $p$-value is smaller than $\\alpha$, so we can reject the null hypothesis and conclude that the difference between the two proportions is significantly greater than zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let’s repeat the above test, comparing the difference to $0.15$ instead, as an example. | 1 2 3 4 5 6 7 8 . | import numpy as np hyp_diff = 0.15 # hypothesized difference std_error = np.sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic = ((p_bar1 - p_bar2) - hyp_diff)/std_error # test statistic from scipy import stats stats.norm.sf(abs(test_statistic)) # right-tailed p-value . | . | 1 . | 0.08372265786829386 . | . Our $p$-value, 0.0837, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly greater than 0.15. Left-tailed test . In a left-tailed test, the null hypothesis states that the difference between the two proportions is greater than or equal to a hypothesized value. Let’s begin by using zero as our hypothesized value, $H_0: \\bar{p}_1 - \\bar{p}_2 \\ge 0$. We repeat some code below that we’ve seen above, just to make it easy to copy and paste the example elsewhere. | 1 2 3 4 5 6 7 . | import numpy as np p_bar = (90 + 50) / (150 + 135) # overall proportion std_error = np.sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic = (p_bar1 - p_bar2)/std_error # test statistic from scipy import stats stats.norm.sf(-test_statistic) # left-tailed p-value . | . | 1 . | 0.999945986531686 . | . Our $p$-value, 0.9999, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between the two proportions is significantly less than zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let’s repeat the above test, comparing the difference to $0.15$ instead, as an example. | 1 2 3 4 5 6 7 8 . | import numpy as np hyp_diff = 0.15 # hypothesized difference std_error = np.sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic = ((p_bar1 - p_bar2) - hyp_diff)/std_error # test statistic from scipy import stats stats.norm.sf(-test_statistic) # left-tailed p-value . | . | 1 . | 0.9162773421317061 . | . Our $p$-value, 0.91627, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly less than 0.15. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#using-scipy-in-python"
  },"469": {
    "doc": "How to do a hypothesis test for the difference between two proportions",
    "title": "Solution, in R",
    "content": "View this solution alone. We will use some fake data in this example, but you can replace it with your real data. Imagine we conduct a survey of people in Boston and of people in Nashville and ask them if they prefer chocolate or vanilla ice cream. We get data like the following. | City | Prefer chocolate | Prefer vanilla | Total | . | Boston | 60 | 90 | 150 | . | Nashville | 85 | 50 | 135 | . We want to compare the proportions of people from the two cities who like vanilla. Let $\\bar{p}_1$ represent the proportion of people from Boston who like vanilla and $\\bar{p}_2$ represent the proportion of people from Nashville who like vanilla. | 1 2 3 4 . | n1 &lt;- 150 n2 &lt;- 135 p_bar1 &lt;- 90/150 p_bar2 &lt;- 50/135 . | . We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. For this example, we will use $\\alpha=0.05$. Two-tailed test . In a two-tailed test, the null hypothesis states that the difference between the two proportions equals a hypothesized value; let’s choose zero, $H_0: \\bar{p}_1 - \\bar{p}_2 = 0$. We perform this test by computing a test statistic and $p$-value as shown below, then comparing the $p$-value to our chosen $\\alpha$. | 1 2 3 4 . | p_bar &lt;- (90 + 50) / (150 + 135) # overall proportion std_error &lt;- sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic &lt;- (p_bar1 - p_bar2)/std_error # test statistic 2*pnorm(q = test_statistic, lower.tail = FALSE) # two-tailed p-value . | . | 1 . | [1] 0.0001080269 . | . Our $p$-value, 0.000108, is smaller than $\\alpha$, so we can reject the null hypothesis and conclude that the difference between the two proportions is different from zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let’s repeat the above test, comparing the difference to $0.15$ instead, as an example. | 1 2 3 4 5 . | hyp.diff = 0.15 # hypothesized difference std_error &lt;- sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic &lt;- ((p_bar1 - p_bar2) - hyp.diff)/std_error # test statistic 2*pnorm(q = test_statistic, lower.tail = FALSE) # two-tailed p-value . | . | 1 . | [1] 0.1674453 . | . Our $p$-value, 0.1674, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly different from 0.15. Right-tailed test . In a right-tailed test, the null hypothesis states that the difference between the two proportions is less than or equal to a hypothesized value. Let’s begin by using zero as our hypothesized value, $H_0: \\bar{p}_1 - \\bar{p}_2 \\le 0$. We repeat some code below that we’ve seen above, just to make it easy to copy and paste the example elsewhere. | 1 2 3 4 . | p_bar &lt;- (90 + 50) / (150 + 135) # overall proportion std_error &lt;- sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic &lt;- (p_bar1 - p_bar2)/std_error # test statistic pnorm(q = test_statistic, lower.tail = FALSE) # right-tailed p-value . | . | 1 . | [1] 5.401347e-05 . | . Our $p$-value is smaller than $\\alpha$, so we can reject the null hypothesis and conclude that the difference between the two proportions is significantly greater than zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let’s repeat the above test, comparing the difference to $0.15$ instead, as an example. | 1 2 3 4 5 . | hyp.diff = 0.15 # hypothesized difference std_error &lt;- sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic &lt;- ((p_bar1 - p_bar2) - hyp.diff)/std_error # test statistic pnorm(q = test_statistic, lower.tail = FALSE) # right-tailed p-value . | . | 1 . | [1] 0.08372266 . | . Our $p$-value, 0.0837, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly greater than 0.15. Left-tailed test . In a left-tailed test, the null hypothesis states that the difference between the two proportions is greater than or equal to a hypothesized value. Let’s begin by using zero as our hypothesized value, $H_0: \\bar{p}_1 - \\bar{p}_2 \\ge 0$. We repeat some code below that we’ve seen above, just to make it easy to copy and paste the example elsewhere. | 1 2 3 4 . | p_bar &lt;- (90 + 50) / (150 + 135) # overall proportion std_error &lt;- sqrt(p_bar*(1-p_bar)*(1/n1+1/n2)) # standard error test_statistic &lt;- (p_bar1 - p_bar2)/std_error # test statistic pnorm(q = test_statistic, lower.tail = TRUE) # left-tailed p-value . | . | 1 . | [1] 0.999946 . | . Our $p$-value, 0.9999, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between the two proportions is significantly less than zero. But we did not need to compare the difference to zero; we could have used any hypothesized difference for comparison. Let’s repeat the above test, comparing the difference to $0.15$ instead, as an example. | 1 2 3 4 5 . | hyp.diff = 0.15 # hypothesized difference std_error &lt;- sqrt(p_bar1*(1-p_bar1)/n1 + p_bar2*(1-p_bar2)/n2) # standard error test_statistic &lt;- ((p_bar1 - p_bar2) - hyp.diff)/std_error # test statistic pnorm(q = test_statistic, lower.tail = TRUE) # left-tailed p-value . | . | 1 . | [1] 0.9162773 . | . Our $p$-value, 0.91627, is greater than $\\alpha$, so we cannot reject the null hypothesis and cannot conclude that the difference between these two proportions is significantly less than 0.15. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#solution-in-r",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#solution-in-r"
  },"470": {
    "doc": "How to do a hypothesis test for the difference between two proportions",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#topics-that-include-this-task"
  },"471": {
    "doc": "How to do a hypothesis test for the difference between two proportions",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#opportunities",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions/#opportunities"
  },"472": {
    "doc": "How to do a hypothesis test for the mean with known standard deviation (in Python, using SciPy)",
    "title": "How to do a hypothesis test for the mean with known standard deviation (in Python, using SciPy)",
    "content": "# How to do a hypothesis test for the mean with known standard deviation (in Python, using SciPy) [See all solutions.](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) ## Task Let's say we are measuring a variable over a population, and we know its standard deviation $\\sigma$ is known, and assume that the variable is normally distributed. We take a sample, $x_1, x_2, x_3, \\ldots, x_k$, and compute its mean $\\bar{x}$. We want to determine if the sample mean is significantly different from, greater than, or less than some hypothesized value, such as a hypothesized population mean. How do we formulate an appropriate hypothesis test? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We will use the following fake data, but you can insert your actual data in its place. We have a sample of just 5 values and an assumed population standard deviation of 3. ```python sample = [31, 44, 28, 25, 40] # sample data pop_std = 3 # population standard deviation ``` We also choose a value $0 \\le \\alpha \\le 1$ as our Type I error rate. We'll let $\\alpha$ be 0.05 here, but you can change that in the code below. ### Two-tailed test In a two-tailed test, we compare the unknown population mean to a hypothesized value $m$ using the null hypothesis $H_0: \\mu=m$. Here we'll use $m=30$, but you can replace that value in the code below with the hypothesis relevant for your situation. ```python from scipy import stats import numpy as np m = 30 # hypothesized mean n = len(sample) # number of observations xbar = np.mean(sample) # sample mean test_stat = (xbar - m) / (pop_std/np.sqrt(n)) # test statistic 2*stats.norm.sf(abs(test_stat)) # two-tailed p-value ``` 0.007290358091535614 The $p$-value, 0.00729, is less than $\\alpha$, so we have evidence to reject the null hypothesis and conclude that the actual population mean $\\mu$ is significantly different from the hypothesized value of $m=30$. ### Right-tailed test In a right-tailed hypothesis test, the null hypothesis is that the population mean is greater than or equal to a chosen value, $H_0: \\mu \\ge m$. Most of the code below is the same as above, but we repeat it to make it easy to copy and paste. Only the computation of the $p$-value changes. ```python from scipy import stats import numpy as np m = 30 # hypothesized mean n = len(sample) # number of observations xbar = np.mean(sample) # sample mean test_stat = (xbar - m) / (pop_std/np.sqrt(n)) # test statistic stats.norm.sf(abs(test_stat)) # right-tailed p-value ``` 0.003645179045767807 The $p$-value, 0.003645, is less than $\\alpha$, so we have evidence to reject the null hypothesis and conclude that the actual population mean $\\mu$ is significantly less than the hypothesized value of $m=30$. ### Left-tailed test In a left-tailed hypothesis test, the null hypothesis is that the population mean is less than or equal to a chosen value, $H_0: \\mu \\le m$. Most of the code below is the same as above, but we repeat it to make it easy to copy and paste. Only the computation of the $p$-value changes. ```python from scipy import stats import numpy as np m = 30 # hypothesized mean n = len(sample) # number of observations xbar = np.mean(sample) # sample mean test_stat = (xbar - m) / (pop_std/np.sqrt(n)) # test statistic stats.norm.sf(-abs(test_stat)) # left-tailed p-value ``` 0.9963548209542322 The $p$-value, 0.99635, is greater than $\\alpha$, so wwe do not have sufficient evidence to conclude that $\\mu>m$ and should continue to accept the null hypothesis, that $\\mu\\le m$. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for the mean with known standard deviation/Python, using SciPy.ipynb). Contributed by: * Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation-in-python-using-scipy/"
  },"473": {
    "doc": "How to do a hypothesis test for the mean with known standard deviation (in R)",
    "title": "How to do a hypothesis test for the mean with known standard deviation (in R)",
    "content": "# How to do a hypothesis test for the mean with known standard deviation (in R) [See all solutions.](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) ## Task Let's say we are measuring a variable over a population, and we know its standard deviation $\\sigma$ is known, and assume that the variable is normally distributed. We take a sample, $x_1, x_2, x_3, \\ldots, x_k$, and compute its mean $\\bar{x}$. We want to determine if the sample mean is significantly different from, greater than, or less than some hypothesized value, such as a hypothesized population mean. How do we formulate an appropriate hypothesis test? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We will use the following fake data, but you can insert your actual data in its place. We have a sample of just 5 values and an assumed population standard deviation of 3. ```R sample m$ and should continue to accept the null hypothesis, that $\\mu\\le m$. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for the mean with known standard deviation/R.md). Contributed by: * Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation-in-r/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation-in-r/"
  },"474": {
    "doc": "How to do a hypothesis test for the mean with known standard deviation",
    "title": "How to do a hypothesis test for the mean with known standard deviation",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/"
  },"475": {
    "doc": "How to do a hypothesis test for the mean with known standard deviation",
    "title": "Description",
    "content": "Let’s say we are measuring a variable over a population, and we know its standard deviation $\\sigma$ is known, and assume that the variable is normally distributed. We take a sample, $x_1, x_2, x_3, \\ldots, x_k$, and compute its mean $\\bar{x}$. We want to determine if the sample mean is significantly different from, greater than, or less than some hypothesized value, such as a hypothesized population mean. How do we formulate an appropriate hypothesis test? . Related tasks: . | How to compute a confidence interval for a population mean | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | How to do a hypothesis test for population variance | How to do a hypothesis test for the difference between means when both population variances are known | How to do a hypothesis test for the difference between two proportions | How to do a hypothesis test for the ratio of two population variances | How to do a hypothesis test of a coefficient’s significance | How to do a one-sided hypothesis test for two sample means | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#description",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#description"
  },"476": {
    "doc": "How to do a hypothesis test for the mean with known standard deviation",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We will use the following fake data, but you can insert your actual data in its place. We have a sample of just 5 values and an assumed population standard deviation of 3. | 1 2 . | sample = [31, 44, 28, 25, 40] # sample data pop_std = 3 # population standard deviation . | . We also choose a value $0 \\le \\alpha \\le 1$ as our Type I error rate. We’ll let $\\alpha$ be 0.05 here, but you can change that in the code below. Two-tailed test . In a two-tailed test, we compare the unknown population mean to a hypothesized value $m$ using the null hypothesis $H_0: \\mu=m$. Here we’ll use $m=30$, but you can replace that value in the code below with the hypothesis relevant for your situation. | 1 2 3 4 5 6 7 . | from scipy import stats import numpy as np m = 30 # hypothesized mean n = len(sample) # number of observations xbar = np.mean(sample) # sample mean test_stat = (xbar - m) / (pop_std/np.sqrt(n)) # test statistic 2*stats.norm.sf(abs(test_stat)) # two-tailed p-value . | . | 1 . | 0.007290358091535614 . | . The $p$-value, 0.00729, is less than $\\alpha$, so we have evidence to reject the null hypothesis and conclude that the actual population mean $\\mu$ is significantly different from the hypothesized value of $m=30$. Right-tailed test . In a right-tailed hypothesis test, the null hypothesis is that the population mean is greater than or equal to a chosen value, $H_0: \\mu \\ge m$. Most of the code below is the same as above, but we repeat it to make it easy to copy and paste. Only the computation of the $p$-value changes. | 1 2 3 4 5 6 7 . | from scipy import stats import numpy as np m = 30 # hypothesized mean n = len(sample) # number of observations xbar = np.mean(sample) # sample mean test_stat = (xbar - m) / (pop_std/np.sqrt(n)) # test statistic stats.norm.sf(abs(test_stat)) # right-tailed p-value . | . | 1 . | 0.003645179045767807 . | . The $p$-value, 0.003645, is less than $\\alpha$, so we have evidence to reject the null hypothesis and conclude that the actual population mean $\\mu$ is significantly less than the hypothesized value of $m=30$. Left-tailed test . In a left-tailed hypothesis test, the null hypothesis is that the population mean is less than or equal to a chosen value, $H_0: \\mu \\le m$. Most of the code below is the same as above, but we repeat it to make it easy to copy and paste. Only the computation of the $p$-value changes. | 1 2 3 4 5 6 7 . | from scipy import stats import numpy as np m = 30 # hypothesized mean n = len(sample) # number of observations xbar = np.mean(sample) # sample mean test_stat = (xbar - m) / (pop_std/np.sqrt(n)) # test statistic stats.norm.sf(-abs(test_stat)) # left-tailed p-value . | . | 1 . | 0.9963548209542322 . | . The $p$-value, 0.99635, is greater than $\\alpha$, so wwe do not have sufficient evidence to conclude that $\\mu&gt;m$ and should continue to accept the null hypothesis, that $\\mu\\le m$. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#using-scipy-in-python"
  },"477": {
    "doc": "How to do a hypothesis test for the mean with known standard deviation",
    "title": "Solution, in R",
    "content": "View this solution alone. We will use the following fake data, but you can insert your actual data in its place. We have a sample of just 5 values and an assumed population standard deviation of 3. | 1 2 . | sample &lt;- c(31, 44, 28, 25, 40) # sample data pop.std &lt;- 3 # population standard deviation . | . We also choose a value $0 \\le \\alpha \\le 1$ as our Type I error rate. We’ll let $\\alpha$ be 0.05 here, but you can change that in the code below. Two-tailed test . In a two-tailed test, we compare the unknown population mean to a hypothesized value $m$ using the null hypothesis $H_0: \\mu=m$. Here we’ll use $m=30$, but you can replace that value in the code below with the hypothesis relevant for your situation. | 1 2 3 4 5 . | m &lt;- 30 # hypothesized mean n &lt;- length(sample) # number of observations xbar &lt;- mean(sample) # sample mean test.stat &lt;- (xbar - m) / (pop.std/sqrt(n)) # test statistic 2*pnorm(abs(test.stat), 0, 1, lower.tail=FALSE) # two-tailed p-value . | . | 1 . | [1] 0.007290358 . | . The $p$-value, 0.00729, is less than $\\alpha$, so we have evidence to reject the null hypothesis and conclude that the actual population mean $\\mu$ is significantly different from the hypothesized value of $m=30$. Right-tailed test . In a right-tailed hypothesis test, the null hypothesis is that the population mean is greater than or equal to a chosen value, $H_0: \\mu \\ge m$. Most of the code below is the same as above, but we repeat it to make it easy to copy and paste. Only the computation of the $p$-value changes. | 1 2 3 4 5 . | m &lt;- 30 # hypothesized mean n &lt;- length(sample) # number of observations xbar &lt;- mean(sample) # sample mean test.stat &lt;- (xbar - m) / (pop.std/sqrt(n)) # test statistic pnorm(test.stat, 0, 1, lower.tail=FALSE) # right-tailed p-value . | . | 1 . | [1] 0.003645179 . | . The $p$-value, 0.003645, is less than $\\alpha$, so we have evidence to reject the null hypothesis and conclude that the actual population mean $\\mu$ is significantly less than the hypothesized value of $m=30$. Left-tailed test . In a left-tailed hypothesis test, the null hypothesis is that the population mean is less than or equal to a chosen value, $H_0: \\mu \\le m$. Most of the code below is the same as above, but we repeat it to make it easy to copy and paste. Only the computation of the $p$-value changes. | 1 2 3 4 5 . | m &lt;- 30 # hypothesized mean n &lt;- length(sample) # number of observations xbar &lt;- mean(sample) # sample mean test.stat &lt;- (xbar - m) / (pop.std/sqrt(n)) # test statistic pnorm(test.stat, 0, 1, lower.tail=TRUE) # left-tailed p-value . | . | 1 . | [1] 0.9963548 . | . The $p$-value, 0.99635, is greater than $\\alpha$, so wwe do not have sufficient evidence to conclude that $\\mu&gt;m$ and should continue to accept the null hypothesis, that $\\mu\\le m$. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#solution-in-r",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#solution-in-r"
  },"478": {
    "doc": "How to do a hypothesis test for the mean with known standard deviation",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#topics-that-include-this-task"
  },"479": {
    "doc": "How to do a hypothesis test for the mean with known standard deviation",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#opportunities",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation/#opportunities"
  },"480": {
    "doc": "How to do a hypothesis test for the ratio of two population variances (in Python, using SciPy)",
    "title": "How to do a hypothesis test for the ratio of two population variances (in Python, using SciPy)",
    "content": "# How to do a hypothesis test for the ratio of two population variances (in Python, using SciPy) [See all solutions.](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) ## Task Let's say we want to compare the variability of two populations. We take two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ from population 1 and $x'_1, x'_2, x'_3, \\ldots, x'_k$ from population 2. What hypothesis tests can help us compare the population variances? Related tasks: * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We'll use R's dataset `EuStockMarkets` to do an example. This dataset has information on the daily closing prices of 4 European stock indices. We're going to compare the variability of Germany's DAX and France's CAC closing prices. Let's load the dataset. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) If using your own data, place it into the `sample1` and `sample2` variables instead of using the code below. ```python from rdatasets import data import pandas as pd # Load in the EuStockMarkets data and place it in a pandas DataFrame EuStockMarkets = data('EuStockMarkets') df = pd.DataFrame(EuStockMarkets[['DAX', 'CAC']]) # Choose the two columns we want to analyze # (You can replace the two lines below with your actual data.) sample1 = df['DAX'] sample2 = df['CAC'] ``` For all tests below, we will use $\\alpha=0.05$ as our Type I Error Rate, but any value between 0.0 and 1.0 can be used. ### Two-tailed test We can use a two-tailed test to test whether the two population variances are equal. Specifically, the null hypothesis will be: $$H_0: \\frac{\\sigma_1^2}{\\sigma_2^2} = 1$$ ```python from scipy import stats sample1_df = len(sample1) - 1 # degrees of freedom sample2_df = len(sample2) - 1 # degrees of freedom test_statistic = sample1.var() / sample2.var() # test statistic stats.f.sf(test_statistic, dfn = sample1_df, dfd = sample2_df)*2 # p-value ``` 7.729079251495416e-151 Our $p$-value is smaller than our chosen alpha, so we have sufficient evidence to reject the null hypothesis. The ratio of the variance of the closing prices on Germany's DAX and France's CAC is significantly different than 1, so the variances are not equal. ### Right-tailed test In a right-tailed test, the null hypothesis is that the ratio is less than or equal to 1. This is equivalent to asking if $\\sigma_1^2 \\le \\sigma_2^2$. $$H_0: \\frac{\\sigma_1^2}{\\sigma_2^2} \\le 1$$ We repeat below some of the code above to make each example easy to copy and paste. ```python from scipy import stats sample1_df = len(sample1) - 1 # degrees of freedom sample2_df = len(sample2) - 1 # degrees of freedom test_statistic = sample1.var() / sample2.var() # test statistic stats.f.sf(test_statistic, dfn = sample1_df, dfd = sample2_df) # p-value ``` 3.864539625747708e-151 Our $p$-value is smaller than our chosen alpha, so we have sufficient evidence to reject the null hypothesis. The ratio of the variance of the closing prices on Germany's DAX and France's CAC is significantly greater than 1, so the variance of closing prices on Germany's DAX is greater than that of closing prices on France's CAC. To test whether $\\sigma_1^2 \\ge \\sigma_2^2$, simply swap the roles of the two data columns in the above code. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for the ratio of two population variances/Python, using SciPy.ipynb). Contributed by: * Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances-in-python-using-scipy/"
  },"481": {
    "doc": "How to do a hypothesis test for the ratio of two population variances (in R)",
    "title": "How to do a hypothesis test for the ratio of two population variances (in R)",
    "content": "# How to do a hypothesis test for the ratio of two population variances (in R) [See all solutions.](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) ## Task Let's say we want to compare the variability of two populations. We take two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ from population 1 and $x'_1, x'_2, x'_3, \\ldots, x'_k$ from population 2. What hypothesis tests can help us compare the population variances? Related tasks: * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test of a coefficient's significance](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We'll use R's dataset `EuStockMarkets` to do an example. This dataset has information on the daily closing prices of 4 European stock indices. We're going to compare the variability of Germany's DAX and France's CAC closing prices. Let's load the dataset. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) If using your own data, place it into the `sample1` and `sample2` variables instead of using the code below. ```R # install.packages(\"datasets\") # If you have not already done so library(datasets) # Load the dataset and convert it to a data frame, then extract two columns EuStockMarkets <- data.frame(EuStockMarkets) sample.1 <- EuStockMarkets$DAX sample.2 <- EuStockMarkets$CAC ``` # Two-tailed test For all tests below, we will use $\\alpha=0.05$ as our Type I Error Rate, but any value between 0.0 and 1.0 can be used. ### Two-tailed test We can use a two-tailed test to test whether the two population variances are equal. Specifically, the null hypothesis will be: $$H_0: \\frac{\\sigma_1^2}{\\sigma_2^2} = 1$$ ```R sample.1.df <- length(sample.1) - 1 # degrees of freedom sample.2.df <- length(sample.2) - 1 # degrees of freedom test.statistic <- var(sample.1)/var(sample.2) # test statistic 2*pf(test.statistic, df1=sample.1.df, df2=sample.2.df, lower.tail=FALSE) # p-value ``` [1] 7.729079e-151 Our $p$-value is smaller than our chosen alpha, so we have sufficient evidence to reject the null hypothesis. The ratio of the variance of the closing prices on Germany's DAX and France's CAC is significantly different than 1, so the variances are not equal. ### Right-tailed test In a right-tailed test, the null hypothesis is that the ratio is less than or equal to 1. This is equivalent to asking if $\\sigma_1^2 \\le \\sigma_2^2$. $$H_0: \\frac{\\sigma_1^2}{\\sigma_2^2} \\le 1$$ We repeat below some of the code above to make each example easy to copy and paste. ```R sample.1.df <- length(sample.1) - 1 # degrees of freedom sample.2.df <- length(sample.2) - 1 # degrees of freedom test.statistic <- var(sample.1)/var(sample.2) # test statistic pf(test.statistic, df1=sample.1.df, df2=sample.2.df, lower.tail=FALSE) # p-value ``` [1] 3.86454e-151 Our $p$-value is smaller than our chosen alpha, so we have sufficient evidence to reject the null hypothesis. The ratio of the variance of the closing prices on Germany's DAX and France's CAC is significantly greater than 1, so the variance of closing prices on Germany's DAX is greater than that of closing prices on France's CAC. To test whether $\\sigma_1^2 \\ge \\sigma_2^2$, simply swap the roles of the two data columns in the above code. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test for the ratio of two population variances/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances-in-r/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances-in-r/"
  },"482": {
    "doc": "How to do a hypothesis test for the ratio of two population variances",
    "title": "How to do a hypothesis test for the ratio of two population variances",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/"
  },"483": {
    "doc": "How to do a hypothesis test for the ratio of two population variances",
    "title": "Description",
    "content": "Let’s say we want to compare the variability of two populations. We take two samples of data, $x_1, x_2, x_3, \\ldots, x_k$ from population 1 and $x’_1, x’_2, x’_3, \\ldots, x’_k$ from population 2. What hypothesis tests can help us compare the population variances? . Related tasks: . | How to compute a confidence interval for the difference between two proportions | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | How to do a hypothesis test for population variance | How to do a hypothesis test for the difference between means when both population variances are known | How to do a hypothesis test for the difference between two proportions | How to do a hypothesis test for the mean with known standard deviation | How to do a hypothesis test of a coefficient’s significance | How to do a one-sided hypothesis test for two sample means | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#description",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#description"
  },"484": {
    "doc": "How to do a hypothesis test for the ratio of two population variances",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’ll use R’s dataset EuStockMarkets to do an example. This dataset has information on the daily closing prices of 4 European stock indices. We’re going to compare the variability of Germany’s DAX and France’s CAC closing prices. Let’s load the dataset. (See how to quickly load some sample data.) If using your own data, place it into the sample1 and sample2 variables instead of using the code below. | 1 2 3 4 5 6 7 8 9 10 11 . | from rdatasets import data import pandas as pd # Load in the EuStockMarkets data and place it in a pandas DataFrame EuStockMarkets = data('EuStockMarkets') df = pd.DataFrame(EuStockMarkets[['DAX', 'CAC']]) # Choose the two columns we want to analyze # (You can replace the two lines below with your actual data.) sample1 = df['DAX'] sample2 = df['CAC'] . | . For all tests below, we will use $\\alpha=0.05$ as our Type I Error Rate, but any value between 0.0 and 1.0 can be used. Two-tailed test . We can use a two-tailed test to test whether the two population variances are equal. Specifically, the null hypothesis will be: . \\[H_0: \\frac{\\sigma_1^2}{\\sigma_2^2} = 1\\] | 1 2 3 4 5 . | from scipy import stats sample1_df = len(sample1) - 1 # degrees of freedom sample2_df = len(sample2) - 1 # degrees of freedom test_statistic = sample1.var() / sample2.var() # test statistic stats.f.sf(test_statistic, dfn = sample1_df, dfd = sample2_df)*2 # p-value . | . | 1 . | 7.729079251495416e-151 . | . Our $p$-value is smaller than our chosen alpha, so we have sufficient evidence to reject the null hypothesis. The ratio of the variance of the closing prices on Germany’s DAX and France’s CAC is significantly different than 1, so the variances are not equal. Right-tailed test . In a right-tailed test, the null hypothesis is that the ratio is less than or equal to 1. This is equivalent to asking if $\\sigma_1^2 \\le \\sigma_2^2$. \\[H_0: \\frac{\\sigma_1^2}{\\sigma_2^2} \\le 1\\] We repeat below some of the code above to make each example easy to copy and paste. | 1 2 3 4 5 . | from scipy import stats sample1_df = len(sample1) - 1 # degrees of freedom sample2_df = len(sample2) - 1 # degrees of freedom test_statistic = sample1.var() / sample2.var() # test statistic stats.f.sf(test_statistic, dfn = sample1_df, dfd = sample2_df) # p-value . | . | 1 . | 3.864539625747708e-151 . | . Our $p$-value is smaller than our chosen alpha, so we have sufficient evidence to reject the null hypothesis. The ratio of the variance of the closing prices on Germany’s DAX and France’s CAC is significantly greater than 1, so the variance of closing prices on Germany’s DAX is greater than that of closing prices on France’s CAC. To test whether $\\sigma_1^2 \\ge \\sigma_2^2$, simply swap the roles of the two data columns in the above code. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#using-scipy-in-python"
  },"485": {
    "doc": "How to do a hypothesis test for the ratio of two population variances",
    "title": "Solution, in R",
    "content": "View this solution alone. We’ll use R’s dataset EuStockMarkets to do an example. This dataset has information on the daily closing prices of 4 European stock indices. We’re going to compare the variability of Germany’s DAX and France’s CAC closing prices. Let’s load the dataset. (See how to quickly load some sample data.) If using your own data, place it into the sample1 and sample2 variables instead of using the code below. | 1 2 3 4 5 6 7 . | # install.packages(\"datasets\") # If you have not already done so library(datasets) # Load the dataset and convert it to a data frame, then extract two columns EuStockMarkets &lt;- data.frame(EuStockMarkets) sample.1 &lt;- EuStockMarkets$DAX sample.2 &lt;- EuStockMarkets$CAC . | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#solution-in-r",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#solution-in-r"
  },"486": {
    "doc": "How to do a hypothesis test for the ratio of two population variances",
    "title": "Two-tailed test",
    "content": "For all tests below, we will use $\\alpha=0.05$ as our Type I Error Rate, but any value between 0.0 and 1.0 can be used. Two-tailed test . We can use a two-tailed test to test whether the two population variances are equal. Specifically, the null hypothesis will be: . \\[H_0: \\frac{\\sigma_1^2}{\\sigma_2^2} = 1\\] | 1 2 3 4 . | sample.1.df &lt;- length(sample.1) - 1 # degrees of freedom sample.2.df &lt;- length(sample.2) - 1 # degrees of freedom test.statistic &lt;- var(sample.1)/var(sample.2) # test statistic 2*pf(test.statistic, df1=sample.1.df, df2=sample.2.df, lower.tail=FALSE) # p-value . | . | 1 . | [1] 7.729079e-151 . | . Our $p$-value is smaller than our chosen alpha, so we have sufficient evidence to reject the null hypothesis. The ratio of the variance of the closing prices on Germany’s DAX and France’s CAC is significantly different than 1, so the variances are not equal. Right-tailed test . In a right-tailed test, the null hypothesis is that the ratio is less than or equal to 1. This is equivalent to asking if $\\sigma_1^2 \\le \\sigma_2^2$. \\[H_0: \\frac{\\sigma_1^2}{\\sigma_2^2} \\le 1\\] We repeat below some of the code above to make each example easy to copy and paste. | 1 2 3 4 . | sample.1.df &lt;- length(sample.1) - 1 # degrees of freedom sample.2.df &lt;- length(sample.2) - 1 # degrees of freedom test.statistic &lt;- var(sample.1)/var(sample.2) # test statistic pf(test.statistic, df1=sample.1.df, df2=sample.2.df, lower.tail=FALSE) # p-value . | . | 1 . | [1] 3.86454e-151 . | . Our $p$-value is smaller than our chosen alpha, so we have sufficient evidence to reject the null hypothesis. The ratio of the variance of the closing prices on Germany’s DAX and France’s CAC is significantly greater than 1, so the variance of closing prices on Germany’s DAX is greater than that of closing prices on France’s CAC. To test whether $\\sigma_1^2 \\ge \\sigma_2^2$, simply swap the roles of the two data columns in the above code. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#two-tailed-test-1",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#two-tailed-test-1"
  },"487": {
    "doc": "How to do a hypothesis test for the ratio of two population variances",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#topics-that-include-this-task"
  },"488": {
    "doc": "How to do a hypothesis test for the ratio of two population variances",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#opportunities",
    "relUrl": "/how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances/#opportunities"
  },"489": {
    "doc": "How to do a hypothesis test of a coefficient's significance (in R)",
    "title": "How to do a hypothesis test of a coefficient's significance (in R)",
    "content": "# How to do a hypothesis test of a coefficient's significance (in R) [See all solutions.](../how-to-do-a-hypothesis-test-of-a-coefficient-s-significance) ## Task Let's say we have a linear model, either one variable or many. How do we conduct a test of significance for the coefficient of a single explanatory variable in the model? Similarly, how can we determine if an explanatory variable has a significant impact on the response variable? Related tasks: * [How to compute a confidence interval for the difference between two proportions](../how-to-compute-a-confidence-interval-for-the-difference-between-two-proportions) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) * [How to do a hypothesis test for population variance](../how-to-do-a-hypothesis-test-for-population-variance) * [How to do a hypothesis test for the difference between means when both population variances are known](../how-to-do-a-hypothesis-test-for-the-difference-between-means-when-both-population-variances-are-known) * [How to do a hypothesis test for the difference between two proportions](../how-to-do-a-hypothesis-test-for-the-difference-between-two-proportions) * [How to do a hypothesis test for the mean with known standard deviation](../how-to-do-a-hypothesis-test-for-the-mean-with-known-standard-deviation) * [How to do a hypothesis test for the ratio of two population variances](../how-to-do-a-hypothesis-test-for-the-ratio-of-two-population-variances) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Solution We will use the fake data shown below with a single variable model. You can use a model created from your own actual data instead. ```R x |t|) (Intercept) 354.082248 76.732772 4.6144853 0.002441995 x -1.009013 1.472939 -0.6850334 0.515358250 The final column of output shows $p$-values for each $\\beta_i$. The $p$-value associated with the $x$ row is therefore for $\\beta_1$, the coefficient on $x$. Because it is 0.515358250, which is greater than $\\alpha$, we cannot reject the null hypothesis, and we should continue to assume that $\\beta_1=0$ and there is no significant relationship between the explanatory and response variable in this situation. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a hypothesis test of a coefficient's significance/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance-in-r/",
    "relUrl": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance-in-r/"
  },"490": {
    "doc": "How to do a hypothesis test of a coefficient's significance",
    "title": "How to do a hypothesis test of a coefficient’s significance",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#how-to-do-a-hypothesis-test-of-a-coefficients-significance",
    "relUrl": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#how-to-do-a-hypothesis-test-of-a-coefficients-significance"
  },"491": {
    "doc": "How to do a hypothesis test of a coefficient's significance",
    "title": "Description",
    "content": "Let’s say we have a linear model, either one variable or many. How do we conduct a test of significance for the coefficient of a single explanatory variable in the model? Similarly, how can we determine if an explanatory variable has a significant impact on the response variable? . Related tasks: . | How to compute a confidence interval for the difference between two proportions | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | How to do a hypothesis test for population variance | How to do a hypothesis test for the difference between means when both population variances are known | How to do a hypothesis test for the difference between two proportions | How to do a hypothesis test for the mean with known standard deviation | How to do a hypothesis test for the ratio of two population variances | How to do a one-sided hypothesis test for two sample means | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | . ",
    "url": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#description",
    "relUrl": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#description"
  },"492": {
    "doc": "How to do a hypothesis test of a coefficient's significance",
    "title": "Solution, in R",
    "content": "View this solution alone. We will use the fake data shown below with a single variable model. You can use a model created from your own actual data instead. | 1 2 3 . | x &lt;- c( 34, 9, 78, 60, 22, 45, 83, 59, 25) y &lt;- c(126, 347, 298, 309, 450, 187, 266, 385, 400) model &lt;- lm(y ~ x) . | . We can test whether a coefficient is zero by using that as our null hypothesis, $H_0: \\beta_i = 0$. We can use any value $0 \\le \\alpha \\le 1$ as our Type 1 error rate; we will set $\\alpha$ to be 0.05 here. The answer to our hypothesis test can be obtained by looking at just the coefficients portion of the model summary: . | 1 . | summary(model)$coef . | . | 1 2 3 . | Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 354.082248 76.732772 4.6144853 0.002441995 x -1.009013 1.472939 -0.6850334 0.515358250 . | . The final column of output shows $p$-values for each $\\beta_i$. The $p$-value associated with the $x$ row is therefore for $\\beta_1$, the coefficient on $x$. Because it is 0.515358250, which is greater than $\\alpha$, we cannot reject the null hypothesis, and we should continue to assume that $\\beta_1=0$ and there is no significant relationship between the explanatory and response variable in this situation. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#solution-in-r",
    "relUrl": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#solution-in-r"
  },"493": {
    "doc": "How to do a hypothesis test of a coefficient's significance",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#topics-that-include-this-task"
  },"494": {
    "doc": "How to do a hypothesis test of a coefficient's significance",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#opportunities",
    "relUrl": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/#opportunities"
  },"495": {
    "doc": "How to do a hypothesis test of a coefficient's significance",
    "title": "How to do a hypothesis test of a coefficient's significance",
    "content": " ",
    "url": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/",
    "relUrl": "/how-to-do-a-hypothesis-test-of-a-coefficient-s-significance/"
  },"496": {
    "doc": "How to do a Kruskal-Wallis test (in Python, using SciPy)",
    "title": "How to do a Kruskal-Wallis test (in Python, using SciPy)",
    "content": "# How to do a Kruskal-Wallis test (in Python, using SciPy) [See all solutions.](../how-to-do-a-kruskal-wallis-test) ## Task If we have samples from several independent populations, we might want to test whether the population medians are equal. We may not be able to assume anything about the populations' variances, nor whether they are normally distributed, but we do assume that the populations have distributions that are approximately the same shape. The Kruskal-Wallis Test will allow us to test the medians for equality. It is similar to a One-Way ANOVA but using medians instead of means. How do we perform a Kruskal-Wallis Test? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to use Bonferroni's Correction method](../how-to-use-bonferroni-s-correction-method) * [How to do a Wilcoxon rank-sum test](../how-to-do-a-wilcoxon-rank-sum-test) ## Solution For the purposes of this example, let's say we have a sample of GPAs from matriculated students at three Ivy League institutions: Harvard, Dartmouth, and Columbia. This is example data, and you can replace it with your actual data when you re-use this code. SciPy requires our data to be in NumPy arrays, as shown below. Note that pandas Series (e.g., columns in a DataFrame) are also NumPy arrays. ```python import numpy as np # Replace the fake data below with your real data harvard = np.array([3.40, 3.66, 3.90, 3.55, 3.90, 3.58]) dartmouth = np.array([3.90, 3.97, 3.92, 3.83, 4.00, 3.68]) columbia = np.array([4.00, 3.75, 3.34]) ``` The Kruskal-Willis Test uses a null hypothesis that the category medians are equal, $H_0: m_C = m_H = m_D \\le 0$. We choose $\\alpha$, or the Type I error rate, as 0.05 and run the test as shown below. ```python from scipy import stats stats.kruskal(harvard, dartmouth, columbia) ``` KruskalResult(statistic=3.706006006006005, pvalue=0.15676569090635095) The p-value, 0.1568, is greater than $\\alpha$, so we fail to reject the null hypothesis. We do not have sufficient evidence to conclude that the median GPAs of matriculated students at these three schools are different from each other. Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Kruskal-Wallis test/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-kruskal-wallis-test-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-kruskal-wallis-test-in-python-using-scipy/"
  },"497": {
    "doc": "How to do a Kruskal-Wallis test (in R)",
    "title": "How to do a Kruskal-Wallis test (in R)",
    "content": "# How to do a Kruskal-Wallis test (in R) [See all solutions.](../how-to-do-a-kruskal-wallis-test) ## Task If we have samples from several independent populations, we might want to test whether the population medians are equal. We may not be able to assume anything about the populations' variances, nor whether they are normally distributed, but we do assume that the populations have distributions that are approximately the same shape. The Kruskal-Wallis Test will allow us to test the medians for equality. It is similar to a One-Way ANOVA but using medians instead of means. How do we perform a Kruskal-Wallis Test? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to use Bonferroni's Correction method](../how-to-use-bonferroni-s-correction-method) * [How to do a Wilcoxon rank-sum test](../how-to-do-a-wilcoxon-rank-sum-test) ## Solution For the purposes of this example, let's say we have a sample of GPAs from matriculated students at three Ivy League institutions: Harvard, Dartmouth, and Columbia. This is example data, and you can replace it with your actual data when you re-use this code. R requires that our categories and our numeric sample values be in separate vectors. We could structure our data as follows. ```R gpas <- c( 3.40, 3.66, 3.90, 3.55, 3.90, 3.58, 3.90, 3.97, 3.92, 3.83, 4.00, 3.68, 4.00, 3.75, 3.34 ) schools <- c( \"Harvard\", \"Harvard\", \"Harvard\", \"Harvard\", \"Harvard\", \"Harvard\", \"Dartmouth\", \"Dartmouth\", \"Dartmouth\", \"Dartmouth\", \"Dartmouth\", \"Dartmouth\", \"Columbia\", \"Columbia\", \"Columbia\" ) ``` The Kruskal-Willis Test uses a null hypothesis that the category medians are equal, $H_0: m_C = m_H = m_D \\le 0$. We choose $\\alpha$, or the Type I error rate, as 0.05 and run the test as shown below. ```R kruskal.test(gpas, schools) ``` Kruskal-Wallis rank sum test data: gpas and schools Kruskal-Wallis chi-squared = 3.706, df = 2, p-value = 0.1568 The p-value, 0.1568, is greater than $\\alpha$, so we fail to reject the null hypothesis. We do not have sufficient evidence to conclude that the median GPAs of matriculated students at these three schools are different from each other. Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Kruskal-Wallis test/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-kruskal-wallis-test-in-r/",
    "relUrl": "/how-to-do-a-kruskal-wallis-test-in-r/"
  },"498": {
    "doc": "How to do a Kruskal-Wallis test",
    "title": "How to do a Kruskal-Wallis test",
    "content": " ",
    "url": "/how-to-do-a-kruskal-wallis-test/",
    "relUrl": "/how-to-do-a-kruskal-wallis-test/"
  },"499": {
    "doc": "How to do a Kruskal-Wallis test",
    "title": "Description",
    "content": "If we have samples from several independent populations, we might want to test whether the population medians are equal. We may not be able to assume anything about the populations’ variances, nor whether they are normally distributed, but we do assume that the populations have distributions that are approximately the same shape. The Kruskal-Wallis Test will allow us to test the medians for equality. It is similar to a One-Way ANOVA but using medians instead of means. How do we perform a Kruskal-Wallis Test? . Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to use Bonferroni’s Correction method | How to do a Wilcoxon rank-sum test | . ",
    "url": "/how-to-do-a-kruskal-wallis-test/#description",
    "relUrl": "/how-to-do-a-kruskal-wallis-test/#description"
  },"500": {
    "doc": "How to do a Kruskal-Wallis test",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. For the purposes of this example, let’s say we have a sample of GPAs from matriculated students at three Ivy League institutions: Harvard, Dartmouth, and Columbia. This is example data, and you can replace it with your actual data when you re-use this code. SciPy requires our data to be in NumPy arrays, as shown below. Note that pandas Series (e.g., columns in a DataFrame) are also NumPy arrays. | 1 2 3 4 5 . | import numpy as np # Replace the fake data below with your real data harvard = np.array([3.40, 3.66, 3.90, 3.55, 3.90, 3.58]) dartmouth = np.array([3.90, 3.97, 3.92, 3.83, 4.00, 3.68]) columbia = np.array([4.00, 3.75, 3.34]) . | . The Kruskal-Willis Test uses a null hypothesis that the category medians are equal, $H_0: m_C = m_H = m_D \\le 0$. We choose $\\alpha$, or the Type I error rate, as 0.05 and run the test as shown below. | 1 2 . | from scipy import stats stats.kruskal(harvard, dartmouth, columbia) . | . | 1 . | KruskalResult(statistic=3.706006006006005, pvalue=0.15676569090635095) . | . The p-value, 0.1568, is greater than $\\alpha$, so we fail to reject the null hypothesis. We do not have sufficient evidence to conclude that the median GPAs of matriculated students at these three schools are different from each other. Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-kruskal-wallis-test/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-kruskal-wallis-test/#using-scipy-in-python"
  },"501": {
    "doc": "How to do a Kruskal-Wallis test",
    "title": "Solution, in R",
    "content": "View this solution alone. For the purposes of this example, let’s say we have a sample of GPAs from matriculated students at three Ivy League institutions: Harvard, Dartmouth, and Columbia. This is example data, and you can replace it with your actual data when you re-use this code. R requires that our categories and our numeric sample values be in separate vectors. We could structure our data as follows. | 1 2 3 4 5 6 7 . | gpas &lt;- c( 3.40, 3.66, 3.90, 3.55, 3.90, 3.58, 3.90, 3.97, 3.92, 3.83, 4.00, 3.68, 4.00, 3.75, 3.34 ) schools &lt;- c( \"Harvard\", \"Harvard\", \"Harvard\", \"Harvard\", \"Harvard\", \"Harvard\", \"Dartmouth\", \"Dartmouth\", \"Dartmouth\", \"Dartmouth\", \"Dartmouth\", \"Dartmouth\", \"Columbia\", \"Columbia\", \"Columbia\" ) . | . The Kruskal-Willis Test uses a null hypothesis that the category medians are equal, $H_0: m_C = m_H = m_D \\le 0$. We choose $\\alpha$, or the Type I error rate, as 0.05 and run the test as shown below. | 1 . | kruskal.test(gpas, schools) . | . | 1 2 3 4 . | Kruskal-Wallis rank sum test data: gpas and schools Kruskal-Wallis chi-squared = 3.706, df = 2, p-value = 0.1568 . | . The p-value, 0.1568, is greater than $\\alpha$, so we fail to reject the null hypothesis. We do not have sufficient evidence to conclude that the median GPAs of matriculated students at these three schools are different from each other. Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-kruskal-wallis-test/#solution-in-r",
    "relUrl": "/how-to-do-a-kruskal-wallis-test/#solution-in-r"
  },"502": {
    "doc": "How to do a Kruskal-Wallis test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-kruskal-wallis-test/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-kruskal-wallis-test/#topics-that-include-this-task"
  },"503": {
    "doc": "How to do a Kruskal-Wallis test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-kruskal-wallis-test/#opportunities",
    "relUrl": "/how-to-do-a-kruskal-wallis-test/#opportunities"
  },"504": {
    "doc": "How to do a one-sided hypothesis test for two sample means (in Python, using SciPy)",
    "title": "How to do a one-sided hypothesis test for two sample means (in Python, using SciPy)",
    "content": "# How to do a one-sided hypothesis test for two sample means (in Python, using SciPy) [See all solutions.](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) ## Task If we have two samples, $x_1, \\ldots , x_n$ and $x'_1, \\ldots , x'_n$, and we compute the mean of each one, we might want to ask whether one mean is less than the other. Or more precisely, is their difference significantly less than zero? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Solution If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a two-sided test with the null hypothesis $H_0: \\bar x_1 - \\bar x_2 \\ge 0$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). Let's use $\\alpha=0.10$ as an example. ```python from scipy import stats # Replace these first three lines with the values from your situation. sample1 = [ 6, 9, 7, 10, 10, 9 ] sample2 = [ 12, 14, 10, 17, 9 ] # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. stats.ttest_ind( sample1, sample2, equal_var=False, alternative=\"less\" ) ``` Ttest_indResult(statistic=-2.4616581720814326, pvalue=0.025486418709238467) The output says that the $p$-value is about $0.0255$, which is less than $\\alpha=0.10$. Therefore the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. That is, the data suggest that $\\bar x_1 < \\bar x_2$. The `equal_var` parameter tells SciPy *not* to assume that the two samples have equal variances. If in your case they do, you can omit that parameter, and it will revert to its default value of `True`. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a one-sided hypothesis test for two sample means/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means-in-python-using-scipy/"
  },"505": {
    "doc": "How to do a one-sided hypothesis test for two sample means (in R)",
    "title": "How to do a one-sided hypothesis test for two sample means (in R)",
    "content": "# How to do a one-sided hypothesis test for two sample means (in R) [See all solutions.](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) ## Task If we have two samples, $x_1, \\ldots , x_n$ and $x'_1, \\ldots , x'_n$, and we compute the mean of each one, we might want to ask whether one mean is less than the other. Or more precisely, is their difference significantly less than zero? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Solution If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a left-tailed test with the null hypothesis $H_0: \\bar x_1 - \\bar x_2 \\ge 0$. We choose a value $0 \\le \\alpha \\le 1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). ```R # Replace these first three lines with the values from your situation. alpha <- 0.10 sample1 <- c( 6, 9, 7, 10, 10, 9 ) sample2 <- c( 12, 14, 10, 17, 9 ) # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. t.test( sample1, sample2, conf.level=1-alpha, alternative = \"less\" ) ``` Welch Two Sample t-test data: sample1 and sample2 t = -2.4617, df = 5.7201, p-value = 0.02549 alternative hypothesis: true difference in means is less than 0 90 percent confidence interval: -Inf -1.605229 sample estimates: mean of x mean of y 8.5 12.4 Although we can deduce the answer to our question from the above output, by comparing the $p$-value with $\\alpha$ manually, we can also ask R to do it. ```R # Is there enough evidence to reject the null hypothesis? result <- t.test( sample1, sample2, conf.level=1-alpha, alternative = \"less\" ) result$p.value < alpha ``` [1] TRUE In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. The data suggest that $\\bar x_1 < \\bar x_2$. Here we did not assume that the two samples had equal variance. If in your case they do, you can pass the parameter `var.equal=TRUE` to `t.test`. Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a one-sided hypothesis test for two sample means/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means-in-r/",
    "relUrl": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means-in-r/"
  },"506": {
    "doc": "How to do a one-sided hypothesis test for two sample means",
    "title": "How to do a one-sided hypothesis test for two sample means",
    "content": " ",
    "url": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/",
    "relUrl": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/"
  },"507": {
    "doc": "How to do a one-sided hypothesis test for two sample means",
    "title": "Description",
    "content": "If we have two samples, $x_1, \\ldots , x_n$ and $x’_1, \\ldots , x’_n$, and we compute the mean of each one, we might want to ask whether one mean is less than the other. Or more precisely, is their difference significantly less than zero? . Related tasks: . | How to compute a confidence interval for a population mean | How to do a two-sided hypothesis test for a sample mean | How to do a two-sided hypothesis test for two sample means | How to do a one-way analysis of variance (ANOVA) | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | . ",
    "url": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#description",
    "relUrl": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#description"
  },"508": {
    "doc": "How to do a one-sided hypothesis test for two sample means",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a two-sided test with the null hypothesis $H_0: \\bar x_1 - \\bar x_2 \\ge 0$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). Let’s use $\\alpha=0.10$ as an example. | 1 2 3 4 5 6 7 8 9 . | from scipy import stats # Replace these first three lines with the values from your situation. sample1 = [ 6, 9, 7, 10, 10, 9 ] sample2 = [ 12, 14, 10, 17, 9 ] # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. stats.ttest_ind( sample1, sample2, equal_var=False, alternative=\"less\" ) . | . | 1 . | Ttest_indResult(statistic=-2.4616581720814326, pvalue=0.025486418709238467) . | . The output says that the $p$-value is about $0.0255$, which is less than $\\alpha=0.10$. Therefore the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. That is, the data suggest that $\\bar x_1 &lt; \\bar x_2$. The equal_var parameter tells SciPy not to assume that the two samples have equal variances. If in your case they do, you can omit that parameter, and it will revert to its default value of True. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#using-scipy-in-python"
  },"509": {
    "doc": "How to do a one-sided hypothesis test for two sample means",
    "title": "Solution, in R",
    "content": "View this solution alone. If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a left-tailed test with the null hypothesis $H_0: \\bar x_1 - \\bar x_2 \\ge 0$. We choose a value $0 \\le \\alpha \\le 1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). | 1 2 3 4 5 6 7 8 . | # Replace these first three lines with the values from your situation. alpha &lt;- 0.10 sample1 &lt;- c( 6, 9, 7, 10, 10, 9 ) sample2 &lt;- c( 12, 14, 10, 17, 9 ) # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. t.test( sample1, sample2, conf.level=1-alpha, alternative = \"less\" ) . | . | 1 2 3 4 5 6 7 8 9 10 . | Welch Two Sample t-test data: sample1 and sample2 t = -2.4617, df = 5.7201, p-value = 0.02549 alternative hypothesis: true difference in means is less than 0 90 percent confidence interval: -Inf -1.605229 sample estimates: mean of x mean of y 8.5 12.4 . | . Although we can deduce the answer to our question from the above output, by comparing the $p$-value with $\\alpha$ manually, we can also ask R to do it. | 1 2 3 . | # Is there enough evidence to reject the null hypothesis? result &lt;- t.test( sample1, sample2, conf.level=1-alpha, alternative = \"less\" ) result$p.value &lt; alpha . | . | 1 . | [1] TRUE . | . In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. The data suggest that $\\bar x_1 &lt; \\bar x_2$. Here we did not assume that the two samples had equal variance. If in your case they do, you can pass the parameter var.equal=TRUE to t.test. Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#solution-in-r",
    "relUrl": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#solution-in-r"
  },"510": {
    "doc": "How to do a one-sided hypothesis test for two sample means",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#topics-that-include-this-task"
  },"511": {
    "doc": "How to do a one-sided hypothesis test for two sample means",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#opportunities",
    "relUrl": "/how-to-do-a-one-sided-hypothesis-test-for-two-sample-means/#opportunities"
  },"512": {
    "doc": "How to do a one-way analysis of variance (ANOVA) (in Julia)",
    "title": "How to do a one-way analysis of variance (ANOVA) (in Julia)",
    "content": "# How to do a one-way analysis of variance (ANOVA) (in Julia) [See all solutions.](../how-to-do-a-one-way-analysis-of-variance-anova) ## Task If we have multiple independent samples of the same quantity (such as students' SAT scores from several different schools), we may want to test whether the means of each of the samples are the same. Analysis of Variance (ANOVA) can determine whether any two of the sample means differ significantly. How can we do an ANOVA? Related tasks: * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) (which is just an ANOVA with only two samples) * [How to do a two-way ANOVA test with interaction](../how-to-do-a-two-way-anova-test-with-interaction) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) ## Solution Let's assume we have our samples in several different Julia arrays. Here I'll construct some made-up data about SAT scores at four different schools. ```julia school1_SATs = [ 1100, 1250, 1390, 970, 1510 ]; school2_SATs = [ 1010, 1050, 1090, 1110 ]; school3_SATs = [ 900, 1550, 1300, 1270, 1210 ]; school4_SATs = [ 900, 850, 1110, 1070, 910, 920 ]; ``` ANOVA tests the null hypothesis that all group means are equal. You choose $\\alpha$, the probability of Type I error (false positive, finding we should reject $H_0$ when it's actually true). I will use $\\alpha=0.05$ in this example. ```julia using HypothesisTests alpha = 0.05 p_value = pvalue( OneWayANOVATest( school1_SATs, school2_SATs, school3_SATs, school4_SATs ) ) reject_H0 = p_value < alpha alpha, p_value, reject_H0 ``` (0.05, 0.03405326535040251, true) The result we see above is to reject $H_0$, and therefore conclude that at least one pair of means is statistically significantly different. If you are using the most common $\\alpha$ value of $0.05$, you can save a few lines of code and get a more detailed printout by just printing out the test itself: ```julia OneWayANOVATest( school1_SATs, school2_SATs, school3_SATs, school4_SATs ) ``` One-way analysis of variance (ANOVA) test ----------------------------------------- Population details: parameter of interest: Means value under h_0: \"all equal\" point estimate: NaN Test summary: outcome with 95% confidence: reject h_0 p-value: 0.0341 Details: number of observations: [5, 4, 5, 6] F statistic: 3.69513 degrees of freedom: (3, 16) Content last modified on 05 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a one-way analysis of variance (ANOVA)/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova-in-julia/",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova-in-julia/"
  },"513": {
    "doc": "How to do a one-way analysis of variance (ANOVA) (in Python, using SciPy)",
    "title": "How to do a one-way analysis of variance (ANOVA) (in Python, using SciPy)",
    "content": "# How to do a one-way analysis of variance (ANOVA) (in Python, using SciPy) [See all solutions.](../how-to-do-a-one-way-analysis-of-variance-anova) ## Task If we have multiple independent samples of the same quantity (such as students' SAT scores from several different schools), we may want to test whether the means of each of the samples are the same. Analysis of Variance (ANOVA) can determine whether any two of the sample means differ significantly. How can we do an ANOVA? Related tasks: * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) (which is just an ANOVA with only two samples) * [How to do a two-way ANOVA test with interaction](../how-to-do-a-two-way-anova-test-with-interaction) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) ## Solution Let's assume we have our samples in several different Python lists. (Although anything like a list is also supported, including pandas Series.) Here I'll construct some made-up data about SAT scores at four different schools. ```python school1_SATs = [ 1100, 1250, 1390, 970, 1510 ] school2_SATs = [ 1010, 1050, 1090, 1110 ] school3_SATs = [ 900, 1550, 1300, 1270, 1210 ] school4_SATs = [ 900, 850, 1110, 1070, 910, 920 ] ``` ANOVA tests the null hypothesis that all group means are equal. You choose $\\alpha$, the probability of Type I error (false positive, finding we should reject $H_0$ when it's actually true). I will use $\\alpha=0.05$ in this example. ```python alpha = 0.05 # Run a one-way ANOVA and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. from scipy import stats F_statistic, p_value = stats.f_oneway( school1_SATs, school2_SATs, school3_SATs, school4_SATs ) reject_H0 = p_value < alpha alpha, p_value, reject_H0 ``` (0.05, 0.0342311478489849, True) The result we see above is to reject $H_0$, and therefore conclude that at least one pair of means is statistically significantly different. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a one-way analysis of variance (ANOVA)/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova-in-python-using-scipy/"
  },"514": {
    "doc": "How to do a one-way analysis of variance (ANOVA) (in R)",
    "title": "How to do a one-way analysis of variance (ANOVA) (in R)",
    "content": "# How to do a one-way analysis of variance (ANOVA) (in R) [See all solutions.](../how-to-do-a-one-way-analysis-of-variance-anova) ## Task If we have multiple independent samples of the same quantity (such as students' SAT scores from several different schools), we may want to test whether the means of each of the samples are the same. Analysis of Variance (ANOVA) can determine whether any two of the sample means differ significantly. How can we do an ANOVA? Related tasks: * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) (which is just an ANOVA with only two samples) * [How to do a two-way ANOVA test with interaction](../how-to-do-a-two-way-anova-test-with-interaction) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) ## Solution R expects you to have all the samples in one vector, and the groups they came from in a separate, categorical vector. So, for example, if we had SAT scores from four different schools (named A, B, C, and D), then our data might be arranged like this. ```R SAT.scores F) school.names 3 321715 107238 3.689 0.0342 * Residuals 16 465140 29071 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 The $p$-value reported in that output is $0.0433$. You could manually check whether $p<\\alpha$. Since it is, we would reject $H_0$, and therefore conclude that at least one pair of means is statistically significantly different. Or you could ask R to do the comparison for you, but getting the $p$-value from the ANOVA summary is fiddly: ```R alpha <- 0.05 p.value <- unname( unlist( summary( result ) ) )[9] p.value < alpha ``` [1] TRUE Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a one-way analysis of variance (ANOVA)/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova-in-r/",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova-in-r/"
  },"515": {
    "doc": "How to do a one-way analysis of variance (ANOVA)",
    "title": "How to do a one-way analysis of variance (ANOVA)",
    "content": " ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova/",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova/"
  },"516": {
    "doc": "How to do a one-way analysis of variance (ANOVA)",
    "title": "Description",
    "content": "If we have multiple independent samples of the same quantity (such as students’ SAT scores from several different schools), we may want to test whether the means of each of the samples are the same. Analysis of Variance (ANOVA) can determine whether any two of the sample means differ significantly. How can we do an ANOVA? . Related tasks: . | How to do a two-sided hypothesis test for two sample means (which is just an ANOVA with only two samples) | How to do a two-way ANOVA test with interaction | How to do a two-way ANOVA test without interaction | How to compare two nested linear models | How to conduct a mixed designs ANOVA | How to conduct a repeated measures ANOVA | How to perform an analysis of covariance (ANCOVA) | How to do a Kruskal-Wallis test | . ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova/#description",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova/#description"
  },"517": {
    "doc": "How to do a one-way analysis of variance (ANOVA)",
    "title": "Solution, in Julia",
    "content": "View this solution alone. Let’s assume we have our samples in several different Julia arrays. Here I’ll construct some made-up data about SAT scores at four different schools. | 1 2 3 4 . | school1_SATs = [ 1100, 1250, 1390, 970, 1510 ]; school2_SATs = [ 1010, 1050, 1090, 1110 ]; school3_SATs = [ 900, 1550, 1300, 1270, 1210 ]; school4_SATs = [ 900, 850, 1110, 1070, 910, 920 ]; . | . ANOVA tests the null hypothesis that all group means are equal. You choose $\\alpha$, the probability of Type I error (false positive, finding we should reject $H_0$ when it’s actually true). I will use $\\alpha=0.05$ in this example. | 1 2 3 4 5 . | using HypothesisTests alpha = 0.05 p_value = pvalue( OneWayANOVATest( school1_SATs, school2_SATs, school3_SATs, school4_SATs ) ) reject_H0 = p_value &lt; alpha alpha, p_value, reject_H0 . | . | 1 . | (0.05, 0.03405326535040251, true) . | . The result we see above is to reject $H_0$, and therefore conclude that at least one pair of means is statistically significantly different. If you are using the most common $\\alpha$ value of $0.05$, you can save a few lines of code and get a more detailed printout by just printing out the test itself: . | 1 . | OneWayANOVATest( school1_SATs, school2_SATs, school3_SATs, school4_SATs ) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | One-way analysis of variance (ANOVA) test ----------------------------------------- Population details: parameter of interest: Means value under h_0: \"all equal\" point estimate: NaN Test summary: outcome with 95% confidence: reject h_0 p-value: 0.0341 Details: number of observations: [5, 4, 5, 6] F statistic: 3.69513 degrees of freedom: (3, 16) . | . Content last modified on 05 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova/#solution-in-julia",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova/#solution-in-julia"
  },"518": {
    "doc": "How to do a one-way analysis of variance (ANOVA)",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. Let’s assume we have our samples in several different Python lists. (Although anything like a list is also supported, including pandas Series.) Here I’ll construct some made-up data about SAT scores at four different schools. | 1 2 3 4 . | school1_SATs = [ 1100, 1250, 1390, 970, 1510 ] school2_SATs = [ 1010, 1050, 1090, 1110 ] school3_SATs = [ 900, 1550, 1300, 1270, 1210 ] school4_SATs = [ 900, 850, 1110, 1070, 910, 920 ] . | . ANOVA tests the null hypothesis that all group means are equal. You choose $\\alpha$, the probability of Type I error (false positive, finding we should reject $H_0$ when it’s actually true). I will use $\\alpha=0.05$ in this example. | 1 2 3 4 5 6 7 8 9 . | alpha = 0.05 # Run a one-way ANOVA and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. from scipy import stats F_statistic, p_value = stats.f_oneway( school1_SATs, school2_SATs, school3_SATs, school4_SATs ) reject_H0 = p_value &lt; alpha alpha, p_value, reject_H0 . | . | 1 . | (0.05, 0.0342311478489849, True) . | . The result we see above is to reject $H_0$, and therefore conclude that at least one pair of means is statistically significantly different. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova/#using-scipy-in-python"
  },"519": {
    "doc": "How to do a one-way analysis of variance (ANOVA)",
    "title": "Solution, in R",
    "content": "View this solution alone. R expects you to have all the samples in one vector, and the groups they came from in a separate, categorical vector. So, for example, if we had SAT scores from four different schools (named A, B, C, and D), then our data might be arranged like this. | 1 2 3 4 5 6 7 8 . | SAT.scores &lt;- c( 1100, 1250, 1390, 970, 1510, 1010, 1050, 1090, 1110, 900, 1550, 1300, 1270, 1210, 900, 850, 1110, 1070, 910, 920 ) school.names &lt;- c( 'A', 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 'C', 'C', 'C', 'C', 'C', 'D', 'D', 'D', 'D', 'D', 'D' ) . | . ANOVA tests the null hypothesis that all group means are equal. You choose $\\alpha$, the probability of Type I error (false positive, finding we should reject $H_0$ when it’s actually true). I will use $\\alpha=0.05$ in this example. | 1 2 3 . | # Run a one-way ANOVA and print a summary of all the output result &lt;- aov( SAT.scores ~ school.names ) summary( result ) . | . | 1 2 3 4 5 . | Df Sum Sq Mean Sq F value Pr(&gt;F) school.names 3 321715 107238 3.689 0.0342 * Residuals 16 465140 29071 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . The $p$-value reported in that output is $0.0433$. You could manually check whether $p&lt;\\alpha$. Since it is, we would reject $H_0$, and therefore conclude that at least one pair of means is statistically significantly different. Or you could ask R to do the comparison for you, but getting the $p$-value from the ANOVA summary is fiddly: . | 1 2 3 . | alpha &lt;- 0.05 p.value &lt;- unname( unlist( summary( result ) ) )[9] p.value &lt; alpha . | . | 1 . | [1] TRUE . | . Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova/#solution-in-r",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova/#solution-in-r"
  },"520": {
    "doc": "How to do a one-way analysis of variance (ANOVA)",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR521 | Bentley University MA214 | . ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova/#topics-that-include-this-task"
  },"521": {
    "doc": "How to do a one-way analysis of variance (ANOVA)",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-one-way-analysis-of-variance-anova/#opportunities",
    "relUrl": "/how-to-do-a-one-way-analysis-of-variance-anova/#opportunities"
  },"522": {
    "doc": "How to do a Spearman rank correlation test (in Python, using SciPy)",
    "title": "How to do a Spearman rank correlation test (in Python, using SciPy)",
    "content": "# How to do a Spearman rank correlation test (in Python, using SciPy) [See all solutions.](../how-to-do-a-spearman-rank-correlation-test) ## Task When we want to determine whether there is a relationship between two variables, but our samples do not come from normally distributed populations, we can use the Spearman Rank Correlation Test. How do we conduct it? ## Solution We will use some fake data about height and weight measurements for people. You can replace it with your real data. Our data should be NumPy arrays, as in the example below. (Recall that pandas DataFrame columns are also NumPy arrays.) ```python import numpy as np heights = np.array([60, 76, 57, 68, 70, 62, 63]) weights = np.array([145, 178, 120, 143, 174, 130, 137]) ``` Let's say we want to test the correlation between height (inches) and weight (pounds). Our null hypothesis would state that the Pearson correlation coefficient is equal to zero, or that there is no relationship between height and weight, $H_0: \\rho_s = 0$. We choose $\\alpha$, or the Type I error rate, to be 0.05 and carry out the Spearman Rank Correlation Test to get the test-statistic and $p$-value. ```python from scipy import stats from scipy.stats import spearmanr spearmanr(heights, weights) ``` SpearmanrResult(correlation=0.7857142857142859, pvalue=0.03623846267982713) Our $p$-value is $0.03624$, which is less than $\\alpha=0.05$, so we reject the null hypothesis. There does appear to be a relationship between height and weight. (This $p$-value is different than the one computed in the solution using R, because different approximation methods are used by the two software packages when the sample size is small.) Note that for right- or left-tailed tests, the following syntax can be used. ~~~python spearmanr(heights, weights, alternative=\"greater\") # right-tailed spearmanr(heights, weights, alternative=\"less\") # left-talied ~~~ Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Spearman rank correlation test/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-spearman-rank-correlation-test-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-spearman-rank-correlation-test-in-python-using-scipy/"
  },"523": {
    "doc": "How to do a Spearman rank correlation test (in R)",
    "title": "How to do a Spearman rank correlation test (in R)",
    "content": "# How to do a Spearman rank correlation test (in R) [See all solutions.](../how-to-do-a-spearman-rank-correlation-test) ## Task When we want to determine whether there is a relationship between two variables, but our samples do not come from normally distributed populations, we can use the Spearman Rank Correlation Test. How do we conduct it? ## Solution We will use some fake data about height and weight measurements for people. You can replace it with your real data. Our data should be stored in R vectors, as shown below. ```R heights <- c(60, 76, 57, 68, 70, 62, 63) weights <- c(145, 178, 120, 143, 174, 130, 137) ``` Let's say we want to test the correlation between height (inches) and weight (pounds). Our null hypothesis would state that the Pearson correlation coefficient is equal to zero, or that there is no relationship between height and weight, $H_0: \\rho_s = 0$. We choose $\\alpha$, or the Type I error rate, to be 0.05 and carry out the Spearman Rank Correlation Test to get the test-statistic and $p$-value. ```R # Run the Spearman Rank Correlation Test to get the test-statistic and p-value cor.test(heights, weights, alternative = \"two.sided\", method = \"spearman\") ``` Spearman's rank correlation rho data: heights and weights S = 12, p-value = 0.04802 alternative hypothesis: true rho is not equal to 0 sample estimates: rho 0.7857143 Our $p$-value is $0.04802$, which is less than $\\alpha=0.05$, so we reject the null hypothesis. There does appear to be a relationship between height and weight. (This $p$-value is different than the one computed in the solution using Python, because different approximation methods are used by the two software packages when the sample size is small.) Note that for a right-tailed test, you can replace \"two.sided\" with \"greater\" and for a left-tailed test, you can replace \"two.sided\" with \"less\". Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Spearman rank correlation test/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-spearman-rank-correlation-test-in-r/",
    "relUrl": "/how-to-do-a-spearman-rank-correlation-test-in-r/"
  },"524": {
    "doc": "How to do a Spearman rank correlation test",
    "title": "How to do a Spearman rank correlation test",
    "content": " ",
    "url": "/how-to-do-a-spearman-rank-correlation-test/",
    "relUrl": "/how-to-do-a-spearman-rank-correlation-test/"
  },"525": {
    "doc": "How to do a Spearman rank correlation test",
    "title": "Description",
    "content": "When we want to determine whether there is a relationship between two variables, but our samples do not come from normally distributed populations, we can use the Spearman Rank Correlation Test. How do we conduct it? . ",
    "url": "/how-to-do-a-spearman-rank-correlation-test/#description",
    "relUrl": "/how-to-do-a-spearman-rank-correlation-test/#description"
  },"526": {
    "doc": "How to do a Spearman rank correlation test",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We will use some fake data about height and weight measurements for people. You can replace it with your real data. Our data should be NumPy arrays, as in the example below. (Recall that pandas DataFrame columns are also NumPy arrays.) . | 1 2 3 . | import numpy as np heights = np.array([60, 76, 57, 68, 70, 62, 63]) weights = np.array([145, 178, 120, 143, 174, 130, 137]) . | . Let’s say we want to test the correlation between height (inches) and weight (pounds). Our null hypothesis would state that the Pearson correlation coefficient is equal to zero, or that there is no relationship between height and weight, $H_0: \\rho_s = 0$. We choose $\\alpha$, or the Type I error rate, to be 0.05 and carry out the Spearman Rank Correlation Test to get the test-statistic and $p$-value. | 1 2 3 . | from scipy import stats from scipy.stats import spearmanr spearmanr(heights, weights) . | . | 1 . | SpearmanrResult(correlation=0.7857142857142859, pvalue=0.03623846267982713) . | . Our $p$-value is $0.03624$, which is less than $\\alpha=0.05$, so we reject the null hypothesis. There does appear to be a relationship between height and weight. (This $p$-value is different than the one computed in the solution using R, because different approximation methods are used by the two software packages when the sample size is small.) . Note that for right- or left-tailed tests, the following syntax can be used. | 1 2 . | spearmanr(heights, weights, alternative=\"greater\") # right-tailed spearmanr(heights, weights, alternative=\"less\") # left-talied . | . Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-spearman-rank-correlation-test/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-spearman-rank-correlation-test/#using-scipy-in-python"
  },"527": {
    "doc": "How to do a Spearman rank correlation test",
    "title": "Solution, in R",
    "content": "View this solution alone. We will use some fake data about height and weight measurements for people. You can replace it with your real data. Our data should be stored in R vectors, as shown below. | 1 2 . | heights &lt;- c(60, 76, 57, 68, 70, 62, 63) weights &lt;- c(145, 178, 120, 143, 174, 130, 137) . | . Let’s say we want to test the correlation between height (inches) and weight (pounds). Our null hypothesis would state that the Pearson correlation coefficient is equal to zero, or that there is no relationship between height and weight, $H_0: \\rho_s = 0$. We choose $\\alpha$, or the Type I error rate, to be 0.05 and carry out the Spearman Rank Correlation Test to get the test-statistic and $p$-value. | 1 2 . | # Run the Spearman Rank Correlation Test to get the test-statistic and p-value cor.test(heights, weights, alternative = \"two.sided\", method = \"spearman\") . | . | 1 2 3 4 5 6 7 8 . | Spearman's rank correlation rho data: heights and weights S = 12, p-value = 0.04802 alternative hypothesis: true rho is not equal to 0 sample estimates: rho 0.7857143 . | . Our $p$-value is $0.04802$, which is less than $\\alpha=0.05$, so we reject the null hypothesis. There does appear to be a relationship between height and weight. (This $p$-value is different than the one computed in the solution using Python, because different approximation methods are used by the two software packages when the sample size is small.) . Note that for a right-tailed test, you can replace “two.sided” with “greater” and for a left-tailed test, you can replace “two.sided” with “less”. Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-spearman-rank-correlation-test/#solution-in-r",
    "relUrl": "/how-to-do-a-spearman-rank-correlation-test/#solution-in-r"
  },"528": {
    "doc": "How to do a Spearman rank correlation test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-do-a-spearman-rank-correlation-test/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-spearman-rank-correlation-test/#topics-that-include-this-task"
  },"529": {
    "doc": "How to do a Spearman rank correlation test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-spearman-rank-correlation-test/#opportunities",
    "relUrl": "/how-to-do-a-spearman-rank-correlation-test/#opportunities"
  },"530": {
    "doc": "How to do a test of joint significance (in Python, using Statsmodels)",
    "title": "How to do a test of joint significance (in Python, using Statsmodels)",
    "content": "# How to do a test of joint significance (in Python, using Statsmodels) [See all solutions.](../how-to-do-a-test-of-joint-significance) ## Task If we have a multivariate linear model, how do we test the joint significance of all the variables in the model? In other words, how do we test the overall significance of the regression model? ## Solution Let's assume that you already made your multivariate linear model, similar to the one shown below. If you still need to create one, first see [how to fit a multiple linear regression model](../how-to-fit-a-multiple-linear-regression-model). We use example data here, but you would use your own data instead. ```python import pandas as pd import statsmodels.api as sm data = { 'x1' : [ 2, 7, 4, 3, 11, 18, 6, 15, 9, 12], 'x2' : [ 4, 6, 10, 1, 18, 11, 8, 20, 16, 13], 'x3' : [11, 16, 20, 6, 14, 8, 5, 23, 13, 10], 'y' : [24, 60, 32, 29, 90, 45, 130, 76, 100, 120] } ``` The following code fits the model to the data. ```python df = pd.DataFrame(data) xs = df[['x1', 'x2', 'x3']] y = df['y'] xs = sm.add_constant(xs) model = sm.OLS(y, xs).fit() ``` /opt/conda/lib/python3.9/site-packages/statsmodels/tsa/tsatools.py:142: FutureWarning: In a future version of pandas all arguments of concat except for the argument 'objs' will be keyword-only x = pd.concat(x[::order], 1) Now we want to test whether the model is significant. We will use a null hypothesis that states that all of the model's coefficients are equal to zero, that is, they are not jointly significant in predicting $y$. We can write $H_0: \\beta_0 = \\beta_1 = \\beta2 = \\beta_3 = 0$. We also choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. Herer we'll use $\\alpha=0.05$. The summary output for the model will give us both the F-statistic and the p-value. ```python model.summary() ``` /opt/conda/lib/python3.9/site-packages/scipy/stats/stats.py:1541: UserWarning: kurtosistest only valid for n>=20 ... continuing anyway, n=10 warnings.warn(\"kurtosistest only valid for n>=20 ... continuing \" OLS Regression Results | Dep. Variable: | y | R-squared: | 0.594 | . | Model: | OLS | Adj. R-squared: | 0.390 | . | Method: | Least Squares | F-statistic: | 2.921 | . | Date: | Tue, 05 Oct 2021 | Prob (F-statistic): | 0.122 | . | Time: | 20:20:04 | Log-Likelihood: | -45.689 | . | No. Observations: | 10 | AIC: | 99.38 | . | Df Residuals: | 6 | BIC: | 100.6 | . | Df Model: | 3 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P>|t| | [0.025 | 0.975] | . | const | 77.2443 | 27.366 | 2.823 | 0.030 | 10.282 | 144.206 | . | x1 | -2.7009 | 2.855 | -0.946 | 0.381 | -9.686 | 4.284 | . | x2 | 7.2989 | 2.875 | 2.539 | 0.044 | 0.265 | 14.333 | . | x3 | -4.8607 | 2.187 | -2.223 | 0.068 | -10.211 | 0.490 | . | Omnibus: | 2.691 | Durbin-Watson: | 2.123 | . | Prob(Omnibus): | 0.260 | Jarque-Bera (JB): | 1.251 | . | Skew: | 0.524 | Prob(JB): | 0.535 | . | Kurtosis: | 1.620 | Cond. No. | 58.2 | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified. Near the top right of the output, we can see that the F-statistic is 2.921. The corresponding $p$-value immediately below it is 0.1222, which is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We cannot conclude that the independent variables in our model are jointly significant in predicting the response variable. Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a test of joint significance/Python, using Statsmodels.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-test-of-joint-significance-in-python-using-statsmodels/",
    "relUrl": "/how-to-do-a-test-of-joint-significance-in-python-using-statsmodels/"
  },"531": {
    "doc": "How to do a test of joint significance (in R)",
    "title": "How to do a test of joint significance (in R)",
    "content": "# How to do a test of joint significance (in R) [See all solutions.](../how-to-do-a-test-of-joint-significance) ## Task If we have a multivariate linear model, how do we test the joint significance of all the variables in the model? In other words, how do we test the overall significance of the regression model? ## Solution Let's assume that you already made your multiple regression model, similar to the one shown below. You can visit this task, , to see how to construct a multivariate linear model. Let's assume that you already made your multivariate linear model, similar to the one shown below. If you still need to create one, first see [how to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model). We use example data here, but you would use your own data instead. ```R x1 |t|) (Intercept) 77.244 27.366 2.823 0.0302 * x1 -2.701 2.855 -0.946 0.3806 x2 7.299 2.875 2.539 0.0441 * x3 -4.861 2.187 -2.223 0.0679 . --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 30.13 on 6 degrees of freedom Multiple R-squared: 0.5936, Adjusted R-squared: 0.3904 F-statistic: 2.921 on 3 and 6 DF, p-value: 0.1222 In the final line of the output, we can see that the F-statistic is 2.921. The corresponding $p$-value in the same line is 0.1222, which is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We cannot conclude that the independent variables in our model are jointly significant in predicting the response variable. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a test of joint significance/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-test-of-joint-significance-in-r/",
    "relUrl": "/how-to-do-a-test-of-joint-significance-in-r/"
  },"532": {
    "doc": "How to do a test of joint significance",
    "title": "How to do a test of joint significance",
    "content": " ",
    "url": "/how-to-do-a-test-of-joint-significance/",
    "relUrl": "/how-to-do-a-test-of-joint-significance/"
  },"533": {
    "doc": "How to do a test of joint significance",
    "title": "Description",
    "content": "If we have a multivariate linear model, how do we test the joint significance of all the variables in the model? In other words, how do we test the overall significance of the regression model? . ",
    "url": "/how-to-do-a-test-of-joint-significance/#description",
    "relUrl": "/how-to-do-a-test-of-joint-significance/#description"
  },"534": {
    "doc": "How to do a test of joint significance",
    "title": "Using Statsmodels, in Python",
    "content": "View this solution alone. Let’s assume that you already made your multivariate linear model, similar to the one shown below. If you still need to create one, first see how to fit a multiple linear regression model. We use example data here, but you would use your own data instead. | 1 2 3 4 5 6 7 8 . | import pandas as pd import statsmodels.api as sm data = { 'x1' : [ 2, 7, 4, 3, 11, 18, 6, 15, 9, 12], 'x2' : [ 4, 6, 10, 1, 18, 11, 8, 20, 16, 13], 'x3' : [11, 16, 20, 6, 14, 8, 5, 23, 13, 10], 'y' : [24, 60, 32, 29, 90, 45, 130, 76, 100, 120] } . | . The following code fits the model to the data. | 1 2 3 4 5 . | df = pd.DataFrame(data) xs = df[['x1', 'x2', 'x3']] y = df['y'] xs = sm.add_constant(xs) model = sm.OLS(y, xs).fit() . | . | 1 2 . | /opt/conda/lib/python3.9/site-packages/statsmodels/tsa/tsatools.py:142: FutureWarning: In a future version of pandas all arguments of concat except for the argument 'objs' will be keyword-only x = pd.concat(x[::order], 1) . | . Now we want to test whether the model is significant. We will use a null hypothesis that states that all of the model’s coefficients are equal to zero, that is, they are not jointly significant in predicting $y$. We can write $H_0: \\beta_0 = \\beta_1 = \\beta2 = \\beta_3 = 0$. We also choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. Herer we’ll use $\\alpha=0.05$. The summary output for the model will give us both the F-statistic and the p-value. | 1 . | model.summary() . | . | 1 2 . | /opt/conda/lib/python3.9/site-packages/scipy/stats/stats.py:1541: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=10 warnings.warn(\"kurtosistest only valid for n&gt;=20 ... continuing \" . | . OLS Regression Results | Dep. Variable: | y | R-squared: | 0.594 | . | Model: | OLS | Adj. R-squared: | 0.390 | . | Method: | Least Squares | F-statistic: | 2.921 | . | Date: | Tue, 05 Oct 2021 | Prob (F-statistic): | 0.122 | . | Time: | 20:20:04 | Log-Likelihood: | -45.689 | . | No. Observations: | 10 | AIC: | 99.38 | . | Df Residuals: | 6 | BIC: | 100.6 | . | Df Model: | 3 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P&gt;|t| | [0.025 | 0.975] | . | const | 77.2443 | 27.366 | 2.823 | 0.030 | 10.282 | 144.206 | . | x1 | -2.7009 | 2.855 | -0.946 | 0.381 | -9.686 | 4.284 | . | x2 | 7.2989 | 2.875 | 2.539 | 0.044 | 0.265 | 14.333 | . | x3 | -4.8607 | 2.187 | -2.223 | 0.068 | -10.211 | 0.490 | . | Omnibus: | 2.691 | Durbin-Watson: | 2.123 | . | Prob(Omnibus): | 0.260 | Jarque-Bera (JB): | 1.251 | . | Skew: | 0.524 | Prob(JB): | 0.535 | . | Kurtosis: | 1.620 | Cond. No. | 58.2 | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified. Near the top right of the output, we can see that the F-statistic is 2.921. The corresponding $p$-value immediately below it is 0.1222, which is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We cannot conclude that the independent variables in our model are jointly significant in predicting the response variable. Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-test-of-joint-significance/#using-statsmodels-in-python",
    "relUrl": "/how-to-do-a-test-of-joint-significance/#using-statsmodels-in-python"
  },"535": {
    "doc": "How to do a test of joint significance",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s assume that you already made your multiple regression model, similar to the one shown below. You can visit this task, , to see how to construct a multivariate linear model. Let’s assume that you already made your multivariate linear model, similar to the one shown below. If you still need to create one, first see how to fit a multivariate linear model. We use example data here, but you would use your own data instead. | 1 2 3 4 5 . | x1 &lt;- c( 2, 7, 4, 3, 11, 18, 6, 15, 9, 12) x2 &lt;- c( 4, 6, 10, 1, 18, 11, 8, 20, 16, 13) x3 &lt;- c(11, 16, 20, 6, 14, 8, 5, 23, 13, 10) y &lt;- c(24, 60, 32, 29, 90, 45, 130, 76, 100, 120) model &lt;- lm(y ~ x1 + x2 + x3) . | . Now we want to test whether the model is significant. We will use a null hypothesis that states that all of the model’s coefficients are equal to zero, that is, they are not jointly significant in predicting $y$. We can write $H_0: \\beta_0 = \\beta_1 = \\beta2 = \\beta_3 = 0$. We also choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. Herer we’ll use $\\alpha=0.05$. The summary output for the model will give us both the F-statistic and the p-value. | 1 . | summary(model) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 . | Call: lm(formula = y ~ x1 + x2 + x3) Residuals: Min 1Q Median 3Q Max -25.031 -20.218 -8.373 22.937 35.640 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 77.244 27.366 2.823 0.0302 * x1 -2.701 2.855 -0.946 0.3806 x2 7.299 2.875 2.539 0.0441 * x3 -4.861 2.187 -2.223 0.0679 . --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 30.13 on 6 degrees of freedom Multiple R-squared: 0.5936, Adjusted R-squared: 0.3904 F-statistic: 2.921 on 3 and 6 DF, p-value: 0.1222 . | . In the final line of the output, we can see that the F-statistic is 2.921. The corresponding $p$-value in the same line is 0.1222, which is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We cannot conclude that the independent variables in our model are jointly significant in predicting the response variable. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-test-of-joint-significance/#solution-in-r",
    "relUrl": "/how-to-do-a-test-of-joint-significance/#solution-in-r"
  },"536": {
    "doc": "How to do a test of joint significance",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-do-a-test-of-joint-significance/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-test-of-joint-significance/#topics-that-include-this-task"
  },"537": {
    "doc": "How to do a test of joint significance",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-test-of-joint-significance/#opportunities",
    "relUrl": "/how-to-do-a-test-of-joint-significance/#opportunities"
  },"538": {
    "doc": "How to do a two-sided hypothesis test for a sample mean (in Julia)",
    "title": "How to do a two-sided hypothesis test for a sample mean (in Julia)",
    "content": "# How to do a two-sided hypothesis test for a sample mean (in Julia) [See all solutions.](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) ## Task Say we have a population whose mean $\\mu$ is known. We take a sample $x_1,\\ldots,x_n$ and compute its mean, $\\bar x$. We then ask whether this sample is significantly different from the population at large, that is, is $\\mu=\\bar x$? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Solution This is a two-sided test with the null hypothesis $H_0:\\mu=\\bar x$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). ```julia # Replace these first three lines with the values from your situation. alpha = 0.05 pop_mean = 10 sample = [ 9, 12, 14, 8, 13 ] # The following code runs the test for your chosen alpha: using HypothesisTests p_value = pvalue( OneSampleTTest( sample, pop_mean ) ) reject_H0 = p_value < alpha alpha, p_value, reject_H0 ``` (0.05, 0.35845634462296455, false) In this case, the $p$-value was larger than $\\alpha$, so the sample does not give us enough information to reject the null hypothesis. We would continue to assume that the sample is like the population, $\\mu=\\bar x$. When you are using the most common value for $\\alpha$, which is $0.05$ for the $95\\%$ confidence interval, you can simply print out the test itself and get a detailed printout with all the information you need, thus saving a few lines of code. ```julia OneSampleTTest( sample, pop_mean ) ``` One sample t-test ----------------- Population details: parameter of interest: Mean value under h_0: 10 point estimate: 11.2 95% confidence interval: (7.986, 14.41) Test summary: outcome with 95% confidence: fail to reject h_0 two-sided p-value: 0.3585 Details: number of observations: 5 t-statistic: 1.0366421106976316 degrees of freedom: 4 empirical standard error: 1.1575836902790224 Content last modified on 05 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-sided hypothesis test for a sample mean/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean-in-julia/",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean-in-julia/"
  },"539": {
    "doc": "How to do a two-sided hypothesis test for a sample mean (in Python, using SciPy)",
    "title": "How to do a two-sided hypothesis test for a sample mean (in Python, using SciPy)",
    "content": "# How to do a two-sided hypothesis test for a sample mean (in Python, using SciPy) [See all solutions.](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) ## Task Say we have a population whose mean $\\mu$ is known. We take a sample $x_1,\\ldots,x_n$ and compute its mean, $\\bar x$. We then ask whether this sample is significantly different from the population at large, that is, is $\\mu=\\bar x$? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Solution This is a two-sided test with the null hypothesis $H_0:\\mu=\\bar x$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). ```python from scipy import stats # Replace these first three lines with the values from your situation. alpha = 0.05 pop_mean = 10 sample = [ 9, 12, 14, 8, 13 ] # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. t_statistic, p_value = stats.ttest_1samp( sample, pop_mean ) reject_H0 = p_value < alpha alpha, p_value, reject_H0 ``` (0.05, 0.35845634462296455, False) In this case, the sample does not give us enough information to reject the null hypothesis. We would continue to assume that the sample is like the population, $\\mu=\\bar x$. Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-sided hypothesis test for a sample mean/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean-in-python-using-scipy/"
  },"540": {
    "doc": "How to do a two-sided hypothesis test for a sample mean (in R)",
    "title": "How to do a two-sided hypothesis test for a sample mean (in R)",
    "content": "# How to do a two-sided hypothesis test for a sample mean (in R) [See all solutions.](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) ## Task Say we have a population whose mean $\\mu$ is known. We take a sample $x_1,\\ldots,x_n$ and compute its mean, $\\bar x$. We then ask whether this sample is significantly different from the population at large, that is, is $\\mu=\\bar x$? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Solution This is a two-sided test with the null hypothesis $H_0:\\mu=\\bar x$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). ```R # Replace these first three lines with the values from your situation. alpha <- 0.05 pop.mean <- 10 sample <- c( 9, 12, 14, 8, 13 ) # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. t.test( sample, mu=pop.mean, conf.level=1-alpha ) ``` One Sample t-test data: sample t = 1.0366, df = 4, p-value = 0.3585 alternative hypothesis: true mean is not equal to 10 95 percent confidence interval: 7.986032 14.413968 sample estimates: mean of x 11.2 Although we can deduce the answer to our question from the above output, by comparing the $p$ value with $\\alpha$ manually, we can also ask R to do it. ```R # Is there enough evidence to reject the null hypothesis? result <- t.test( sample, mu=pop.mean, conf.level=1-alpha ) result$p.value < alpha ``` [1] FALSE In this case, the sample does not give us enough information to reject the null hypothesis. We would continue to assume that the sample is like the population, $\\mu=\\bar x$. Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-sided hypothesis test for a sample mean/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean-in-r/",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean-in-r/"
  },"541": {
    "doc": "How to do a two-sided hypothesis test for a sample mean",
    "title": "How to do a two-sided hypothesis test for a sample mean",
    "content": " ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/"
  },"542": {
    "doc": "How to do a two-sided hypothesis test for a sample mean",
    "title": "Description",
    "content": "Say we have a population whose mean $\\mu$ is known. We take a sample $x_1,\\ldots,x_n$ and compute its mean, $\\bar x$. We then ask whether this sample is significantly different from the population at large, that is, is $\\mu=\\bar x$? . Related tasks: . | How to compute a confidence interval for a population mean | How to do a two-sided hypothesis test for two sample means | How to do a one-sided hypothesis test for two sample means | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | . ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#description",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#description"
  },"543": {
    "doc": "How to do a two-sided hypothesis test for a sample mean",
    "title": "Solution, in Julia",
    "content": "View this solution alone. This is a two-sided test with the null hypothesis $H_0:\\mu=\\bar x$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). | 1 2 3 4 5 6 7 8 9 10 . | # Replace these first three lines with the values from your situation. alpha = 0.05 pop_mean = 10 sample = [ 9, 12, 14, 8, 13 ] # The following code runs the test for your chosen alpha: using HypothesisTests p_value = pvalue( OneSampleTTest( sample, pop_mean ) ) reject_H0 = p_value &lt; alpha alpha, p_value, reject_H0 . | . | 1 . | (0.05, 0.35845634462296455, false) . | . In this case, the $p$-value was larger than $\\alpha$, so the sample does not give us enough information to reject the null hypothesis. We would continue to assume that the sample is like the population, $\\mu=\\bar x$. When you are using the most common value for $\\alpha$, which is $0.05$ for the $95\\%$ confidence interval, you can simply print out the test itself and get a detailed printout with all the information you need, thus saving a few lines of code. | 1 . | OneSampleTTest( sample, pop_mean ) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | One sample t-test ----------------- Population details: parameter of interest: Mean value under h_0: 10 point estimate: 11.2 95% confidence interval: (7.986, 14.41) Test summary: outcome with 95% confidence: fail to reject h_0 two-sided p-value: 0.3585 Details: number of observations: 5 t-statistic: 1.0366421106976316 degrees of freedom: 4 empirical standard error: 1.1575836902790224 . | . Content last modified on 05 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#solution-in-julia",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#solution-in-julia"
  },"544": {
    "doc": "How to do a two-sided hypothesis test for a sample mean",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. This is a two-sided test with the null hypothesis $H_0:\\mu=\\bar x$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). | 1 2 3 4 5 6 7 8 9 10 11 12 . | from scipy import stats # Replace these first three lines with the values from your situation. alpha = 0.05 pop_mean = 10 sample = [ 9, 12, 14, 8, 13 ] # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. t_statistic, p_value = stats.ttest_1samp( sample, pop_mean ) reject_H0 = p_value &lt; alpha alpha, p_value, reject_H0 . | . | 1 . | (0.05, 0.35845634462296455, False) . | . In this case, the sample does not give us enough information to reject the null hypothesis. We would continue to assume that the sample is like the population, $\\mu=\\bar x$. Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#using-scipy-in-python"
  },"545": {
    "doc": "How to do a two-sided hypothesis test for a sample mean",
    "title": "Solution, in R",
    "content": "View this solution alone. This is a two-sided test with the null hypothesis $H_0:\\mu=\\bar x$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). | 1 2 3 4 5 6 7 8 . | # Replace these first three lines with the values from your situation. alpha &lt;- 0.05 pop.mean &lt;- 10 sample &lt;- c( 9, 12, 14, 8, 13 ) # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. t.test( sample, mu=pop.mean, conf.level=1-alpha ) . | . | 1 2 3 4 5 6 7 8 9 10 . | One Sample t-test data: sample t = 1.0366, df = 4, p-value = 0.3585 alternative hypothesis: true mean is not equal to 10 95 percent confidence interval: 7.986032 14.413968 sample estimates: mean of x 11.2 . | . Although we can deduce the answer to our question from the above output, by comparing the $p$ value with $\\alpha$ manually, we can also ask R to do it. | 1 2 3 . | # Is there enough evidence to reject the null hypothesis? result &lt;- t.test( sample, mu=pop.mean, conf.level=1-alpha ) result$p.value &lt; alpha . | . | 1 . | [1] FALSE . | . In this case, the sample does not give us enough information to reject the null hypothesis. We would continue to assume that the sample is like the population, $\\mu=\\bar x$. Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#solution-in-r",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#solution-in-r"
  },"546": {
    "doc": "How to do a two-sided hypothesis test for a sample mean",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | . ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#topics-that-include-this-task"
  },"547": {
    "doc": "How to do a two-sided hypothesis test for a sample mean",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#opportunities",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean/#opportunities"
  },"548": {
    "doc": "How to do a two-sided hypothesis test for two sample means (in Julia)",
    "title": "How to do a two-sided hypothesis test for two sample means (in Julia)",
    "content": "# How to do a two-sided hypothesis test for two sample means (in Julia) [See all solutions.](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Task If we have two samples, $x_1,\\ldots,x_n$ and $x'_1,\\ldots,x'_m$, and we compute the mean of each one, we might want to ask whether the two means seem approximately equal. Or more precisely, is their difference statistically significant at a given level? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Solution If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a two-sided test with the null hypothesis $H_0:\\bar x_1=\\bar x_2$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). ```julia # Replace these first three lines with the values from your situation. alpha = 0.10 sample1 = [ 6, 9, 7, 10, 10, 9 ] sample2 = [ 12, 14, 10, 17, 9 ] # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. using HypothesisTests p_value = pvalue( UnequalVarianceTTest( sample1, sample2 ) ) reject_H0 = p_value < alpha alpha, p_value, reject_H0 ``` (0.1, 0.05097283741847691, true) In this case, the $p$-value was less than $\\alpha$, so the sample gives us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. The data suggest that $\\bar x_1\\neq\\bar x_2$. When you are using the most common value for $\\alpha$, which is $0.05$ for the $95\\%$ confidence interval, you can simply print out the test itself and get a detailed printout with all the information you need, thus saving a few lines of code. Note that this gives a different answer below than the one above, because above we chose to use $\\alpha=0.10$, but the default below is $\\alpha=0.05$. ```julia UnequalVarianceTTest( sample1, sample2 ) ``` Two sample t-test (unequal variance) ------------------------------------ Population details: parameter of interest: Mean difference value under h_0: 0 point estimate: -3.9 95% confidence interval: (-7.823, 0.02309) Test summary: outcome with 95% confidence: fail to reject h_0 two-sided p-value: 0.0510 Details: number of observations: [6,5] t-statistic: -2.4616581720814326 degrees of freedom: 5.720083530052662 empirical standard error: 1.584297951775486 Here we did not assume that the two samples had equal variance. If in your case they do, you can use `EqualVarianceTTest()` instead of `UnequalVarianceTTest()`. Content last modified on 05 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-sided hypothesis test for two sample means/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means-in-julia/",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means-in-julia/"
  },"549": {
    "doc": "How to do a two-sided hypothesis test for two sample means (in Python, using SciPy)",
    "title": "How to do a two-sided hypothesis test for two sample means (in Python, using SciPy)",
    "content": "# How to do a two-sided hypothesis test for two sample means (in Python, using SciPy) [See all solutions.](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Task If we have two samples, $x_1,\\ldots,x_n$ and $x'_1,\\ldots,x'_m$, and we compute the mean of each one, we might want to ask whether the two means seem approximately equal. Or more precisely, is their difference statistically significant at a given level? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Solution If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a two-sided test with the null hypothesis $H_0:\\bar x_1=\\bar x_2$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). Let's use $\\alpha=0.10$ as an example. ```python from scipy import stats # Replace these first three lines with the values from your situation. alpha = 0.10 sample1 = [ 6, 9, 7, 10, 10, 9 ] sample2 = [ 12, 14, 10, 17, 9 ] # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. stats.ttest_ind( sample1, sample2, equal_var=False ) ``` Ttest_indResult(statistic=-2.4616581720814326, pvalue=0.05097283741847698) The output says that the $p$-value is about $0.05097$, which is less than $\\alpha=0.10$. In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. That is, the data suggest that $\\bar x_1\\neq\\bar x_2$. The `equal_var` parameter tells SciPy *not* to assume that the two samples have equal variances. If in your case they do, you can omit that parameter, and it will revert to its default value of `True`. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-sided hypothesis test for two sample means/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means-in-python-using-scipy/"
  },"550": {
    "doc": "How to do a two-sided hypothesis test for two sample means (in R)",
    "title": "How to do a two-sided hypothesis test for two sample means (in R)",
    "content": "# How to do a two-sided hypothesis test for two sample means (in R) [See all solutions.](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) ## Task If we have two samples, $x_1,\\ldots,x_n$ and $x'_1,\\ldots,x'_m$, and we compute the mean of each one, we might want to ask whether the two means seem approximately equal. Or more precisely, is their difference statistically significant at a given level? Related tasks: * [How to compute a confidence interval for a population mean](../how-to-compute-a-confidence-interval-for-a-population-mean) * [How to do a two-sided hypothesis test for a sample mean](../how-to-do-a-two-sided-hypothesis-test-for-a-sample-mean) * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a one-sided hypothesis test for two sample means](../how-to-do-a-one-sided-hypothesis-test-for-two-sample-means) * [How to do a hypothesis test for a mean difference (matched pairs)](../how-to-do-a-hypothesis-test-for-a-mean-difference-matched-pairs) * [How to do a hypothesis test for a population proportion](../how-to-do-a-hypothesis-test-for-a-population-proportion) ## Solution If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a two-sided test with the null hypothesis $H_0:\\bar x_1=\\bar x_2$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). ```R # Replace these first three lines with the values from your situation. alpha <- 0.10 sample1 <- c( 6, 9, 7, 10, 10, 9 ) sample2 <- c( 12, 14, 10, 17, 9 ) # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. t.test( sample1, sample2, conf.level=1-alpha ) ``` Welch Two Sample t-test data: sample1 and sample2 t = -2.4617, df = 5.7201, p-value = 0.05097 alternative hypothesis: true difference in means is not equal to 0 90 percent confidence interval: -7.0057683 -0.7942317 sample estimates: mean of x mean of y 8.5 12.4 Although we can deduce the answer to our question from the above output, by comparing the $p$ value with $\\alpha$ manually, we can also ask R to do it. ```R # Is there enough evidence to reject the null hypothesis? result <- t.test( sample1, sample2, conf.level=1-alpha ) result$p.value < alpha ``` [1] TRUE In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. The data suggest that $\\bar x_1\\neq\\bar x_2$. Here we did not assume that the two samples had equal variance. If in your case they do, you can pass the parameter `var.equal=TRUE` to `t.test`. Content last modified on 28 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-sided hypothesis test for two sample means/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means-in-r/",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means-in-r/"
  },"551": {
    "doc": "How to do a two-sided hypothesis test for two sample means",
    "title": "How to do a two-sided hypothesis test for two sample means",
    "content": " ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/"
  },"552": {
    "doc": "How to do a two-sided hypothesis test for two sample means",
    "title": "Description",
    "content": "If we have two samples, $x_1,\\ldots,x_n$ and $x’_1,\\ldots,x’_m$, and we compute the mean of each one, we might want to ask whether the two means seem approximately equal. Or more precisely, is their difference statistically significant at a given level? . Related tasks: . | How to compute a confidence interval for a population mean | How to do a two-sided hypothesis test for a sample mean | How to do a one-way analysis of variance (ANOVA) | How to do a one-sided hypothesis test for two sample means | How to do a hypothesis test for a mean difference (matched pairs) | How to do a hypothesis test for a population proportion | . ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#description",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#description"
  },"553": {
    "doc": "How to do a two-sided hypothesis test for two sample means",
    "title": "Solution, in Julia",
    "content": "View this solution alone. If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a two-sided test with the null hypothesis $H_0:\\bar x_1=\\bar x_2$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). | 1 2 3 4 5 6 7 8 9 10 11 . | # Replace these first three lines with the values from your situation. alpha = 0.10 sample1 = [ 6, 9, 7, 10, 10, 9 ] sample2 = [ 12, 14, 10, 17, 9 ] # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. using HypothesisTests p_value = pvalue( UnequalVarianceTTest( sample1, sample2 ) ) reject_H0 = p_value &lt; alpha alpha, p_value, reject_H0 . | . | 1 . | (0.1, 0.05097283741847691, true) . | . In this case, the $p$-value was less than $\\alpha$, so the sample gives us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. The data suggest that $\\bar x_1\\neq\\bar x_2$. When you are using the most common value for $\\alpha$, which is $0.05$ for the $95\\%$ confidence interval, you can simply print out the test itself and get a detailed printout with all the information you need, thus saving a few lines of code. Note that this gives a different answer below than the one above, because above we chose to use $\\alpha=0.10$, but the default below is $\\alpha=0.05$. | 1 . | UnequalVarianceTTest( sample1, sample2 ) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | Two sample t-test (unequal variance) ------------------------------------ Population details: parameter of interest: Mean difference value under h_0: 0 point estimate: -3.9 95% confidence interval: (-7.823, 0.02309) Test summary: outcome with 95% confidence: fail to reject h_0 two-sided p-value: 0.0510 Details: number of observations: [6,5] t-statistic: -2.4616581720814326 degrees of freedom: 5.720083530052662 empirical standard error: 1.584297951775486 . | . Here we did not assume that the two samples had equal variance. If in your case they do, you can use EqualVarianceTTest() instead of UnequalVarianceTTest(). Content last modified on 05 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#solution-in-julia",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#solution-in-julia"
  },"554": {
    "doc": "How to do a two-sided hypothesis test for two sample means",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a two-sided test with the null hypothesis $H_0:\\bar x_1=\\bar x_2$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). Let’s use $\\alpha=0.10$ as an example. | 1 2 3 4 5 6 7 8 9 10 . | from scipy import stats # Replace these first three lines with the values from your situation. alpha = 0.10 sample1 = [ 6, 9, 7, 10, 10, 9 ] sample2 = [ 12, 14, 10, 17, 9 ] # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. stats.ttest_ind( sample1, sample2, equal_var=False ) . | . | 1 . | Ttest_indResult(statistic=-2.4616581720814326, pvalue=0.05097283741847698) . | . The output says that the $p$-value is about $0.05097$, which is less than $\\alpha=0.10$. In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. That is, the data suggest that $\\bar x_1\\neq\\bar x_2$. The equal_var parameter tells SciPy not to assume that the two samples have equal variances. If in your case they do, you can omit that parameter, and it will revert to its default value of True. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#using-scipy-in-python"
  },"555": {
    "doc": "How to do a two-sided hypothesis test for two sample means",
    "title": "Solution, in R",
    "content": "View this solution alone. If we call the mean of the first sample $\\bar x_1$ and the mean of the second sample $\\bar x_2$, then this is a two-sided test with the null hypothesis $H_0:\\bar x_1=\\bar x_2$. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). | 1 2 3 4 5 6 7 8 . | # Replace these first three lines with the values from your situation. alpha &lt;- 0.10 sample1 &lt;- c( 6, 9, 7, 10, 10, 9 ) sample2 &lt;- c( 12, 14, 10, 17, 9 ) # Run a one-sample t-test and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. t.test( sample1, sample2, conf.level=1-alpha ) . | . | 1 2 3 4 5 6 7 8 9 10 . | Welch Two Sample t-test data: sample1 and sample2 t = -2.4617, df = 5.7201, p-value = 0.05097 alternative hypothesis: true difference in means is not equal to 0 90 percent confidence interval: -7.0057683 -0.7942317 sample estimates: mean of x mean of y 8.5 12.4 . | . Although we can deduce the answer to our question from the above output, by comparing the $p$ value with $\\alpha$ manually, we can also ask R to do it. | 1 2 3 . | # Is there enough evidence to reject the null hypothesis? result &lt;- t.test( sample1, sample2, conf.level=1-alpha ) result$p.value &lt; alpha . | . | 1 . | [1] TRUE . | . In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.10$ level. The data suggest that $\\bar x_1\\neq\\bar x_2$. Here we did not assume that the two samples had equal variance. If in your case they do, you can pass the parameter var.equal=TRUE to t.test. Content last modified on 28 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#solution-in-r",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#solution-in-r"
  },"556": {
    "doc": "How to do a two-sided hypothesis test for two sample means",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | . ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#topics-that-include-this-task"
  },"557": {
    "doc": "How to do a two-sided hypothesis test for two sample means",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#opportunities",
    "relUrl": "/how-to-do-a-two-sided-hypothesis-test-for-two-sample-means/#opportunities"
  },"558": {
    "doc": "How to do a two-way ANOVA test with interaction (in Python, using Statsmodels)",
    "title": "How to do a two-way ANOVA test with interaction (in Python, using Statsmodels)",
    "content": "# How to do a two-way ANOVA test with interaction (in Python, using Statsmodels) [See all solutions.](../how-to-do-a-two-way-anova-test-with-interaction) ## Task When we analyze the impact that two factors have on a response variable, we often consider the possible relationship between the two factors. That is, does their interaction term affect the response variable? A two-way ANOVA test with interaction can answer that question. Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) using ANOVA * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution We're going to use R's `esoph` dataset, about esophageal cancer cases. We will focus on the impact of age group (`agegp`) and alcohol consumption (`alcgp`) on the number of cases of the cancer (`ncases`). We ask, does the interaction between these two factors affect the number of cases? First, we load in the dataset. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data data = data('esoph') data.head() ``` | | agegp | alcgp | tobgp | ncases | ncontrols | . | 0 | 25-34 | 0-39g/day | 0-9g/day | 0 | 40 | . | 1 | 25-34 | 0-39g/day | 10-19 | 0 | 10 | . | 2 | 25-34 | 0-39g/day | 20-29 | 0 | 6 | . | 3 | 25-34 | 0-39g/day | 30+ | 0 | 5 | . | 4 | 25-34 | 40-79 | 0-9g/day | 0 | 27 | . Next, we create a model that includes the response variable we care about, plus the two categorical variables we will be testing, as well as their interaction term. ```python import statsmodels.api as sm from statsmodels.formula.api import ols # C(...) means the variable is categorical, and : means multiplication. model = ols('ncases ~ C(alcgp) + C(agegp) + C(alcgp):C(agegp)', data = data).fit() ``` A two-way ANOVA with interaction tests the following three null hypotheses. 1. There is no interaction between the two categorical variables. (If we reject this we do not test the other two hypotheses.) 2. The mean response is the same across all groups of the first factor. (In our example, that says the mean `ncases` is the same for all age groups.) 3. The mean response is the same across all groups of the second factor. (In our example, that says the mean `ncases` is the same for all alcohol consumption groups.) We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. Let's let $\\alpha=0.05$ here. ```python sm.stats.anova_lm(model, typ=2) ``` | | sum_sq | df | F | PR(&gt;F) | . | C(alcgp) | 52.695287 | 3.0 | 4.723387 | 4.862447e-03 | . | C(agegp) | 267.026108 | 5.0 | 14.361068 | 2.021935e-09 | . | C(alcgp):C(agegp) | 107.557743 | 15.0 | 1.928206 | 3.632710e-02 | . | Residual | 238.000000 | 64.0 | NaN | NaN | . The $p$-value for the interaction of age group and alcohol consumption is in the third row, final column, $3.63271\\times10^{-2}$. It is less than $\\alpha$, so we can reject the null hypothesis that age group and alcohol consumption do not interact with regards to the number of esophageal cancer cases. That is, we have reason to believe that their interaction does effect the outcome. As we stated when we listed the hypotheses to test, since we rejected the first null hypothesis, we will not test the other two. In the case where you failed to reject the first null hypothesis, you could consider each $p$-value in the first two rows of the above table, one for each of the two factors. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-way ANOVA test with interaction/Python, using Statsmodels.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-two-way-anova-test-with-interaction-in-python-using-statsmodels/",
    "relUrl": "/how-to-do-a-two-way-anova-test-with-interaction-in-python-using-statsmodels/"
  },"559": {
    "doc": "How to do a two-way ANOVA test with interaction (in R)",
    "title": "How to do a two-way ANOVA test with interaction (in R)",
    "content": "# How to do a two-way ANOVA test with interaction (in R) [See all solutions.](../how-to-do-a-two-way-anova-test-with-interaction) ## Task When we analyze the impact that two factors have on a response variable, we often consider the possible relationship between the two factors. That is, does their interaction term affect the response variable? A two-way ANOVA test with interaction can answer that question. Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) using ANOVA * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution We're going to use R's `esoph` dataset, about esophageal cancer cases. We will focus on the impact of age group (`agegp`) and alcohol consumption (`alcgp`) on the number of cases of the cancer (`ncases`). We ask, does the interaction between these two factors affect the number of cases? First, we load in the dataset. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R # install.packages(\"datasets\") # if you have not already done this library(datasets) data F) agegp 5 261.2 52.24 14.048 2.89e-09 *** alcgp 3 52.7 17.57 4.723 0.00486 ** agegp:alcgp 15 107.6 7.17 1.928 0.03633 * Residuals 64 238.0 3.72 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 The $p$-value for the interaction of age group and alcohol consumption is in the third row, final column, $0.03633$. It is less than $\\alpha$, so we can reject the null hypothesis that age group and alcohol consumption do not interact with regards to the number of esophageal cancer cases. That is, we have reason to believe that their interaction does effect the outcome. As we stated when we listed the hypotheses to test, since we rejected the first null hypothesis, we will not test the other two. In the case where you failed to reject the first null hypothesis, you could consider each $p$-value in the first two rows of the above table, one for each of the two factors. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-way ANOVA test with interaction/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-two-way-anova-test-with-interaction-in-r/",
    "relUrl": "/how-to-do-a-two-way-anova-test-with-interaction-in-r/"
  },"560": {
    "doc": "How to do a two-way ANOVA test with interaction",
    "title": "How to do a two-way ANOVA test with interaction",
    "content": " ",
    "url": "/how-to-do-a-two-way-anova-test-with-interaction/",
    "relUrl": "/how-to-do-a-two-way-anova-test-with-interaction/"
  },"561": {
    "doc": "How to do a two-way ANOVA test with interaction",
    "title": "Description",
    "content": "When we analyze the impact that two factors have on a response variable, we often consider the possible relationship between the two factors. That is, does their interaction term affect the response variable? A two-way ANOVA test with interaction can answer that question. Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to do a two-way ANOVA test without interaction | How to compare two nested linear models using ANOVA | How to conduct a mixed designs ANOVA | How to conduct a repeated measures ANOVA | How to perform an analysis of covariance (ANCOVA) | . ",
    "url": "/how-to-do-a-two-way-anova-test-with-interaction/#description",
    "relUrl": "/how-to-do-a-two-way-anova-test-with-interaction/#description"
  },"562": {
    "doc": "How to do a two-way ANOVA test with interaction",
    "title": "Using Statsmodels, in Python",
    "content": "View this solution alone. We’re going to use R’s esoph dataset, about esophageal cancer cases. We will focus on the impact of age group (agegp) and alcohol consumption (alcgp) on the number of cases of the cancer (ncases). We ask, does the interaction between these two factors affect the number of cases? . First, we load in the dataset. (See how to quickly load some sample data.) . | 1 2 3 . | from rdatasets import data data = data('esoph') data.head() . | . | | agegp | alcgp | tobgp | ncases | ncontrols | . | 0 | 25-34 | 0-39g/day | 0-9g/day | 0 | 40 | . | 1 | 25-34 | 0-39g/day | 10-19 | 0 | 10 | . | 2 | 25-34 | 0-39g/day | 20-29 | 0 | 6 | . | 3 | 25-34 | 0-39g/day | 30+ | 0 | 5 | . | 4 | 25-34 | 40-79 | 0-9g/day | 0 | 27 | . Next, we create a model that includes the response variable we care about, plus the two categorical variables we will be testing, as well as their interaction term. | 1 2 3 4 . | import statsmodels.api as sm from statsmodels.formula.api import ols # C(...) means the variable is categorical, and : means multiplication. model = ols('ncases ~ C(alcgp) + C(agegp) + C(alcgp):C(agegp)', data = data).fit() . | . A two-way ANOVA with interaction tests the following three null hypotheses. | There is no interaction between the two categorical variables. (If we reject this we do not test the other two hypotheses.) | The mean response is the same across all groups of the first factor. (In our example, that says the mean ncases is the same for all age groups.) | The mean response is the same across all groups of the second factor. (In our example, that says the mean ncases is the same for all alcohol consumption groups.) | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. Let’s let $\\alpha=0.05$ here. | 1 . | sm.stats.anova_lm(model, typ=2) . | . | | sum_sq | df | F | PR(&gt;F) | . | C(alcgp) | 52.695287 | 3.0 | 4.723387 | 4.862447e-03 | . | C(agegp) | 267.026108 | 5.0 | 14.361068 | 2.021935e-09 | . | C(alcgp):C(agegp) | 107.557743 | 15.0 | 1.928206 | 3.632710e-02 | . | Residual | 238.000000 | 64.0 | NaN | NaN | . The $p$-value for the interaction of age group and alcohol consumption is in the third row, final column, $3.63271\\times10^{-2}$. It is less than $\\alpha$, so we can reject the null hypothesis that age group and alcohol consumption do not interact with regards to the number of esophageal cancer cases. That is, we have reason to believe that their interaction does effect the outcome. As we stated when we listed the hypotheses to test, since we rejected the first null hypothesis, we will not test the other two. In the case where you failed to reject the first null hypothesis, you could consider each $p$-value in the first two rows of the above table, one for each of the two factors. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-way-anova-test-with-interaction/#using-statsmodels-in-python",
    "relUrl": "/how-to-do-a-two-way-anova-test-with-interaction/#using-statsmodels-in-python"
  },"563": {
    "doc": "How to do a two-way ANOVA test with interaction",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use R’s esoph dataset, about esophageal cancer cases. We will focus on the impact of age group (agegp) and alcohol consumption (alcgp) on the number of cases of the cancer (ncases). We ask, does the interaction between these two factors affect the number of cases? . First, we load in the dataset. (See how to quickly load some sample data.) . | 1 2 3 4 . | # install.packages(\"datasets\") # if you have not already done this library(datasets) data &lt;- esoph head(data) . | . | 1 2 3 4 5 6 7 . | agegp alcgp tobgp ncases ncontrols 1 25-34 0-39g/day 0-9g/day 0 40 2 25-34 0-39g/day 10-19 0 10 3 25-34 0-39g/day 20-29 0 6 4 25-34 0-39g/day 30+ 0 5 5 25-34 40-79 0-9g/day 0 27 6 25-34 40-79 10-19 0 7 . | . Next, we create a model that includes the response variable we care about, plus the two categorical variables we will be testing, as well as their interaction term. | 1 2 . | # the * below means multiplication, to create an interaction term model &lt;- aov(ncases ~ agegp*alcgp, data = data) . | . A two-way ANOVA with interaction tests the following three null hypotheses. | There is no interaction between the two categorical variables. (If we reject this we do not test the other two hypotheses.) | The mean response is the same across all groups of the first factor. (In our example, that says the mean ncases is the same for all age groups.) | The mean response is the same across all groups of the second factor. (In our example, that says the mean ncases is the same for all alcohol consumption groups.) | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. Let’s let $\\alpha=0.05$ here. | 1 . | summary(model) . | . | 1 2 3 4 5 6 7 . | Df Sum Sq Mean Sq F value Pr(&gt;F) agegp 5 261.2 52.24 14.048 2.89e-09 *** alcgp 3 52.7 17.57 4.723 0.00486 ** agegp:alcgp 15 107.6 7.17 1.928 0.03633 * Residuals 64 238.0 3.72 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . The $p$-value for the interaction of age group and alcohol consumption is in the third row, final column, $0.03633$. It is less than $\\alpha$, so we can reject the null hypothesis that age group and alcohol consumption do not interact with regards to the number of esophageal cancer cases. That is, we have reason to believe that their interaction does effect the outcome. As we stated when we listed the hypotheses to test, since we rejected the first null hypothesis, we will not test the other two. In the case where you failed to reject the first null hypothesis, you could consider each $p$-value in the first two rows of the above table, one for each of the two factors. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-way-anova-test-with-interaction/#solution-in-r",
    "relUrl": "/how-to-do-a-two-way-anova-test-with-interaction/#solution-in-r"
  },"564": {
    "doc": "How to do a two-way ANOVA test with interaction",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-two-way-anova-test-with-interaction/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-two-way-anova-test-with-interaction/#topics-that-include-this-task"
  },"565": {
    "doc": "How to do a two-way ANOVA test with interaction",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-two-way-anova-test-with-interaction/#opportunities",
    "relUrl": "/how-to-do-a-two-way-anova-test-with-interaction/#opportunities"
  },"566": {
    "doc": "How to do a two-way ANOVA test without interaction (in Python, using Statsmodels)",
    "title": "How to do a two-way ANOVA test without interaction (in Python, using Statsmodels)",
    "content": "# How to do a two-way ANOVA test without interaction (in Python, using Statsmodels) [See all solutions.](../how-to-do-a-two-way-anova-test-without-interaction) ## Task When we analyze the impact that two factors have on a response variable, we may know in advance that the two factors do not interact. How can we use a two-way ANOVA test to test for an effect from each factor without including an interaction term for the two factors? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) using ANOVA * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution We're going to use R's `esoph` dataset, about esophageal cancer cases. We will focus on the impact of age group (`agegp`) and alcohol consumption (`alcgp`) on the number of cases of the cancer (`ncases`). We ask, does either of these two factors affect the number of cases? First, we load in the dataset. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data data = data('esoph') data.head() ``` | | agegp | alcgp | tobgp | ncases | ncontrols | . | 0 | 25-34 | 0-39g/day | 0-9g/day | 0 | 40 | . | 1 | 25-34 | 0-39g/day | 10-19 | 0 | 10 | . | 2 | 25-34 | 0-39g/day | 20-29 | 0 | 6 | . | 3 | 25-34 | 0-39g/day | 30+ | 0 | 5 | . | 4 | 25-34 | 40-79 | 0-9g/day | 0 | 27 | . Next, we create a model that includes the response variable we care about, plus the two categorical variables we will be testing. We simply omit the interaction term. (If you wish to include it, see [how to do a two-way ANOVA test with interaction](../how-to-do-a-two-way-anova-test-with-interaction).) ```python import statsmodels.api as sm from statsmodels.formula.api import ols # C(...) means the variable is categorical, below model = ols('ncases ~ C(alcgp) + C(agegp)', data = data).fit() ``` A two-way ANOVA with interaction tests the following two null hypotheses. 1. The mean response is the same across all groups of the first factor. (In our example, that says the mean `ncases` is the same for all age groups.) 2. The mean response is the same across all groups of the second factor. (In our example, that says the mean `ncases` is the same for all alcohol consumption groups.) We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. Let's let $\\alpha=0.05$ here. ```python sm.stats.anova_lm(model, typ=2) ``` | | sum_sq | df | F | PR(&gt;F) | . | C(alcgp) | 52.695287 | 3.0 | 4.015660 | 1.029452e-02 | . | C(agegp) | 267.026108 | 5.0 | 12.209284 | 8.907998e-09 | . | Residual | 345.557743 | 79.0 | NaN | NaN | . The $p$-value for the alcohol consumption factor is in the first row, final column, $1.029452\\times10^{-2}$. It is less than $\\alpha$, so we can reject the null hypothesis that alcohol consumption does not affect the number of esophageal cancer cases. That is, we have reason to believe that it does affect the number of cases. The $p$-value for the age group factor is in the second row, final column, $8.907998\\times10^{-9}$. It is less than $\\alpha$, so we can reject the null hypothesis that age group does not affect the number of esophageal cancer cases. Again, we have reason to believe that it does affect the number of cases. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-way ANOVA test without interaction/Python, using Statsmodels.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-two-way-anova-test-without-interaction-in-python-using-statsmodels/",
    "relUrl": "/how-to-do-a-two-way-anova-test-without-interaction-in-python-using-statsmodels/"
  },"567": {
    "doc": "How to do a two-way ANOVA test without interaction (in R)",
    "title": "How to do a two-way ANOVA test without interaction (in R)",
    "content": "# How to do a two-way ANOVA test without interaction (in R) [See all solutions.](../how-to-do-a-two-way-anova-test-without-interaction) ## Task When we analyze the impact that two factors have on a response variable, we may know in advance that the two factors do not interact. How can we use a two-way ANOVA test to test for an effect from each factor without including an interaction term for the two factors? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-way ANOVA test without interaction](../how-to-do-a-two-way-anova-test-without-interaction) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) using ANOVA * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) * [How to perform an analysis of covariance (ANCOVA)](../how-to-perform-an-analysis-of-covariance-ancova) ## Solution We're going to use R's `esoph` dataset, about esophageal cancer cases. We will focus on the impact of age group (`agegp`) and alcohol consumption (`alcgp`) on the number of cases of the cancer (`ncases`). We ask, does either of these two factors affect the number of cases? First, we load in the dataset. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R # install.packages(\"datasets\") # if you have not already done this library(datasets) data F) agegp 5 261.2 52.24 11.943 1.28e-08 *** alcgp 3 52.7 17.57 4.016 0.0103 * Residuals 79 345.6 4.37 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 The $p$-value for the alcohol consumption factor is in the first row, final column, $1.029452\\times10^{-2}$. It is less than $\\alpha$, so we can reject the null hypothesis that alcohol consumption does not affect the number of esophageal cancer cases. That is, we have reason to believe that it does affect the number of cases. The $p$-value for the age group factor is in the second row, final column, $8.907998\\times10^{-9}$. It is less than $\\alpha$, so we can reject the null hypothesis that age group does not affect the number of esophageal cancer cases. Again, we have reason to believe that it does affect the number of cases. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a two-way ANOVA test without interaction/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-two-way-anova-test-without-interaction-in-r/",
    "relUrl": "/how-to-do-a-two-way-anova-test-without-interaction-in-r/"
  },"568": {
    "doc": "How to do a two-way ANOVA test without interaction",
    "title": "How to do a two-way ANOVA test without interaction",
    "content": " ",
    "url": "/how-to-do-a-two-way-anova-test-without-interaction/",
    "relUrl": "/how-to-do-a-two-way-anova-test-without-interaction/"
  },"569": {
    "doc": "How to do a two-way ANOVA test without interaction",
    "title": "Description",
    "content": "When we analyze the impact that two factors have on a response variable, we may know in advance that the two factors do not interact. How can we use a two-way ANOVA test to test for an effect from each factor without including an interaction term for the two factors? . Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to do a two-way ANOVA test without interaction | How to compare two nested linear models using ANOVA | How to conduct a mixed designs ANOVA | How to conduct a repeated measures ANOVA | How to perform an analysis of covariance (ANCOVA) | . ",
    "url": "/how-to-do-a-two-way-anova-test-without-interaction/#description",
    "relUrl": "/how-to-do-a-two-way-anova-test-without-interaction/#description"
  },"570": {
    "doc": "How to do a two-way ANOVA test without interaction",
    "title": "Using Statsmodels, in Python",
    "content": "View this solution alone. We’re going to use R’s esoph dataset, about esophageal cancer cases. We will focus on the impact of age group (agegp) and alcohol consumption (alcgp) on the number of cases of the cancer (ncases). We ask, does either of these two factors affect the number of cases? . First, we load in the dataset. (See how to quickly load some sample data.) . | 1 2 3 . | from rdatasets import data data = data('esoph') data.head() . | . | | agegp | alcgp | tobgp | ncases | ncontrols | . | 0 | 25-34 | 0-39g/day | 0-9g/day | 0 | 40 | . | 1 | 25-34 | 0-39g/day | 10-19 | 0 | 10 | . | 2 | 25-34 | 0-39g/day | 20-29 | 0 | 6 | . | 3 | 25-34 | 0-39g/day | 30+ | 0 | 5 | . | 4 | 25-34 | 40-79 | 0-9g/day | 0 | 27 | . Next, we create a model that includes the response variable we care about, plus the two categorical variables we will be testing. We simply omit the interaction term. (If you wish to include it, see how to do a two-way ANOVA test with interaction.) . | 1 2 3 4 . | import statsmodels.api as sm from statsmodels.formula.api import ols # C(...) means the variable is categorical, below model = ols('ncases ~ C(alcgp) + C(agegp)', data = data).fit() . | . A two-way ANOVA with interaction tests the following two null hypotheses. | The mean response is the same across all groups of the first factor. (In our example, that says the mean ncases is the same for all age groups.) | The mean response is the same across all groups of the second factor. (In our example, that says the mean ncases is the same for all alcohol consumption groups.) | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. Let’s let $\\alpha=0.05$ here. | 1 . | sm.stats.anova_lm(model, typ=2) . | . | | sum_sq | df | F | PR(&gt;F) | . | C(alcgp) | 52.695287 | 3.0 | 4.015660 | 1.029452e-02 | . | C(agegp) | 267.026108 | 5.0 | 12.209284 | 8.907998e-09 | . | Residual | 345.557743 | 79.0 | NaN | NaN | . The $p$-value for the alcohol consumption factor is in the first row, final column, $1.029452\\times10^{-2}$. It is less than $\\alpha$, so we can reject the null hypothesis that alcohol consumption does not affect the number of esophageal cancer cases. That is, we have reason to believe that it does affect the number of cases. The $p$-value for the age group factor is in the second row, final column, $8.907998\\times10^{-9}$. It is less than $\\alpha$, so we can reject the null hypothesis that age group does not affect the number of esophageal cancer cases. Again, we have reason to believe that it does affect the number of cases. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-way-anova-test-without-interaction/#using-statsmodels-in-python",
    "relUrl": "/how-to-do-a-two-way-anova-test-without-interaction/#using-statsmodels-in-python"
  },"571": {
    "doc": "How to do a two-way ANOVA test without interaction",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use R’s esoph dataset, about esophageal cancer cases. We will focus on the impact of age group (agegp) and alcohol consumption (alcgp) on the number of cases of the cancer (ncases). We ask, does either of these two factors affect the number of cases? . First, we load in the dataset. (See how to quickly load some sample data.) . | 1 2 3 4 . | # install.packages(\"datasets\") # if you have not already done this library(datasets) data &lt;- esoph head(data) . | . | 1 2 3 4 5 6 7 . | agegp alcgp tobgp ncases ncontrols 1 25-34 0-39g/day 0-9g/day 0 40 2 25-34 0-39g/day 10-19 0 10 3 25-34 0-39g/day 20-29 0 6 4 25-34 0-39g/day 30+ 0 5 5 25-34 40-79 0-9g/day 0 27 6 25-34 40-79 10-19 0 7 . | . Next, we create a model that includes the response variable we care about, plus the two categorical variables we will be testing. We simply omit the interaction term. (If you wish to include it, see how to do a two-way ANOVA test with interaction.) . | 1 2 . | # the * below means multiplication, to create an interaction term model &lt;- aov(ncases ~ agegp + alcgp, data = data) . | . A two-way ANOVA with interaction tests the following two null hypotheses. | The mean response is the same across all groups of the first factor. (In our example, that says the mean ncases is the same for all age groups.) | The mean response is the same across all groups of the second factor. (In our example, that says the mean ncases is the same for all alcohol consumption groups.) | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. Let’s let $\\alpha=0.05$ here. | 1 . | summary(model) . | . | 1 2 3 4 5 6 . | Df Sum Sq Mean Sq F value Pr(&gt;F) agegp 5 261.2 52.24 11.943 1.28e-08 *** alcgp 3 52.7 17.57 4.016 0.0103 * Residuals 79 345.6 4.37 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . The $p$-value for the alcohol consumption factor is in the first row, final column, $1.029452\\times10^{-2}$. It is less than $\\alpha$, so we can reject the null hypothesis that alcohol consumption does not affect the number of esophageal cancer cases. That is, we have reason to believe that it does affect the number of cases. The $p$-value for the age group factor is in the second row, final column, $8.907998\\times10^{-9}$. It is less than $\\alpha$, so we can reject the null hypothesis that age group does not affect the number of esophageal cancer cases. Again, we have reason to believe that it does affect the number of cases. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-two-way-anova-test-without-interaction/#solution-in-r",
    "relUrl": "/how-to-do-a-two-way-anova-test-without-interaction/#solution-in-r"
  },"572": {
    "doc": "How to do a two-way ANOVA test without interaction",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-two-way-anova-test-without-interaction/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-two-way-anova-test-without-interaction/#topics-that-include-this-task"
  },"573": {
    "doc": "How to do a two-way ANOVA test without interaction",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-two-way-anova-test-without-interaction/#opportunities",
    "relUrl": "/how-to-do-a-two-way-anova-test-without-interaction/#opportunities"
  },"574": {
    "doc": "How to do a Wilcoxon rank-sum test (in Python, using SciPy)",
    "title": "How to do a Wilcoxon rank-sum test (in Python, using SciPy)",
    "content": "# How to do a Wilcoxon rank-sum test (in Python, using SciPy) [See all solutions.](../how-to-do-a-wilcoxon-rank-sum-test) ## Task Assume we have two independent samples of data, $x_1, x_2, x_3, \\ldots x_n$ and $x'_1, x'_2, x'_3, \\ldots x'_m$, each from a different population. Also assume that the sample sizes are small or the populations are not normally distributed, but that the two population distributions are approximately the same shape. How can we test whether there is a significant difference between the two medians (or if one is significantly greater than or less than the other)? One method is the Wilcoxon Rank-Sum Test. Related tasks: * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) * [How to do a Wilcoxon signed-rank test](../how-to-do-a-wilcoxon-signed-rank-test) * [How to do a Wilcoxon signed-rank test for matched pairs](../how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs) ## Solution We're going to use fake data for illustrative purposes, but you can replace our fake data with your real data. Say our first sample, $x_1, x_2, x_3, \\ldots x_n$, has median $m_1$, and our second sample, $x'_1, x'_2, x'_3, \\ldots x'_m$, has median $m_2$. ```python import numpy as np # Replace sample1 and sample2 with your data sample1 = np.array([56, 31, 190, 176, 119, 15, 140, 152, 167]) sample2 = np.array([45, 36, 78, 54, 12, 25, 39, 48, 52, 70, 85]) ``` We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We'll let $\\alpha$ be 0.05. ### Two-tailed test To test the null hypothesis $H_0: m_1 - m_2 = 0$, that is, $m_1=m_2$, we use a two-tailed test: ```python from scipy import stats from scipy.stats import ranksums ranksums(sample1, sample2) ``` RanksumsResult(statistic=2.0892772350933626, pvalue=0.03668277440246522) Our p-value, $0.03668$, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The population medians are significantly different from each other. (The output above is slightly different from the output you would get by running this test in R, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) ### Right-tailed test To test the null hypothesis $H_0: m_1 - m_2 \\le 0$, that is, $m_1\\le m_2$, we use a right-tailed test: ```python ranksums(sample1, sample2, alternative = 'greater') ``` RanksumsResult(statistic=2.0892772350933626, pvalue=0.01834138720123261) Our p-value, $0.01834$, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The first population medians is significantly greater second. (The output above is slightly different from the output you would get by running this test in R, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) ### Left-tailed test To test the null hypothesis $H_0: m_1 - m_2 \\ge 0$, that is, $m_1\\ge m_2$, we use a left-tailed test: ```python ranksums(sample1, sample2, alternative = 'less') ``` RanksumsResult(statistic=2.0892772350933626, pvalue=0.9816586127987674) Our p-value, $0.98165$, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. The first population median is not significantly smaller than the second population median. (The output above is slightly different from the output you would get by running this test in R, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Wilcoxon rank-sum test/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-wilcoxon-rank-sum-test-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-wilcoxon-rank-sum-test-in-python-using-scipy/"
  },"575": {
    "doc": "How to do a Wilcoxon rank-sum test (in R)",
    "title": "How to do a Wilcoxon rank-sum test (in R)",
    "content": "# How to do a Wilcoxon rank-sum test (in R) [See all solutions.](../how-to-do-a-wilcoxon-rank-sum-test) ## Task Assume we have two independent samples of data, $x_1, x_2, x_3, \\ldots x_n$ and $x'_1, x'_2, x'_3, \\ldots x'_m$, each from a different population. Also assume that the sample sizes are small or the populations are not normally distributed, but that the two population distributions are approximately the same shape. How can we test whether there is a significant difference between the two medians (or if one is significantly greater than or less than the other)? One method is the Wilcoxon Rank-Sum Test. Related tasks: * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) * [How to do a Wilcoxon signed-rank test](../how-to-do-a-wilcoxon-signed-rank-test) * [How to do a Wilcoxon signed-rank test for matched pairs](../how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs) ## Solution We're going to use fake data for illustrative purposes, but you can replace our fake data with your real data. Say our first sample, $x_1, x_2, x_3, \\ldots x_k$, has median $m_1$, and our second sample, $x'_1, x'_2, x'_3, \\ldots x'_k$, has median $m_2$. ```R # Replace sample1 and sample2 with your data sample1 <- c(56, 31, 190, 176, 119, 15, 140, 152, 167) sample2 <- c(45, 36, 78, 54, 12, 25, 39, 48, 52, 70, 85) ``` We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We'll let $\\alpha$ be 0.05. ### Two-tailed test To test the null hypothesis $H_0: m_1 - m_2 = 0$, that is, $m_1=m_2$, we use a two-tailed test: ```R wilcox.test(sample1, sample2, alternative = \"two.sided\", mu = 0, paired = FALSE) ``` Wilcoxon rank sum exact test data: sample1 and sample2 W = 77, p-value = 0.03813 alternative hypothesis: true location shift is not equal to 0 Our p-value, $0.03813$, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The population medians are significantly different from each other. (The output above is slightly different than the output you would get by running this test in Python, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) ### Right-tailed test To test the null hypothesis $H_0: m_1 - m_2 \\le 0$, that is, $m_1\\le m_2$, we use a right-tailed test: ```R wilcox.test(sample1, sample2, alternative = \"greater\", mu = 0, paired = FALSE) ``` Wilcoxon rank sum exact test data: sample1 and sample2 W = 77, p-value = 0.01906 alternative hypothesis: true location shift is greater than 0 Our p-value, $0.01906$, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The first population medians is significantly greater second. (The output above is slightly different from the output you would get by running this test in Python, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) ### Left-tailed test To test the null hypothesis $H_0: m_1 - m_2 \\ge 0$, that is, $m_1\\ge m_2$, we use a left-tailed test: ```R wilcox.test(sample1, sample2, alternative = \"less\", mu = 0, paired = FALSE) ``` Wilcoxon rank sum exact test data: sample1 and sample2 W = 77, p-value = 0.9845 alternative hypothesis: true location shift is less than 0 Our p-value, $0.9845$, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. The first population median is not significantly smaller than the second population median. (The output above is slightly different from the output you would get by running this test in Python, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) NOTE: If there are ties in the data and there are fewer than 50 observations in each sample, then R will compute a $p$-value using the normal approximation, and there will be an error message indicating that the exact $p$-value cannot be calculated. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Wilcoxon rank-sum test/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-wilcoxon-rank-sum-test-in-r/",
    "relUrl": "/how-to-do-a-wilcoxon-rank-sum-test-in-r/"
  },"576": {
    "doc": "How to do a Wilcoxon rank-sum test",
    "title": "How to do a Wilcoxon rank-sum test",
    "content": " ",
    "url": "/how-to-do-a-wilcoxon-rank-sum-test/",
    "relUrl": "/how-to-do-a-wilcoxon-rank-sum-test/"
  },"577": {
    "doc": "How to do a Wilcoxon rank-sum test",
    "title": "Description",
    "content": "Assume we have two independent samples of data, $x_1, x_2, x_3, \\ldots x_n$ and $x’_1, x’_2, x’_3, \\ldots x’_m$, each from a different population. Also assume that the sample sizes are small or the populations are not normally distributed, but that the two population distributions are approximately the same shape. How can we test whether there is a significant difference between the two medians (or if one is significantly greater than or less than the other)? One method is the Wilcoxon Rank-Sum Test. Related tasks: . | How to do a Kruskal-Wallis test | How to do a Wilcoxon signed-rank test | How to do a Wilcoxon signed-rank test for matched pairs | . ",
    "url": "/how-to-do-a-wilcoxon-rank-sum-test/#description",
    "relUrl": "/how-to-do-a-wilcoxon-rank-sum-test/#description"
  },"578": {
    "doc": "How to do a Wilcoxon rank-sum test",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’re going to use fake data for illustrative purposes, but you can replace our fake data with your real data. Say our first sample, $x_1, x_2, x_3, \\ldots x_n$, has median $m_1$, and our second sample, $x’_1, x’_2, x’_3, \\ldots x’_m$, has median $m_2$. | 1 2 3 4 . | import numpy as np # Replace sample1 and sample2 with your data sample1 = np.array([56, 31, 190, 176, 119, 15, 140, 152, 167]) sample2 = np.array([45, 36, 78, 54, 12, 25, 39, 48, 52, 70, 85]) . | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We’ll let $\\alpha$ be 0.05. Two-tailed test . To test the null hypothesis $H_0: m_1 - m_2 = 0$, that is, $m_1=m_2$, we use a two-tailed test: . | 1 2 3 . | from scipy import stats from scipy.stats import ranksums ranksums(sample1, sample2) . | . | 1 . | RanksumsResult(statistic=2.0892772350933626, pvalue=0.03668277440246522) . | . Our p-value, $0.03668$, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The population medians are significantly different from each other. (The output above is slightly different from the output you would get by running this test in R, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) . Right-tailed test . To test the null hypothesis $H_0: m_1 - m_2 \\le 0$, that is, $m_1\\le m_2$, we use a right-tailed test: . | 1 . | ranksums(sample1, sample2, alternative = 'greater') . | . | 1 . | RanksumsResult(statistic=2.0892772350933626, pvalue=0.01834138720123261) . | . Our p-value, $0.01834$, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The first population medians is significantly greater second. (The output above is slightly different from the output you would get by running this test in R, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) . Left-tailed test . To test the null hypothesis $H_0: m_1 - m_2 \\ge 0$, that is, $m_1\\ge m_2$, we use a left-tailed test: . | 1 . | ranksums(sample1, sample2, alternative = 'less') . | . | 1 . | RanksumsResult(statistic=2.0892772350933626, pvalue=0.9816586127987674) . | . Our p-value, $0.98165$, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. The first population median is not significantly smaller than the second population median. (The output above is slightly different from the output you would get by running this test in R, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) . Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-wilcoxon-rank-sum-test/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-wilcoxon-rank-sum-test/#using-scipy-in-python"
  },"579": {
    "doc": "How to do a Wilcoxon rank-sum test",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use fake data for illustrative purposes, but you can replace our fake data with your real data. Say our first sample, $x_1, x_2, x_3, \\ldots x_k$, has median $m_1$, and our second sample, $x’_1, x’_2, x’_3, \\ldots x’_k$, has median $m_2$. | 1 2 3 . | # Replace sample1 and sample2 with your data sample1 &lt;- c(56, 31, 190, 176, 119, 15, 140, 152, 167) sample2 &lt;- c(45, 36, 78, 54, 12, 25, 39, 48, 52, 70, 85) . | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We’ll let $\\alpha$ be 0.05. Two-tailed test . To test the null hypothesis $H_0: m_1 - m_2 = 0$, that is, $m_1=m_2$, we use a two-tailed test: . | 1 . | wilcox.test(sample1, sample2, alternative = \"two.sided\", mu = 0, paired = FALSE) . | . | 1 2 3 4 5 . | Wilcoxon rank sum exact test data: sample1 and sample2 W = 77, p-value = 0.03813 alternative hypothesis: true location shift is not equal to 0 . | . Our p-value, $0.03813$, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The population medians are significantly different from each other. (The output above is slightly different than the output you would get by running this test in Python, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) . Right-tailed test . To test the null hypothesis $H_0: m_1 - m_2 \\le 0$, that is, $m_1\\le m_2$, we use a right-tailed test: . | 1 . | wilcox.test(sample1, sample2, alternative = \"greater\", mu = 0, paired = FALSE) . | . | 1 2 3 4 5 . | Wilcoxon rank sum exact test data: sample1 and sample2 W = 77, p-value = 0.01906 alternative hypothesis: true location shift is greater than 0 . | . Our p-value, $0.01906$, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The first population medians is significantly greater second. (The output above is slightly different from the output you would get by running this test in Python, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) . Left-tailed test . To test the null hypothesis $H_0: m_1 - m_2 \\ge 0$, that is, $m_1\\ge m_2$, we use a left-tailed test: . | 1 . | wilcox.test(sample1, sample2, alternative = \"less\", mu = 0, paired = FALSE) . | . | 1 2 3 4 5 . | Wilcoxon rank sum exact test data: sample1 and sample2 W = 77, p-value = 0.9845 alternative hypothesis: true location shift is less than 0 . | . Our p-value, $0.9845$, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. The first population median is not significantly smaller than the second population median. (The output above is slightly different from the output you would get by running this test in Python, because SciPy uses a normal distribution internally, but R uses a Wilcoxon distribution.) . NOTE: If there are ties in the data and there are fewer than 50 observations in each sample, then R will compute a $p$-value using the normal approximation, and there will be an error message indicating that the exact $p$-value cannot be calculated. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-wilcoxon-rank-sum-test/#solution-in-r",
    "relUrl": "/how-to-do-a-wilcoxon-rank-sum-test/#solution-in-r"
  },"580": {
    "doc": "How to do a Wilcoxon rank-sum test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-wilcoxon-rank-sum-test/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-wilcoxon-rank-sum-test/#topics-that-include-this-task"
  },"581": {
    "doc": "How to do a Wilcoxon rank-sum test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-wilcoxon-rank-sum-test/#opportunities",
    "relUrl": "/how-to-do-a-wilcoxon-rank-sum-test/#opportunities"
  },"582": {
    "doc": "How to do a Wilcoxon signed-rank test for matched pairs (in Python, using SciPy)",
    "title": "How to do a Wilcoxon signed-rank test for matched pairs (in Python, using SciPy)",
    "content": "# How to do a Wilcoxon signed-rank test for matched pairs (in Python, using SciPy) [See all solutions.](../how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs) ## Task Assume we have two samples of data that come in matched pairs, $x_1, x_2, x_3, \\ldots x_k$ and $x'_1, x'_2, x'_3, \\ldots x'_k$, which we might pair up as $(x_1,x'_1),(x_2,x'_2),\\ldots,(x_k,x'_k)$. The two samples may be from different populations. Also assume that the sample sizes are small or the populations are not normally distributed. Consider measuring the difference in each pair, $x_1-x'_1,x_2-x'_2,\\ldots,x_k-x'_k$. We want to perform tests that compare the median of those differences, $m_D$, to a hypothesized value (equal, greater, or less). One method is the Wilcoxon Signed-Rank Test for Matched Pairs. Related tasks: * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) * [How to do a Wilcoxon rank-sum test](../how-to-do-a-wilcoxon-rank-sum-test) * [How to do a Wilcoxon signed-rank test](../how-to-do-a-wilcoxon-signed-rank-test) ## Solution The method we will use is equivalent to subtracting the two samples and then performing the signed-rank test. See [how to do a Wilcoxon signed-rank test](../how-to-do-a-wilcoxon-signed-rank-test) to compare the two methods. We're going to use fake data for illustrative purposes, but you can replace our fake data with your real data. ```python import numpy as np # Replace sample1 and sample2 with your data sample1 = np.array([156, 133, 90, 176, 119, 120, 40, 52, 167, 80]) sample2 = np.array([45, 36, 78, 54, 12, 25, 39, 48, 52, 70]) ``` We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We'll let $\\alpha$ be 0.05. ### Two-tailed test To test the null hypothesis $H_0: m_D = 0$, we use a two-tailed test: ```python from scipy import stats from scipy.stats import wilcoxon wilcoxon(sample1 - sample2) ``` WilcoxonResult(statistic=0.0, pvalue=0.001953125) Our p-value, 0.001953125, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The median difference is significantly different from zero. ### Right-tailed test To test the null hypothesis $H_0: m_D \\le 0$, we use a right-tailed test: ```python wilcoxon(sample1 - sample2, alternative = 'greater') ``` WilcoxonResult(statistic=55.0, pvalue=0.0009765625) Our p-value, 0.0009765625, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The median difference is significantly greater than zero. ### Left-tailed test To test the null hypothesis $H_0: m_D \\ge 0$, we use a left-tailed test: ```python wilcoxon(sample1 - sample2, alternative = 'less') ``` WilcoxonResult(statistic=55.0, pvalue=1.0) Our p-value, 1.0, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We should continue to assume that the mean difference may be less than (or equal to) zero. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Wilcoxon signed-rank test for matched pairs/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs-in-python-using-scipy/"
  },"583": {
    "doc": "How to do a Wilcoxon signed-rank test for matched pairs (in R)",
    "title": "How to do a Wilcoxon signed-rank test for matched pairs (in R)",
    "content": "# How to do a Wilcoxon signed-rank test for matched pairs (in R) [See all solutions.](../how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs) ## Task Assume we have two samples of data that come in matched pairs, $x_1, x_2, x_3, \\ldots x_k$ and $x'_1, x'_2, x'_3, \\ldots x'_k$, which we might pair up as $(x_1,x'_1),(x_2,x'_2),\\ldots,(x_k,x'_k)$. The two samples may be from different populations. Also assume that the sample sizes are small or the populations are not normally distributed. Consider measuring the difference in each pair, $x_1-x'_1,x_2-x'_2,\\ldots,x_k-x'_k$. We want to perform tests that compare the median of those differences, $m_D$, to a hypothesized value (equal, greater, or less). One method is the Wilcoxon Signed-Rank Test for Matched Pairs. Related tasks: * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) * [How to do a Wilcoxon rank-sum test](../how-to-do-a-wilcoxon-rank-sum-test) * [How to do a Wilcoxon signed-rank test](../how-to-do-a-wilcoxon-signed-rank-test) ## Solution The method we will use is equivalent to subtracting the two samples and then performing the signed-rank test. See [how to do a Wilcoxon signed-rank test](../how-to-do-a-wilcoxon-signed-rank-test) to compare the two methods. We're going to use fake data for illustrative purposes, but you can replace our fake data with your real data. ```R # Replace sample1 and sample2 with your data sample1 <- c(156, 133, 90, 176, 119, 120, 40, 52, 167, 80) sample2 <- c(45, 36, 78, 54, 12, 25, 39, 48, 52, 70) ``` We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We'll let $\\alpha$ be 0.05. ### Two-tailed test To test the null hypothesis $H_0: m_D = 0$, we use a two-tailed test: ```R wilcox.test(sample1, sample2, alternative = \"two.sided\", mu = 0, paired = TRUE) ``` Wilcoxon signed rank exact test data: sample1 and sample2 V = 55, p-value = 0.001953 alternative hypothesis: true location shift is not equal to 0 Our p-value, 0.00195, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The median difference is significantly different from zero. ### Right-tailed test To test the null hypothesis $H_0: m_D \\le 0$, we use a right-tailed test: ```R wilcox.test(sample1, sample2, alternative = \"greater\", mu = 0, paired = TRUE) ``` Wilcoxon signed rank exact test data: sample1 and sample2 V = 55, p-value = 0.0009766 alternative hypothesis: true location shift is greater than 0 Our p-value, 0.0009766, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The median difference is significantly greater than zero. ### Left-tailed test To test the null hypothesis $H_0: m_D \\ge 0$, we use a left-tailed test: ```R wilcox.test(sample1, sample2, alternative = \"less\", mu = 0, paired = TRUE) ``` Wilcoxon signed rank exact test data: sample1 and sample2 V = 55, p-value = 1 alternative hypothesis: true location shift is less than 0 Our p-value, 1.0, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We should continue to assume that the mean difference may be less than (or equal to) zero. NOTE: If there are ties in the data and there are fewer than 50 observations in each sample, then R will compute a $p$-value using the normal approximation, and there will be an error message indicating that the exact $p$-value cannot be calculated. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Wilcoxon signed-rank test for matched pairs/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs-in-r/",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs-in-r/"
  },"584": {
    "doc": "How to do a Wilcoxon signed-rank test for matched pairs",
    "title": "How to do a Wilcoxon signed-rank test for matched pairs",
    "content": " ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/"
  },"585": {
    "doc": "How to do a Wilcoxon signed-rank test for matched pairs",
    "title": "Description",
    "content": "Assume we have two samples of data that come in matched pairs, $x_1, x_2, x_3, \\ldots x_k$ and $x’_1, x’_2, x’_3, \\ldots x’_k$, which we might pair up as $(x_1,x’_1),(x_2,x’_2),\\ldots,(x_k,x’_k)$. The two samples may be from different populations. Also assume that the sample sizes are small or the populations are not normally distributed. Consider measuring the difference in each pair, $x_1-x’_1,x_2-x’_2,\\ldots,x_k-x’_k$. We want to perform tests that compare the median of those differences, $m_D$, to a hypothesized value (equal, greater, or less). One method is the Wilcoxon Signed-Rank Test for Matched Pairs. Related tasks: . | How to do a Kruskal-Wallis test | How to do a Wilcoxon rank-sum test | How to do a Wilcoxon signed-rank test | . ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#description",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#description"
  },"586": {
    "doc": "How to do a Wilcoxon signed-rank test for matched pairs",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. The method we will use is equivalent to subtracting the two samples and then performing the signed-rank test. See how to do a Wilcoxon signed-rank test to compare the two methods. We’re going to use fake data for illustrative purposes, but you can replace our fake data with your real data. | 1 2 3 4 . | import numpy as np # Replace sample1 and sample2 with your data sample1 = np.array([156, 133, 90, 176, 119, 120, 40, 52, 167, 80]) sample2 = np.array([45, 36, 78, 54, 12, 25, 39, 48, 52, 70]) . | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We’ll let $\\alpha$ be 0.05. Two-tailed test . To test the null hypothesis $H_0: m_D = 0$, we use a two-tailed test: . | 1 2 3 . | from scipy import stats from scipy.stats import wilcoxon wilcoxon(sample1 - sample2) . | . | 1 . | WilcoxonResult(statistic=0.0, pvalue=0.001953125) . | . Our p-value, 0.001953125, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The median difference is significantly different from zero. Right-tailed test . To test the null hypothesis $H_0: m_D \\le 0$, we use a right-tailed test: . | 1 . | wilcoxon(sample1 - sample2, alternative = 'greater') . | . | 1 . | WilcoxonResult(statistic=55.0, pvalue=0.0009765625) . | . Our p-value, 0.0009765625, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The median difference is significantly greater than zero. Left-tailed test . To test the null hypothesis $H_0: m_D \\ge 0$, we use a left-tailed test: . | 1 . | wilcoxon(sample1 - sample2, alternative = 'less') . | . | 1 . | WilcoxonResult(statistic=55.0, pvalue=1.0) . | . Our p-value, 1.0, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We should continue to assume that the mean difference may be less than (or equal to) zero. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#using-scipy-in-python"
  },"587": {
    "doc": "How to do a Wilcoxon signed-rank test for matched pairs",
    "title": "Solution, in R",
    "content": "View this solution alone. The method we will use is equivalent to subtracting the two samples and then performing the signed-rank test. See how to do a Wilcoxon signed-rank test to compare the two methods. We’re going to use fake data for illustrative purposes, but you can replace our fake data with your real data. | 1 2 3 . | # Replace sample1 and sample2 with your data sample1 &lt;- c(156, 133, 90, 176, 119, 120, 40, 52, 167, 80) sample2 &lt;- c(45, 36, 78, 54, 12, 25, 39, 48, 52, 70) . | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We’ll let $\\alpha$ be 0.05. Two-tailed test . To test the null hypothesis $H_0: m_D = 0$, we use a two-tailed test: . | 1 . | wilcox.test(sample1, sample2, alternative = \"two.sided\", mu = 0, paired = TRUE) . | . | 1 2 3 4 5 . | Wilcoxon signed rank exact test data: sample1 and sample2 V = 55, p-value = 0.001953 alternative hypothesis: true location shift is not equal to 0 . | . Our p-value, 0.00195, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The median difference is significantly different from zero. Right-tailed test . To test the null hypothesis $H_0: m_D \\le 0$, we use a right-tailed test: . | 1 . | wilcox.test(sample1, sample2, alternative = \"greater\", mu = 0, paired = TRUE) . | . | 1 2 3 4 5 . | Wilcoxon signed rank exact test data: sample1 and sample2 V = 55, p-value = 0.0009766 alternative hypothesis: true location shift is greater than 0 . | . Our p-value, 0.0009766, is less than $\\alpha=0.05$, so we have sufficient evidence to reject the null hypothesis. The median difference is significantly greater than zero. Left-tailed test . To test the null hypothesis $H_0: m_D \\ge 0$, we use a left-tailed test: . | 1 . | wilcox.test(sample1, sample2, alternative = \"less\", mu = 0, paired = TRUE) . | . | 1 2 3 4 5 . | Wilcoxon signed rank exact test data: sample1 and sample2 V = 55, p-value = 1 alternative hypothesis: true location shift is less than 0 . | . Our p-value, 1.0, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We should continue to assume that the mean difference may be less than (or equal to) zero. NOTE: If there are ties in the data and there are fewer than 50 observations in each sample, then R will compute a $p$-value using the normal approximation, and there will be an error message indicating that the exact $p$-value cannot be calculated. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#solution-in-r",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#solution-in-r"
  },"588": {
    "doc": "How to do a Wilcoxon signed-rank test for matched pairs",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#topics-that-include-this-task"
  },"589": {
    "doc": "How to do a Wilcoxon signed-rank test for matched pairs",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#opportunities",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs/#opportunities"
  },"590": {
    "doc": "How to do a Wilcoxon signed-rank test (in Python, using SciPy)",
    "title": "How to do a Wilcoxon signed-rank test (in Python, using SciPy)",
    "content": "# How to do a Wilcoxon signed-rank test (in Python, using SciPy) [See all solutions.](../how-to-do-a-wilcoxon-signed-rank-test) ## Task Assume we a sample of data, $x_1, x_2, x_3, \\ldots x_k$ and either the sample size is small or the population is not normally distributed. But we still want to perform tests that compare the sample median to a hypothesized value (equal, greater, or less). One method is the Wilcoxon Signed-Rank Test. Related tasks: * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) * [How to do a Wilcoxon rank-sum test](../how-to-do-a-wilcoxon-rank-sum-test) * [How to do a Wilcoxon signed-rank test for matched pairs](../how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs) ## Solution We're going to use fake data for illustrative purposes, but you can replace our fake data with your real data. Say our sample, $x_1, x_2, x_3, \\ldots x_k$, has median $m$. ```python import numpy as np # Replace the next line with your data sample = np.array([19, 4, 23, 16, 1, 8, 30, 25, 13]) ``` We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We'll let $\\alpha$ be 0.05. In the examples below, we will be comparing the median $m$ to a hypothesized value of $a=10$, but you can use any value for $a$. ### Two-tailed test To test the null hypothesis $H_0: m=a$, we use a two-tailed test: ```python from scipy import stats from scipy.stats import wilcoxon a = 10 # or your chosen value for comparison wilcoxon(sample - a) ``` WilcoxonResult(statistic=10.0, pvalue=0.1640625) Our p-value, 0.1640625, is greater than $\\alpha=0.05$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is equal to 10. ### Right-tailed test To test the null hypothesis $H_0: m\\ge a$, we use a right-tailed test: ```python wilcoxon(sample - a, alternative = 'less') ``` WilcoxonResult(statistic=35.0, pvalue=0.935546875) Our p-value, 0.935546875, is greater than $\\alpha=0.05$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is less than (or equal to) 10. ### Left-tailed test To test the null hypothesis $H_0: m\\le a$, we use a left-tailed test: ```python wilcoxon(sample - a, alternative = 'greater') ``` WilcoxonResult(statistic=35.0, pvalue=0.08203125) Our p-value, 0.08203125, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is greater than (or equal to) 10. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Wilcoxon signed-rank test/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-in-python-using-scipy/",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-in-python-using-scipy/"
  },"591": {
    "doc": "How to do a Wilcoxon signed-rank test (in R)",
    "title": "How to do a Wilcoxon signed-rank test (in R)",
    "content": "# How to do a Wilcoxon signed-rank test (in R) [See all solutions.](../how-to-do-a-wilcoxon-signed-rank-test) ## Task Assume we a sample of data, $x_1, x_2, x_3, \\ldots x_k$ and either the sample size is small or the population is not normally distributed. But we still want to perform tests that compare the sample median to a hypothesized value (equal, greater, or less). One method is the Wilcoxon Signed-Rank Test. Related tasks: * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) * [How to do a Wilcoxon rank-sum test](../how-to-do-a-wilcoxon-rank-sum-test) * [How to do a Wilcoxon signed-rank test for matched pairs](../how-to-do-a-wilcoxon-signed-rank-test-for-matched-pairs) ## Solution We're going to use fake data for illustrative purposes, but you can replace our fake data with your real data. Say our sample, $x_1, x_2, x_3, \\ldots x_k$, has median $m$. ```R # Replace the next line with your data sample <- c(19, 4, 23, 16, 1, 8, 30, 25, 13) ``` We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We'll let $\\alpha$ be 0.05. In the examples below, we will be comparing the median $m$ to a hypothesized value of $a=10$, but you can use any value for $a$. ### Two-tailed test To test the null hypothesis $H_0: m=a$, we use a two-tailed test: ```R a <- 10 wilcox.test(sample, mu = a, alternative = \"two.sided\") ``` Warning message in wilcox.test.default(sample, mu = a, alternative = \"two.sided\"): “cannot compute exact p-value with ties” Wilcoxon signed rank test with continuity correction data: sample V = 35, p-value = 0.1544 alternative hypothesis: true location is not equal to 10 Our p-value, 0.1544, is greater than $\\alpha=0.05$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is equal to 10. ### Right-tailed test To test the null hypothesis $H_0: m\\ge a$, we use a right-tailed test: ```R wilcox.test(sample, mu = a, alternative = \"less\") ``` Warning message in wilcox.test.default(sample, mu = a, alternative = \"less\"): “cannot compute exact p-value with ties” Wilcoxon signed rank test with continuity correction data: sample V = 35, p-value = 0.9386 alternative hypothesis: true location is less than 10 Our p-value, 0.9386, is greater than $\\alpha=0.05$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is less than (or equal to) 10. ### Left-tailed test To test the null hypothesis $H_0: m\\le a$, we use a left-tailed test: ```R wilcox.test(sample, mu = a, alternative = \"greater\") ``` Warning message in wilcox.test.default(sample, mu = a, alternative = \"greater\"): “cannot compute exact p-value with ties” Wilcoxon signed rank test with continuity correction data: sample V = 35, p-value = 0.0772 alternative hypothesis: true location is greater than 10 Our p-value, 0.0772, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is greater than (or equal to) 10. NOTE: If there are ties in the data and there are fewer than 50 observations in each sample, then R will compute a $p$-value using the normal approximation, and there will be an error message indicating that the exact $p$-value cannot be calculated. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do a Wilcoxon signed-rank test/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test-in-r/",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test-in-r/"
  },"592": {
    "doc": "How to do a Wilcoxon signed-rank test",
    "title": "How to do a Wilcoxon signed-rank test",
    "content": " ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test/",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test/"
  },"593": {
    "doc": "How to do a Wilcoxon signed-rank test",
    "title": "Description",
    "content": "Assume we a sample of data, $x_1, x_2, x_3, \\ldots x_k$ and either the sample size is small or the population is not normally distributed. But we still want to perform tests that compare the sample median to a hypothesized value (equal, greater, or less). One method is the Wilcoxon Signed-Rank Test. Related tasks: . | How to do a Kruskal-Wallis test | How to do a Wilcoxon rank-sum test | How to do a Wilcoxon signed-rank test for matched pairs | . ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test/#description",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test/#description"
  },"594": {
    "doc": "How to do a Wilcoxon signed-rank test",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’re going to use fake data for illustrative purposes, but you can replace our fake data with your real data. Say our sample, $x_1, x_2, x_3, \\ldots x_k$, has median $m$. | 1 2 3 . | import numpy as np # Replace the next line with your data sample = np.array([19, 4, 23, 16, 1, 8, 30, 25, 13]) . | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We’ll let $\\alpha$ be 0.05. In the examples below, we will be comparing the median $m$ to a hypothesized value of $a=10$, but you can use any value for $a$. Two-tailed test . To test the null hypothesis $H_0: m=a$, we use a two-tailed test: . | 1 2 3 4 . | from scipy import stats from scipy.stats import wilcoxon a = 10 # or your chosen value for comparison wilcoxon(sample - a) . | . | 1 . | WilcoxonResult(statistic=10.0, pvalue=0.1640625) . | . Our p-value, 0.1640625, is greater than $\\alpha=0.05$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is equal to 10. Right-tailed test . To test the null hypothesis $H_0: m\\ge a$, we use a right-tailed test: . | 1 . | wilcoxon(sample - a, alternative = 'less') . | . | 1 . | WilcoxonResult(statistic=35.0, pvalue=0.935546875) . | . Our p-value, 0.935546875, is greater than $\\alpha=0.05$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is less than (or equal to) 10. Left-tailed test . To test the null hypothesis $H_0: m\\le a$, we use a left-tailed test: . | 1 . | wilcoxon(sample - a, alternative = 'greater') . | . | 1 . | WilcoxonResult(statistic=35.0, pvalue=0.08203125) . | . Our p-value, 0.08203125, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is greater than (or equal to) 10. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test/#using-scipy-in-python",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test/#using-scipy-in-python"
  },"595": {
    "doc": "How to do a Wilcoxon signed-rank test",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use fake data for illustrative purposes, but you can replace our fake data with your real data. Say our sample, $x_1, x_2, x_3, \\ldots x_k$, has median $m$. | 1 2 . | # Replace the next line with your data sample &lt;- c(19, 4, 23, 16, 1, 8, 30, 25, 13) . | . We choose a value, $0 \\le \\alpha \\le 1$, as the Type I Error Rate. We’ll let $\\alpha$ be 0.05. In the examples below, we will be comparing the median $m$ to a hypothesized value of $a=10$, but you can use any value for $a$. Two-tailed test . To test the null hypothesis $H_0: m=a$, we use a two-tailed test: . | 1 2 . | a &lt;- 10 wilcox.test(sample, mu = a, alternative = \"two.sided\") . | . | 1 2 3 4 5 6 7 8 9 10 11 . | Warning message in wilcox.test.default(sample, mu = a, alternative = \"two.sided\"): “cannot compute exact p-value with ties” Wilcoxon signed rank test with continuity correction data: sample V = 35, p-value = 0.1544 alternative hypothesis: true location is not equal to 10 . | . Our p-value, 0.1544, is greater than $\\alpha=0.05$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is equal to 10. Right-tailed test . To test the null hypothesis $H_0: m\\ge a$, we use a right-tailed test: . | 1 . | wilcox.test(sample, mu = a, alternative = \"less\") . | . | 1 2 3 4 5 6 7 8 9 10 11 . | Warning message in wilcox.test.default(sample, mu = a, alternative = \"less\"): “cannot compute exact p-value with ties” Wilcoxon signed rank test with continuity correction data: sample V = 35, p-value = 0.9386 alternative hypothesis: true location is less than 10 . | . Our p-value, 0.9386, is greater than $\\alpha=0.05$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is less than (or equal to) 10. Left-tailed test . To test the null hypothesis $H_0: m\\le a$, we use a left-tailed test: . | 1 . | wilcox.test(sample, mu = a, alternative = \"greater\") . | . | 1 2 3 4 5 6 7 8 9 10 11 . | Warning message in wilcox.test.default(sample, mu = a, alternative = \"greater\"): “cannot compute exact p-value with ties” Wilcoxon signed rank test with continuity correction data: sample V = 35, p-value = 0.0772 alternative hypothesis: true location is greater than 10 . | . Our p-value, 0.0772, is greater than $\\alpha$, so we do not have sufficient evidence to reject the null hypothesis. We may continue to assume the population median is greater than (or equal to) 10. NOTE: If there are ties in the data and there are fewer than 50 observations in each sample, then R will compute a $p$-value using the normal approximation, and there will be an error message indicating that the exact $p$-value cannot be calculated. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test/#solution-in-r",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test/#solution-in-r"
  },"596": {
    "doc": "How to do a Wilcoxon signed-rank test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test/#topics-that-include-this-task",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test/#topics-that-include-this-task"
  },"597": {
    "doc": "How to do a Wilcoxon signed-rank test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-a-wilcoxon-signed-rank-test/#opportunities",
    "relUrl": "/how-to-do-a-wilcoxon-signed-rank-test/#opportunities"
  },"598": {
    "doc": "How to do basic mathematical computations (in Excel)",
    "title": "How to do basic mathematical computations (in Excel)",
    "content": "# How to do basic mathematical computations (in Excel) [See all solutions.](../how-to-do-basic-mathematical-computations) ## Task How do we write the most common mathematical operations in a given piece of software? For example, how do we write multiplication, or exponentiation, or logarithms, in Python vs. R vs. Excel, and so on? ## Solution Each of the formulas shown on the right of the table below is valid code for use in Excel formulas, in cells in a worksheet. | Mathematical notation | Excel notation | Example | --------------------- | -------------- | ------------- | $x+y$ | `x+y` | `=A1+B1` | $x-y$ | `x-y` | `=A1-B1` | $xy$ | `x*y` | `=A1*B1` | $\\frac xy$ | `x/y` | `=A1/B1` | $x^y$ | `x^y` | `=A1^B1` | $\\vert x\\vert$ | `ABS(x)` | `=ABS(A1)` | $\\ln x$ | `LN(x)` | `=LN(A1)` | $\\log_a b$ | `LOG(b,a)` | `=LOG(A1,B1)` | $e^x$ | `EXP(x)` | `=EXP(A1)` | $\\pi$ | `PI()` | `=PI()` | $\\sin x$ | `SIN(x)` | `=SIN(A1)` | $\\sin^{-1} x$ | `ASIN(x)` | `=ASIN(A1)` | $\\sqrt x$ | `SQRT(x)` | `=SQRT(A1)` | Other trigonometric functions are also available besides just `SIN`, including `COS`, `TAN`, etc. Content last modified on 09 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do basic mathematical computations/Excel.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-basic-mathematical-computations-in-excel/",
    "relUrl": "/how-to-do-basic-mathematical-computations-in-excel/"
  },"599": {
    "doc": "How to do basic mathematical computations (in Julia)",
    "title": "How to do basic mathematical computations (in Julia)",
    "content": "# How to do basic mathematical computations (in Julia) [See all solutions.](../how-to-do-basic-mathematical-computations) ## Task How do we write the most common mathematical operations in a given piece of software? For example, how do we write multiplication, or exponentiation, or logarithms, in Python vs. R vs. Excel, and so on? ## Solution | Mathematical notation | Julia code |--|--| $x+y$ | `x+y` | $x-y$ | `x-y` | $xy$ | `x*y` | $\\frac xy$ | `x/y` (or `y\\x`) | $\\left\\lfloor\\frac xy\\right\\rfloor$ | `x÷y` | remainder of $x\\div y$ | `x%y` | $x^y$ | `x^y` | $\\vert x\\vert$ | `abs(x)` | $\\ln x$ | `log(x)` | $\\log_a b$ | `log(a,b)` | $e^x$ | `exp(x)` | $\\pi$ | `pi` | $\\sin x$ | `sin(x)` | $\\sin^{-1} x$ | `asin(x)` | $\\sqrt x$ | `sqrt(x)` | Other trigonometric functions are also available besides just `sin` including `cos`, `tan`, etc. Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do basic mathematical computations/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-basic-mathematical-computations-in-julia/",
    "relUrl": "/how-to-do-basic-mathematical-computations-in-julia/"
  },"600": {
    "doc": "How to do basic mathematical computations (in Python, using NumPy)",
    "title": "How to do basic mathematical computations (in Python, using NumPy)",
    "content": "# How to do basic mathematical computations (in Python, using NumPy) [See all solutions.](../how-to-do-basic-mathematical-computations) ## Task How do we write the most common mathematical operations in a given piece of software? For example, how do we write multiplication, or exponentiation, or logarithms, in Python vs. R vs. Excel, and so on? ## Solution This answer assumes you have imported NumPy as follows. ```python import numpy as np ``` | Mathematical notation | Python code | Requires NumPy? |--|--|--| $x+y$ | `x+y` | no | $x-y$ | `x-y` | no | $xy$ | `x*y` | no | $\\frac xy$ | `x/y` | no | $\\left\\lfloor\\frac xy\\right\\rfloor$ | `x//y` | no | $\\left\\lfloor\\frac xy\\right\\rfloor$ | `np.floor_divide(x,y)` | yes | remainder of $x\\div y$ | `x%y` | no | remainder of $x\\div y$ | `np.remainder(x,y)` | yes | $x^y$ | `x**y` | no | $\\vert x\\vert$ | `abs(x)` | no | $\\vert x\\vert$ | `np.abs(x)` | yes | $\\ln x$ | `np.log(x)` | yes | $\\log_a b$ | `np.log(b)/np.log(a)` | yes | $e^x$ | `np.exp(x)` | yes | $\\pi$ | `np.pi` | yes | $\\sin x$ | `np.sin(x)` | yes | $\\sin^{-1} x$ | `np.asin(x)` | yes | $\\sqrt x$ | `x**0.5` | no | $\\sqrt x$ | `np.sqrt(x)` | yes | Other trigonometric functions are also available besides just `np.sin`, including `np.cos`, `np.tan`, etc. NumPy automatically applies any of these functions to all entries of a NumPy array or pandas Series, but the built-in Python functions do not have this feature. For example, to square all numbers in an array, see below. ```python import numpy as np example_array = np.array( [ -3, 2, 0.5, -1, 10, 9.2, -3.3 ] ) example_array ** 2 ``` array([ 9. , 4. , 0.25, 1. , 100. , 84.64, 10.89]) Content last modified on 14 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do basic mathematical computations/Python, using NumPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-basic-mathematical-computations-in-python-using-numpy/",
    "relUrl": "/how-to-do-basic-mathematical-computations-in-python-using-numpy/"
  },"601": {
    "doc": "How to do basic mathematical computations (in Python, using SymPy)",
    "title": "How to do basic mathematical computations (in Python, using SymPy)",
    "content": "# How to do basic mathematical computations (in Python, using SymPy) [See all solutions.](../how-to-do-basic-mathematical-computations) ## Task How do we write the most common mathematical operations in a given piece of software? For example, how do we write multiplication, or exponentiation, or logarithms, in Python vs. R vs. Excel, and so on? ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` | Mathematical notation | Python code | Requires SymPy? |--|--|--| $x+y$ | `x+y` | no | $x-y$ | `x-y` | no | $xy$ | `x*y` | no | $\\frac xy$ | `x/y` | no | $\\left\\lfloor\\frac xy\\right\\rfloor$ | `x//y` | no | remainder of $x\\div y$ | `x%y` | no | $x^y$ | `x**y` | no | $\\vert x\\vert$ | `abs(x)` | no | $\\ln x$ | `log(x)` | yes | $\\log_a b$ | `log(b,a)` | yes | $e^x$ | `E` | yes | $\\pi$ | `pi` | yes | $\\sin x$ | `sin(x)` | yes | $\\sin^{-1} x$ | `asin(x)` | yes | $\\sqrt x$ | `sqrt(x)` | yes | Other trigonometric functions are also available besides just `sin`, including `cos`, `tan`, etc. Note that SymPy gives precise answers to mathematical queries, which may not be what you want. ```python sqrt(2) ``` $\\displaystyle \\sqrt{2}$ If you want a decimal approximation instead, you can use the `N` function. ```python N(sqrt(2)) ``` $\\displaystyle 1.4142135623731$ Or you can use the `evalf` function. ```python sqrt(2).evalf() ``` $\\displaystyle 1.4142135623731$ By contrast, if you need an exact rational number when Python gives you an approximation, you can use the `Rational` function to build one. Note the differences below: ```python 1/3 ``` $\\displaystyle 0.333333333333333$ ```python Rational(1,3) ``` $\\displaystyle \\frac{1}{3}$ Content last modified on 14 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do basic mathematical computations/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-basic-mathematical-computations-in-python-using-sympy/",
    "relUrl": "/how-to-do-basic-mathematical-computations-in-python-using-sympy/"
  },"602": {
    "doc": "How to do basic mathematical computations (in Python)",
    "title": "How to do basic mathematical computations (in Python)",
    "content": "# How to do basic mathematical computations (in Python) [See all solutions.](../how-to-do-basic-mathematical-computations) ## Task How do we write the most common mathematical operations in a given piece of software? For example, how do we write multiplication, or exponentiation, or logarithms, in Python vs. R vs. Excel, and so on? ## Solution For those expressions that need the Python math package, use the code `import math` beforehand to ensure that package is loaded. Alternatively, you can write `from math import *` and thus drop the `math` prefixes in the table below. | Mathematical notation | Python code | Requires math package? |--|--|--| $x+y$ | `x+y` | no | $x-y$ | `x-y` | no | $xy$ | `x*y` | no | $\\frac xy$ | `x/y` | no | $\\left\\lfloor\\frac xy\\right\\rfloor$ | `x//y` | no | remainder of $x\\div y$ | `x%y` | no | $x^y$ | `x**y` | no | $\\vert x\\vert$ | `abs(x)` | no | $\\ln x$ | `math.log(x)` | yes | $\\log_a b$ | `math.log(b,a)` | yes | $e^x$ | `math.exp(x)` | yes | $\\pi$ | `math.pi` | yes | $\\sin x$ | `math.sin(x)` | yes | $\\sin^{-1} x$ | `math.asin(x)` | yes | $\\sqrt x$ | `x**0.5` | no | $\\sqrt x$ | `math.sqrt(x)` | yes | Other trigonometric functions are also available besides just `math.sin`, including `math.cos`, `math.tan`, etc. Content last modified on 14 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do basic mathematical computations/Python.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-basic-mathematical-computations-in-python/",
    "relUrl": "/how-to-do-basic-mathematical-computations-in-python/"
  },"603": {
    "doc": "How to do basic mathematical computations (in R)",
    "title": "How to do basic mathematical computations (in R)",
    "content": "# How to do basic mathematical computations (in R) [See all solutions.](../how-to-do-basic-mathematical-computations) ## Task How do we write the most common mathematical operations in a given piece of software? For example, how do we write multiplication, or exponentiation, or logarithms, in Python vs. R vs. Excel, and so on? ## Solution For those expressions that need the Python math package, use the code `import math` beforehand to ensure that package is loaded. Alternatively, you can write `from math import *` and thus drop the `math` prefixes in the table below. | Mathematical notation | R code |--|--| $x+y$ | `x+y` | $x-y$ | `x-y` | $xy$ | `x*y` | $\\frac xy$ | `x/y` | $x^y$ | `x^y` | $\\vert x\\vert$ | `abs(x)` | $\\ln x$ | `log(x)` | $\\log_a b$ | `log(b,a)` | $e^x$ | `exp(x)` | $\\pi$ | `pi` | $\\sin x$ | `sin(x)` | $\\sin^{-1} x$ | `asin(x)` | $\\sqrt x$ | `sqrt(x)` | Other trigonometric functions are also available besides just `sin`, including `cos`, `tan`, etc. R naturally applies these functions across vectors. For example, you can square all the entries in a vector as in the example below. ```R example.vector <- c( -3, 2, 0.5, -1, 10, 9.2, -3.3 ) example.vector ^ 2 ``` [1] 9.00 4.00 0.25 1.00 100.00 84.64 10.89 Content last modified on 23 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do basic mathematical computations/R.Rmd). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-basic-mathematical-computations-in-r/",
    "relUrl": "/how-to-do-basic-mathematical-computations-in-r/"
  },"604": {
    "doc": "How to do basic mathematical computations",
    "title": "How to do basic mathematical computations",
    "content": " ",
    "url": "/how-to-do-basic-mathematical-computations/",
    "relUrl": "/how-to-do-basic-mathematical-computations/"
  },"605": {
    "doc": "How to do basic mathematical computations",
    "title": "Description",
    "content": "How do we write the most common mathematical operations in a given piece of software? For example, how do we write multiplication, or exponentiation, or logarithms, in Python vs. R vs. Excel, and so on? . ",
    "url": "/how-to-do-basic-mathematical-computations/#description",
    "relUrl": "/how-to-do-basic-mathematical-computations/#description"
  },"606": {
    "doc": "How to do basic mathematical computations",
    "title": "Solution, in Excel",
    "content": "View this solution alone. Each of the formulas shown on the right of the table below is valid code for use in Excel formulas, in cells in a worksheet. | Mathematical notation | Excel notation | Example | . | $x+y$ | x+y | =A1+B1 | . | $x-y$ | x-y | =A1-B1 | . | $xy$ | x*y | =A1*B1 | . | $\\frac xy$ | x/y | =A1/B1 | . | $x^y$ | x^y | =A1^B1 | . | $\\vert x\\vert$ | ABS(x) | =ABS(A1) | . | $\\ln x$ | LN(x) | =LN(A1) | . | $\\log_a b$ | LOG(b,a) | =LOG(A1,B1) | . | $e^x$ | EXP(x) | =EXP(A1) | . | $\\pi$ | PI() | =PI() | . | $\\sin x$ | SIN(x) | =SIN(A1) | . | $\\sin^{-1} x$ | ASIN(x) | =ASIN(A1) | . | $\\sqrt x$ | SQRT(x) | =SQRT(A1) | . Other trigonometric functions are also available besides just SIN, including COS, TAN, etc. Content last modified on 09 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-basic-mathematical-computations/#solution-in-excel",
    "relUrl": "/how-to-do-basic-mathematical-computations/#solution-in-excel"
  },"607": {
    "doc": "How to do basic mathematical computations",
    "title": "Solution, in Julia",
    "content": "View this solution alone. | Mathematical notation | Julia code | . | $x+y$ | x+y | . | $x-y$ | x-y | . | $xy$ | x*y | . | $\\frac xy$ | x/y (or y\\x) | . | $\\left\\lfloor\\frac xy\\right\\rfloor$ | x÷y | . | remainder of $x\\div y$ | x%y | . | $x^y$ | x^y | . | $\\vert x\\vert$ | abs(x) | . | $\\ln x$ | log(x) | . | $\\log_a b$ | log(a,b) | . | $e^x$ | exp(x) | . | $\\pi$ | pi | . | $\\sin x$ | sin(x) | . | $\\sin^{-1} x$ | asin(x) | . | $\\sqrt x$ | sqrt(x) | . Other trigonometric functions are also available besides just sin including cos, tan, etc. Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-basic-mathematical-computations/#solution-in-julia",
    "relUrl": "/how-to-do-basic-mathematical-computations/#solution-in-julia"
  },"608": {
    "doc": "How to do basic mathematical computations",
    "title": "Using NumPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported NumPy as follows. | 1 . | import numpy as np . | . | Mathematical notation | Python code | Requires NumPy? | . | $x+y$ | x+y | no | . | $x-y$ | x-y | no | . | $xy$ | x*y | no | . | $\\frac xy$ | x/y | no | . | $\\left\\lfloor\\frac xy\\right\\rfloor$ | x//y | no | . | $\\left\\lfloor\\frac xy\\right\\rfloor$ | np.floor_divide(x,y) | yes | . | remainder of $x\\div y$ | x%y | no | . | remainder of $x\\div y$ | np.remainder(x,y) | yes | . | $x^y$ | x**y | no | . | $\\vert x\\vert$ | abs(x) | no | . | $\\vert x\\vert$ | np.abs(x) | yes | . | $\\ln x$ | np.log(x) | yes | . | $\\log_a b$ | np.log(b)/np.log(a) | yes | . | $e^x$ | np.exp(x) | yes | . | $\\pi$ | np.pi | yes | . | $\\sin x$ | np.sin(x) | yes | . | $\\sin^{-1} x$ | np.asin(x) | yes | . | $\\sqrt x$ | x**0.5 | no | . | $\\sqrt x$ | np.sqrt(x) | yes | . Other trigonometric functions are also available besides just np.sin, including np.cos, np.tan, etc. NumPy automatically applies any of these functions to all entries of a NumPy array or pandas Series, but the built-in Python functions do not have this feature. For example, to square all numbers in an array, see below. | 1 2 3 . | import numpy as np example_array = np.array( [ -3, 2, 0.5, -1, 10, 9.2, -3.3 ] ) example_array ** 2 . | . | 1 . | array([ 9. , 4. , 0.25, 1. , 100. , 84.64, 10.89]) . | . Content last modified on 14 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-basic-mathematical-computations/#using-numpy-in-python",
    "relUrl": "/how-to-do-basic-mathematical-computations/#using-numpy-in-python"
  },"609": {
    "doc": "How to do basic mathematical computations",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . | Mathematical notation | Python code | Requires SymPy? | . | $x+y$ | x+y | no | . | $x-y$ | x-y | no | . | $xy$ | x*y | no | . | $\\frac xy$ | x/y | no | . | $\\left\\lfloor\\frac xy\\right\\rfloor$ | x//y | no | . | remainder of $x\\div y$ | x%y | no | . | $x^y$ | x**y | no | . | $\\vert x\\vert$ | abs(x) | no | . | $\\ln x$ | log(x) | yes | . | $\\log_a b$ | log(b,a) | yes | . | $e^x$ | E | yes | . | $\\pi$ | pi | yes | . | $\\sin x$ | sin(x) | yes | . | $\\sin^{-1} x$ | asin(x) | yes | . | $\\sqrt x$ | sqrt(x) | yes | . Other trigonometric functions are also available besides just sin, including cos, tan, etc. Note that SymPy gives precise answers to mathematical queries, which may not be what you want. | 1 . | sqrt(2) . | . $\\displaystyle \\sqrt{2}$ . If you want a decimal approximation instead, you can use the N function. | 1 . | N(sqrt(2)) . | . $\\displaystyle 1.4142135623731$ . Or you can use the evalf function. | 1 . | sqrt(2).evalf() . | . $\\displaystyle 1.4142135623731$ . By contrast, if you need an exact rational number when Python gives you an approximation, you can use the Rational function to build one. Note the differences below: . | 1 . | 1/3 . | . $\\displaystyle 0.333333333333333$ . | 1 . | Rational(1,3) . | . $\\displaystyle \\frac{1}{3}$ . Content last modified on 14 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-basic-mathematical-computations/#using-sympy-in-python",
    "relUrl": "/how-to-do-basic-mathematical-computations/#using-sympy-in-python"
  },"610": {
    "doc": "How to do basic mathematical computations",
    "title": "Solution, in Python",
    "content": "View this solution alone. For those expressions that need the Python math package, use the code import math beforehand to ensure that package is loaded. Alternatively, you can write from math import * and thus drop the math prefixes in the table below. | Mathematical notation | Python code | Requires math package? | . | $x+y$ | x+y | no | . | $x-y$ | x-y | no | . | $xy$ | x*y | no | . | $\\frac xy$ | x/y | no | . | $\\left\\lfloor\\frac xy\\right\\rfloor$ | x//y | no | . | remainder of $x\\div y$ | x%y | no | . | $x^y$ | x**y | no | . | $\\vert x\\vert$ | abs(x) | no | . | $\\ln x$ | math.log(x) | yes | . | $\\log_a b$ | math.log(b,a) | yes | . | $e^x$ | math.exp(x) | yes | . | $\\pi$ | math.pi | yes | . | $\\sin x$ | math.sin(x) | yes | . | $\\sin^{-1} x$ | math.asin(x) | yes | . | $\\sqrt x$ | x**0.5 | no | . | $\\sqrt x$ | math.sqrt(x) | yes | . Other trigonometric functions are also available besides just math.sin, including math.cos, math.tan, etc. Content last modified on 14 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-basic-mathematical-computations/#solution-in-python",
    "relUrl": "/how-to-do-basic-mathematical-computations/#solution-in-python"
  },"611": {
    "doc": "How to do basic mathematical computations",
    "title": "Solution, in R",
    "content": "View this solution alone. For those expressions that need the Python math package, use the code import math beforehand to ensure that package is loaded. Alternatively, you can write from math import * and thus drop the math prefixes in the table below. | Mathematical notation | R code | . | $x+y$ | x+y | . | $x-y$ | x-y | . | $xy$ | x*y | . | $\\frac xy$ | x/y | . | $x^y$ | x^y | . | $\\vert x\\vert$ | abs(x) | . | $\\ln x$ | log(x) | . | $\\log_a b$ | log(b,a) | . | $e^x$ | exp(x) | . | $\\pi$ | pi | . | $\\sin x$ | sin(x) | . | $\\sin^{-1} x$ | asin(x) | . | $\\sqrt x$ | sqrt(x) | . Other trigonometric functions are also available besides just sin, including cos, tan, etc. R naturally applies these functions across vectors. For example, you can square all the entries in a vector as in the example below. | 1 2 . | example.vector &lt;- c( -3, 2, 0.5, -1, 10, 9.2, -3.3 ) example.vector ^ 2 . | . | 1 . | [1] 9.00 4.00 0.25 1.00 100.00 84.64 10.89 . | . Content last modified on 23 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-basic-mathematical-computations/#solution-in-r",
    "relUrl": "/how-to-do-basic-mathematical-computations/#solution-in-r"
  },"612": {
    "doc": "How to do basic mathematical computations",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | Bentley University GR526 | Bentley University MA346 | . ",
    "url": "/how-to-do-basic-mathematical-computations/#topics-that-include-this-task",
    "relUrl": "/how-to-do-basic-mathematical-computations/#topics-that-include-this-task"
  },"613": {
    "doc": "How to do implicit differentiation (in Python, using SymPy)",
    "title": "How to do implicit differentiation (in Python, using SymPy)",
    "content": "# How to do implicit differentiation (in Python, using SymPy) [See all solutions.](../how-to-do-implicit-differentiation) ## Task Assume we have an equation in which $y$ cannot be isolated as a function of $x$. (The standard example is the formula for the unit circle, $x^2+y^2=1$.) We would still like to be able to compute the derivative of $y$ with respect to $x$. Related tasks: * [How to graph curves that are not functions](../how-to-graph-curves-that-are-not-functions) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's consider the example of the unit circle, $x^2+y^2=1$. To plot it, SymPy first expects us to move everything to the left-hand side of the equation, so in this case, we would have $x^2+y^2-1=0$. We then use that left hand side to represent the equation as a single formula, and computue $\\frac{dy}{dx}$ using the `idiff` function (standing for \"implicit differentiation\"). ```python var( 'x y' ) formula = x**2 + y**2 - 1 # to represent x^2+y^2=1 idiff( formula, y, x ) ``` $\\displaystyle - \\frac{x}{y}$ So in this case, $\\frac{dy}{dx}=-\\frac xy$. Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to do implicit differentiation/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-do-implicit-differentiation-in-python-using-sympy/",
    "relUrl": "/how-to-do-implicit-differentiation-in-python-using-sympy/"
  },"614": {
    "doc": "How to do implicit differentiation",
    "title": "How to do implicit differentiation",
    "content": " ",
    "url": "/how-to-do-implicit-differentiation/",
    "relUrl": "/how-to-do-implicit-differentiation/"
  },"615": {
    "doc": "How to do implicit differentiation",
    "title": "Description",
    "content": "Assume we have an equation in which $y$ cannot be isolated as a function of $x$. (The standard example is the formula for the unit circle, $x^2+y^2=1$.) We would still like to be able to compute the derivative of $y$ with respect to $x$. Related tasks: . | How to graph curves that are not functions | . ",
    "url": "/how-to-do-implicit-differentiation/#description",
    "relUrl": "/how-to-do-implicit-differentiation/#description"
  },"616": {
    "doc": "How to do implicit differentiation",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s consider the example of the unit circle, $x^2+y^2=1$. To plot it, SymPy first expects us to move everything to the left-hand side of the equation, so in this case, we would have $x^2+y^2-1=0$. We then use that left hand side to represent the equation as a single formula, and computue $\\frac{dy}{dx}$ using the idiff function (standing for “implicit differentiation”). | 1 2 3 . | var( 'x y' ) formula = x**2 + y**2 - 1 # to represent x^2+y^2=1 idiff( formula, y, x ) . | . $\\displaystyle - \\frac{x}{y}$ . So in this case, $\\frac{dy}{dx}=-\\frac xy$. Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-do-implicit-differentiation/#using-sympy-in-python",
    "relUrl": "/how-to-do-implicit-differentiation/#using-sympy-in-python"
  },"617": {
    "doc": "How to do implicit differentiation",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-do-implicit-differentiation/#topics-that-include-this-task",
    "relUrl": "/how-to-do-implicit-differentiation/#topics-that-include-this-task"
  },"618": {
    "doc": "How to do implicit differentiation",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-do-implicit-differentiation/#opportunities",
    "relUrl": "/how-to-do-implicit-differentiation/#opportunities"
  },"619": {
    "doc": "How to find critical values and p-values from the normal distribution (in Julia)",
    "title": "How to find critical values and p-values from the normal distribution (in Julia)",
    "content": "# How to find critical values and p-values from the normal distribution (in Julia) [See all solutions.](../how-to-find-critical-values-and-p-values-from-the-normal-distribution) ## Task Some statistical techniques require computing critical values or $p$-values from the normal distribution. For example, we need to do this when constructing a confidence interval or conducting a hypothesis test. How do we compute such values? Related tasks: * [How to find critical values and p-values from the t-distribution](../how-to-find-critical-values-and-p-values-from-the-t-distribution) ## Solution If we choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate, then we can find the critical value from the normal distribution using the `quantile()` function in Julia's Distributions package. If you don't have that package installed, first run `using Pkg` and then `Pkg.add( \"Distributions\" )` from within Julia. The code below shows how to do this for left-tailed, right-tailed, and two-tailed hypothesis tests. ```julia using Distributions alpha = 0.05 # Replace with your alpha value standard_normal = Normal( 0, 1 ) quantile( standard_normal, alpha ) # Critical value for a left-tailed test ``` -1.6448536269514724 ```julia quantile( standard_normal, 1 - alpha ) # Critical value for a right-tailed test ``` 1.6448536269514717 ```julia quantile( standard_normal, alpha / 2 ) # Critical value for a two-tailed test ``` -1.9599639845400592 We can also compute $p$-values from the normal distribution to compare to a test statistic. As an example, we'll use a test statistic of 2.67, but you can substitute your test statistic's value instead. We can find the $p$-value for this test statistic using the `cdf()` function in Julia's Distributions package. Again, we show code for left-tailed, right-tailed, and two-tailed tests. ```julia test_statistic = 2.67 # Replace with your test statistic cdf( standard_normal, test_statistic ) # p-value for a left-tailed test ``` 0.9962074376523146 ```julia 1 - cdf( standard_normal, test_statistic ) # p-value for a right-tailed test ``` 0.0037925623476854353 ```julia 2 * ( 1 - cdf( standard_normal, test_statistic ) ) # p-value for a two-tailed test ``` 0.007585124695370871 Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to find critical values and p-values from the normal distribution/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution-in-julia/",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution-in-julia/"
  },"620": {
    "doc": "How to find critical values and p-values from the normal distribution (in R)",
    "title": "How to find critical values and p-values from the normal distribution (in R)",
    "content": "# How to find critical values and p-values from the normal distribution (in R) [See all solutions.](../how-to-find-critical-values-and-p-values-from-the-normal-distribution) ## Task Some statistical techniques require computing critical values or $p$-values from the normal distribution. For example, we need to do this when constructing a confidence interval or conducting a hypothesis test. How do we compute such values? Related tasks: * [How to find critical values and p-values from the t-distribution](../how-to-find-critical-values-and-p-values-from-the-t-distribution) ## Solution If we choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate, then we can find the critical value from the normal distribution using R's `qnorm()` function. The code below shows how to do this for left-tailed, right-tailed, and two-tailed hypothesis tests. ```R alpha <- 0.05 # Replace with your alpha value qnorm(p = alpha, lower.tail = TRUE) # Critical value for a left-tailed test qnorm(p = alpha, lower.tail = FALSE) # Critical value for a right-tailed test qnorm(p = alpha/2, lower.tail = FALSE) # Critical value for a two-tailed test ``` [1] -1.644854 [1] 1.644854 [1] 1.959964 We can also compute $p$-values from the normal distribution to compare to a test statistic. As an example, we'll use a test statistic of 2.67, but you can substitute your test statistic's value instead. We can find the $p$-value for this test statistic using R's `pnorm()` function. Again, we show code for left-tailed, right-tailed, and two-tailed tests. ```R test_statistic <- 2.67 # Replace with your test statistic pnorm(test_statistic, lower.tail = TRUE) # p-value for a left-tailed test pnorm(test_statistic, lower.tail = FALSE) # p-value for a right-tailed test 2*pnorm(test_statistic, lower.tail = FALSE) # p-value for a two-tailed test ``` [1] 0.9962074 [1] 0.003792562 [1] 0.007585125 Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to find critical values and p-values from the normal distribution/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution-in-r/",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution-in-r/"
  },"621": {
    "doc": "How to find critical values and p-values from the normal distribution",
    "title": "How to find critical values and p-values from the normal distribution",
    "content": " ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/"
  },"622": {
    "doc": "How to find critical values and p-values from the normal distribution",
    "title": "Description",
    "content": "Some statistical techniques require computing critical values or $p$-values from the normal distribution. For example, we need to do this when constructing a confidence interval or conducting a hypothesis test. How do we compute such values? . Related tasks: . | How to find critical values and p-values from the t-distribution | . ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#description",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#description"
  },"623": {
    "doc": "How to find critical values and p-values from the normal distribution",
    "title": "Solution, in Julia",
    "content": "View this solution alone. If we choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate, then we can find the critical value from the normal distribution using the quantile() function in Julia’s Distributions package. If you don’t have that package installed, first run using Pkg and then Pkg.add( \"Distributions\" ) from within Julia. The code below shows how to do this for left-tailed, right-tailed, and two-tailed hypothesis tests. | 1 2 3 4 . | using Distributions alpha = 0.05 # Replace with your alpha value standard_normal = Normal( 0, 1 ) quantile( standard_normal, alpha ) # Critical value for a left-tailed test . | . | 1 . | -1.6448536269514724 . | . | 1 . | quantile( standard_normal, 1 - alpha ) # Critical value for a right-tailed test . | . | 1 . | 1.6448536269514717 . | . | 1 . | quantile( standard_normal, alpha / 2 ) # Critical value for a two-tailed test . | . | 1 . | -1.9599639845400592 . | . We can also compute $p$-values from the normal distribution to compare to a test statistic. As an example, we’ll use a test statistic of 2.67, but you can substitute your test statistic’s value instead. We can find the $p$-value for this test statistic using the cdf() function in Julia’s Distributions package. Again, we show code for left-tailed, right-tailed, and two-tailed tests. | 1 2 . | test_statistic = 2.67 # Replace with your test statistic cdf( standard_normal, test_statistic ) # p-value for a left-tailed test . | . | 1 . | 0.9962074376523146 . | . | 1 . | 1 - cdf( standard_normal, test_statistic ) # p-value for a right-tailed test . | . | 1 . | 0.0037925623476854353 . | . | 1 . | 2 * ( 1 - cdf( standard_normal, test_statistic ) ) # p-value for a two-tailed test . | . | 1 . | 0.007585124695370871 . | . Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#solution-in-julia",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#solution-in-julia"
  },"624": {
    "doc": "How to find critical values and p-values from the normal distribution",
    "title": "Solution, in R",
    "content": "View this solution alone. If we choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate, then we can find the critical value from the normal distribution using R’s qnorm() function. The code below shows how to do this for left-tailed, right-tailed, and two-tailed hypothesis tests. | 1 2 3 4 . | alpha &lt;- 0.05 # Replace with your alpha value qnorm(p = alpha, lower.tail = TRUE) # Critical value for a left-tailed test qnorm(p = alpha, lower.tail = FALSE) # Critical value for a right-tailed test qnorm(p = alpha/2, lower.tail = FALSE) # Critical value for a two-tailed test . | . | 1 2 3 4 5 6 7 8 9 . | [1] -1.644854 [1] 1.644854 [1] 1.959964 . | . We can also compute $p$-values from the normal distribution to compare to a test statistic. As an example, we’ll use a test statistic of 2.67, but you can substitute your test statistic’s value instead. We can find the $p$-value for this test statistic using R’s pnorm() function. Again, we show code for left-tailed, right-tailed, and two-tailed tests. | 1 2 3 4 . | test_statistic &lt;- 2.67 # Replace with your test statistic pnorm(test_statistic, lower.tail = TRUE) # p-value for a left-tailed test pnorm(test_statistic, lower.tail = FALSE) # p-value for a right-tailed test 2*pnorm(test_statistic, lower.tail = FALSE) # p-value for a two-tailed test . | . | 1 2 3 4 5 6 7 8 9 . | [1] 0.9962074 [1] 0.003792562 [1] 0.007585125 . | . Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#solution-in-r",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#solution-in-r"
  },"625": {
    "doc": "How to find critical values and p-values from the normal distribution",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | . ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#topics-that-include-this-task",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#topics-that-include-this-task"
  },"626": {
    "doc": "How to find critical values and p-values from the normal distribution",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#opportunities",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-normal-distribution/#opportunities"
  },"627": {
    "doc": "How to find critical values and p-values from the t-distribution (in Julia)",
    "title": "How to find critical values and p-values from the t-distribution (in Julia)",
    "content": "# How to find critical values and p-values from the t-distribution (in Julia) [See all solutions.](../how-to-find-critical-values-and-p-values-from-the-t-distribution) ## Task If we have a test statistic and need to find the corresponding p-value from the t-distribution, how do we do that? If we need to find a p-value from the t distribution, given that we know the significance level and degrees of freedom, how do we do that? Related tasks: * [How to find critical values and p-values from the normal distribution](../how-to-find-critical-values-and-p-values-from-the-normal-distribution) ## Solution If we choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate, then we can find the critical value from the normal distribution using the `quantile()` function in Julia's Distributions package. If you don't have that package installed, first run `using Pkg` and then `Pkg.add( \"Distributions\" )` from within Julia. The code below shows how to do this for left-tailed, right-tailed, and two-tailed hypothesis tests. ```julia using Distributions alpha = 0.05 # Replace with your alpha value n = 68 # Replace with your sample size tdist = TDist( n - 1 ) quantile( tdist, alpha ) # Critical value for a left-tailed test ``` -1.6679161141074252 ```julia quantile( tdist, 1 - alpha ) # Critical value for a right-tailed test ``` 1.6679161141074246 ```julia quantile( tdist, alpha / 2 ) # Critical value for a two-tailed test ``` -1.996008354025297 We can also compute $p$-values from the normal distribution to compare to a test statistic. As an example, we'll use a test statistic of 2.67, but you can substitute your test statistic's value instead. We can find the $p$-value for this test statistic using the `cdf()` function in Julia's Distributions package. Again, we show code for left-tailed, right-tailed, and two-tailed tests. ```julia test_statistic = 2.67 # Replace with your test statistic cdf( tdist, test_statistic ) # p-value for a left-tailed test ``` 0.9952454518351646 ```julia 1 - cdf( tdist, test_statistic ) # p-value for a right-tailed test ``` 0.004754548164835448 ```julia 2 * ( 1 - cdf( tdist, test_statistic ) ) # p-value for a two-tailed test ``` 0.009509096329670896 Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to find critical values and p-values from the t-distribution/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-t-distribution-in-julia/",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-t-distribution-in-julia/"
  },"628": {
    "doc": "How to find critical values and p-values from the t-distribution (in R)",
    "title": "How to find critical values and p-values from the t-distribution (in R)",
    "content": "# How to find critical values and p-values from the t-distribution (in R) [See all solutions.](../how-to-find-critical-values-and-p-values-from-the-t-distribution) ## Task If we have a test statistic and need to find the corresponding p-value from the t-distribution, how do we do that? If we need to find a p-value from the t distribution, given that we know the significance level and degrees of freedom, how do we do that? Related tasks: * [How to find critical values and p-values from the normal distribution](../how-to-find-critical-values-and-p-values-from-the-normal-distribution) ## Solution If we choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate, and we know the sample size of our data, then we can find the *critical value* from the $t$-distribution using R's `qt()` function. The code below shows how to do this for left-tailed, right-tailed, and two-tailed hypothesis tests. ```R alpha <- 0.05 # Replace with your alpha value n <- 68 # Replace with your sample size qt(p = alpha, df = n-1, lower.tail = TRUE) # Critical value for a left-tailed test qt(p = alpha, df = n-1, lower.tail = FALSE) # Critical value for a right-tailed test qt(p = alpha/2, df = n-1, lower.tail = FALSE) # Critical value for a two-tailed test ``` [1] -1.667916 [1] 1.667916 [1] 1.996008 We can also compute $p$-values from the $t$-distribution to compare to a test statistic. As an example, we'll use a test statistic of 2.67, but you can substitute your test statistic's value instead. We can find the $p$-value for this test statistic using R's `pt()` function. We will use the same example sample size as above. Again, we show code for left-tailed, right-tailed, and two-tailed tests. ```R test_statistic <- 2.67 # Replace with your test statistic n <- 68 # Replace with your sample size pt(test_statistic, df = n-1, lower.tail = TRUE) # p-value for a left-tailed test pt(test_statistic, df = n-1, lower.tail = FALSE) # p-value for a right-tailed test 2*pt(test_statistic, df = n-1, lower.tail = FALSE) # p-value for a two-tailed test ``` [1] 0.9952455 [1] 0.004754548 [1] 0.009509096 Content last modified on 05 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to find critical values and p-values from the t-distribution/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-t-distribution-in-r/",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-t-distribution-in-r/"
  },"629": {
    "doc": "How to find critical values and p-values from the t-distribution",
    "title": "How to find critical values and p-values from the t-distribution",
    "content": " ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/"
  },"630": {
    "doc": "How to find critical values and p-values from the t-distribution",
    "title": "Description",
    "content": "If we have a test statistic and need to find the corresponding p-value from the t-distribution, how do we do that? If we need to find a p-value from the t distribution, given that we know the significance level and degrees of freedom, how do we do that? . Related tasks: . | How to find critical values and p-values from the normal distribution | . ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#description",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#description"
  },"631": {
    "doc": "How to find critical values and p-values from the t-distribution",
    "title": "Solution, in Julia",
    "content": "View this solution alone. If we choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate, then we can find the critical value from the normal distribution using the quantile() function in Julia’s Distributions package. If you don’t have that package installed, first run using Pkg and then Pkg.add( \"Distributions\" ) from within Julia. The code below shows how to do this for left-tailed, right-tailed, and two-tailed hypothesis tests. | 1 2 3 4 5 . | using Distributions alpha = 0.05 # Replace with your alpha value n = 68 # Replace with your sample size tdist = TDist( n - 1 ) quantile( tdist, alpha ) # Critical value for a left-tailed test . | . | 1 . | -1.6679161141074252 . | . | 1 . | quantile( tdist, 1 - alpha ) # Critical value for a right-tailed test . | . | 1 . | 1.6679161141074246 . | . | 1 . | quantile( tdist, alpha / 2 ) # Critical value for a two-tailed test . | . | 1 . | -1.996008354025297 . | . We can also compute $p$-values from the normal distribution to compare to a test statistic. As an example, we’ll use a test statistic of 2.67, but you can substitute your test statistic’s value instead. We can find the $p$-value for this test statistic using the cdf() function in Julia’s Distributions package. Again, we show code for left-tailed, right-tailed, and two-tailed tests. | 1 2 . | test_statistic = 2.67 # Replace with your test statistic cdf( tdist, test_statistic ) # p-value for a left-tailed test . | . | 1 . | 0.9952454518351646 . | . | 1 . | 1 - cdf( tdist, test_statistic ) # p-value for a right-tailed test . | . | 1 . | 0.004754548164835448 . | . | 1 . | 2 * ( 1 - cdf( tdist, test_statistic ) ) # p-value for a two-tailed test . | . | 1 . | 0.009509096329670896 . | . Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#solution-in-julia",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#solution-in-julia"
  },"632": {
    "doc": "How to find critical values and p-values from the t-distribution",
    "title": "Solution, in R",
    "content": "View this solution alone. If we choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate, and we know the sample size of our data, then we can find the critical value from the $t$-distribution using R’s qt() function. The code below shows how to do this for left-tailed, right-tailed, and two-tailed hypothesis tests. | 1 2 3 4 5 . | alpha &lt;- 0.05 # Replace with your alpha value n &lt;- 68 # Replace with your sample size qt(p = alpha, df = n-1, lower.tail = TRUE) # Critical value for a left-tailed test qt(p = alpha, df = n-1, lower.tail = FALSE) # Critical value for a right-tailed test qt(p = alpha/2, df = n-1, lower.tail = FALSE) # Critical value for a two-tailed test . | . | 1 2 3 4 5 6 7 8 9 . | [1] -1.667916 [1] 1.667916 [1] 1.996008 . | . We can also compute $p$-values from the $t$-distribution to compare to a test statistic. As an example, we’ll use a test statistic of 2.67, but you can substitute your test statistic’s value instead. We can find the $p$-value for this test statistic using R’s pt() function. We will use the same example sample size as above. Again, we show code for left-tailed, right-tailed, and two-tailed tests. | 1 2 3 4 5 . | test_statistic &lt;- 2.67 # Replace with your test statistic n &lt;- 68 # Replace with your sample size pt(test_statistic, df = n-1, lower.tail = TRUE) # p-value for a left-tailed test pt(test_statistic, df = n-1, lower.tail = FALSE) # p-value for a right-tailed test 2*pt(test_statistic, df = n-1, lower.tail = FALSE) # p-value for a two-tailed test . | . | 1 2 3 4 5 6 7 8 9 . | [1] 0.9952455 [1] 0.004754548 [1] 0.009509096 . | . Content last modified on 05 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#solution-in-r",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#solution-in-r"
  },"633": {
    "doc": "How to find critical values and p-values from the t-distribution",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | . ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#topics-that-include-this-task",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#topics-that-include-this-task"
  },"634": {
    "doc": "How to find critical values and p-values from the t-distribution",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#opportunities",
    "relUrl": "/how-to-find-critical-values-and-p-values-from-the-t-distribution/#opportunities"
  },"635": {
    "doc": "How to find the critical numbers of a function (in Python, using SymPy)",
    "title": "How to find the critical numbers of a function (in Python, using SymPy)",
    "content": "# How to find the critical numbers of a function (in Python, using SymPy) [See all solutions.](../how-to-find-the-critical-numbers-of-a-function) ## Task When trying to find the maximum and minimum values of a function, one of the main techniques in calculus is to use the \"critical numbers\" of the function, which are the most important $x$ values to examine to find maxima and minima. Can we find critical numbers for a single-variable function using software? Related tasks: * [How to compute the domain of a function](../how-to-compute-the-domain-of-a-function) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's create an example function to work with. ```python var( 'x' ) formula = sqrt( x - 1 ) - x formula ``` $\\displaystyle - x + \\sqrt{x - 1}$ Critical numbers come in two kinds. First, where is the derivative zero? Second, where is the derivative undefined but the function is defined? Let's begin by finding where the derivative is zero. We'll use the same techniques introduced in [how to write symbolic equations](../how-to-write-symbolic-equations) and [how to solve symbolic equations](../how-to-solve-symbolic-equations). ```python derivative = diff( formula ) derivative ``` $\\displaystyle -1 + \\frac{1}{2 \\sqrt{x - 1}}$ ```python solve( Eq( derivative, 0 ) ) ``` $\\displaystyle \\left[ \\frac{5}{4}\\right]$ So one critical number, where the derivative is zero, is $x=\\frac54$. Now where is the derivative defined but the function undefined? We compute the domain of both functions and subtract them, using the techniques from [how to compute the domain of a function](../how-to-compute-the-domain-of-a-function). ```python from sympy.calculus.util import continuous_domain f_domain = continuous_domain( formula, x, S.Reals ) deriv_domain = continuous_domain( derivative, x, S.Reals ) Complement( f_domain, deriv_domain ) ``` $\\displaystyle \\left\\\\{1\\right\\\\}$ So another critical number, where the function is defined but the derivative is not, is $x=1$. Thus the full set of critical numbers for this function is $\\left\\\\{1,\\frac54\\right\\\\}$. Content last modified on 13 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to find the critical numbers of a function/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-find-the-critical-numbers-of-a-function-in-python-using-sympy/",
    "relUrl": "/how-to-find-the-critical-numbers-of-a-function-in-python-using-sympy/"
  },"636": {
    "doc": "How to find the critical numbers of a function",
    "title": "How to find the critical numbers of a function",
    "content": " ",
    "url": "/how-to-find-the-critical-numbers-of-a-function/",
    "relUrl": "/how-to-find-the-critical-numbers-of-a-function/"
  },"637": {
    "doc": "How to find the critical numbers of a function",
    "title": "Description",
    "content": "When trying to find the maximum and minimum values of a function, one of the main techniques in calculus is to use the “critical numbers” of the function, which are the most important $x$ values to examine to find maxima and minima. Can we find critical numbers for a single-variable function using software? . Related tasks: . | How to compute the domain of a function | . ",
    "url": "/how-to-find-the-critical-numbers-of-a-function/#description",
    "relUrl": "/how-to-find-the-critical-numbers-of-a-function/#description"
  },"638": {
    "doc": "How to find the critical numbers of a function",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s create an example function to work with. | 1 2 3 . | var( 'x' ) formula = sqrt( x - 1 ) - x formula . | . $\\displaystyle - x + \\sqrt{x - 1}$ . Critical numbers come in two kinds. First, where is the derivative zero? Second, where is the derivative undefined but the function is defined? . Let’s begin by finding where the derivative is zero. We’ll use the same techniques introduced in how to write symbolic equations and how to solve symbolic equations. | 1 2 . | derivative = diff( formula ) derivative . | . $\\displaystyle -1 + \\frac{1}{2 \\sqrt{x - 1}}$ . | 1 . | solve( Eq( derivative, 0 ) ) . | . $\\displaystyle \\left[ \\frac{5}{4}\\right]$ . So one critical number, where the derivative is zero, is $x=\\frac54$. Now where is the derivative defined but the function undefined? We compute the domain of both functions and subtract them, using the techniques from how to compute the domain of a function. | 1 2 3 4 . | from sympy.calculus.util import continuous_domain f_domain = continuous_domain( formula, x, S.Reals ) deriv_domain = continuous_domain( derivative, x, S.Reals ) Complement( f_domain, deriv_domain ) . | . $\\displaystyle \\left\\{1\\right\\}$ . So another critical number, where the function is defined but the derivative is not, is $x=1$. Thus the full set of critical numbers for this function is $\\left\\{1,\\frac54\\right\\}$. Content last modified on 13 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-find-the-critical-numbers-of-a-function/#using-sympy-in-python",
    "relUrl": "/how-to-find-the-critical-numbers-of-a-function/#using-sympy-in-python"
  },"639": {
    "doc": "How to find the critical numbers of a function",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-find-the-critical-numbers-of-a-function/#topics-that-include-this-task",
    "relUrl": "/how-to-find-the-critical-numbers-of-a-function/#topics-that-include-this-task"
  },"640": {
    "doc": "How to find the critical numbers of a function",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-find-the-critical-numbers-of-a-function/#opportunities",
    "relUrl": "/how-to-find-the-critical-numbers-of-a-function/#opportunities"
  },"641": {
    "doc": "How to fit a linear model to two columns of data (in Julia)",
    "title": "How to fit a linear model to two columns of data (in Julia)",
    "content": "# How to fit a linear model to two columns of data (in Julia) [See all solutions.](../how-to-fit-a-linear-model-to-two-columns-of-data) ## Task Let's say we have two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can I find the best fit linear model that predicts $y$ based on $x$? In other words, what are the model coefficients $\\beta_0$ and $\\beta_1$ that give me the best linear model $\\hat y=\\beta_0+\\beta_1x$ based on my data? Related tasks: * [How to compute R-squared for a simple linear model](../how-to-compute-r-squared-for-a-simple-linear-model) * [How to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model) * [How to predict the response variable in a linear model](../how-to-predict-the-response-variable-in-a-linear-model) ## Solution This solution uses fake example data. When using this code, replace our fake data with your real data. ```julia # Here is the fake data you should replace with your real data. xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] # Place the data into a DataFrame, because that's what Julia's modeling tools expect: using DataFrames data = DataFrame( xs=xs, ys=ys ) # Or you can name the columns whatever you like # Create the linear model: using GLM lm( @formula( ys ~ xs ), data ) ``` StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}} ys ~ 1 + xs Coefficients: ─────────────────────────────────────────────────────────────────────────── Coef. Std. Error t Pr(>|t|) Lower 95% Upper 95% ─────────────────────────────────────────────────────────────────────────── (Intercept) -37.3214 18.9954 -1.96 0.1066 -86.1508 11.5079 xs 0.13272 0.029589 4.49 0.0065 0.0566587 0.20878 ─────────────────────────────────────────────────────────────────────────── The linear model in this example is approximately $y=0.13272x-37.3214$. Content last modified on 05 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to fit a linear model to two columns of data/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data-in-julia/",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data-in-julia/"
  },"642": {
    "doc": "How to fit a linear model to two columns of data (in Python, using SciPy)",
    "title": "How to fit a linear model to two columns of data (in Python, using SciPy)",
    "content": "# How to fit a linear model to two columns of data (in Python, using SciPy) [See all solutions.](../how-to-fit-a-linear-model-to-two-columns-of-data) ## Task Let's say we have two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can I find the best fit linear model that predicts $y$ based on $x$? In other words, what are the model coefficients $\\beta_0$ and $\\beta_1$ that give me the best linear model $\\hat y=\\beta_0+\\beta_1x$ based on my data? Related tasks: * [How to compute R-squared for a simple linear model](../how-to-compute-r-squared-for-a-simple-linear-model) * [How to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model) * [How to predict the response variable in a linear model](../how-to-predict-the-response-variable-in-a-linear-model) ## Solution This solution uses a pandas DataFrame of fake example data. When using this code, replace our fake data with your real data. Although the solution below uses plain Python lists of data, it also works if the data are stored in NumPy arrays or pandas Series. ```python # Here is the fake data you should replace with your real data. xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] # We will use SciPy to build the model import scipy.stats as stats # If you need the model coefficients stored in variables for later use, do: model = stats.linregress( xs, ys ) beta0 = model.intercept beta1 = model.slope # If you just need to see the coefficients (and some other related data), # do this alone: stats.linregress( xs, ys ) ``` LinregressResult(slope=0.1327195637885226, intercept=-37.32141898334582, rvalue=0.8949574425541466, pvalue=0.006486043236692156, stderr=0.029588975845594334, intercept_stderr=18.995444317768097) The linear model in this example is approximately $\\hat y=0.133x-37.32$. Content last modified on 08 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to fit a linear model to two columns of data/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data-in-python-using-scipy/",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data-in-python-using-scipy/"
  },"643": {
    "doc": "How to fit a linear model to two columns of data (in Python, using statsmodels)",
    "title": "How to fit a linear model to two columns of data (in Python, using statsmodels)",
    "content": "# How to fit a linear model to two columns of data (in Python, using statsmodels) [See all solutions.](../how-to-fit-a-linear-model-to-two-columns-of-data) ## Task Let's say we have two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can I find the best fit linear model that predicts $y$ based on $x$? In other words, what are the model coefficients $\\beta_0$ and $\\beta_1$ that give me the best linear model $\\hat y=\\beta_0+\\beta_1x$ based on my data? Related tasks: * [How to compute R-squared for a simple linear model](../how-to-compute-r-squared-for-a-simple-linear-model) * [How to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model) * [How to predict the response variable in a linear model](../how-to-predict-the-response-variable-in-a-linear-model) ## Solution This solution uses fake example data. When using this code, replace our fake data with your real data. Although the solution below uses plain Python lists of data, it also works if the data are stored in NumPy arrays or pandas Series. ```python # Here is the fake data you should replace with your real data. xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] # We will use statsmodels to build the model import statsmodels.api as sm # statsmodels does not add a constant term to the model unless you request it: xs = sm.add_constant( xs ) # Fit the model and tell us all about it: model = sm.OLS( ys, xs ).fit() model.summary() ``` /opt/conda/lib/python3.10/site-packages/statsmodels/stats/stattools.py:74: ValueWarning: omni_normtest is not valid with less than 8 observations; 7 samples were given. warn(\"omni_normtest is not valid with less than 8 observations; %i \" OLS Regression Results | Dep. Variable: | y | R-squared: | 0.801 | . | Model: | OLS | Adj. R-squared: | 0.761 | . | Method: | Least Squares | F-statistic: | 20.12 | . | Date: | Tue, 08 Nov 2022 | Prob (F-statistic): | 0.00649 | . | Time: | 21:35:13 | Log-Likelihood: | -25.926 | . | No. Observations: | 7 | AIC: | 55.85 | . | Df Residuals: | 5 | BIC: | 55.74 | . | Df Model: | 1 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P>|t| | [0.025 | 0.975] | . | const | -37.3214 | 18.995 | -1.965 | 0.107 | -86.151 | 11.508 | . | x1 | 0.1327 | 0.030 | 4.485 | 0.006 | 0.057 | 0.209 | . | Omnibus: | nan | Durbin-Watson: | 0.806 | . | Prob(Omnibus): | nan | Jarque-Bera (JB): | 0.520 | . | Skew: | -0.366 | Prob(JB): | 0.771 | . | Kurtosis: | 1.883 | Cond. No. | 2.78e+03 | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.[2] The condition number is large, 2.78e+03. This might indicate that there arestrong multicollinearity or other numerical problems. The linear model in this example is approximately $\\hat y=0.1327x-37.3214$. Content last modified on 08 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to fit a linear model to two columns of data/Python, using statsmodels.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data-in-python-using-statsmodels/",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data-in-python-using-statsmodels/"
  },"644": {
    "doc": "How to fit a linear model to two columns of data (in R)",
    "title": "How to fit a linear model to two columns of data (in R)",
    "content": "# How to fit a linear model to two columns of data (in R) [See all solutions.](../how-to-fit-a-linear-model-to-two-columns-of-data) ## Task Let's say we have two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can I find the best fit linear model that predicts $y$ based on $x$? In other words, what are the model coefficients $\\beta_0$ and $\\beta_1$ that give me the best linear model $\\hat y=\\beta_0+\\beta_1x$ based on my data? Related tasks: * [How to compute R-squared for a simple linear model](../how-to-compute-r-squared-for-a-simple-linear-model) * [How to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model) * [How to predict the response variable in a linear model](../how-to-predict-the-response-variable-in-a-linear-model) ## Solution This solution uses fake example data. When using this code, replace our fake data with your real data. ```R # Here is the fake data you should replace with your real data. xs <- c( 393, 453, 553, 679, 729, 748, 817 ) ys <- c( 24, 25, 27, 36, 55, 68, 84 ) # If you need the model coefficients stored in variables for later use, do: model <- lm( ys ~ xs ) beta0 = model$coefficients[1] beta1 = model$coefficients[2] # If you just need to see the coefficients, do this alone: lm( ys ~ xs ) ``` Call: lm(formula = ys ~ xs) Coefficients: (Intercept) xs -37.3214 0.1327 The linear model in this example is approximately $y=0.133x-37.32$. Content last modified on 28 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to fit a linear model to two columns of data/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data-in-r/",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data-in-r/"
  },"645": {
    "doc": "How to fit a linear model to two columns of data",
    "title": "How to fit a linear model to two columns of data",
    "content": " ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data/",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data/"
  },"646": {
    "doc": "How to fit a linear model to two columns of data",
    "title": "Description",
    "content": "Let’s say we have two columns of data, one for a single independent variable $x$ and the other for a single dependent variable $y$. How can I find the best fit linear model that predicts $y$ based on $x$? . In other words, what are the model coefficients $\\beta_0$ and $\\beta_1$ that give me the best linear model $\\hat y=\\beta_0+\\beta_1x$ based on my data? . Related tasks: . | How to compute R-squared for a simple linear model | How to fit a multivariate linear model | How to predict the response variable in a linear model | . ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data/#description",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data/#description"
  },"647": {
    "doc": "How to fit a linear model to two columns of data",
    "title": "Solution, in Julia",
    "content": "View this solution alone. This solution uses fake example data. When using this code, replace our fake data with your real data. | 1 2 3 4 5 6 7 8 9 10 11 . | # Here is the fake data you should replace with your real data. xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] # Place the data into a DataFrame, because that's what Julia's modeling tools expect: using DataFrames data = DataFrame( xs=xs, ys=ys ) # Or you can name the columns whatever you like # Create the linear model: using GLM lm( @formula( ys ~ xs ), data ) . | . | 1 2 3 4 5 6 7 8 9 10 11 . | StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}} ys ~ 1 + xs Coefficients: ─────────────────────────────────────────────────────────────────────────── Coef. Std. Error t Pr(&gt;|t|) Lower 95% Upper 95% ─────────────────────────────────────────────────────────────────────────── (Intercept) -37.3214 18.9954 -1.96 0.1066 -86.1508 11.5079 xs 0.13272 0.029589 4.49 0.0065 0.0566587 0.20878 ─────────────────────────────────────────────────────────────────────────── . | . The linear model in this example is approximately $y=0.13272x-37.3214$. Content last modified on 05 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data/#solution-in-julia",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data/#solution-in-julia"
  },"648": {
    "doc": "How to fit a linear model to two columns of data",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. This solution uses a pandas DataFrame of fake example data. When using this code, replace our fake data with your real data. Although the solution below uses plain Python lists of data, it also works if the data are stored in NumPy arrays or pandas Series. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | # Here is the fake data you should replace with your real data. xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] # We will use SciPy to build the model import scipy.stats as stats # If you need the model coefficients stored in variables for later use, do: model = stats.linregress( xs, ys ) beta0 = model.intercept beta1 = model.slope # If you just need to see the coefficients (and some other related data), # do this alone: stats.linregress( xs, ys ) . | . | 1 . | LinregressResult(slope=0.1327195637885226, intercept=-37.32141898334582, rvalue=0.8949574425541466, pvalue=0.006486043236692156, stderr=0.029588975845594334, intercept_stderr=18.995444317768097) . | . The linear model in this example is approximately $\\hat y=0.133x-37.32$. Content last modified on 08 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data/#using-scipy-in-python",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data/#using-scipy-in-python"
  },"649": {
    "doc": "How to fit a linear model to two columns of data",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. This solution uses fake example data. When using this code, replace our fake data with your real data. Although the solution below uses plain Python lists of data, it also works if the data are stored in NumPy arrays or pandas Series. | 1 2 3 4 5 6 7 8 9 10 11 12 13 . | # Here is the fake data you should replace with your real data. xs = [ 393, 453, 553, 679, 729, 748, 817 ] ys = [ 24, 25, 27, 36, 55, 68, 84 ] # We will use statsmodels to build the model import statsmodels.api as sm # statsmodels does not add a constant term to the model unless you request it: xs = sm.add_constant( xs ) # Fit the model and tell us all about it: model = sm.OLS( ys, xs ).fit() model.summary() . | . | 1 2 . | /opt/conda/lib/python3.10/site-packages/statsmodels/stats/stattools.py:74: ValueWarning: omni_normtest is not valid with less than 8 observations; 7 samples were given. warn(\"omni_normtest is not valid with less than 8 observations; %i \" . | . OLS Regression Results | Dep. Variable: | y | R-squared: | 0.801 | . | Model: | OLS | Adj. R-squared: | 0.761 | . | Method: | Least Squares | F-statistic: | 20.12 | . | Date: | Tue, 08 Nov 2022 | Prob (F-statistic): | 0.00649 | . | Time: | 21:35:13 | Log-Likelihood: | -25.926 | . | No. Observations: | 7 | AIC: | 55.85 | . | Df Residuals: | 5 | BIC: | 55.74 | . | Df Model: | 1 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P&gt;|t| | [0.025 | 0.975] | . | const | -37.3214 | 18.995 | -1.965 | 0.107 | -86.151 | 11.508 | . | x1 | 0.1327 | 0.030 | 4.485 | 0.006 | 0.057 | 0.209 | . | Omnibus: | nan | Durbin-Watson: | 0.806 | . | Prob(Omnibus): | nan | Jarque-Bera (JB): | 0.520 | . | Skew: | -0.366 | Prob(JB): | 0.771 | . | Kurtosis: | 1.883 | Cond. No. | 2.78e+03 | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.[2] The condition number is large, 2.78e+03. This might indicate that there arestrong multicollinearity or other numerical problems. The linear model in this example is approximately $\\hat y=0.1327x-37.3214$. Content last modified on 08 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data/#using-statsmodels-in-python",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data/#using-statsmodels-in-python"
  },"650": {
    "doc": "How to fit a linear model to two columns of data",
    "title": "Solution, in R",
    "content": "View this solution alone. This solution uses fake example data. When using this code, replace our fake data with your real data. | 1 2 3 4 5 6 7 8 9 10 11 . | # Here is the fake data you should replace with your real data. xs &lt;- c( 393, 453, 553, 679, 729, 748, 817 ) ys &lt;- c( 24, 25, 27, 36, 55, 68, 84 ) # If you need the model coefficients stored in variables for later use, do: model &lt;- lm( ys ~ xs ) beta0 = model$coefficients[1] beta1 = model$coefficients[2] # If you just need to see the coefficients, do this alone: lm( ys ~ xs ) . | . | 1 2 3 4 5 6 . | Call: lm(formula = ys ~ xs) Coefficients: (Intercept) xs -37.3214 0.1327 . | . The linear model in this example is approximately $y=0.133x-37.32$. Content last modified on 28 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data/#solution-in-r",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data/#solution-in-r"
  },"651": {
    "doc": "How to fit a linear model to two columns of data",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | Bentley University MA214 | Bentley University MA252 | . ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data/#topics-that-include-this-task",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data/#topics-that-include-this-task"
  },"652": {
    "doc": "How to fit a linear model to two columns of data",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-fit-a-linear-model-to-two-columns-of-data/#opportunities",
    "relUrl": "/how-to-fit-a-linear-model-to-two-columns-of-data/#opportunities"
  },"653": {
    "doc": "How to fit a multivariate linear model (in Python, using statsmodels)",
    "title": "How to fit a multivariate linear model (in Python, using statsmodels)",
    "content": "# How to fit a multivariate linear model (in Python, using statsmodels) [See all solutions.](../how-to-fit-a-multivariate-linear-model) ## Task Let's say we have several independent variables, $x_1, x_2, \\ldots, x_k$, and a dependent variable $y$. How can I fit a linear model that uses these independent variables to best predict the dependent variable? In other words, what are the model coefficients $\\beta_0, \\beta_1, \\beta_2, \\ldots, \\beta_k$ that give me the best linear model $\\hat{y}=\\beta_0 + \\beta_1x + \\beta_2x + \\cdots + \\beta_kx$ based on my data? Related tasks: * [How to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data) * [How to predict the response variable in a linear model](../how-to-predict-the-response-variable-in-a-linear-model) ## Solution We're going to use fake data here for illustrative purposes. You can replace our fake data with your real data in the code below. We'll put the data into a dataframe and then make a variable with a list of the independent variables and a variable with the outcome variable. ```python import pandas as pd # Replace this fake data with your real data df = pd.DataFrame( { 'x1':[2, 7, 4, 3, 11, 18, 6, 15, 9, 12], 'x2':[4, 6, 10, 1, 18, 11, 8, 20, 16, 13], 'x3':[11, 16, 20, 6, 14, 8, 5, 23, 13, 10], 'y':[24, 60, 32, 29, 90, 45, 130, 76, 100, 120] } ) xs = df[['x1', 'x2', 'x3']] # list of independent variables y = df['y'] # dependent variable ``` We can use StatsModels' `OLS` to build our multivariate linear model. We'll print out the coefficients and the intercept, and the coefficients will be in the form of an array when we print them. ```python import statsmodels.api as sm # Add a constant to the dependent variables first xs = sm.add_constant(xs) # Build the model model = sm.OLS(y, xs).fit() # Show the model summary to get the coefficients and the intercept model.summary() ``` /opt/conda/lib/python3.9/site-packages/statsmodels/tsa/tsatools.py:142: FutureWarning: In a future version of pandas all arguments of concat except for the argument 'objs' will be keyword-only x = pd.concat(x[::order], 1) /opt/conda/lib/python3.9/site-packages/scipy/stats/stats.py:1541: UserWarning: kurtosistest only valid for n>=20 ... continuing anyway, n=10 warnings.warn(\"kurtosistest only valid for n>=20 ... continuing \" OLS Regression Results | Dep. Variable: | y | R-squared: | 0.594 | . | Model: | OLS | Adj. R-squared: | 0.390 | . | Method: | Least Squares | F-statistic: | 2.921 | . | Date: | Tue, 07 Dec 2021 | Prob (F-statistic): | 0.122 | . | Time: | 15:07:00 | Log-Likelihood: | -45.689 | . | No. Observations: | 10 | AIC: | 99.38 | . | Df Residuals: | 6 | BIC: | 100.6 | . | Df Model: | 3 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P>|t| | [0.025 | 0.975] | . | const | 77.2443 | 27.366 | 2.823 | 0.030 | 10.282 | 144.206 | . | x1 | -2.7009 | 2.855 | -0.946 | 0.381 | -9.686 | 4.284 | . | x2 | 7.2989 | 2.875 | 2.539 | 0.044 | 0.265 | 14.333 | . | x3 | -4.8607 | 2.187 | -2.223 | 0.068 | -10.211 | 0.490 | . | Omnibus: | 2.691 | Durbin-Watson: | 2.123 | . | Prob(Omnibus): | 0.260 | Jarque-Bera (JB): | 1.251 | . | Skew: | 0.524 | Prob(JB): | 0.535 | . | Kurtosis: | 1.620 | Cond. No. | 58.2 | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified. The coefficients and intercept appear on the left hand side of the output, about half way down, under the heading \"coef.\" Thus the multivariate linear model from the example data is $\\hat y = 77.2443 - 2.7009x_1 + 7.2989x_2 - 4.8607x_3$. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to fit a multivariate linear model/Python, using statsmodels.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-fit-a-multivariate-linear-model-in-python-using-statsmodels/",
    "relUrl": "/how-to-fit-a-multivariate-linear-model-in-python-using-statsmodels/"
  },"654": {
    "doc": "How to fit a multivariate linear model (in R)",
    "title": "How to fit a multivariate linear model (in R)",
    "content": "# How to fit a multivariate linear model (in R) [See all solutions.](../how-to-fit-a-multivariate-linear-model) ## Task Let's say we have several independent variables, $x_1, x_2, \\ldots, x_k$, and a dependent variable $y$. How can I fit a linear model that uses these independent variables to best predict the dependent variable? In other words, what are the model coefficients $\\beta_0, \\beta_1, \\beta_2, \\ldots, \\beta_k$ that give me the best linear model $\\hat{y}=\\beta_0 + \\beta_1x + \\beta_2x + \\cdots + \\beta_kx$ based on my data? Related tasks: * [How to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data) * [How to predict the response variable in a linear model](../how-to-predict-the-response-variable-in-a-linear-model) ## Solution We're going to use fake data here for illustrative purposes. You can replace our fake data with your real data in the code below. ```R # Replace this fake data with your real data x1 |t|) (Intercept) 77.244 27.366 2.823 0.0302 * x1 -2.701 2.855 -0.946 0.3806 x2 7.299 2.875 2.539 0.0441 * x3 -4.861 2.187 -2.223 0.0679 . --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 30.13 on 6 degrees of freedom Multiple R-squared: 0.5936, Adjusted R-squared: 0.3904 F-statistic: 2.921 on 3 and 6 DF, p-value: 0.1222 The coefficients and intercept appear on the left hand side of the output, about half way down, under the heading \"Estimate.\" Thus the multivariate linear model from the example data is $\\hat y = 77.244 - 2.701x_1 + 7.299x_2 - 4.861x_3$. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to fit a multivariate linear model/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-fit-a-multivariate-linear-model-in-r/",
    "relUrl": "/how-to-fit-a-multivariate-linear-model-in-r/"
  },"655": {
    "doc": "How to fit a multivariate linear model",
    "title": "How to fit a multivariate linear model",
    "content": " ",
    "url": "/how-to-fit-a-multivariate-linear-model/",
    "relUrl": "/how-to-fit-a-multivariate-linear-model/"
  },"656": {
    "doc": "How to fit a multivariate linear model",
    "title": "Description",
    "content": "Let’s say we have several independent variables, $x_1, x_2, \\ldots, x_k$, and a dependent variable $y$. How can I fit a linear model that uses these independent variables to best predict the dependent variable? . In other words, what are the model coefficients $\\beta_0, \\beta_1, \\beta_2, \\ldots, \\beta_k$ that give me the best linear model $\\hat{y}=\\beta_0 + \\beta_1x + \\beta_2x + \\cdots + \\beta_kx$ based on my data? . Related tasks: . | How to fit a linear model to two columns of data | How to predict the response variable in a linear model | . ",
    "url": "/how-to-fit-a-multivariate-linear-model/#description",
    "relUrl": "/how-to-fit-a-multivariate-linear-model/#description"
  },"657": {
    "doc": "How to fit a multivariate linear model",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. We’re going to use fake data here for illustrative purposes. You can replace our fake data with your real data in the code below. We’ll put the data into a dataframe and then make a variable with a list of the independent variables and a variable with the outcome variable. | 1 2 3 4 5 6 7 8 9 10 11 12 . | import pandas as pd # Replace this fake data with your real data df = pd.DataFrame( { 'x1':[2, 7, 4, 3, 11, 18, 6, 15, 9, 12], 'x2':[4, 6, 10, 1, 18, 11, 8, 20, 16, 13], 'x3':[11, 16, 20, 6, 14, 8, 5, 23, 13, 10], 'y':[24, 60, 32, 29, 90, 45, 130, 76, 100, 120] } ) xs = df[['x1', 'x2', 'x3']] # list of independent variables y = df['y'] # dependent variable . | . We can use StatsModels’ OLS to build our multivariate linear model. We’ll print out the coefficients and the intercept, and the coefficients will be in the form of an array when we print them. | 1 2 3 4 5 6 7 8 9 10 . | import statsmodels.api as sm # Add a constant to the dependent variables first xs = sm.add_constant(xs) # Build the model model = sm.OLS(y, xs).fit() # Show the model summary to get the coefficients and the intercept model.summary() . | . | 1 2 3 4 . | /opt/conda/lib/python3.9/site-packages/statsmodels/tsa/tsatools.py:142: FutureWarning: In a future version of pandas all arguments of concat except for the argument 'objs' will be keyword-only x = pd.concat(x[::order], 1) /opt/conda/lib/python3.9/site-packages/scipy/stats/stats.py:1541: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=10 warnings.warn(\"kurtosistest only valid for n&gt;=20 ... continuing \" . | . OLS Regression Results | Dep. Variable: | y | R-squared: | 0.594 | . | Model: | OLS | Adj. R-squared: | 0.390 | . | Method: | Least Squares | F-statistic: | 2.921 | . | Date: | Tue, 07 Dec 2021 | Prob (F-statistic): | 0.122 | . | Time: | 15:07:00 | Log-Likelihood: | -45.689 | . | No. Observations: | 10 | AIC: | 99.38 | . | Df Residuals: | 6 | BIC: | 100.6 | . | Df Model: | 3 | | | . | Covariance Type: | nonrobust | | | . | | coef | std err | t | P&gt;|t| | [0.025 | 0.975] | . | const | 77.2443 | 27.366 | 2.823 | 0.030 | 10.282 | 144.206 | . | x1 | -2.7009 | 2.855 | -0.946 | 0.381 | -9.686 | 4.284 | . | x2 | 7.2989 | 2.875 | 2.539 | 0.044 | 0.265 | 14.333 | . | x3 | -4.8607 | 2.187 | -2.223 | 0.068 | -10.211 | 0.490 | . | Omnibus: | 2.691 | Durbin-Watson: | 2.123 | . | Prob(Omnibus): | 0.260 | Jarque-Bera (JB): | 1.251 | . | Skew: | 0.524 | Prob(JB): | 0.535 | . | Kurtosis: | 1.620 | Cond. No. | 58.2 | . Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified. The coefficients and intercept appear on the left hand side of the output, about half way down, under the heading “coef.” . Thus the multivariate linear model from the example data is $\\hat y = 77.2443 - 2.7009x_1 + 7.2989x_2 - 4.8607x_3$. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-fit-a-multivariate-linear-model/#using-statsmodels-in-python",
    "relUrl": "/how-to-fit-a-multivariate-linear-model/#using-statsmodels-in-python"
  },"658": {
    "doc": "How to fit a multivariate linear model",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use fake data here for illustrative purposes. You can replace our fake data with your real data in the code below. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | # Replace this fake data with your real data x1 &lt;- c(2, 7, 4, 3, 11, 18, 6, 15, 9, 12) x2 &lt;- c(4, 6, 10, 1, 18, 11, 8, 20, 16, 13) x3 &lt;- c(11, 16, 20, 6, 14, 8, 5, 23, 13, 10) y &lt;- c(24, 60, 32, 29, 90, 45, 130, 76, 100, 120) # If you'll need the model coefficients later, store them as variables like this: model &lt;- lm(y ~ x1 + x2 + x3) beta0 &lt;- model$coefficients[1] beta1 &lt;- model$coefficients[2] beta2 &lt;- model$coefficients[3] beta3 &lt;- model$coefficients[4] # To see the model summary, which includes the coefficients and much more, do this: summary(model) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 . | Call: lm(formula = y ~ x1 + x2 + x3) Residuals: Min 1Q Median 3Q Max -25.031 -20.218 -8.373 22.937 35.640 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 77.244 27.366 2.823 0.0302 * x1 -2.701 2.855 -0.946 0.3806 x2 7.299 2.875 2.539 0.0441 * x3 -4.861 2.187 -2.223 0.0679 . --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 30.13 on 6 degrees of freedom Multiple R-squared: 0.5936, Adjusted R-squared: 0.3904 F-statistic: 2.921 on 3 and 6 DF, p-value: 0.1222 . | . The coefficients and intercept appear on the left hand side of the output, about half way down, under the heading “Estimate.” . Thus the multivariate linear model from the example data is $\\hat y = 77.244 - 2.701x_1 + 7.299x_2 - 4.861x_3$. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-fit-a-multivariate-linear-model/#solution-in-r",
    "relUrl": "/how-to-fit-a-multivariate-linear-model/#solution-in-r"
  },"659": {
    "doc": "How to fit a multivariate linear model",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA252 | . ",
    "url": "/how-to-fit-a-multivariate-linear-model/#topics-that-include-this-task",
    "relUrl": "/how-to-fit-a-multivariate-linear-model/#topics-that-include-this-task"
  },"660": {
    "doc": "How to fit a multivariate linear model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-fit-a-multivariate-linear-model/#opportunities",
    "relUrl": "/how-to-fit-a-multivariate-linear-model/#opportunities"
  },"661": {
    "doc": "How to generate random values from a distribution (in Excel)",
    "title": "How to generate random values from a distribution (in Excel)",
    "content": "# How to generate random values from a distribution (in Excel) [See all solutions.](../how-to-generate-random-values-from-a-distribution) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to generate random values from a chosen distribution? Related tasks: * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution You can generate random numbers from many common distributions easily using the Data Analysis Toolpak. (Below we cover another method that does not use the Data Analysis Toolpak.) If you’ve never enabled it before, see [these instructions from Microsoft](https://support.microsoft.com/en-us/office/load-the-analysis-toolpak-in-excel-6a63e598-cd6d-42e3-9317-6b40ba1a66b4#OfficeVersion=Windows) on how to do so. On the Data tab, click the Data Analysis button, shown below. From the list of tools it provides, choose Random Number Generation, as shown below, then click OK. Choose a number of variables (that is, columns of output) and of random numbers (that is, rows of output) and a distribution. Once you select a distribution, you can also select its parameters (e.g., the mean and standard deviation for a normal distribution). Choose where you want the output and then click OK. Here is example data generated for 3 variables, 20 random numbers per variable, using a standard normal distribution. It’s also possible to generate random numbers using Excel formulas in place of the Data Analysis Toolpak. Here’s how: No matter what distribution you want to draw from, *begin by generating random values from the uniform distribution on the interval \\[0,1\\]* using the =RAND() function. For example, if you’ll want 10 random values, place the =RAND() formula into 10 cells in a single column, like so: Then in an adjacent column, apply one of the built-in inverse CDF functions from Excel’s statistics function set. For example, to generate values from a normal distribution with mean 5 and standard deviation 2, apply =NORM.INV(\\_,5,2) to each random number in the first column. The NORM.INV function converts uniform random values into random values chosen from the specified distribution. Excel also has built-in functions for several other distributions, including BETA.INV, BINOM.INV, CHISQ.INV, F.INV, GAMMA.INV, LOGNORM.INV, and T.INV. Excel recomputes random values every time a formula or cell changes. If you do not want this behavior, simply copy all the random cells and then paste them back into the exact same locations, but using the “Paste Values” functionality of Excel, which removes the original formulas, leaving only their final results. Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to generate random values from a distribution/Excel.docx). ",
    "url": "/how-to-generate-random-values-from-a-distribution-in-excel/",
    "relUrl": "/how-to-generate-random-values-from-a-distribution-in-excel/"
  },"662": {
    "doc": "How to generate random values from a distribution (in Julia)",
    "title": "How to generate random values from a distribution (in Julia)",
    "content": "# How to generate random values from a distribution (in Julia) [See all solutions.](../how-to-generate-random-values-from-a-distribution) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to generate random values from a chosen distribution? Related tasks: * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution You can import many different random variables from Julia's `Distributions` package. The full list of them is online [here](https://juliastats.org/Distributions.jl/stable/univariate/). If you don't have that package installed, first run `using Pkg` and then `Pkg.add( \"Distributions\" )` from within Julia. Regardless of whether the distribution is discrete or continuous, the appropriate function to call is `rand`. Here are two examples. Using a **normal distribution:** ```julia using Distributions X = Normal( 5, 3 ) rand( X, 10 ) ``` 10-element Vector{Float64}: 3.2984814947222136 3.8868925858958496 11.054518475291347 2.151820027715916 6.288103699884755 4.207026557133198 2.957553317891313 7.192469043513352 4.440336885361706 4.809597919062985 Using a **uniform distribution:** In this example, we generate the random values in one line of code, without giving the random variable a name. ```julia using Distributions rand( Uniform( 100, 200 ), 5 ) ``` 5-element Vector{Float64}: 147.77637653948742 139.5897785099046 154.48524776533654 141.81989321071512 116.27699388606632 Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to generate random values from a distribution/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-generate-random-values-from-a-distribution-in-julia/",
    "relUrl": "/how-to-generate-random-values-from-a-distribution-in-julia/"
  },"663": {
    "doc": "How to generate random values from a distribution (in Python, using SciPy)",
    "title": "How to generate random values from a distribution (in Python, using SciPy)",
    "content": "# How to generate random values from a distribution (in Python, using SciPy) [See all solutions.](../how-to-generate-random-values-from-a-distribution) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to generate random values from a chosen distribution? Related tasks: * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution You can import many different random variables from SciPy's `stats` module. The full list of them is online [here](https://docs.scipy.org/doc/scipy/reference/stats.html#discrete-distributions). Regardless of whether the distribution is discrete or continuous, the appropriate function to call is `rvs`, which stands for \"random values.\" Here are two examples. Using a **normal distribution:** ```python from scipy import stats X = stats.norm( 10, 5 ) # normal random variable with μ=10 and σ=5 X.rvs( 20 ) # 20 random values from X ``` array([ 1.13692807, -3.09919844, 13.79356131, 17.84684953, 7.34652953, 5.96476561, 6.23576219, 12.28853107, 10.27890569, 2.09501497, 17.00005655, 4.48580115, 13.15019787, 5.88702913, 0.69611227, 3.91977886, 7.94029598, 17.89184954, 5.30894695, 4.85143363]) Using a **uniform distribution:** (Note that in SciPy, the uniform distribution needs a \"location,\" which is where the sample space begins---in this case 50---and a \"scale,\" which is the width of the sample space---in this case 10.) ```python from scipy import stats X = stats.uniform( 50, 10 ) # uniform random variable on the interval [50,60] X.rvs( 20 ) # 20 random values from X ``` array([55.91662278, 51.49011128, 52.01391463, 50.2982162 , 57.60499819, 53.57351348, 55.85305281, 51.26367314, 56.40196614, 52.4686033 , 55.2603163 , 57.10813614, 54.95842753, 52.03184066, 50.18116328, 51.52196773, 55.10236943, 59.15484043, 56.90184757, 58.04909252]) Content last modified on 27 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to generate random values from a distribution/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-generate-random-values-from-a-distribution-in-python-using-scipy/",
    "relUrl": "/how-to-generate-random-values-from-a-distribution-in-python-using-scipy/"
  },"664": {
    "doc": "How to generate random values from a distribution (in R)",
    "title": "How to generate random values from a distribution (in R)",
    "content": "# How to generate random values from a distribution (in R) [See all solutions.](../how-to-generate-random-values-from-a-distribution) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to generate random values from a chosen distribution? Related tasks: * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution Because R is designed for use in statistics, it comes with many probability distributions built in. A list of them is online [here](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Probability-distributions). Regardless of whether the distribution is discrete or continuous, prefix the name of the distribution with `r`, which stands for \"random values.\" Here are two examples. Using a **normal distribution:** ```R # 20 random values from the normal distribution with μ=10 and σ=5 rnorm( 20, mean=10, sd=5 ) ``` [1] 10.900996 11.976357 10.050084 12.659541 9.213338 10.347917 7.532614 [8] 11.563255 15.942300 13.378527 8.029759 5.707103 16.132197 -1.686346 [15] 5.930778 5.099380 8.945254 13.480151 18.683996 1.714144 Using a **uniform distribution:** ```R # 20 random values from the uniform distribution on the interval [50,60] runif( 20, min=50, max=60 ) ``` [1] 57.95825 50.30892 59.89443 58.67946 59.24075 58.61541 52.79747 51.46903 [9] 54.59619 52.78599 54.41834 55.62009 51.94706 54.79693 55.33611 59.67543 [17] 56.80342 50.73818 59.68497 58.63296 Content last modified on 27 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to generate random values from a distribution/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-generate-random-values-from-a-distribution-in-r/",
    "relUrl": "/how-to-generate-random-values-from-a-distribution-in-r/"
  },"665": {
    "doc": "How to generate random values from a distribution",
    "title": "How to generate random values from a distribution",
    "content": " ",
    "url": "/how-to-generate-random-values-from-a-distribution/",
    "relUrl": "/how-to-generate-random-values-from-a-distribution/"
  },"666": {
    "doc": "How to generate random values from a distribution",
    "title": "Description",
    "content": "There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to generate random values from a chosen distribution? . Related tasks: . | How to compute probabilities from a distribution | How to plot continuous probability distributions | How to plot discrete probability distributions | . ",
    "url": "/how-to-generate-random-values-from-a-distribution/#description",
    "relUrl": "/how-to-generate-random-values-from-a-distribution/#description"
  },"667": {
    "doc": "How to generate random values from a distribution",
    "title": "Solution, in Excel",
    "content": "View this solution alone. You can generate random numbers from many common distributions easily using the Data Analysis Toolpak. (Below we cover another method that does not use the Data Analysis Toolpak.) If you’ve never enabled it before, see these instructions from Microsoft on how to do so. On the Data tab, click the Data Analysis button, shown below. From the list of tools it provides, choose Random Number Generation, as shown below, then click OK. Choose a number of variables (that is, columns of output) and of random numbers (that is, rows of output) and a distribution. Once you select a distribution, you can also select its parameters (e.g., the mean and standard deviation for a normal distribution). Choose where you want the output and then click OK. Here is example data generated for 3 variables, 20 random numbers per variable, using a standard normal distribution. It’s also possible to generate random numbers using Excel formulas in place of the Data Analysis Toolpak. Here’s how: . No matter what distribution you want to draw from, begin by generating random values from the uniform distribution on the interval [0,1] using the =RAND() function. For example, if you’ll want 10 random values, place the =RAND() formula into 10 cells in a single column, like so: . Then in an adjacent column, apply one of the built-in inverse CDF functions from Excel’s statistics function set. For example, to generate values from a normal distribution with mean 5 and standard deviation 2, apply =NORM.INV(_,5,2) to each random number in the first column. The NORM.INV function converts uniform random values into random values chosen from the specified distribution. Excel also has built-in functions for several other distributions, including BETA.INV, BINOM.INV, CHISQ.INV, F.INV, GAMMA.INV, LOGNORM.INV, and T.INV. Excel recomputes random values every time a formula or cell changes. If you do not want this behavior, simply copy all the random cells and then paste them back into the exact same locations, but using the “Paste Values” functionality of Excel, which removes the original formulas, leaving only their final results. Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-generate-random-values-from-a-distribution/#solution-in-excel",
    "relUrl": "/how-to-generate-random-values-from-a-distribution/#solution-in-excel"
  },"668": {
    "doc": "How to generate random values from a distribution",
    "title": "Solution, in Julia",
    "content": "View this solution alone. You can import many different random variables from Julia’s Distributions package. The full list of them is online here. If you don’t have that package installed, first run using Pkg and then Pkg.add( \"Distributions\" ) from within Julia. Regardless of whether the distribution is discrete or continuous, the appropriate function to call is rand. Here are two examples. Using a normal distribution: . | 1 2 3 . | using Distributions X = Normal( 5, 3 ) rand( X, 10 ) . | . | 1 2 3 4 5 6 7 8 9 10 11 . | 10-element Vector{Float64}: 3.2984814947222136 3.8868925858958496 11.054518475291347 2.151820027715916 6.288103699884755 4.207026557133198 2.957553317891313 7.192469043513352 4.440336885361706 4.809597919062985 . | . Using a uniform distribution: . In this example, we generate the random values in one line of code, without giving the random variable a name. | 1 2 . | using Distributions rand( Uniform( 100, 200 ), 5 ) . | . | 1 2 3 4 5 6 . | 5-element Vector{Float64}: 147.77637653948742 139.5897785099046 154.48524776533654 141.81989321071512 116.27699388606632 . | . Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-generate-random-values-from-a-distribution/#solution-in-julia",
    "relUrl": "/how-to-generate-random-values-from-a-distribution/#solution-in-julia"
  },"669": {
    "doc": "How to generate random values from a distribution",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. You can import many different random variables from SciPy’s stats module. The full list of them is online here. Regardless of whether the distribution is discrete or continuous, the appropriate function to call is rvs, which stands for “random values.” Here are two examples. Using a normal distribution: . | 1 2 3 . | from scipy import stats X = stats.norm( 10, 5 ) # normal random variable with μ=10 and σ=5 X.rvs( 20 ) # 20 random values from X . | . | 1 2 3 4 . | array([ 1.13692807, -3.09919844, 13.79356131, 17.84684953, 7.34652953, 5.96476561, 6.23576219, 12.28853107, 10.27890569, 2.09501497, 17.00005655, 4.48580115, 13.15019787, 5.88702913, 0.69611227, 3.91977886, 7.94029598, 17.89184954, 5.30894695, 4.85143363]) . | . Using a uniform distribution: . (Note that in SciPy, the uniform distribution needs a “location,” which is where the sample space begins—in this case 50—and a “scale,” which is the width of the sample space—in this case 10.) . | 1 2 3 . | from scipy import stats X = stats.uniform( 50, 10 ) # uniform random variable on the interval [50,60] X.rvs( 20 ) # 20 random values from X . | . | 1 2 3 4 . | array([55.91662278, 51.49011128, 52.01391463, 50.2982162 , 57.60499819, 53.57351348, 55.85305281, 51.26367314, 56.40196614, 52.4686033 , 55.2603163 , 57.10813614, 54.95842753, 52.03184066, 50.18116328, 51.52196773, 55.10236943, 59.15484043, 56.90184757, 58.04909252]) . | . Content last modified on 27 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-generate-random-values-from-a-distribution/#using-scipy-in-python",
    "relUrl": "/how-to-generate-random-values-from-a-distribution/#using-scipy-in-python"
  },"670": {
    "doc": "How to generate random values from a distribution",
    "title": "Solution, in R",
    "content": "View this solution alone. Because R is designed for use in statistics, it comes with many probability distributions built in. A list of them is online here. Regardless of whether the distribution is discrete or continuous, prefix the name of the distribution with r, which stands for “random values.” Here are two examples. Using a normal distribution: . | 1 2 . | # 20 random values from the normal distribution with μ=10 and σ=5 rnorm( 20, mean=10, sd=5 ) . | . | 1 2 3 . | [1] 10.900996 11.976357 10.050084 12.659541 9.213338 10.347917 7.532614 [8] 11.563255 15.942300 13.378527 8.029759 5.707103 16.132197 -1.686346 [15] 5.930778 5.099380 8.945254 13.480151 18.683996 1.714144 . | . Using a uniform distribution: . | 1 2 . | # 20 random values from the uniform distribution on the interval [50,60] runif( 20, min=50, max=60 ) . | . | 1 2 3 . | [1] 57.95825 50.30892 59.89443 58.67946 59.24075 58.61541 52.79747 51.46903 [9] 54.59619 52.78599 54.41834 55.62009 51.94706 54.79693 55.33611 59.67543 [17] 56.80342 50.73818 59.68497 58.63296 . | . Content last modified on 27 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-generate-random-values-from-a-distribution/#solution-in-r",
    "relUrl": "/how-to-generate-random-values-from-a-distribution/#solution-in-r"
  },"671": {
    "doc": "How to generate random values from a distribution",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | . ",
    "url": "/how-to-generate-random-values-from-a-distribution/#topics-that-include-this-task",
    "relUrl": "/how-to-generate-random-values-from-a-distribution/#topics-that-include-this-task"
  },"672": {
    "doc": "How to graph a two-variable function as a surface (in Python, using SymPy)",
    "title": "How to graph a two-variable function as a surface (in Python, using SymPy)",
    "content": "# How to graph a two-variable function as a surface (in Python, using SymPy) [See all solutions.](../how-to-graph-a-two-variable-function-as-a-surface) ## Task Assume we have a mathematical formula in the variables $x$ and $y$ and we would like to plot a graph of it using a 3D coordinate system. Related tasks: * [How to graph mathematical functions](../how-to-graph-mathematical-functions) * [How to graph mathematical sequences](../how-to-graph-mathematical-sequences) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` First, we need a two-variable function that we wish to plot. ```python var( 'x y' ) formula = sin( x**2 + y**2 ) formula ``` $\\displaystyle \\sin{\\left(x^{2} + y^{2} \\right)}$ You can use `plot3d`, but you have to import it specifically, because it is not imported by default with the rest of SymPy. ```python from sympy.plotting.plot import plot3d plot3d( formula ) ``` ![png](data:image/png;base64,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TgjBmDFj+MxnPsOnP/1ptm3bxu23387HP/5x+vv7ecc73sH555/PvHnzKBQKPPbYYziOQzqdZv369bS1tVFTc2DWhUoy+7jRvPDUdjOIaEWCzmp0Y+WgeFLGDWuiqUn/U0oxrv0FTjxpFGMmp3nmmWdCt9Z1XTZt2sSePXvCMqPbbruNG2+8kXvuuedl0U8PJocCx/n617+O67q8973vrXiMNwoc55WKOAip18tvR/I6ELvI87vf/S5PPPEEN998c2ybUqnE5MmTefjhhxkxYgQLFizgV7/6VRjHAB0Y/e1vf0s6nWbChAn8/Oc/p6Ghoex8x2qdYiXp7Ozk17/+NXfccQe7d+8ml8sxefJk/u3f/g3P89i5cyednZ0MDAzQ0tJCe3s7NTU1h2SV7tndw/23L6VY9PBKPn/502q2bdyNElBq1spPARd94Hje9+6DNwf904oNnDJjbNlyw5fe2dnJzp078TwPIQSzZs2iurqau+66ix/+8Ifcc889ByznOpxyww038OMf/5iHH374kJTjV77yFWpqavjc5z53FEZ3WOSIuyV/lcrqb/7mb1i2bBlCCMaOHctPfvITOjo62Lp1Kx/60IfCQP29997Lpz71qRCMl0Tc/+53v+Otb31rGBgFKgZGx44dy1/+8pe/qsCo53m8733vY9++ffi+T2dnJ2eddRYXXHAB06ZNw/d9du7cSVdXF729vbS0tNDW1vayGCL6+/u5/zd/5I93b+SlXb0UlW5Ket23FjNz2piD7r955z5GthxY2WzZsoWtW7fS3NzMv/zLv7By5Up6enq46667OO644w5pnK9W7r//fj7zmc/wv//7v7S2tlbcpre3F9/3qa2tpbe3l0WLFvGlL32pLMv9OpYhZfV6kV//+tfcdttt/L//9//K1v01Kqs///nPPPzww/zTP/0ToBkwfvvb33L77bezYcMGFi1axAUXXMCsWbNQSrFr1y46Ozvp6ekpo4ypJP39/TzzzDNMnz491pllz65e6htzh5Rp9H2FPAChn0HXG9Dqgw8+yPXXX8/ixYt58MEHQyvrSMvEiRPJ5/NhA4cTTzyRH//4x7HJc926dWHpWqlU4tJLL61YrvY6liFl9XqRd77znVx88cVcdtllZevGjRtHY2PjX02d4sGku7ube+65h9tvv51Vq1ZxxhlnsHjxYo4//ngAdu3aRVdXF/v376exsTFkiDCKq6+vj2eeeeagfRVfjWzbto0tW7Ywd67m7PrDH/7Al770Je69917a2jQvfX9//1ELrL8BZEhZHWk51MDoX/7yF+64446KloIpgjWB0e9///tvmMBoX18f9913H7fffjvPPfccb3nLW1i8eDELFy5ECMGePXvo7Oxk37591NfXU19fz8aNG4+oours7GTjxo1hveKf/vQn/vEf/5G77777DVkAfJRkSFm91vIGCIweNhkYGODBBx/ktttu46mnnuLNb34zixcv5s1vfjOO47B69Wq2bt1KKpUKLa7m5ubDSr/S1dWleeUDRfX444/z2c9+lt/+9reDlm+9GvnKV77CT3/60zAWde2111asmLj//vv5u7/7OzzP40Mf+hBf+MIXDvtYXmM58rgfpdSB/r2h5b777lPTpk1TXV1dg27T09Oj9u/fH34+6aST1H333afuu+8+NXnyZDVhwgR13XXXle3n+7765Cc/qSZMmKCOO+449dRTTx2x63gtJJ/Pq/vuu0996EMfUjNmzFAXXXSRGjt2rPrLX/6ienp61JYtW9TSpUvVQw89pB5//HG1bt06tX//ftXb2/uK/23YsEH9/ve/V3v37lW9vb3qj3/8o5o9e7basGHDEbvOL3/5y+pf//VfD7hNqVRS48ePVy+++KLK5/Nq1qxZasWKFUdsTK+RHEyXvOp/xyzO6mjIVVddRT6fZ9GiRUDlwGhnZ2dZYNRQtryRmwCk02nOPvtszj77bJ5//nne+c53cuKJJ3L55Zczd+5cFi9ezOmnn87kyZPp7u6ms7OT9evXk8vlaG9vp6Wl5WUVE+/cuZP169eHnFrPPPMMV111FXfccQdjxhw8s3gk5a+1tOtoy5CyOoCsXbu24vKD1Sk+9thjQ00ALPnOd77D7bffzuzZs/E8j0cffZTbbruNL3/5y8ycOZPFixdz5plnMnHiRHp6ekLW0Ww2GwI7D1RcvGvXLl588cVQUS1fvpyPfvSj3HrrrUyYMOGIX98PfvADfvnLXzJ//ny+/e1vlzXqPRSe9SE5uAwpqyMgQ00A4vLTn/40/Ow4Dqeeeiqnnnoqvu/z5JNPcuutt3LttdcyadIkFi9ezFlnncWECRNCYOfSpUtJpVK0t7fT2toaKzbevXs3a9euZe7cuaTTaZ5//nk+9KEPcfPNN1fsaflK5EBJmI9//OP80z/9E0II/umf/onPfvaz/Pd//3dsO/UGK+06UjKkrI6AHMrDOfQA6zq/E088kRNPPBHf93n66ae59dZb+c53vsPo0aM577zzOOeccxg/fjx9fX10dXWxbNkyHMehra2NTCbDunXrQkW1Zs0aPvCBD/B//+//Pawu1lBp1+tDhpTVEZChJgAvX6SUHH/88Rx//PFce+21LF++nFtvvZV3vOMdtLe3c9555/GOd7yDsWPH0t/fz7p16+js7KSmpoYf/ehHzJs3j6uvvppf/OIXzJo166iN23bdf/3rX8dIII0cCs/6kByCHCQCPySvQIrFoho3bpxat25dmP1Zvnx5bJu7775bnX322cr3ffXYY4+pBQsWVDzWxo0b1WmnnaamTp2qpk+frr73ve+VbfP73/9e1dXVqdmzZ6vZs2err371q0fkul4L8X1frVixQn31q19VCxYsUGeeeab6h3/4BzVr1izV1dWlduzYoT73uc+pkSNHqlmzZqlvfvObat26dUdtfJdddpmaOXOmOu6449Q73/lOtXXrVqWUUlu2bFFvf/vbw+3uueceNWnSJDV+/Hj1L//yL0dtfEdRjng2cEhZHSGp9HD+6Ec/Uj/60Y+UUvol/MQnPqHGjx+vZs6cqZYsWVLxOFu3bg1hDfv371eTJk0qS3v//ve/V+eee+4RvJrXh/i+r+68807V0dGhTj31VHXaaaepL33pS2rmzJnqkUceUV1dXeqnP/2p+u///u/XeqhvRBlSVkMSl/POO0/97ne/iy17oyirgYEBddJJJ6m1a9cq3/fV+vXr1Uc+8hH1H//xH6/10IbkKCirIQT7MSQbNmzg1FNPZfny5bFSlT/84Q+8613vYuTIkQwfPpxvfetbMaqbvyYplUpDzRxen3LEs0NDv/oxIj09PbzrXe/ie9/7XllN3bx583jppZeoqanh3nvvZfHixaxZs+Y1GumRlaOlqC6++GJWrVoFaMaJhoYGli1bVrbdXxOX2etdhiyrY0CKxSLveMc7OOuss/jMZz5z0O3/GilrXkv57Gc/S319PV/60pfK1g3d61COuGV1zHKwv1FEKcUVV1zBtGnTBlVU27dvD3FbTz75JL7vh9xJthys1ZNSir/9279l4sSJzJo1i6VLlx7eizkGRSnFLbfccsDu4ENydGTIDXydy6OPPsqNN94YKhnQlf0bN24EdOfe2267jR/96Ee4rksul+Pmm28eFGB6oFZPf+31iq9E/vSnP9He3h62lk+KafLwRuEyey1lSFm9zuXkk0+uiHa35aqrruKqq6561ed6I9UrwqFxmd10000HtKqGmjwcPRlSVm8gOZgV8EaqV4SDl9GUSiXuuOMOnnrqqUG3MVUHbW1tXHDBBTz55JNDyuoIyVDM6g0kjz76KEuXLuW+++7jhz/8IX/84x9j6ytZcG+0ekVbHnroIaZOnTooaV9vby/d3d3h59/97ncVy22G5PDIkLJ6A0klK8CWoXrFuNx8881lLuDWrVtDJtDOzk5OPvlkZs+ezQknnMC55557LHWjOfbkIKjRIfkrkcEYTW05lHrFF154IaxBnD17tqqtrVXf/e53Y9v8NdcqDsmgcsQR7EMxqzeIVGI0Pfvss/nxj38M6KziOeecw7333svEiROpqqri5z//edlxpkyZEoIjPc9jxIgR4XFtOeWUU7j77ruP3AUNyRtPDqLNhmRIBpUHHnhAvelNbypb/nqqVbzlllvU9OnTlRCirFj82muvVRMmTFCTJ09W999/f8X9d+3apc4880w1ceJEdeaZZ6rdu3cfjWEfi3LELauhmNWQvGKpFNMx8thjjzF79mze/va3s2LFiqM8skhmzpzJHXfcUZahW7lyJTfffDMrVqzg/vvv5xOf+ASe55Xtf/3113PGGWewZs0azjjjDK6//vqjNfQhScpBtNmQDElFyefzqrm5WW3fvr1s3b59+1R3d7dSSlPlTJw48WgPr0ze8pa3xCyra6+9Vl177bXh97e97W3qz3/+c9l+kydPDjmqtm7dqiZPnnzkB3tsypBlNSSvT7nvvvuYN28e7e3tZevq6uqoqakB4JxzzqFYLLJz586jPcQDymCYsqR0dnaGOLOOjg66urqO2hiHJC5DympIXpEcCNl9oFrFD37wg7S1tcXwSLt372bRokVMmjSJRYsWsWfPnorHvf/++5kyZQoTJ06MuWNnnnkmM2fOLPt31113DTp+Mz5b3siYsmNCjob5NvTvr+sfUAXsAuqtZR8DPhZ8vgpYATwDPA68ydruVGAesNxa9k3gC8HnLwDfqHBOB3gRGA+kg2NPfxlj/gMw3/r+D8A/WN8fAE6qsN8qoCP43AGseq3v/xv135BlNSQvW5RSfUqpZqXUPmvZj5VSPw4+/0ApNUMpNVspdaJS6s/Wdn8EdicOeT5wQ/D5BmBxhdOeAKxVSq1TShWAm4P9Xqn8BrhECJERQowDJgFPDrLd5cHny4HBzbUhOaIypKyG5PUg7UqpbQDB37YK24wANlnfNwfLDihCiAuEEJuBk4B7hBAPBOdZAdwCrATuB65USnnBPv8lhDAcOtcDi4QQa4BFwfcheQ1kCBQ6JMeKVAooHZQcUin1a+DXg6z7OvD1Css/ZH3eBZxx6MMckiMlQ5bVkLwepFMI0QEQ/K2UctsMjLK+jwS2HoWxDcnrRIaU1ZC8HuRQ4kJLgElCiHFCiDRwSbDfkLxBZEhZDclRFSHETcBjwBQhxGYhxBUMEhcSQgwXQtwLoJQqobOMDwDPA7cEcacheYPIwRpGDMmQDMmQvC5kyLIakiEZkmNChpTVkAzJkBwTMqSshmRIhuSYkCFlNSRDMiTHhAwpqyEZkiE5JmRIWQ3JkAzJMSFDympIhmRIjgkZUlZDMiRDckzI/w+Q3ETOtq5YGAAAAABJRU5ErkJggg== ) Specify the minimum and maximum values for both $x$ and $y$ as follows. In this example, I keep $-\\pi\\leq x\\leq\\pi$ and $-\\frac\\pi2\\leq y\\leq\\frac\\pi2$. ```python plot3d( formula, (x,-pi,pi), (y,-pi/2,pi/2) ) ``` ![png](data:image/png;base64,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 ) Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to graph a two-variable function as a surface/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-graph-a-two-variable-function-as-a-surface-in-python-using-sympy/",
    "relUrl": "/how-to-graph-a-two-variable-function-as-a-surface-in-python-using-sympy/"
  },"673": {
    "doc": "How to graph a two-variable function as a surface",
    "title": "How to graph a two-variable function as a surface",
    "content": " ",
    "url": "/how-to-graph-a-two-variable-function-as-a-surface/",
    "relUrl": "/how-to-graph-a-two-variable-function-as-a-surface/"
  },"674": {
    "doc": "How to graph a two-variable function as a surface",
    "title": "Description",
    "content": "Assume we have a mathematical formula in the variables $x$ and $y$ and we would like to plot a graph of it using a 3D coordinate system. Related tasks: . | How to graph mathematical functions | How to graph mathematical sequences | . ",
    "url": "/how-to-graph-a-two-variable-function-as-a-surface/#description",
    "relUrl": "/how-to-graph-a-two-variable-function-as-a-surface/#description"
  },"675": {
    "doc": "How to graph a two-variable function as a surface",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . First, we need a two-variable function that we wish to plot. | 1 2 3 . | var( 'x y' ) formula = sin( x**2 + y**2 ) formula . | . $\\displaystyle \\sin{\\left(x^{2} + y^{2} \\right)}$ . You can use plot3d, but you have to import it specifically, because it is not imported by default with the rest of SymPy. | 1 2 . | from sympy.plotting.plot import plot3d plot3d( formula ) . | . | 1 . | &lt;sympy.plotting.plot.Plot at 0x7f76ca409280&gt; . | . Specify the minimum and maximum values for both $x$ and $y$ as follows. In this example, I keep $-\\pi\\leq x\\leq\\pi$ and $-\\frac\\pi2\\leq y\\leq\\frac\\pi2$. | 1 . | plot3d( formula, (x,-pi,pi), (y,-pi/2,pi/2) ) . | . | 1 . | &lt;sympy.plotting.plot.Plot at 0x7f763acebd30&gt; . | . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-graph-a-two-variable-function-as-a-surface/#using-sympy-in-python",
    "relUrl": "/how-to-graph-a-two-variable-function-as-a-surface/#using-sympy-in-python"
  },"676": {
    "doc": "How to graph a two-variable function as a surface",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-graph-a-two-variable-function-as-a-surface/#topics-that-include-this-task",
    "relUrl": "/how-to-graph-a-two-variable-function-as-a-surface/#topics-that-include-this-task"
  },"677": {
    "doc": "How to graph a two-variable function as a surface",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-graph-a-two-variable-function-as-a-surface/#opportunities",
    "relUrl": "/how-to-graph-a-two-variable-function-as-a-surface/#opportunities"
  },"678": {
    "doc": "How to graph curves that are not functions (in Python, using SymPy)",
    "title": "How to graph curves that are not functions (in Python, using SymPy)",
    "content": "# How to graph curves that are not functions (in Python, using SymPy) [See all solutions.](../how-to-graph-curves-that-are-not-functions) ## Task Assume we have an equation in which $y$ cannot be isolated as a function of $x$. (The standard example is the formula for the unit circle, $x^2+y^2=1$.) We would still like to be able to use software to plot such curves. How? Related tasks: * [How to graph mathematical functions](../how-to-graph-mathematical-functions) * [How to do implicit differentiation](../how-to-do-implicit-differentiation) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's consider the example of the unit circle, $x^2+y^2=1$. To plot it, SymPy first expects us to move everything to the left-hand side of the equation, so in this case, we would have $x^2+y^2-1=0$. We then use that left hand side to represent the equation as a single formula, and we can plot it with SymPy's `plot_implicit` function. ```python var( 'x y' ) formula = x**2 + y**2 - 1 # to represent x^2+y^2=1 plot_implicit( formula ) ``` ![png](data:image/png;base64,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 ) Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to graph curves that are not functions/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-graph-curves-that-are-not-functions-in-python-using-sympy/",
    "relUrl": "/how-to-graph-curves-that-are-not-functions-in-python-using-sympy/"
  },"679": {
    "doc": "How to graph curves that are not functions",
    "title": "How to graph curves that are not functions",
    "content": " ",
    "url": "/how-to-graph-curves-that-are-not-functions/",
    "relUrl": "/how-to-graph-curves-that-are-not-functions/"
  },"680": {
    "doc": "How to graph curves that are not functions",
    "title": "Description",
    "content": "Assume we have an equation in which $y$ cannot be isolated as a function of $x$. (The standard example is the formula for the unit circle, $x^2+y^2=1$.) We would still like to be able to use software to plot such curves. How? . Related tasks: . | How to graph mathematical functions | How to do implicit differentiation | . ",
    "url": "/how-to-graph-curves-that-are-not-functions/#description",
    "relUrl": "/how-to-graph-curves-that-are-not-functions/#description"
  },"681": {
    "doc": "How to graph curves that are not functions",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s consider the example of the unit circle, $x^2+y^2=1$. To plot it, SymPy first expects us to move everything to the left-hand side of the equation, so in this case, we would have $x^2+y^2-1=0$. We then use that left hand side to represent the equation as a single formula, and we can plot it with SymPy’s plot_implicit function. | 1 2 3 . | var( 'x y' ) formula = x**2 + y**2 - 1 # to represent x^2+y^2=1 plot_implicit( formula ) . | . | 1 . | &lt;sympy.plotting.plot.Plot at 0x7f10dbd7d130&gt; . | . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-graph-curves-that-are-not-functions/#using-sympy-in-python",
    "relUrl": "/how-to-graph-curves-that-are-not-functions/#using-sympy-in-python"
  },"682": {
    "doc": "How to graph curves that are not functions",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-graph-curves-that-are-not-functions/#topics-that-include-this-task",
    "relUrl": "/how-to-graph-curves-that-are-not-functions/#topics-that-include-this-task"
  },"683": {
    "doc": "How to graph curves that are not functions",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-graph-curves-that-are-not-functions/#opportunities",
    "relUrl": "/how-to-graph-curves-that-are-not-functions/#opportunities"
  },"684": {
    "doc": "How to graph mathematical functions (in Python, using NumPy and Matplotlib)",
    "title": "How to graph mathematical functions (in Python, using NumPy and Matplotlib)",
    "content": "# How to graph mathematical functions (in Python, using NumPy and Matplotlib) [See all solutions.](../how-to-graph-mathematical-functions) ## Task Assume we have a mathematical formula and we would like to plot a graph of it using the standard Cartesian coordinate system. Related tasks: * [How to graph curves that are not functions](../how-to-graph-curves-that-are-not-functions) * [How to graph mathematical sequences](../how-to-graph-mathematical-sequences) * [How to graph a two-variable function as a surface](../how-to-graph-a-two-variable-function-as-a-surface) ## Solution Let's assume we want to graph the function $x^2-5x+9$ from $x=-10$ to $x=10$. Let's import NumPy for the mathematics and Matplotlib for the graph. ```python import numpy as np import matplotlib.pyplot as plt ``` We compute a series of $(x,y)$ pairs to generate the plot. Notice how NumPy automatically computes a $y$ value for each $x$ value if we just include all the $x$s in the formula we wish to graph. ```python xs = np.linspace( -10, 10, 100 ) # 100 values from x=-10 to x=10 ys = xs**2 - 5*xs + 9 # compute all corresponding ys plt.plot( xs, ys ) plt.show() ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXcAAAD4CAYAAAAXUaZHAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/MnkTPAAAACXBIWXMAAAsTAAALEwEAmpwYAAApOUlEQVR4nO3deXhU5fn/8fedhQRIIJCNEMImIewgRATFBZDFpYJaLXXDulCrWLUula9ttYstra3V1hUFxRUXXHAXEAVlTdj3hD0QSEIgQCD7/fsjo780JhIyMzmz3K/r4pqZc87MuXOGfHLmmec8j6gqxhhjAkuI0wUYY4zxPAt3Y4wJQBbuxhgTgCzcjTEmAFm4G2NMAApzugCAuLg47dy5s9NlGGOMX8nMzCxQ1fi61vlEuHfu3JmMjAynyzDGGL8iIrvqW2fNMsYYE4As3I0xJgBZuBtjTACycDfGmAB00nAXkRkikici62stv0NEtojIBhH5R43lU0Qk27VujDeKNsYY8+Ma0lvmJeBJ4OXvFojIcGAc0E9VS0UkwbW8FzAB6A20B+aJSHdVrfR04cYYY+p30jN3VV0IFNZa/CtgqqqWurbJcy0fB8xS1VJV3QFkA4M9WK8xxpgGaGybe3fgHBFZJiJfi8gZruXJwJ4a2+W4lv2AiEwSkQwRycjPz29UEXlHSvjzRxs5fLysUc83xphA1dhwDwPaAEOA+4C3REQAqWPbOgeMV9Vpqpququnx8XVeYHVSh46XM/2bHbz47c5GPd8YYwJVY8M9B3hXqy0HqoA41/KUGtt1APa5V2L90tpFM6Z3Ii9+u4OjJeXe2o0xxvidxob7+8AIABHpDjQDCoA5wAQRiRCRLkAqsNwDddZr8vBUjpRU8PKSeq/CNcaYoNOQrpBvAEuANBHJEZGbgBlAV1f3yFnARNdZ/AbgLWAj8Blwu7d7yvTt0Jrz0+KZ/s0OjpdVeHNXxhjjN8QX5lBNT09XdwYOy9xVyBXPLOF3F/fk5nO6erAyY4zxXSKSqarpda0LiCtUB3Vqy9CusUxbuJ2ScutSb4wxARHuAHeM7Ebe0VLeythz8o2NMSbABUy4D+0aS3qnNjzz1TZKK+zs3RgT3AIm3EWEX49MJbeohNmZe50uxxhjHBUw4Q5wTmocA1JieGpBNmUVVU6XY4wxjgmocBcR7hyZyt7DJ3hvVY7T5RhjjGMCKtwBzk+Lp1+H1jy5IJvySjt7N8YEp4ALdxHh1yNS2VN4gvdXWdu7MSY4BVy4A4zsmUDv9q14ckE2FXb2bowJQgEZ7iLCXRd0Z9fB47xnZ+/GmCAUkOEOcEHPBPok29m7MSY4BWy4iwh3jaw+e3/Xzt6NMUEmYMMdqtve+yS34skvreeMMSa4BHS4f3f2vrvwOO+ttLN3Y0zwCOhwh+qz934dWvOfL7PsqlVjTNAI+HAXEe4e1Z2cQyd4J9OuWjXGBIeGzMQ0Q0TyXLMu1V53r4ioiMTVWDZFRLJFZIuIjPF0wY1xfvd4Tu8Yw5NfZtmIkcaYoNCQM/eXgLG1F4pICjAK2F1jWS9gAtDb9ZynRSTUI5W6QUS4Z1Qa+4pKeHOFjfdujAl8Jw13VV0IFNax6t/A/UDNefrGAbNUtVRVdwDZwGBPFOqus7vFMrhzW578MttmazLGBLxGtbmLyKXAXlVdU2tVMlDz1DjHtayu15gkIhkikpGfn9+YMk7Jd23veUdLeXXpLq/vzxhjnHTK4S4iLYAHgT/UtbqOZXXOwK2q01Q1XVXT4+PjT7WMRhl6WixnnRbLM19to7i0okn2aYwxTmjMmftpQBdgjYjsBDoAK0WkHdVn6ik1tu0A7HO3SE+6d0waB4vLeGnxTqdLMcYYrznlcFfVdaqaoKqdVbUz1YE+UFX3A3OACSISISJdgFRguUcrdtPAjm0Y2SOB577eRtGJcqfLMcYYr2hIV8g3gCVAmojkiMhN9W2rqhuAt4CNwGfA7arqc99e/mZ0d46UVPD8wu1Ol2KMMV4RdrINVPXnJ1nfudbjR4BH3CvLu3q3b83F/ZKY8e0OfnF2Z2KjIpwuyRhjPCrgr1Ctz90XdKekvJKnv9rmdCnGGONxQRvu3RKiuGJgB15Zuot9h084XY4xxnhU0IY7wJ0XpILCE/OynC7FGGM8KqjDvUObFlwzpCNvZ+5hW/4xp8sxxhiPCepwB7h9eDciw0N57IutTpdijDEeE/ThHhcVwc3DuvDxulzW5RQ5XY4xxnhE0Ic7wM3ndiWmRTj/+Hyz06UYY4xHWLgDrSLDmTy8G4uyCvg2u8Dpcowxxm0W7i7XDulEckxzpn66maqqOsc6M8YYv2Hh7hIZHsrdo7qzbm8Rn6zPdbocY4xxi4V7DZednkxaYjT//HwL5ZU2mbYxxn9ZuNcQGiL89sI0dh48ziybjs8Y48cs3GsZnpbA4C5teWJelk3oYYzxWxbutYgIUy7sQcGxUp5fZEMCG2P8k4V7HU7v2IaL+yYxbeF28o6WOF2OMcacMgv3etw3Jo2yiiobVMwY45caMhPTDBHJE5H1NZY9KiKbRWStiLwnIjE11k0RkWwR2SIiY7xUt9d1jmvJtUM6MWvFHrLzbFAxY4x/aciZ+0vA2FrL5gJ9VLUfsBWYAiAivYAJQG/Xc54WkVCPVdvE7hjRjebhoUz91IYlMMb4l5OGu6ouBAprLftCVb/rSrIU6OC6Pw6YpaqlqroDyAYGe7DeJhUbFcGvzj+NeZsOsHT7QafLMcaYBvNEm/uNwKeu+8lAzQ7iOa5lfuumYV1o3zqSRz7eZMMSGGP8hlvhLiIPAhXAa98tqmOzOhNRRCaJSIaIZOTn57tThldFhody39g01u0t4oM1e50uxxhjGqTR4S4iE4FLgGtU9bsAzwFSamzWAdhX1/NVdZqqpqtqenx8fGPLaBLj+ifTN7k1j362hZLySqfLMcaYk2pUuIvIWOC3wKWqerzGqjnABBGJEJEuQCqw3P0ynRUSIjx4cU/2FZUw/ZsdTpdjjDEn1ZCukG8AS4A0EckRkZuAJ4FoYK6IrBaRZwFUdQPwFrAR+Ay4XVUD4lR3SNdYRvVK5OkF2XZhkzHG58n/b1FxTnp6umZkZDhdxkntKChm9L+/5oqBHZh6RT+nyzHGBDkRyVTV9LrW2RWqp6BLXEuuH9qZNzP2sGGfzbdqjPFdFu6n6NcjUolpHs5fPtqEL3zqMcaYuli4n6LWLcK5e1R3lmw/yNyNB5wuxxhj6mTh3ghXD+5IakIUj3yyidKKgPi+2BgTYCzcGyEsNITfXdKLXQeP89K3O50uxxhjfsDCvZHO6x7PyB4J/PdL6xppjPE9Fu5u+N0lvSitqOSfn29xuhRjjPkfFu5u6BLXkhvP7sLbmTmszTnsdDnGGPM9C3c3TR7RjdiWETw8Z4N1jTTG+AwLdzdFR4Zz/9g0Vu4+zPurbdRIY4xvsHD3gJ8O7ED/lBj++slmjpaUO12OMcZYuHtCSIjwp0t7U3CslP9+me10OcYYY+HuKf1TYrhqUAozvtlhE2obYxxn4e5B941No3mzUP74oX25aoxxloW7B8VFRXDPqO4syirg8w37nS7HGBPELNw97NohnejRLpo/fbiR42UVTpdjjAlSFu4eFhYawl/G92FfUYl9uWqMcUxDptmbISJ5IrK+xrK2IjJXRLJct21qrJsiItkiskVExnircF+W3rktPx3UgRcWbbcvV40xjmjImftLwNhayx4A5qtqKjDf9RgR6QVMAHq7nvO0iIR6rFo/8sCFPYgMD+WhOevty1VjTJM7abir6kKgsNbiccBM1/2ZwPgay2epaqmq7gCygcGeKdW/xEVFcN+YNL7NPsiHa3OdLscYE2Qa2+aeqKq5AK7bBNfyZGBPje1yXMt+QEQmiUiGiGTk5+c3sgzfds2Zneib3Jo/f7SRI3blqjGmCXn6C1WpY1mdbRKqOk1V01U1PT4+3sNl+IbQEOGRy/pQcKyUx77Y6nQ5xpgg0thwPyAiSQCu2zzX8hwgpcZ2HYB9jS/P//XrEMP1Qzrx8pKdNiywMabJNDbc5wATXfcnAh/UWD5BRCJEpAuQCix3r0T/d8+YNGKjInjwvfVUVtmXq8YY72tIV8g3gCVAmojkiMhNwFRglIhkAaNcj1HVDcBbwEbgM+B2VQ36GaRbRYbz+0t6sW5vEa8s2el0OcaYICC+0E0vPT1dMzIynC7Dq1SV62csZ9Xuw8z7zXm0ax3pdEnGGD8nIpmqml7XOrtCtYmICI+M70tFVRUPzVl/8icYY4wbLNybUMfYFtw5sjufbzjAFzawmDHGiyzcm9jN53ShR7toHpqzgWOlNrCYMcY7LNybWHhoCH+9vC/7j5Tw6GebnS7HGBOgLNwdMLBjGyYO7czLS3eRueuQ0+UYYwKQhbtD7h2TRlKrSB6YvZbSiqDvLWqM8TALd4dERYTxyOV9yco7xjNfbXO6HGNMgLFwd9DwtATGDWjPUwuy2XrgqNPlGGMCiIW7w/5wSS+iIsK4/521NjSBMcZjLNwdFhsVwcOX9mb1nsO8+O0Op8sxxgQIC3cfcGn/9lzQM5FHP9/CjoJip8sxxgQAC3cfIFI97nuzsBB+O3stVdY8Y4xxk4W7j0hsFcnvL+nF8h2FvLpsl9PlGGP8nIW7D7lyUAfO7R7P3z7ZzO6Dx50uxxjjxyzcfYiIMPXyvoSFCPe9s8aaZ4wxjWbh7mPaxzTn9z/pxbIdhbxsE3sYYxrJrXAXkbtFZIOIrBeRN0QkUkTaishcEcly3bbxVLHB4spBHRieFs/Uzzaz03rPGGMaodHhLiLJwK+BdFXtA4QCE4AHgPmqmgrMdz02p0BE+Nvl/QgPDeHet9fYxU3GmFPmbrNMGNBcRMKAFsA+YBww07V+JjDezX0EpXatI/nTuN5k7DrE84u2O12OMcbPNDrcVXUv8E9gN5ALFKnqF0Ciqua6tskFEup6vohMEpEMEcnIz89vbBkBbfyAZMb2bsdjX2xl8/4jTpdjjPEj7jTLtKH6LL0L0B5oKSLXNvT5qjpNVdNVNT0+Pr6xZQS07y5uatU8jLvfXENZRZXTJRlj/IQ7zTIXADtUNV9Vy4F3gbOAAyKSBOC6zXO/zOAVGxXB3y7vx6bcIzw+b6vT5Rhj/IQ74b4bGCIiLUREgJHAJmAOMNG1zUTgA/dKNKN6JXLloA48+/U2VuwsdLocY4wfcKfNfRnwDrASWOd6rWnAVGCUiGQBo1yPjZseurQ3Hdq04O43V3O0pNzpcowxPs6t3jKq+pCq9lDVPqp6naqWqupBVR2pqqmuWzvV9ICoiDD+/bP+7Dt8gofnbHS6HGOMj7MrVP3IoE5tmTy8G7NX5vDx2lynyzHG+DALdz9zx8hU+qfE8H/vrWPf4RNOl2OM8VEW7n4mPDSEJ342gPLKKu5+c7VdvWqMqZOFux/qHNeSP43rw7IdhTz79TanyzHG+CALdz91xcBkLu3fnsfmbmXl7kNOl2OM8TEW7n5KRPjLZX1Iah3JnbNWccS6RxpjarBw92OtIsN5YsLp7DtcwpTZ61C19ndjTDULdz83qFMb7h2dxsfrcnlj+R6nyzHG+AgL9wDwy3O7ck5qHH/8cIONHmmMASzcA0JIiPDYVQNo1Tycya+vori0wumSjDEOs3APEPHRETz+swFsyz/G799fb+3vxgQ5C/cAcna3OO4a2Z13V+3lzRXW/m5MMLNwDzCTR3RjWLc4HpqzgU251v5uTLCycA8woSHC4xMG0Lp5OLe9ttKGBzYmSFm4B6C4qAievHoguwuPc9/ba6393ZggZOEeoAZ3acuUC3vw2Yb9PL9ou9PlGGOamFvhLiIxIvKOiGwWkU0iMlRE2orIXBHJct228VSx5tTcNKwLF/Vtx98/28LS7QedLscY04TcPXN/AvhMVXsA/ameQ/UBYL6qpgLzXY+NA0SEv1/Rj06xLZj8+ir2F5U4XZIxpok0OtxFpBVwLjAdQFXLVPUwMA6Y6dpsJjDevRKNO6Ijw3nu2kGcKKvgV69lUlpR6XRJxpgm4M6Ze1cgH3hRRFaJyAsi0hJIVNVcANdtQl1PFpFJIpIhIhn5+flulGFOJjUxmn9d1Z9Vuw/b/KvG+JCDx0q9NuGOO+EeBgwEnlHV04FiTqEJRlWnqWq6qqbHx8e7UYZpiLF9krh9+Gm8sXw3ry/b7XQ5xgS942UVXPPCMu6ctcorr+9OuOcAOaq6zPX4HarD/oCIJAG4bvPcK9F4ym9GpXFe93gemrOezF2FTpdjTNBSVe59ew1bDxzlyvQUr+yj0eGuqvuBPSKS5lo0EtgIzAEmupZNBD5wq0LjMaEhwn8mnE5yTHN++cpKm2DbGIc8tSCbT9bt54ELe3Bed++0XLjbW+YO4DURWQsMAP4KTAVGiUgWMMr12PiI1i3CeWFiOiXllUx6JYMTZfYFqzFNae7GA/zzi62MH9CeW87p6rX9uBXuqrra1W7eT1XHq+ohVT2oqiNVNdV1a5//fUy3hGiemDCADfuOcP9su4LVmKayZf9R7pq1ir7JrZl6RT9ExGv7sitUg9TInoncNyaND9fs48kvs50ux5iAV3CslJtmrqBlRBjTrh9EZHioV/cX5tVXNz7tV+edRtaBY/xr7la6xkdxcb8kp0syJiCVVlRy6yuZ5B8t5a1fDiWpdXOv79PO3IOYiDD1ir4M6tSG37y1mjV7DjtdkjEBR1V58L31ZOw6xL+u6k//lJgm2a+Fe5CLCAvluesGER8dwc0vZ1gPGmM87OmvtvFOZg53jkzlkn7tm2y/Fu6GuKgIZtxwBiVlldz40gobA94YD/lg9V4e/XwLl52ezF0XpDbpvi3cDQDdE6N55tpBZOcd47bXVlJeWeV0Scb4tRU7C7nv7bUM7tyWqVf09WrPmLpYuJvvDUuN46+X9WVRVoFNsm2MG7bnH2PSyxkkt2nOc9cNIiLMuz1j6mK9Zcz/uOqMFHYXHufJBdl0aNOcySOa9qOkMf4u/2gpE19cjojw4g1n0KZlM0fqsHA3P3DP6O7sPXyCf36xlcRWkV4b+8KYQFNcWsFNM1eQf7SUN24ZQue4lo7VYuFufuC7ST4KjpXywLvriIuOYHhanSM3G2NcKiqrmPz6StbvLWLademc3tHZSeiszd3UqVlYCM9cO4ge7aK5/bWV1gfemB+hqvx29joWbMnnT+P6cEGvRKdLsnA39YuKCOPFX5xBbFQzbnhxOdl5x5wuyRifNPXTzcxemcNdF6Ry7ZBOTpcDWLibk0iIjuSVG88kNCSE66cvs4ucjKll2sJtPLdwO9cN6cSdI32nA4KFuzmpznEtmXnjGRwtqeC66csoLC5zuiRjfMJbGXv46yebubhfEg9f2rvJ+7L/GAt30yC927fmhYnp5Bw6wcQZyzliV7GaIPfx2lwemL2Wc1LjeOyq/oSG+E6wg4W7OQVndo3lmWsHsin3CDe9tILjZRVOl2SMI77aksddb65iYMc2jl2kdDIW7uaUjOiRyOMTBpC56xC/fCWT0gqbyckEl6XbD3Lrq5mkJkQz/YYzaNHMN3uUux3uIhIqIqtE5CPX47YiMldEsly3znb2NB53Sb/2TL28H4uyCrj9tVWUVdg4NCY4ZO4q5MaXVpAc05yXbxpM6+bhTpdUL0+cud8JbKrx+AFgvqqmAvNdj02AueqMFP40rjfzNh3gzlmrbKAxE/DW7DnMDTNWkNgqkjduGUJcVITTJf0ot8JdRDoAFwMv1Fg8Dpjpuj8TGO/OPozvun5oZ353cU8+Xb+f37y1hgoLeBOg1u8t4rrpy4hpGc7rt5xJQqtIp0s6KXcbix4H7geiayxLVNVcAFXNFZE6r1sXkUnAJICOHTu6WYZxys3ndKWiSpn66WZCBf55ZX/CQu2rHBM41u8t4poXlhEdGc7rNw9pkinyPKHRv4UicgmQp6qZjXm+qk5T1XRVTY+Pj29sGcYH3Hreadw3Jo33V+/jbjuDNwFkXU4RVz+/lKiIMGZNGkJK2xZOl9Rg7py5nw1cKiIXAZFAKxF5FTggIkmus/YkIM8ThRrfdvvwboSGCFM/3UxVlfL4hAGE2xm88WNrcw5z7QvLaNU8nDdu8a9gBzfO3FV1iqp2UNXOwATgS1W9FpgDTHRtNhH4wO0qjV+49bzTePCinny8LpfJr6+0bpLGb2XsLOSa5/032ME7/dynAqNEJAsY5XpsgsQt53bloZ/04vMNB5j0ciYnyizgjX9ZnF3AddOXEx8dwdu3DvXLYAcPjeeuql8BX7nuHwRGeuJ1jX/6xdldaB4eypT31nHDi8uZfsMZREX45oUextS0YHMet76aSafYFrx685kkRPt+r5j6WKOo8YoJgzvy+M8GkLHrENe8sIxDNtiY8XEfrN7LLS9nkJoYxaxJQ/062MHC3XjRuAHJPHNN9Vg0Vz63hNwiGy7Y+KZXluzkrjdXM6hTG964ZQhtHZr31JMs3I1Xje7djpm/GMz+ohJ++swStuXbhB/Gd6gqT8zL4vcfbGBkjwRm3jiY6EjfHVLgVFi4G68belossyYNobSikp8+s5iVuw85XZIxVFRW8eD76/n3vK1cPjCZZ64dRGS4743u2FgW7qZJ9EluzTu3nkWr5uFc/fxS5m484HRJJoidKKvk1ldX8vqy3dx2/mn868r+AXddRmD9NMandY5ryexfnUVaYjS/fCWDV5bucrokE4QKjpVy9QtLmb/5AH+8tDf3j+3hUzMoeYqFu2lScVERvDFpCMPTEvj9++t55OONVFap02WZIJGdd4zLnv6WTblHeOaagUw8q7PTJXmNhbtpci2ahfHcdYOYOLQTzy/awa2vZtqsTsbrFm8r4PKnv+VEWSWzJg1lbJ8kp0vyKgt344iw0BD+OK4PD/+kF/M3HeCq55aw77B1lTTe8fqy3Vw/fTkJrSJ577azGZAS43RJXmfhbhx1w9ldmD7xDHYWHOfSJ78lc5f1pDGeU1FZxcNzNvB/761jWGoc7952lt8OJ3CqLNyN44b3SOC9284iKiKUn09bylsZe5wuyQSAwuIybnhxBS8t3skt51SfRLQKkD7sDWHhbnxCamI0799+NoO7tOX+d9by+/fX29ysptHW7y3iJ//9huU7C3n0p/148OJehIYEXo+YH2PhbnxGTItmvPSLM/jluV15ZekuJkxbwv6iEqfLMn5mdmYOVzyzGFXlnVuHcmV6itMlOcLC3fiUsNAQplzUk6euHsjm/Ue55L+LWJxd4HRZxg+UlFcy5d213PP2Gk7vGMOHdwyjX4cYp8tyjIW78UkX90vig9vPpnXzcK6ZvozH5221/vCmXjsLirn86cW8sXwPt51/Gq/edCaxURFOl+UoC3fjs1ITo5kzeRjjByTz+Lwsrp+xjLyj1kxj/tcHq/dyyX+/Ye/hE8y4IZ37x/awSdpxb4LsFBFZICKbRGSDiNzpWt5WROaKSJbrto3nyjXBpmVEGI9d1Z9/XNGPzF2HuPDxRXy52calMVBcWsE9b63hzlmrSWsXzce/HsaIHolOl+Uz3PnzVgHco6o9gSHA7SLSC3gAmK+qqcB812NjGk1EuOqMFD6cPIyEVpHc+FIGD32wnpJym8IvWK3afYhL/vsN767K4dcjuvHmpCF0aBMc/dcbyp0JsnNVdaXr/lFgE5AMjANmujabCYx3s0ZjgO+6S57FTcO6MHPJLi7+zyLW5hx2uizThMorq3jsiy389NkllJZX8vrNQ/jN6DRrhqmDqLr/JZWIdAYWAn2A3aoaU2PdIVX9QdOMiEwCJgF07Nhx0K5dNkKgabhvsgq475015B0t5fbh3bhjRLeAG7LV/K8t+49y79trWLe3iMsHJvPwpb2D6qKkuohIpqqm17nO3XAXkSjga+ARVX1XRA43JNxrSk9P14yMDLfqMMGn6EQ5f5yzgXdX7aVnUise/Wk/+iS3dros42HllVU8+9U2/vNlFtGR4Twyvg8X9g3sQb8a6sfC3a1THREJB2YDr6nqu67FB0QkybU+CchzZx/G1Kd183Ae+9kApl03iIPHShn31LdM/XSztcUHkHU5RYx/6lv+NXcrY3q3Y+7d51qwN1BYY58o1aPbTwc2qepjNVbNASYCU123H7hVoTEnMbp3O87sGstfP97Es19v49P1ufxpXB/O6x7vdGmmkY6VVvDYF1t5afEOYqMiePbaQYzt087psvxKo5tlRGQYsAhYB3w3CMj/AcuAt4COwG7gSlUt/LHXsmYZ4ymLswv43fvr2V5QzMX9kvjDJb1IbBXpdFmmgVSVT9fv588fbWT/kRKuPbMT941NC/q29fp4tc3dEyzcjSeVVlTy3NfbeXJBNmEhwuQR3bhpWBciwgJn8uNAlHXgKA/N2cDibQfpmdSKv4zvw6BOdpnMj7FwN0Fp18Fi/vLxJuZuPECn2BY8eFFPRvVKDMj5Mv1ZYXEZT8zbymvLdtMyIox7R3fn6jM7Bd0ojo1h4W6C2sKt+fzxww1syy9mcOe2TLmoB6d3tDNCp5WUVzJz8U6eXJDN8bJKJpyRwj2j02jbspnTpfkNC3cT9Coqq5i1Yg+Pz9tKwbEyLurbjt+M6k63hGinSws6FZVVvJOZwxPzs8gtKmFEjwSmXNiD1ER7L06VhbsxLsdKK5i2cDvTF23nRHkl4wck8+uRqXSOa+l0aQGvorKKj9bm8sT8LHYUFDMgJYb7x6RxVrc4p0vzWxbuxtRSWFzGs19vY+binZRXVjFuQDK3nX+anT16QXllFR+s3sdTC7LZUVBMj3bR3DM6jQt6Jtj3H26ycDemHnlHSnh+0XZeXbqbkopKxvRqxy3ndmFQp7ZOl+b3iksrmLViDzO+2cHewyfo3b4Vd4xIZXSvRELsy1KPsHA35iQKi8t48dsdvLxkF0Unyjm9Yww3D+vK6N6JNmbNKco5dJxXl+7m9WW7OFJSweDObfnleV0Z0cPO1D3Nwt2YBioureCdzBymf7OD3YXHSWwVwdWDO/HzwSkk2MVQ9aqqUhZvO8jLS3Yyb1P1ePuje7Vj0nldGWg9k7zGwt2YU1RZpSzYnMcrS3fx9dZ8QkOE4WnxXJmewogeCXY277Lv8AlmZ+bwZsYecg6doG3LZkw4I4VrhnQiOaa50+UFvB8L90aPLWNMIAsNES7olcgFvRLZWVDMmxl7mJ2Zw7xNecS2bMZFfZMYN6A9Azu2Cbr246IT5Xy6Lpf3V+9l2Y5CVOHsbrHcP7YHo3slEhluVwL7AjtzN6aBKiqrWJiVz+zMvczbdIDSiiqSY5ozuncio3u144zObQJ20oiDx0qZu/EAn67fz+JtBZRXKl3jWjJuQDKXnZ5Mx1ibBckJ1ixjjIcdK61g7sb9fLw2l4VZBZRVVNGmRTjndo/nvO7xnJMaT3x0hNNlNlpllbJ+bxFfbclnwZY81uQcRhVS2jbnwj5JXNw3iX4dWtsXpA6zcDfGi4pLK/h6az5zNx5gUVY+BcfKAOieGMWZXWIZ0jWWgZ1iSGrtu23QZRVVbNhXROauQyzdXsiyHQc5WlKBCPTvEMPwtAQu6JVAr6RWFug+xMLdmCZSVaVszD3C11vzWbr9IJm7DnG8rHrykMRWEQxIiaF3+9b0aBdNz6RWJMc0b/I2++LSCrblH2PjviNszD3C+r1FrN93hLKK6pG7O8W24KzTqv8oDesWR2yU/34CCXQW7sY4pLyyig37jrBq9yFW7znMmj2H2Xnw+PfrI8ND6Bzbki5xLUlp24Kk1pEktW5OfHQEsS2b0TaqGdERYQ0+Wy6rqOJISTkFx0opOFpG/rES9h46wd7DJ9hdeJzt+cXkFpV8v31URBg9k6Lp3yGGgZ3aMLBjG9q1ti6f/sJ6yxjjkPDQEAakxDAgJeb7ZcWlFWw5cJTNuUfZnn+MHQXFbNl/lPmb874/e65JBFqEh9IiIoyIsBDCQuT7s/2KSqW8sorSiiqOlVRQVvnD5wPERTUjuU0LhnaN5bSEKLrGtaRnUis6tm0RdL19goXXwl1ExgJPAKHAC6o61Vv7MsaftIwIY2DHNj+4uEdVOVhcRu7hEgqOlVJYXEZhcRlHS8opLqvkeFkFJeVVVFYpla5P3M1Cq8O+WVgI0ZHhREeGER0ZRmzLCOKimhEXHUFyTHPrnhiEvBLuIhIKPAWMAnKAFSIyR1U3emN/xgQCESEuKoI4a+M2HuCtTrmDgWxV3a6qZcAsYJyX9mWMMaYWb4V7MrCnxuMc17LvicgkEckQkYz8/HwvlWGMMcHJW+Fe1zc0/9MtR1WnqWq6qqbHx8d7qQxjjAlO3gr3HCClxuMOwD4v7csYY0wt3gr3FUCqiHQRkWbABGCOl/ZljDGmFq/0llHVChGZDHxOdVfIGaq6wRv7MsYY80Ne6+euqp8An3jr9Y0xxtQvMMcnNcaYIOcTY8uISD6wy42XiAMKPFSOJ1ldp8bqOjVW16kJxLo6qWqd3Q19ItzdJSIZ9Q2e4ySr69RYXafG6jo1wVaXNcsYY0wAsnA3xpgAFCjhPs3pAuphdZ0aq+vUWF2nJqjqCog2d2OMMf8rUM7cjTHG1GDhbowxAcgvwl1ErhSRDSJSJSLptdZNEZFsEdkiImPqeX5bEZkrIlmu2zZ1beeBOt8UkdWufztFZHU92+0UkXWu7bw+eayIPCwie2vUdlE92411HcdsEXmgCep6VEQ2i8haEXlPRGLq2c7rx+tkP7tU+49r/VoRGeiNOurYb4qILBCRTa7fgTvr2OZ8ESmq8f7+oYlq+9H3xYljJiJpNY7DahE5IiJ31dqmSY6XiMwQkTwRWV9jWYOyyCO/i6rq8/+AnkAa8BWQXmN5L2ANEAF0AbYBoXU8/x/AA677DwB/b4Ka/wX8oZ51O4G4Jjx+DwP3nmSbUNfx6wo0cx3XXl6uazQQ5rr/9/reF28fr4b87MBFwKdUD2c9BFjWRO9dEjDQdT8a2FpHbecDHzXV/6eGvi9OHbNa7+t+qi/0afLjBZwLDATW11h20izy1O+iX5y5q+omVd1Sx6pxwCxVLVXVHUA21bNA1bXdTNf9mcB4rxTqItVT1V8FvOHN/XhYk8+epapfqGqF6+FSqoeGdkJDfvZxwMtabSkQIyJJ3i5MVXNVdaXr/lFgE7UmvvFhjhyzGkYC21TVnavfG01VFwKFtRY3JIs88rvoF+H+I04645NLoqrmQvUvC5Dg5brOAQ6oalY96xX4QkQyRWSSl2v5zmTXR+MZ9XwUbOix9JYbqT7Lq4u3j1dDfnanjw8i0hk4HVhWx+qhIrJGRD4Vkd5NVNLJ3henj9kE6j/BcuJ4QcOyyCPHzWujQp4qEZkHtKtj1YOq+kF9T6tjmVf7djawzp/z42ftZ6vqPhFJAOaKyGbXX3mv1AU8A/yZ6mPzZ6qbjG6s/RJ1PNftY9mQ4yUiDwIVwGv1vIzHj1ftMutYVvtnb/L/a/+zc5EoYDZwl6oeqbV6JdVND8dc36e8D6Q2QVkne18cO2ZSPY/EpcCUOlY7dbwayiPHzWfCXVUvaMTTGjrj0wERSVLVXNfHwrzG1Agnr1NEwoDLgUE/8hr7XLd5IvIe1R/D3Aqrhh4/EXke+KiOVV6ZPasBx2sicAkwUl0NjnW8hsePVy0N+dkdm11MRMKpDvbXVPXd2utrhr2qfiIiT4tInKp6dZCsBrwvTs7IdiGwUlUP1F7h1PFyaUgWeeS4+XuzzBxggohEiEgXqv/6Lq9nu4mu+xOB+j4JeMIFwGZVzalrpYi0FJHo7+5T/aXi+rq29ZRa7ZyX1bO/Jp89S0TGAr8FLlXV4/Vs0xTHqyE/+xzgelcPkCFA0Xcfr73J9f3NdGCTqj5WzzbtXNshIoOp/r0+6OW6GvK+OHLMXOr99OzE8aqhIVnkmd9Fb39j7Il/VAdSDlAKHAA+r7HuQaq/Wd4CXFhj+Qu4etYAscB8IMt129aLtb4E3FprWXvgE9f9rlR/+70G2EB184S3j98rwDpgres/SVLtulyPL6K6N8a2Jqorm+q2xdWuf886dbzq+tmBW797L6n+qPyUa/06avTa8vIxGkb1R/K1NY7TRbVqm+w6Nmuo/mL6rCaoq873xUeOWQuqw7p1jWVNfryo/uOSC5S78uum+rLIG7+LNvyAMcYEIH9vljHGGFMHC3djjAlAFu7GGBOALNyNMSYAWbgbY0wAsnA3xpgAZOFujDEB6P8BlMx3qOJmcHkAAAAASUVORK5CYII= ) You can also plot more than one function on the same graph. ```python ys2 = 10*np.sin(xs) + 20 # ys for the formula y=10sin(x)+20 plt.plot( xs, ys ) # make the original plot plt.plot( xs, ys2 ) # add the second plot to it plt.show() ``` ![png](data:image/png;base64,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 ) Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to graph mathematical functions/Python, using NumPy and Matplotlib.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-graph-mathematical-functions-in-python-using-numpy-and-matplotlib/",
    "relUrl": "/how-to-graph-mathematical-functions-in-python-using-numpy-and-matplotlib/"
  },"685": {
    "doc": "How to graph mathematical functions (in Python, using SymPy)",
    "title": "How to graph mathematical functions (in Python, using SymPy)",
    "content": "# How to graph mathematical functions (in Python, using SymPy) [See all solutions.](../how-to-graph-mathematical-functions) ## Task Assume we have a mathematical formula and we would like to plot a graph of it using the standard Cartesian coordinate system. Related tasks: * [How to graph curves that are not functions](../how-to-graph-curves-that-are-not-functions) * [How to graph mathematical sequences](../how-to-graph-mathematical-sequences) * [How to graph a two-variable function as a surface](../how-to-graph-a-two-variable-function-as-a-surface) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` You can write a formula and plot it in just a few lines of code. ```python var( 'x' ) formula = x**2 - 5*x + 9 plot( formula ) ``` ![png](data:image/png;base64,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 ) If you want to elimiate the extra bit of text after the graph, just assign the plot to a variable, as in `p = plot( formula )`. You can also plot more than one function on the same graph. ```python formula2 = 10*sin(x) + 20 plot( formula, formula2 ) ``` ![png](data:image/png;base64,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 ) Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to graph mathematical functions/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-graph-mathematical-functions-in-python-using-sympy/",
    "relUrl": "/how-to-graph-mathematical-functions-in-python-using-sympy/"
  },"686": {
    "doc": "How to graph mathematical functions (in R)",
    "title": "How to graph mathematical functions (in R)",
    "content": "# How to graph mathematical functions (in R) [See all solutions.](../how-to-graph-mathematical-functions) ## Task Assume we have a mathematical formula and we would like to plot a graph of it using the standard Cartesian coordinate system. Related tasks: * [How to graph curves that are not functions](../how-to-graph-curves-that-are-not-functions) * [How to graph mathematical sequences](../how-to-graph-mathematical-sequences) * [How to graph a two-variable function as a surface](../how-to-graph-a-two-variable-function-as-a-surface) ## Solution Let's assume we want to graph the function $x^2-5x+9$ from $x=-10$ to $x=10$. We compute a series of $(x,y)$ pairs to generate the plot. Notice how R automatically computes a $y$ value for each $x$ value if we just include all the $x$s in the formula we wish to graph. ```R xs <- seq(-10,10,length.out=100) # 100 values from x=-10 to x=10 ys <- xs^2 - 5*xs + 9 # compute all corresponding ys plot( xs, ys, type='l' ) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAADAFBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGC goKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OU lJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWm pqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4 uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnK ysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc 3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u 7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////i sF19AAAACXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3debxN5f7A8XVmZ+CYicxD801K JUTDLY2oLqlbpFLRzb3UVSmkpGguhaZfdZtUmifSfOtmaFYhkiIyZXacYf04x9zZ66y993c9 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) You can also plot more than one function on the same graph. ```R ys2 <- 10*sin(xs) + 20 # ys for the formula y=10sin(x)+20 plot( xs, ys, type='l' ) # make the original plot lines( xs, ys2 ) # add the second plot to it ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAADAFBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGC goKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OU lJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWm pqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4 uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnK ysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc 3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u 7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////i sF19AAAACXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3dd2AURRsG8E3uLr1QEkpCh4Ag SBPpRUAEEWkKggoIigJi/AANTUAUQVBEESkifnZFRVCwIVg/LBSxAEoXBaW3kJB286WRBLjb 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) Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to graph mathematical functions/R.Rmd). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-graph-mathematical-functions-in-r/",
    "relUrl": "/how-to-graph-mathematical-functions-in-r/"
  },"687": {
    "doc": "How to graph mathematical functions",
    "title": "How to graph mathematical functions",
    "content": " ",
    "url": "/how-to-graph-mathematical-functions/",
    "relUrl": "/how-to-graph-mathematical-functions/"
  },"688": {
    "doc": "How to graph mathematical functions",
    "title": "Description",
    "content": "Assume we have a mathematical formula and we would like to plot a graph of it using the standard Cartesian coordinate system. Related tasks: . | How to graph curves that are not functions | How to graph mathematical sequences | How to graph a two-variable function as a surface | . ",
    "url": "/how-to-graph-mathematical-functions/#description",
    "relUrl": "/how-to-graph-mathematical-functions/#description"
  },"689": {
    "doc": "How to graph mathematical functions",
    "title": "Using NumPy and Matplotlib, in Python",
    "content": "View this solution alone. Let’s assume we want to graph the function $x^2-5x+9$ from $x=-10$ to $x=10$. Let’s import NumPy for the mathematics and Matplotlib for the graph. | 1 2 . | import numpy as np import matplotlib.pyplot as plt . | . We compute a series of $(x,y)$ pairs to generate the plot. Notice how NumPy automatically computes a $y$ value for each $x$ value if we just include all the $x$s in the formula we wish to graph. | 1 2 3 4 . | xs = np.linspace( -10, 10, 100 ) # 100 values from x=-10 to x=10 ys = xs**2 - 5*xs + 9 # compute all corresponding ys plt.plot( xs, ys ) plt.show() . | . You can also plot more than one function on the same graph. | 1 2 3 4 . | ys2 = 10*np.sin(xs) + 20 # ys for the formula y=10sin(x)+20 plt.plot( xs, ys ) # make the original plot plt.plot( xs, ys2 ) # add the second plot to it plt.show() . | . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-graph-mathematical-functions/#using-numpy-and-matplotlib-in-python",
    "relUrl": "/how-to-graph-mathematical-functions/#using-numpy-and-matplotlib-in-python"
  },"690": {
    "doc": "How to graph mathematical functions",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . You can write a formula and plot it in just a few lines of code. | 1 2 3 . | var( 'x' ) formula = x**2 - 5*x + 9 plot( formula ) . | . | 1 . | &lt;sympy.plotting.plot.Plot at 0x7f42e07651c0&gt; . | . If you want to elimiate the extra bit of text after the graph, just assign the plot to a variable, as in p = plot( formula ). You can also plot more than one function on the same graph. | 1 2 . | formula2 = 10*sin(x) + 20 plot( formula, formula2 ) . | . | 1 . | &lt;sympy.plotting.plot.Plot at 0x7f42f06383d0&gt; . | . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-graph-mathematical-functions/#using-sympy-in-python",
    "relUrl": "/how-to-graph-mathematical-functions/#using-sympy-in-python"
  },"691": {
    "doc": "How to graph mathematical functions",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s assume we want to graph the function $x^2-5x+9$ from $x=-10$ to $x=10$. We compute a series of $(x,y)$ pairs to generate the plot. Notice how R automatically computes a $y$ value for each $x$ value if we just include all the $x$s in the formula we wish to graph. | 1 2 3 . | xs &lt;- seq(-10,10,length.out=100) # 100 values from x=-10 to x=10 ys &lt;- xs^2 - 5*xs + 9 # compute all corresponding ys plot( xs, ys, type='l' ) . | . You can also plot more than one function on the same graph. | 1 2 3 . | ys2 &lt;- 10*sin(xs) + 20 # ys for the formula y=10sin(x)+20 plot( xs, ys, type='l' ) # make the original plot lines( xs, ys2 ) # add the second plot to it . | . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-graph-mathematical-functions/#solution-in-r",
    "relUrl": "/how-to-graph-mathematical-functions/#solution-in-r"
  },"692": {
    "doc": "How to graph mathematical functions",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-graph-mathematical-functions/#topics-that-include-this-task",
    "relUrl": "/how-to-graph-mathematical-functions/#topics-that-include-this-task"
  },"693": {
    "doc": "How to graph mathematical functions",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-graph-mathematical-functions/#opportunities",
    "relUrl": "/how-to-graph-mathematical-functions/#opportunities"
  },"694": {
    "doc": "How to graph mathematical sequences (in Python, using SymPy and Matplotlib)",
    "title": "How to graph mathematical sequences (in Python, using SymPy and Matplotlib)",
    "content": "# How to graph mathematical sequences (in Python, using SymPy and Matplotlib) [See all solutions.](../how-to-graph-mathematical-sequences) ## Task Assume we have a mathematical sequence $a_0,a_1,a_2,\\ldots$ and we would like to plot a graph of it using the standard Cartesian coordinate system. The result will not look like a curve, because a sequence is separate points instead of a smooth curve. Related tasks: * [How to graph mathematical functions](../how-to-graph-mathematical-functions) * [How to define a mathematical sequence](../how-to-define-a-mathematical-sequence) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` We will re-use the sequence defined in the task [how to define a mathematical sequence](../how-to-define-a-mathematical-sequence). ```python var( 'n' ) a_n = 1 / ( n + 1 ) seq = sequence( a_n, (n,0,oo) ) seq ``` $\\displaystyle \\left[1, \\frac{1}{2}, \\frac{1}{3}, \\frac{1}{4}, \\ldots\\right]$ We can graph any finite range of any sequence as follows. ```python start = 0 stop = 10 import matplotlib.pyplot as plt plt.plot( range(start,stop+1), seq[start:stop+1], '.' ) plt.show() ``` ![png](data:image/png;base64,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 ) Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to graph mathematical sequences/Python, using SymPy and Matplotlib.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-graph-mathematical-sequences-in-python-using-sympy-and-matplotlib/",
    "relUrl": "/how-to-graph-mathematical-sequences-in-python-using-sympy-and-matplotlib/"
  },"695": {
    "doc": "How to graph mathematical sequences",
    "title": "How to graph mathematical sequences",
    "content": " ",
    "url": "/how-to-graph-mathematical-sequences/",
    "relUrl": "/how-to-graph-mathematical-sequences/"
  },"696": {
    "doc": "How to graph mathematical sequences",
    "title": "Description",
    "content": "Assume we have a mathematical sequence $a_0,a_1,a_2,\\ldots$ and we would like to plot a graph of it using the standard Cartesian coordinate system. The result will not look like a curve, because a sequence is separate points instead of a smooth curve. Related tasks: . | How to graph mathematical functions | How to define a mathematical sequence | . ",
    "url": "/how-to-graph-mathematical-sequences/#description",
    "relUrl": "/how-to-graph-mathematical-sequences/#description"
  },"697": {
    "doc": "How to graph mathematical sequences",
    "title": "Using SymPy and Matplotlib, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . We will re-use the sequence defined in the task how to define a mathematical sequence. | 1 2 3 4 . | var( 'n' ) a_n = 1 / ( n + 1 ) seq = sequence( a_n, (n,0,oo) ) seq . | . $\\displaystyle \\left[1, \\frac{1}{2}, \\frac{1}{3}, \\frac{1}{4}, \\ldots\\right]$ . We can graph any finite range of any sequence as follows. | 1 2 3 4 5 . | start = 0 stop = 10 import matplotlib.pyplot as plt plt.plot( range(start,stop+1), seq[start:stop+1], '.' ) plt.show() . | . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-graph-mathematical-sequences/#using-sympy-and-matplotlib-in-python",
    "relUrl": "/how-to-graph-mathematical-sequences/#using-sympy-and-matplotlib-in-python"
  },"698": {
    "doc": "How to graph mathematical sequences",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-graph-mathematical-sequences/#topics-that-include-this-task",
    "relUrl": "/how-to-graph-mathematical-sequences/#topics-that-include-this-task"
  },"699": {
    "doc": "How to graph mathematical sequences",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-graph-mathematical-sequences/#opportunities",
    "relUrl": "/how-to-graph-mathematical-sequences/#opportunities"
  },"700": {
    "doc": "How to isolate one variable in an equation (in Python, using SymPy)",
    "title": "How to isolate one variable in an equation (in Python, using SymPy)",
    "content": "# How to isolate one variable in an equation (in Python, using SymPy) [See all solutions.](../how-to-isolate-one-variable-in-an-equation) ## Task Once we've expressed an equation or system of equations using the technique from [how to write symbolic equations](../how-to-write-symbolic-equations), we often want the software to isolate one variable in terms of all the others. Related tasks: * [How to solve symbolic equations](../how-to-solve-symbolic-equations) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's create an equation with many variables. ```python var('P V n R T') ideal_gas_law = Eq( P*V, n*R*T ) ideal_gas_law ``` $\\displaystyle P V = R T n$ To isolate one variable, call the `solve` function, and pass that variable as the second argument. ```python solve( ideal_gas_law, R ) ``` $\\displaystyle \\left[ \\frac{P V}{T n}\\right]$ The brackets surround a list of all solutions---in this case, just one. That solution is that $R=\\frac{PV}{Tn}$. Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to isolate one variable in an equation/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-isolate-one-variable-in-an-equation-in-python-using-sympy/",
    "relUrl": "/how-to-isolate-one-variable-in-an-equation-in-python-using-sympy/"
  },"701": {
    "doc": "How to isolate one variable in an equation",
    "title": "How to isolate one variable in an equation",
    "content": " ",
    "url": "/how-to-isolate-one-variable-in-an-equation/",
    "relUrl": "/how-to-isolate-one-variable-in-an-equation/"
  },"702": {
    "doc": "How to isolate one variable in an equation",
    "title": "Description",
    "content": "Once we’ve expressed an equation or system of equations using the technique from how to write symbolic equations, we often want the software to isolate one variable in terms of all the others. Related tasks: . | How to solve symbolic equations | . ",
    "url": "/how-to-isolate-one-variable-in-an-equation/#description",
    "relUrl": "/how-to-isolate-one-variable-in-an-equation/#description"
  },"703": {
    "doc": "How to isolate one variable in an equation",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s create an equation with many variables. | 1 2 3 . | var('P V n R T') ideal_gas_law = Eq( P*V, n*R*T ) ideal_gas_law . | . $\\displaystyle P V = R T n$ . To isolate one variable, call the solve function, and pass that variable as the second argument. | 1 . | solve( ideal_gas_law, R ) . | . $\\displaystyle \\left[ \\frac{P V}{T n}\\right]$ . The brackets surround a list of all solutions—in this case, just one. That solution is that $R=\\frac{PV}{Tn}$. Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-isolate-one-variable-in-an-equation/#using-sympy-in-python",
    "relUrl": "/how-to-isolate-one-variable-in-an-equation/#using-sympy-in-python"
  },"704": {
    "doc": "How to isolate one variable in an equation",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-isolate-one-variable-in-an-equation/#topics-that-include-this-task",
    "relUrl": "/how-to-isolate-one-variable-in-an-equation/#topics-that-include-this-task"
  },"705": {
    "doc": "How to isolate one variable in an equation",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-isolate-one-variable-in-an-equation/#opportunities",
    "relUrl": "/how-to-isolate-one-variable-in-an-equation/#opportunities"
  },"706": {
    "doc": "How to perform a chi-squared test on a contingency table (in Julia)",
    "title": "How to perform a chi-squared test on a contingency table (in Julia)",
    "content": "# How to perform a chi-squared test on a contingency table (in Julia) [See all solutions.](../how-to-perform-a-chi-squared-test-on-a-contingency-table) ## Task If we have a contingency table showing the frequencies observed in two categorical variables, how can we run a $\\chi^2$ test to see if the two variables are independent? ## Solution Here we will use a two-dimensional Julia array to store a contingency table of education vs. gender, taken from [Penn State University's online stats review website](https://online.stat.psu.edu/statprogram/reviews/statistical-concepts/chi-square-tests). You should use your own data. ```julia data = [ # HS BS MS Phd 60 54 46 41 # females 40 44 53 57 # males ] ``` 2×4 Matrix{Int64}: 60 54 46 41 40 44 53 57 The $\\chi^2$ test's null hypothesis is that the two variables are independent. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). ```julia alpha = 0.05 # or choose your own alpha here using HypothesisTests p_value = pvalue( ChisqTest( data ) ) reject_H0 = p_value < alpha alpha, p_value, reject_H0 ``` (0.05, 0.04588650089174742, true) In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.05$ level. The data suggest that the two categorical variables are not independent. If you are using the most common $\\alpha$ value of $0.05$, you can save a few lines of code and get more output by just writing the test itself: ```julia ChisqTest( data ) ``` Pearson's Chi-square Test ------------------------- Population details: parameter of interest: Multinomial Probabilities value under h_0: [0.128826, 0.124339, 0.126249, 0.121852, 0.127537, 0.123096, 0.126249, 0.121852] point estimate: [0.151899, 0.101266, 0.136709, 0.111392, 0.116456, 0.134177, 0.103797, 0.144304] 95% confidence interval: [(0.1089, 0.1978), (0.05823, 0.1472), (0.09367, 0.1826), (0.06835, 0.1573), (0.07342, 0.1624), (0.09114, 0.1801), (0.06076, 0.1497), (0.1013, 0.1902)] Test summary: outcome with 95% confidence: reject h_0 one-sided p-value: 0.0459 Details: Sample size: 395 statistic: 8.006066246262527 degrees of freedom: 3 residuals: [1.27763, -1.30048, 0.585074, -0.595536, -0.61671, 0.627737, -1.25583, 1.27828] std. residuals: [2.10956, -2.10956, 0.962783, -0.962783, -1.01656, 1.01656, -2.06656, 2.06656] Content last modified on 05 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform a chi-squared test on a contingency table/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table-in-julia/",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table-in-julia/"
  },"707": {
    "doc": "How to perform a chi-squared test on a contingency table (in Python, using SciPy)",
    "title": "How to perform a chi-squared test on a contingency table (in Python, using SciPy)",
    "content": "# How to perform a chi-squared test on a contingency table (in Python, using SciPy) [See all solutions.](../how-to-perform-a-chi-squared-test-on-a-contingency-table) ## Task If we have a contingency table showing the frequencies observed in two categorical variables, how can we run a $\\chi^2$ test to see if the two variables are independent? ## Solution Here we will use nested Python lists to store a contingency table of education vs. gender, taken from [Penn State University's online stats review website](https://online.stat.psu.edu/statprogram/reviews/statistical-concepts/chi-square-tests). You should use your own data, and it can be in Python lists or NumPy arrays or a pandas DataFrame. ```python data = [ # HS BS MS Phd [ 60, 54, 46, 41 ], # females [ 40, 44, 53, 57 ] # males ] ``` The $\\chi^2$ test's null hypothesis is that the two variables are independent. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). SciPy's stats package provides a `chi2_contingency` function that does exactly what we need. ```python alpha = 0.05 # or choose your own alpha here from scipy import stats # Run a chi-squared and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. # (The dof and ex variables are values we don't need here.) chi2_statistic, p_value, dof, ex = stats.chi2_contingency( data ) reject_H0 = p_value < alpha alpha, p_value, reject_H0 ``` (0.05, 0.045886500891747214, True) In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.05$ level. The data suggest that the two categorical variables are not independent. Content last modified on 28 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform a chi-squared test on a contingency table/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table-in-python-using-scipy/",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table-in-python-using-scipy/"
  },"708": {
    "doc": "How to perform a chi-squared test on a contingency table (in R)",
    "title": "How to perform a chi-squared test on a contingency table (in R)",
    "content": "# How to perform a chi-squared test on a contingency table (in R) [See all solutions.](../how-to-perform-a-chi-squared-test-on-a-contingency-table) ## Task If we have a contingency table showing the frequencies observed in two categorical variables, how can we run a $\\chi^2$ test to see if the two variables are independent? ## Solution Here we will use a $2\\times4$ matrix to store a contingency table of education vs. gender, taken from [Penn State University's online stats review website](https://online.stat.psu.edu/statprogram/reviews/statistical-concepts/chi-square-tests). You should use your own data. (Note: R's `table` function is useful for creating contingency tables from data.) ```R data <- matrix( c( 60, 54, 46, 41, 40, 44, 53, 57 ), ncol = 4, dimnames=list( c('F','M'), c('HS','BS','MS','PhD') ), byrow =TRUE) data ``` HS BS MS PhD F 60 54 46 41 M 40 44 53 57 The $\\chi^2$ test's null hypothesis is that the two variables are independent. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it's actually true). R provides a `chisq.test` function that does exactly what we need. ```R results <- chisq.test( data ) results ``` Pearson's Chi-squared test data: data X-squared = 8.0061, df = 3, p-value = 0.04589 We can manually compare the $p$-value to an $\\alpha$ we've chosen, or ask R to do it. ```R alpha <- 0.05 # or choose your own alpha here results$p.value < alpha # reject the null hypothesis? ``` [1] TRUE Content last modified on 16 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform a chi-squared test on a contingency table/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table-in-r/",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table-in-r/"
  },"709": {
    "doc": "How to perform a chi-squared test on a contingency table",
    "title": "How to perform a chi-squared test on a contingency table",
    "content": " ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/"
  },"710": {
    "doc": "How to perform a chi-squared test on a contingency table",
    "title": "Description",
    "content": "If we have a contingency table showing the frequencies observed in two categorical variables, how can we run a $\\chi^2$ test to see if the two variables are independent? . ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#description",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#description"
  },"711": {
    "doc": "How to perform a chi-squared test on a contingency table",
    "title": "Solution, in Julia",
    "content": "View this solution alone. Here we will use a two-dimensional Julia array to store a contingency table of education vs. gender, taken from Penn State University’s online stats review website. You should use your own data. | 1 2 3 4 5 . | data = [ # HS BS MS Phd 60 54 46 41 # females 40 44 53 57 # males ] . | . | 1 2 3 . | 2×4 Matrix{Int64}: 60 54 46 41 40 44 53 57 . | . The $\\chi^2$ test’s null hypothesis is that the two variables are independent. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). | 1 2 3 4 5 6 . | alpha = 0.05 # or choose your own alpha here using HypothesisTests p_value = pvalue( ChisqTest( data ) ) reject_H0 = p_value &lt; alpha alpha, p_value, reject_H0 . | . | 1 . | (0.05, 0.04588650089174742, true) . | . In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.05$ level. The data suggest that the two categorical variables are not independent. If you are using the most common $\\alpha$ value of $0.05$, you can save a few lines of code and get more output by just writing the test itself: . | 1 . | ChisqTest( data ) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | Pearson's Chi-square Test ------------------------- Population details: parameter of interest: Multinomial Probabilities value under h_0: [0.128826, 0.124339, 0.126249, 0.121852, 0.127537, 0.123096, 0.126249, 0.121852] point estimate: [0.151899, 0.101266, 0.136709, 0.111392, 0.116456, 0.134177, 0.103797, 0.144304] 95% confidence interval: [(0.1089, 0.1978), (0.05823, 0.1472), (0.09367, 0.1826), (0.06835, 0.1573), (0.07342, 0.1624), (0.09114, 0.1801), (0.06076, 0.1497), (0.1013, 0.1902)] Test summary: outcome with 95% confidence: reject h_0 one-sided p-value: 0.0459 Details: Sample size: 395 statistic: 8.006066246262527 degrees of freedom: 3 residuals: [1.27763, -1.30048, 0.585074, -0.595536, -0.61671, 0.627737, -1.25583, 1.27828] std. residuals: [2.10956, -2.10956, 0.962783, -0.962783, -1.01656, 1.01656, -2.06656, 2.06656] . | . Content last modified on 05 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#solution-in-julia",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#solution-in-julia"
  },"712": {
    "doc": "How to perform a chi-squared test on a contingency table",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. Here we will use nested Python lists to store a contingency table of education vs. gender, taken from Penn State University’s online stats review website. You should use your own data, and it can be in Python lists or NumPy arrays or a pandas DataFrame. | 1 2 3 4 5 . | data = [ # HS BS MS Phd [ 60, 54, 46, 41 ], # females [ 40, 44, 53, 57 ] # males ] . | . The $\\chi^2$ test’s null hypothesis is that the two variables are independent. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). SciPy’s stats package provides a chi2_contingency function that does exactly what we need. | 1 2 3 4 5 6 7 8 9 . | alpha = 0.05 # or choose your own alpha here from scipy import stats # Run a chi-squared and print out alpha, the p value, # and whether the comparison says to reject the null hypothesis. # (The dof and ex variables are values we don't need here.) chi2_statistic, p_value, dof, ex = stats.chi2_contingency( data ) reject_H0 = p_value &lt; alpha alpha, p_value, reject_H0 . | . | 1 . | (0.05, 0.045886500891747214, True) . | . In this case, the samples give us enough evidence to reject the null hypothesis at the $\\alpha=0.05$ level. The data suggest that the two categorical variables are not independent. Content last modified on 28 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#using-scipy-in-python",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#using-scipy-in-python"
  },"713": {
    "doc": "How to perform a chi-squared test on a contingency table",
    "title": "Solution, in R",
    "content": "View this solution alone. Here we will use a $2\\times4$ matrix to store a contingency table of education vs. gender, taken from Penn State University’s online stats review website. You should use your own data. (Note: R’s table function is useful for creating contingency tables from data.) . | 1 2 3 4 . | data &lt;- matrix( c( 60, 54, 46, 41, 40, 44, 53, 57 ), ncol = 4, dimnames=list( c('F','M'), c('HS','BS','MS','PhD') ), byrow =TRUE) data . | . | 1 2 3 . | HS BS MS PhD F 60 54 46 41 M 40 44 53 57 . | . The $\\chi^2$ test’s null hypothesis is that the two variables are independent. We choose a value $0\\leq\\alpha\\leq1$ as the probability of a Type I error (false positive, finding we should reject $H_0$ when it’s actually true). R provides a chisq.test function that does exactly what we need. | 1 2 . | results &lt;- chisq.test( data ) results . | . | 1 2 3 4 . | Pearson's Chi-squared test data: data X-squared = 8.0061, df = 3, p-value = 0.04589 . | . We can manually compare the $p$-value to an $\\alpha$ we’ve chosen, or ask R to do it. | 1 2 . | alpha &lt;- 0.05 # or choose your own alpha here results$p.value &lt; alpha # reject the null hypothesis? . | . | 1 . | [1] TRUE . | . Content last modified on 16 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#solution-in-r",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#solution-in-r"
  },"714": {
    "doc": "How to perform a chi-squared test on a contingency table",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR521 | Bentley University MA214 | . ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#topics-that-include-this-task",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#topics-that-include-this-task"
  },"715": {
    "doc": "How to perform a chi-squared test on a contingency table",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#opportunities",
    "relUrl": "/how-to-perform-a-chi-squared-test-on-a-contingency-table/#opportunities"
  },"716": {
    "doc": "How to perform a planned comparison test (in R, using gmodels)",
    "title": "How to perform a planned comparison test (in R, using gmodels)",
    "content": "# How to perform a planned comparison test (in R, using gmodels) [See all solutions.](../how-to-perform-a-planned-comparison-test) ## Task Suppose that ANOVA reveals a significant difference between treatment levels, and you wish to explore further through post hoc analysis by comparing two specific treatment levels. How can we perform perform planned comparisons, also called a contrast test? ## Solution Usually, you have data you wish to compare, but we will use example data here. We load the \"oats\" dataset from R's `MASS` package, about the yield of oats from a split-plot field trial using three varieties (V) and four levels of manurial treatment (N). The experiment was laid out in 6 blocks (B) of 3 main plots, each split into 4 sub-plots. The varieties were applied to the main plots and the manurial treatments to the sub-plots. ```R # install.package('MASS') # if you have not already done so, and want this data library(MASS) df F) N 3 20020 6673 14.2 2.78e-07 *** Residuals 68 31965 470 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 The $p$-value in the `Pr(>F)` column is below $\\alpha=0.05$. So at the 5% significance level, the yield differs according to the nitrogen manurial treatment. We assume that the model assumptions are met but do not verify them here. We now want to perform a planned comparison test (or contrast test) on the data to see whether there is a difference between the $N0.5$ levels. We will use the `fit.contrast` function in the `gmodels` package. Since the order of the levels is 0, 0.2, 0.4 and 0.6, the contrast coefficients will be $-0.5$, $-0.5$, $0.5$, $0.5$, respectively. ```R # install.package('gmodels') # if you have not already done so library(gmodels) fit.contrast(aov1, \"N\", coeff=c(-1/2,-1/2,1/2,1/2)) ``` Estimate Std. Error t value Pr(>|t|) N c=( -0.5 -0.5 0.5 0.5 ) 29.66667 5.110338 5.805225 1.855598e-07 attr(,\"class\") [1] \"fit_contrast\" The $p$-value in the `Pr(>|t|)` column is below $\\alpha=0.05$. This tells us that there is a significant difference between the average yields of the $N0.5$ levels. Content last modified on 10 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform a planned comparison test/R, using gmodels.Rmd). Contributed by: * Krtin Juneja (KJUNEJA@falcon.bentley.edu) * Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-perform-a-planned-comparison-test-in-r-using-gmodels/",
    "relUrl": "/how-to-perform-a-planned-comparison-test-in-r-using-gmodels/"
  },"717": {
    "doc": "How to perform a planned comparison test",
    "title": "How to perform a planned comparison test",
    "content": " ",
    "url": "/how-to-perform-a-planned-comparison-test/",
    "relUrl": "/how-to-perform-a-planned-comparison-test/"
  },"718": {
    "doc": "How to perform a planned comparison test",
    "title": "Description",
    "content": "Suppose that ANOVA reveals a significant difference between treatment levels, and you wish to explore further through post hoc analysis by comparing two specific treatment levels. How can we perform perform planned comparisons, also called a contrast test? . ",
    "url": "/how-to-perform-a-planned-comparison-test/#description",
    "relUrl": "/how-to-perform-a-planned-comparison-test/#description"
  },"719": {
    "doc": "How to perform a planned comparison test",
    "title": "Using gmodels, in R",
    "content": "View this solution alone. Usually, you have data you wish to compare, but we will use example data here. We load the “oats” dataset from R’s MASS package, about the yield of oats from a split-plot field trial using three varieties (V) and four levels of manurial treatment (N). The experiment was laid out in 6 blocks (B) of 3 main plots, each split into 4 sub-plots. The varieties were applied to the main plots and the manurial treatments to the sub-plots. | 1 2 3 . | # install.package('MASS') # if you have not already done so, and want this data library(MASS) df &lt;- oats . | . Before we perform the contrast test, let’s verify that the yield of oats Y depends on the nitrogen manurial treatment given to it N. | 1 2 . | aov1 &lt;- aov(Y ~ N, data = df) summary(aov1) . | . | 1 2 3 4 5 . | Df Sum Sq Mean Sq F value Pr(&gt;F) N 3 20020 6673 14.2 2.78e-07 *** Residuals 68 31965 470 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . The $p$-value in the Pr(&gt;F) column is below $\\alpha=0.05$. So at the 5% significance level, the yield differs according to the nitrogen manurial treatment. We assume that the model assumptions are met but do not verify them here. We now want to perform a planned comparison test (or contrast test) on the data to see whether there is a difference between the $N&lt;0.5$ levels and the $N&gt;0.5$ levels. We will use the fit.contrast function in the gmodels package. Since the order of the levels is 0, 0.2, 0.4 and 0.6, the contrast coefficients will be $-0.5$, $-0.5$, $0.5$, $0.5$, respectively. | 1 2 3 . | # install.package('gmodels') # if you have not already done so library(gmodels) fit.contrast(aov1, \"N\", coeff=c(-1/2,-1/2,1/2,1/2)) . | . | 1 2 3 4 . | Estimate Std. Error t value Pr(&gt;|t|) N c=( -0.5 -0.5 0.5 0.5 ) 29.66667 5.110338 5.805225 1.855598e-07 attr(,\"class\") [1] \"fit_contrast\" . | . The $p$-value in the Pr(&gt;|t|) column is below $\\alpha=0.05$. This tells us that there is a significant difference between the average yields of the $N&lt;0.5$ and $N&gt;0.5$ levels. Content last modified on 10 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-a-planned-comparison-test/#using-gmodels-in-r",
    "relUrl": "/how-to-perform-a-planned-comparison-test/#using-gmodels-in-r"
  },"720": {
    "doc": "How to perform a planned comparison test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-perform-a-planned-comparison-test/#topics-that-include-this-task",
    "relUrl": "/how-to-perform-a-planned-comparison-test/#topics-that-include-this-task"
  },"721": {
    "doc": "How to perform a planned comparison test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-perform-a-planned-comparison-test/#opportunities",
    "relUrl": "/how-to-perform-a-planned-comparison-test/#opportunities"
  },"722": {
    "doc": "How to perform an analysis of covariance (ANCOVA) (in Python, using pingouin)",
    "title": "How to perform an analysis of covariance (ANCOVA) (in Python, using pingouin)",
    "content": "# How to perform an analysis of covariance (ANCOVA) (in Python, using pingouin) [See all solutions.](../how-to-perform-an-analysis-of-covariance-ancova) ## Task Recall that covariates are variables that may be related to the outcome but are unaffected by treatment assignment. In a randomized experiment with one or more observed covariates, an analysis of covariance (ANCOVA) addresses this question: How would the mean outcome in each treatment group change if all groups were equal with respect to the covariate? The goal is to remove any variability in the outcome associated with the covariate from the unexplained variability used to determine statistical significance. Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) ## Solution The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data('mtcars') ``` Let's use ANCOVA to check the effect of the engine type (0 = V-shaped, 1 = straight, in the variable `vs`) on the miles per gallon when considering the weight of the car as a covariate. We will use the `ancova` function from the `pingouin` package to conduct the test. ```python from pingouin import ancova ancova(data=df, dv='mpg', covar='wt', between='vs') ``` | | Source | SS | DF | F | p-unc | np2 | . | 0 | vs | 54.228061 | 1 | 7.017656 | 1.292580e-02 | 0.194839 | . | 1 | wt | 405.425409 | 1 | 52.466123 | 5.632548e-08 | 0.644024 | . | 2 | Residual | 224.093877 | 29 | NaN | NaN | NaN | . /opt/conda/lib/python3.9/site-packages/outdated/utils.py:14: OutdatedPackageWarning: The package pingouin is out of date. Your version is 0.4.0, the latest is 0.5.0. Set the environment variable OUTDATED_IGNORE=1 to disable these warnings. return warn( The $p$-value for each variable is in the `p-unc` column. The $p$-value for the `wt` variable tests the null hypothesis, \"The quantities `wt` and `mpg` are not related.\" Since it is below 0.05, we reject the null hypothesis, and conclude that `wt` is significant in predicting `mpg`. The $p$-value for the `vs` variable tests the null hypothesis, \"The quantities `vs` and `mpg` are not related if we hold `wt` constant.\" Since it is below 0.05, we reject the null hypothesis, and conclude that `vs` is significant in predicting `mpg` even among cars with equal weight (`wt`). Note: Unfortunately, a two-factor ANCOVA is not possible in pingouin. However, a model with more than one covariate is possible, as you can provide a list as the `covar` parameter when calling `ancova`. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform an analysis of covariance (ANCOVA)/Python, using pingouin.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-perform-an-analysis-of-covariance-ancova-in-python-using-pingouin/",
    "relUrl": "/how-to-perform-an-analysis-of-covariance-ancova-in-python-using-pingouin/"
  },"723": {
    "doc": "How to perform an analysis of covariance (ANCOVA) (in R)",
    "title": "How to perform an analysis of covariance (ANCOVA) (in R)",
    "content": "# How to perform an analysis of covariance (ANCOVA) (in R) [See all solutions.](../how-to-perform-an-analysis-of-covariance-ancova) ## Task Recall that covariates are variables that may be related to the outcome but are unaffected by treatment assignment. In a randomized experiment with one or more observed covariates, an analysis of covariance (ANCOVA) addresses this question: How would the mean outcome in each treatment group change if all groups were equal with respect to the covariate? The goal is to remove any variability in the outcome associated with the covariate from the unexplained variability used to determine statistical significance. Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to compare two nested linear models](../how-to-compare-two-nested-linear-models) * [How to conduct a mixed designs ANOVA](../how-to-conduct-a-mixed-designs-anova) * [How to conduct a repeated measures ANOVA](../how-to-conduct-a-repeated-measures-anova) ## Solution The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R df F) wt 1 847.72525 847.725250 109.704168 2.284396e-11 vs 1 54.22806 54.228061 7.017656 1.292580e-02 Residuals 29 224.09388 7.727375 NA NA The $p$-value for each variable can be found in the final column of the output, called `Pr(>F)`. The $p$-value for the `wt` variable tests the null hypothesis, \"The quantities `wt` and `mpg` are not related.\" Since it is below 0.05, we reject the null hypothesis, and conclude that `wt` is significant in predicting `mpg`. The $p$-value for the `vs` variable tests the null hypothesis, \"The quantities `vs` and `mpg` are not related if we hold `wt` constant.\" Since it is below 0.05, we reject the null hypothesis, and conclude that `vs` is significant in predicting `mpg` even among cars with equal weight (`wt`). If we wish to create a 2-factor ANCOVA model, we can test to see if the engine type (0 = V-shaped, 1 = straight) and transmission type (0 = automatic, 1 = manual) have an effect on the Miles/gallon per car when considering the weight of the car as a covariate. ```R cov.model.2 F) wt 1 847.725250 847.725250 109.729918 3.420018e-11 vs 1 54.228061 54.228061 7.019303 1.310627e-02 am 1 7.778149 7.778149 1.006807 3.242621e-01 Residuals 28 216.315728 7.725562 NA NA The $p$-values are again in the final column of output. They show that at the 5% significance level, we would conclude that engine type (`vs`) significantly impacts the Miles/gallon per car while accounting for the weight of the car (`wt`) but the transmission type (`am`) does not. Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform an analysis of covariance (ANCOVA)/R.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-perform-an-analysis-of-covariance-ancova-in-r/",
    "relUrl": "/how-to-perform-an-analysis-of-covariance-ancova-in-r/"
  },"724": {
    "doc": "How to perform an analysis of covariance (ANCOVA)",
    "title": "How to perform an analysis of covariance (ANCOVA)",
    "content": " ",
    "url": "/how-to-perform-an-analysis-of-covariance-ancova/",
    "relUrl": "/how-to-perform-an-analysis-of-covariance-ancova/"
  },"725": {
    "doc": "How to perform an analysis of covariance (ANCOVA)",
    "title": "Description",
    "content": "Recall that covariates are variables that may be related to the outcome but are unaffected by treatment assignment. In a randomized experiment with one or more observed covariates, an analysis of covariance (ANCOVA) addresses this question: How would the mean outcome in each treatment group change if all groups were equal with respect to the covariate? The goal is to remove any variability in the outcome associated with the covariate from the unexplained variability used to determine statistical significance. Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to compare two nested linear models | How to conduct a mixed designs ANOVA | How to conduct a repeated measures ANOVA | . ",
    "url": "/how-to-perform-an-analysis-of-covariance-ancova/#description",
    "relUrl": "/how-to-perform-an-analysis-of-covariance-ancova/#description"
  },"726": {
    "doc": "How to perform an analysis of covariance (ANCOVA)",
    "title": "Using pingouin, in Python",
    "content": "View this solution alone. The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See how to quickly load some sample data.) . | 1 2 . | from rdatasets import data df = data('mtcars') . | . Let’s use ANCOVA to check the effect of the engine type (0 = V-shaped, 1 = straight, in the variable vs) on the miles per gallon when considering the weight of the car as a covariate. We will use the ancova function from the pingouin package to conduct the test. | 1 2 . | from pingouin import ancova ancova(data=df, dv='mpg', covar='wt', between='vs') . | . | | Source | SS | DF | F | p-unc | np2 | . | 0 | vs | 54.228061 | 1 | 7.017656 | 1.292580e-02 | 0.194839 | . | 1 | wt | 405.425409 | 1 | 52.466123 | 5.632548e-08 | 0.644024 | . | 2 | Residual | 224.093877 | 29 | NaN | NaN | NaN | . | 1 2 3 . | /opt/conda/lib/python3.9/site-packages/outdated/utils.py:14: OutdatedPackageWarning: The package pingouin is out of date. Your version is 0.4.0, the latest is 0.5.0. Set the environment variable OUTDATED_IGNORE=1 to disable these warnings. return warn( . | . The $p$-value for each variable is in the p-unc column. The $p$-value for the wt variable tests the null hypothesis, “The quantities wt and mpg are not related.” Since it is below 0.05, we reject the null hypothesis, and conclude that wt is significant in predicting mpg. The $p$-value for the vs variable tests the null hypothesis, “The quantities vs and mpg are not related if we hold wt constant.” Since it is below 0.05, we reject the null hypothesis, and conclude that vs is significant in predicting mpg even among cars with equal weight (wt). Note: Unfortunately, a two-factor ANCOVA is not possible in pingouin. However, a model with more than one covariate is possible, as you can provide a list as the covar parameter when calling ancova. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-an-analysis-of-covariance-ancova/#using-pingouin-in-python",
    "relUrl": "/how-to-perform-an-analysis-of-covariance-ancova/#using-pingouin-in-python"
  },"727": {
    "doc": "How to perform an analysis of covariance (ANCOVA)",
    "title": "Solution, in R",
    "content": "View this solution alone. The solution below uses an example dataset about car design and fuel consumption from a 1974 Motor Trend magazine. (See how to quickly load some sample data.) . | 1 2 . | df &lt;- mtcars df$vs &lt;- as.factor(df$vs) . | . Let’s use ANCOVA to check the effect of the engine type (0 = V-shaped, 1 = straight, in the variable vs) on the miles per gallon when considering the weight of the car as a covariate. We will use the ancova function from the pingouin package to conduct the test. | 1 2 . | cov.model &lt;- lm(mpg ~ wt + vs, data = df) anova(cov.model) . | . | 1 2 3 4 . | Df Sum Sq Mean Sq F value Pr(&gt;F) wt 1 847.72525 847.725250 109.704168 2.284396e-11 vs 1 54.22806 54.228061 7.017656 1.292580e-02 Residuals 29 224.09388 7.727375 NA NA . | . The $p$-value for each variable can be found in the final column of the output, called Pr(&gt;F). The $p$-value for the wt variable tests the null hypothesis, “The quantities wt and mpg are not related.” Since it is below 0.05, we reject the null hypothesis, and conclude that wt is significant in predicting mpg. The $p$-value for the vs variable tests the null hypothesis, “The quantities vs and mpg are not related if we hold wt constant.” Since it is below 0.05, we reject the null hypothesis, and conclude that vs is significant in predicting mpg even among cars with equal weight (wt). If we wish to create a 2-factor ANCOVA model, we can test to see if the engine type (0 = V-shaped, 1 = straight) and transmission type (0 = automatic, 1 = manual) have an effect on the Miles/gallon per car when considering the weight of the car as a covariate. | 1 2 . | cov.model.2 &lt;- lm(mpg ~ wt + vs + am, data = df) anova(cov.model.2) . | . | 1 2 3 4 5 . | Df Sum Sq Mean Sq F value Pr(&gt;F) wt 1 847.725250 847.725250 109.729918 3.420018e-11 vs 1 54.228061 54.228061 7.019303 1.310627e-02 am 1 7.778149 7.778149 1.006807 3.242621e-01 Residuals 28 216.315728 7.725562 NA NA . | . The $p$-values are again in the final column of output. They show that at the 5% significance level, we would conclude that engine type (vs) significantly impacts the Miles/gallon per car while accounting for the weight of the car (wt) but the transmission type (am) does not. Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-an-analysis-of-covariance-ancova/#solution-in-r",
    "relUrl": "/how-to-perform-an-analysis-of-covariance-ancova/#solution-in-r"
  },"728": {
    "doc": "How to perform an analysis of covariance (ANCOVA)",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | Bentley University MA255 | . ",
    "url": "/how-to-perform-an-analysis-of-covariance-ancova/#topics-that-include-this-task",
    "relUrl": "/how-to-perform-an-analysis-of-covariance-ancova/#topics-that-include-this-task"
  },"729": {
    "doc": "How to perform an analysis of covariance (ANCOVA)",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-perform-an-analysis-of-covariance-ancova/#opportunities",
    "relUrl": "/how-to-perform-an-analysis-of-covariance-ancova/#opportunities"
  },"730": {
    "doc": "How to perform pairwise comparisons (in Python, using statsmodels, Matplotlib and scikit)",
    "title": "How to perform pairwise comparisons (in Python, using statsmodels, Matplotlib and scikit)",
    "content": "# How to perform pairwise comparisons (in Python, using statsmodels, Matplotlib and scikit) [See all solutions.](../how-to-perform-pairwise-comparisons) ## Task When analyzing data from a completely randomized single-factor design, suppose that you have performed an ANOVA and noticed that there's a significant difference between at least one pair of treatment levels. How can pairwise comparisons help us explore which pairs of treatment levels are different? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to perform post-hoc analysis with Tukey's HSD test](../how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test) ## Solution The solution below uses an example dataset that details the counts of insects in an agricultural experiment with six types of insecticides, labeled A through F. (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data('InsectSprays') df ``` | | count | spray | . | 0 | 10 | A | . | 1 | 7 | A | . | 2 | 20 | A | . | 3 | 14 | A | . | 4 | 14 | A | . | ... | ... | ... | . | 67 | 10 | F | . | 68 | 26 | F | . | 69 | 26 | F | . | 70 | 24 | F | . | 71 | 13 | F | . 72 rows × 2 columns . Before we perform any post hoc analysis, we need to see if the count of insects depends on the type of insecticide given by conducting a one way ANOVA. (See also [how to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova).) ```python from statsmodels.formula.api import ols model = ols('count ~ spray', data = df).fit() import statsmodels.api as sm sm.stats.anova_lm(model, typ=1) ``` | | df | sum_sq | mean_sq | F | PR(&gt;F) | . | spray | 5.0 | 2668.833333 | 533.766667 | 34.702282 | 3.182584e-17 | . | Residual | 66.0 | 1015.166667 | 15.381313 | NaN | NaN | . At the 5% significance level, we see that the count differs according to the type of insecticide used. We assume that the model assumptions are met, but do not verify that here. If we would like to compare the pairs without any corrections, we can use the 'pairwise t test' in the `scikit_posthocs` package. ```python import scikit_posthocs as sp sp.posthoc_ttest(df, val_col='count', group_col='spray', p_adjust=None, pool_sd=True ) ``` | | A | B | C | D | E | F | . | A | 1.000000e+00 | 6.044761e-01 | 7.266893e-11 | 9.816910e-08 | 2.753922e-09 | 1.805998e-01 | . | B | 6.044761e-01 | 1.000000e+00 | 8.509776e-12 | 1.212803e-08 | 3.257986e-10 | 4.079858e-01 | . | C | 7.266893e-11 | 8.509776e-12 | 1.000000e+00 | 8.141205e-02 | 3.794750e-01 | 2.794343e-13 | . | D | 9.816910e-08 | 1.212803e-08 | 8.141205e-02 | 1.000000e+00 | 3.794750e-01 | 4.035610e-10 | . | E | 2.753922e-09 | 3.257986e-10 | 3.794750e-01 | 3.794750e-01 | 1.000000e+00 | 1.054387e-11 | . | F | 1.805998e-01 | 4.079858e-01 | 2.794343e-13 | 4.035610e-10 | 1.054387e-11 | 1.000000e+00 | . Techniques to adjust the above table for multiple comparisons include the Bonferroni correction, Fisher’s Least Significant Difference (LSD) method, Dunnett’s procedure, and Scheffe’s method. These can be used in place of 'None' for the `p.adjust` argument; [see details here](https://scikit-posthocs.readthedocs.io/en/latest/generated/scikit_posthocs.posthoc_ttest/). You can also determine the magnitude of these differences; see [how to perform post-hoc analysis with Tukey's HSD test](../how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test). Content last modified on 16 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform pairwise comparisons/Python, using statsmodels, Matplotlib and scikit.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-perform-pairwise-comparisons-in-python-using-statsmodels-matplotlib-and-scikit/",
    "relUrl": "/how-to-perform-pairwise-comparisons-in-python-using-statsmodels-matplotlib-and-scikit/"
  },"731": {
    "doc": "How to perform pairwise comparisons (in R)",
    "title": "How to perform pairwise comparisons (in R)",
    "content": "# How to perform pairwise comparisons (in R) [See all solutions.](../how-to-perform-pairwise-comparisons) ## Task When analyzing data from a completely randomized single-factor design, suppose that you have performed an ANOVA and noticed that there's a significant difference between at least one pair of treatment levels. How can pairwise comparisons help us explore which pairs of treatment levels are different? Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to perform post-hoc analysis with Tukey's HSD test](../how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test) ## Solution The solution below uses an example dataset that details the counts of insects in an agricultural experiment with six types of insecticides, labeled A through F. (This is one of the datasets built into R for use in examples like this one.) ```R df F) spray 5 2669 533.8 34.7 <2e-16 *** Residuals 66 1015 15.4 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 At the 5% significance level, we see that the count differs according to the type of insecticide used. We assume that the model assumptions are met, but do not verify that here. If we would like to compare the pairs without any corrections, we can use the `pairwise.t.test` function built into R. ```R pairwise.t.test(df$count, df$spray, p.adj=\"none\") ``` Pairwise comparisons using t tests with pooled SD data: df$count and df$spray A B C D E B 0.604 - - - - C 7.3e-11 8.5e-12 - - - D 9.8e-08 1.2e-08 0.081 - - E 2.8e-09 3.3e-10 0.379 0.379 - F 0.181 0.408 2.8e-13 4.0e-10 1.1e-11 P value adjustment method: none Techniques to adjust the above table for multiple comparisons include the Bonferroni correction, Fisher’s Least Significant Difference (LSD) method, Dunnett’s procedure, and Scheffe’s method. These can be used in place of \"none\" for the `p.adj` argument; [see details here](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/pairwise.t.test). You can also determine the magnitude of these differences; see [how to perform post-hoc analysis with Tukey's HSD test](../how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test). Content last modified on 10 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform pairwise comparisons/R.md). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-perform-pairwise-comparisons-in-r/",
    "relUrl": "/how-to-perform-pairwise-comparisons-in-r/"
  },"732": {
    "doc": "How to perform pairwise comparisons",
    "title": "How to perform pairwise comparisons",
    "content": " ",
    "url": "/how-to-perform-pairwise-comparisons/",
    "relUrl": "/how-to-perform-pairwise-comparisons/"
  },"733": {
    "doc": "How to perform pairwise comparisons",
    "title": "Description",
    "content": "When analyzing data from a completely randomized single-factor design, suppose that you have performed an ANOVA and noticed that there’s a significant difference between at least one pair of treatment levels. How can pairwise comparisons help us explore which pairs of treatment levels are different? . Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to perform post-hoc analysis with Tukey’s HSD test | . ",
    "url": "/how-to-perform-pairwise-comparisons/#description",
    "relUrl": "/how-to-perform-pairwise-comparisons/#description"
  },"734": {
    "doc": "How to perform pairwise comparisons",
    "title": "Using statsmodels, Matplotlib and scikit, in Python",
    "content": "View this solution alone. The solution below uses an example dataset that details the counts of insects in an agricultural experiment with six types of insecticides, labeled A through F. (See how to quickly load some sample data.) . | 1 2 3 . | from rdatasets import data df = data('InsectSprays') df . | . | | count | spray | . | 0 | 10 | A | . | 1 | 7 | A | . | 2 | 20 | A | . | 3 | 14 | A | . | 4 | 14 | A | . | ... | ... | ... | . | 67 | 10 | F | . | 68 | 26 | F | . | 69 | 26 | F | . | 70 | 24 | F | . | 71 | 13 | F | . 72 rows × 2 columns . Before we perform any post hoc analysis, we need to see if the count of insects depends on the type of insecticide given by conducting a one way ANOVA. (See also how to do a one-way analysis of variance (ANOVA).) . | 1 2 3 4 . | from statsmodels.formula.api import ols model = ols('count ~ spray', data = df).fit() import statsmodels.api as sm sm.stats.anova_lm(model, typ=1) . | . | | df | sum_sq | mean_sq | F | PR(&gt;F) | . | spray | 5.0 | 2668.833333 | 533.766667 | 34.702282 | 3.182584e-17 | . | Residual | 66.0 | 1015.166667 | 15.381313 | NaN | NaN | . At the 5% significance level, we see that the count differs according to the type of insecticide used. We assume that the model assumptions are met, but do not verify that here. If we would like to compare the pairs without any corrections, we can use the ‘pairwise t test’ in the scikit_posthocs package. | 1 2 . | import scikit_posthocs as sp sp.posthoc_ttest(df, val_col='count', group_col='spray', p_adjust=None, pool_sd=True ) . | . | | A | B | C | D | E | F | . | A | 1.000000e+00 | 6.044761e-01 | 7.266893e-11 | 9.816910e-08 | 2.753922e-09 | 1.805998e-01 | . | B | 6.044761e-01 | 1.000000e+00 | 8.509776e-12 | 1.212803e-08 | 3.257986e-10 | 4.079858e-01 | . | C | 7.266893e-11 | 8.509776e-12 | 1.000000e+00 | 8.141205e-02 | 3.794750e-01 | 2.794343e-13 | . | D | 9.816910e-08 | 1.212803e-08 | 8.141205e-02 | 1.000000e+00 | 3.794750e-01 | 4.035610e-10 | . | E | 2.753922e-09 | 3.257986e-10 | 3.794750e-01 | 3.794750e-01 | 1.000000e+00 | 1.054387e-11 | . | F | 1.805998e-01 | 4.079858e-01 | 2.794343e-13 | 4.035610e-10 | 1.054387e-11 | 1.000000e+00 | . Techniques to adjust the above table for multiple comparisons include the Bonferroni correction, Fisher’s Least Significant Difference (LSD) method, Dunnett’s procedure, and Scheffe’s method. These can be used in place of ‘None’ for the p.adjust argument; see details here. You can also determine the magnitude of these differences; see how to perform post-hoc analysis with Tukey’s HSD test. Content last modified on 16 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-pairwise-comparisons/#using-statsmodels-matplotlib-and-scikit-in-python",
    "relUrl": "/how-to-perform-pairwise-comparisons/#using-statsmodels-matplotlib-and-scikit-in-python"
  },"735": {
    "doc": "How to perform pairwise comparisons",
    "title": "Solution, in R",
    "content": "View this solution alone. The solution below uses an example dataset that details the counts of insects in an agricultural experiment with six types of insecticides, labeled A through F. (This is one of the datasets built into R for use in examples like this one.) . | 1 2 . | df &lt;- InsectSprays head( df, 10 ) . | . | 1 2 3 4 5 6 7 8 9 10 11 . | count spray 1 10 A 2 7 A 3 20 A 4 14 A 5 14 A 6 12 A 7 10 A 8 23 A 9 17 A 10 20 A . | . Before we perform any post hoc analysis, we need to see if the count of insects depends on the type of insecticide given by conducting a one way ANOVA. (See also how to do a one-way analysis of variance (ANOVA).) . | 1 2 . | aov1 = aov(count ~ spray, data = df) summary(aov1) . | . | 1 2 3 4 5 . | Df Sum Sq Mean Sq F value Pr(&gt;F) spray 5 2669 533.8 34.7 &lt;2e-16 *** Residuals 66 1015 15.4 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . At the 5% significance level, we see that the count differs according to the type of insecticide used. We assume that the model assumptions are met, but do not verify that here. If we would like to compare the pairs without any corrections, we can use the pairwise.t.test function built into R. | 1 . | pairwise.t.test(df$count, df$spray, p.adj=\"none\") . | . | 1 2 3 4 5 6 7 8 9 10 11 12 . | Pairwise comparisons using t tests with pooled SD data: df$count and df$spray A B C D E B 0.604 - - - - C 7.3e-11 8.5e-12 - - - D 9.8e-08 1.2e-08 0.081 - - E 2.8e-09 3.3e-10 0.379 0.379 - F 0.181 0.408 2.8e-13 4.0e-10 1.1e-11 P value adjustment method: none . | . Techniques to adjust the above table for multiple comparisons include the Bonferroni correction, Fisher’s Least Significant Difference (LSD) method, Dunnett’s procedure, and Scheffe’s method. These can be used in place of “none” for the p.adj argument; see details here. You can also determine the magnitude of these differences; see how to perform post-hoc analysis with Tukey’s HSD test. Content last modified on 10 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-pairwise-comparisons/#solution-in-r",
    "relUrl": "/how-to-perform-pairwise-comparisons/#solution-in-r"
  },"736": {
    "doc": "How to perform pairwise comparisons",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-perform-pairwise-comparisons/#topics-that-include-this-task",
    "relUrl": "/how-to-perform-pairwise-comparisons/#topics-that-include-this-task"
  },"737": {
    "doc": "How to perform pairwise comparisons",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-perform-pairwise-comparisons/#opportunities",
    "relUrl": "/how-to-perform-pairwise-comparisons/#opportunities"
  },"738": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test (in Python, using statsmodels, Matplotlib and scikit)",
    "title": "How to perform post-hoc analysis with Tukey's HSD test (in Python, using statsmodels, Matplotlib and scikit)",
    "content": "# How to perform post-hoc analysis with Tukey's HSD test (in Python, using statsmodels, Matplotlib and scikit) [See all solutions.](../how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test) ## Task If we run a one-way ANOVA test and find that there is a significant difference between population means, we might want to know which means are actually different from each other. One way to do so is with Tukey's Honestly Significant Differences (HSD) method. It creates confidence intervals for each pair of samples, while controlling for Type I error rate across all pairs. Thus the resulting intervals are a little wider than those produced using Fisher's LSD method. How do we make these confidence intervals, with an appropriate visualization? ## Solution We load here the same data that appears in the solution for [how to perform pairwise comparisons](../how-to-perform-pairwise-comparisons). That solution used ANOVA to determine which pairs of groups have significant differences in their means; follow its link for more details. ```python from rdatasets import data df = data('InsectSprays') df ``` | | count | spray | . | 0 | 10 | A | . | 1 | 7 | A | . | 2 | 20 | A | . | 3 | 14 | A | . | 4 | 14 | A | . | ... | ... | ... | . | 67 | 10 | F | . | 68 | 26 | F | . | 69 | 26 | F | . | 70 | 24 | F | . | 71 | 13 | F | . 72 rows × 2 columns . We now want to perform an unplanned comparison test on the data to determine the magnitudes of the differences between pairs of groups. We do this by applying Tukey's HSD approach to perform pairwise comparisons and generate confidence intervals that maintain a specified experiment-wide error rate. Before that, the `pairwise_tukeyhsd` module needs to be imported from the `statsmodels` package. ```python from statsmodels.stats.multicomp import pairwise_tukeyhsd tukey = pairwise_tukeyhsd(endog=df['count'], groups=df['spray'], alpha=0.05) print(tukey) ``` Multiple Comparison of Means - Tukey HSD, FWER=0.05 ===================================================== group1 group2 meandiff p-adj lower upper reject ----------------------------------------------------- A B 0.8333 0.9 -3.8659 5.5326 False A C -12.4167 0.001 -17.1159 -7.7174 True A D -9.5833 0.001 -14.2826 -4.8841 True A E -11.0 0.001 -15.6992 -6.3008 True A F 2.1667 0.728 -2.5326 6.8659 False B C -13.25 0.001 -17.9492 -8.5508 True B D -10.4167 0.001 -15.1159 -5.7174 True B E -11.8333 0.001 -16.5326 -7.1341 True B F 1.3333 0.9 -3.3659 6.0326 False C D 2.8333 0.4921 -1.8659 7.5326 False C E 1.4167 0.9 -3.2826 6.1159 False C F 14.5833 0.001 9.8841 19.2826 True D E -1.4167 0.9 -6.1159 3.2826 False D F 11.75 0.001 7.0508 16.4492 True E F 13.1667 0.001 8.4674 17.8659 True ----------------------------------------------------- Because the above table contains a lot of information, it's often helpful to visualize these intervals. Python's `statsmodels` package does not have a built-in way to do so, but we can create our own as follows. ```python import matplotlib.pyplot as plt rows = tukey.summary().data[1:] plt.hlines( range(len(rows)), [row[4] for row in rows], [row[5] for row in rows] ) plt.vlines( 0, -1, len( rows )-1, linestyles='dashed' ) plt.gca().set_yticks( range( len( rows ) ) ) plt.gca().set_yticklabels( [ f'{x[0]}-{x[1]}' for x in rows ] ) plt.show() ``` ![png](data:image/png;base64,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 ) Confidence intervals that cross the vertical, dashed line at $x=0$ are those in which the means across those groups may be equal. Other intervals have mean differences whose 95% confidence intervals do not include zero. Content last modified on 10 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform post-hoc analysis with Tukey's HSD test/Python, using statsmodels, Matplotlib and scikit.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test-in-python-using-statsmodels-matplotlib-and-scikit/",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test-in-python-using-statsmodels-matplotlib-and-scikit/"
  },"739": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test (in R, using agricolae)",
    "title": "How to perform post-hoc analysis with Tukey's HSD test (in R, using agricolae)",
    "content": "# How to perform post-hoc analysis with Tukey's HSD test (in R, using agricolae) [See all solutions.](../how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test) ## Task If we run a one-way ANOVA test and find that there is a significant difference between population means, we might want to know which means are actually different from each other. One way to do so is with Tukey's Honestly Significant Differences (HSD) method. It creates confidence intervals for each pair of samples, while controlling for Type I error rate across all pairs. Thus the resulting intervals are a little wider than those produced using Fisher's LSD method. How do we make these confidence intervals, with an appropriate visualization? ## Solution We load here the same data that appears in the solution for how to perform pairwise comparisons. That solution used ANOVA to determine which pairs of groups have significant differences in their means; follow its link for more details. ```R # Load an inbuilt data set called InsectSprays and assign it to the variable df df <- InsectSprays head( df, 10 ) ``` count spray 1 10 A 2 7 A 3 20 A 4 14 A 5 14 A 6 12 A 7 10 A 8 23 A 9 17 A 10 20 A We now want to perform an unplanned comparison test on the data to determine the magnitudes of the differences between pairs of groups. Although R has a built-in `TukeyHSD` function, its output is not as complete as the `HSD.test` function in the agricolae package, so here we will use that latter function. We provide it the same ANOVA results that we computed in the solution to [how to perform pairwise comparisons](../how-to-perform-pairwise-comparisons). ```R # install.packages( \"agricolae\" ) # if you have not already done this library(agricolae) aov1 <- aov(count ~ spray, data = df) HSD.test(aov1, \"spray\", group=FALSE, console=TRUE) ``` Study: aov1 ~ \"spray\" HSD Test for count Mean Square Error: 15.38131 spray, means count std r Min Max A 14.500000 4.719399 12 7 23 B 15.333333 4.271115 12 7 21 C 2.083333 1.975225 12 0 7 D 4.916667 2.503028 12 2 12 E 3.500000 1.732051 12 1 6 F 16.666667 6.213378 12 9 26 Alpha: 0.05 ; DF Error: 66 Critical Value of Studentized Range: 4.150851 Comparison between treatments means difference pvalue signif. LCL UCL A - B -0.8333333 0.9952 -5.532742 3.866075 A - C 12.4166667 0.0000 *** 7.717258 17.116075 A - D 9.5833333 0.0000 *** 4.883925 14.282742 A - E 11.0000000 0.0000 *** 6.300591 15.699409 A - F -2.1666667 0.7542 -6.866075 2.532742 B - C 13.2500000 0.0000 *** 8.550591 17.949409 B - D 10.4166667 0.0000 *** 5.717258 15.116075 B - E 11.8333333 0.0000 *** 7.133925 16.532742 B - F -1.3333333 0.9603 -6.032742 3.366075 C - D -2.8333333 0.4921 -7.532742 1.866075 C - E -1.4166667 0.9489 -6.116075 3.282742 C - F -14.5833333 0.0000 *** -19.282742 -9.883925 D - E 1.4166667 0.9489 -3.282742 6.116075 D - F -11.7500000 0.0000 *** -16.449409 -7.050591 E - F -13.1666667 0.0000 *** -17.866075 -8.467258 The table above highlights for us those confidence intervals whose means are significantly different from zero, and provides other information as well. To see if there is any statistical different between the pairs, look at the \"signif\" column. The more asterisks appear there, the more significant the difference. Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform post-hoc analysis with Tukey's HSD test/R, using agricolae.md). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test-in-r-using-agricolae/",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test-in-r-using-agricolae/"
  },"740": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test (in R)",
    "title": "How to perform post-hoc analysis with Tukey's HSD test (in R)",
    "content": "# How to perform post-hoc analysis with Tukey's HSD test (in R) [See all solutions.](../how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test) ## Task If we run a one-way ANOVA test and find that there is a significant difference between population means, we might want to know which means are actually different from each other. One way to do so is with Tukey's Honestly Significant Differences (HSD) method. It creates confidence intervals for each pair of samples, while controlling for Type I error rate across all pairs. Thus the resulting intervals are a little wider than those produced using Fisher's LSD method. How do we make these confidence intervals, with an appropriate visualization? ## Solution We load here the same data that appears in the solution for how to perform pairwise comparisons. That solution used ANOVA to determine which pairs of groups have significant differences in their means; follow its link for more details. ```R # Load an inbuilt data set called InsectSprays and assign it to the variable df df <- InsectSprays head( df, 10 ) ``` count spray 1 10 A 2 7 A 3 20 A 4 14 A 5 14 A 6 12 A 7 10 A 8 23 A 9 17 A 10 20 A We now want to perform an unplanned comparison test on the data to determine the magnitudes of the differences between pairs of groups. We do this by applying Tukey's HSD approach to perform pairwise comparisons and generate confidence intervals that maintain a specified experiment-wide error rate. We use R's built-in `TukeyHSD` function, and we give it the same ANOVA results that we computed in the solution for [how to perform pairwise comparisons](../how-to-perform-pairwise-comparisons). ```R aov1 <- aov(count ~ spray, data = df) TukeyHSD(aov1, \"spray\", ordered=TRUE, conf.level = 0.95) ``` Tukey multiple comparisons of means 95% family-wise confidence level factor levels have been ordered Fit: aov(formula = count ~ spray, data = df) $spray diff lwr upr p adj E-C 1.4166667 -3.282742 6.116075 0.9488669 D-C 2.8333333 -1.866075 7.532742 0.4920707 A-C 12.4166667 7.717258 17.116075 0.0000000 B-C 13.2500000 8.550591 17.949409 0.0000000 F-C 14.5833333 9.883925 19.282742 0.0000000 D-E 1.4166667 -3.282742 6.116075 0.9488669 A-E 11.0000000 6.300591 15.699409 0.0000000 B-E 11.8333333 7.133925 16.532742 0.0000000 F-E 13.1666667 8.467258 17.866075 0.0000000 A-D 9.5833333 4.883925 14.282742 0.0000014 B-D 10.4166667 5.717258 15.116075 0.0000002 F-D 11.7500000 7.050591 16.449409 0.0000000 B-A 0.8333333 -3.866075 5.532742 0.9951810 F-A 2.1666667 -2.532742 6.866075 0.7542147 F-B 1.3333333 -3.366075 6.032742 0.9603075 Because the above table contains a lot of information, it's often helpful to visualize these intervals. R lets us do so by simply calling `plot` on the above table. We add a few plotting parameters to improve its appearance. ```R plot( TukeyHSD(aov1, \"spray\", ordered=TRUE, conf.level = 0.95), las=1, cex.axis=0.9 ) ``` ![png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAANICAMAAADKOT/pAAADAFBMVEUAAAABAQECAgIDAwME BAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUW FhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJyco KCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAxMTEyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6 Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tM TExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1e Xl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2doaGhpaWlqampra2tsbGxtbW1ubm5vb29w cHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGC goKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OU lJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWm pqanp6eoqKipqamqqqqrq6usrKytra2urq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4 uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PExMTFxcXGxsbHx8fIyMjJycnK ysrLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc 3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u 7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////i sF19AAAACXBIWXMAABJ0AAASdAHeZh94AAAgAElEQVR4nO3deWBU1b3A8V9CWBKWgCHsAgUr LkhRtG6otaKoCFXqUqVVqbi0iuizSpW2oLi9iiJaRIwb7guCVBRr3AoqtejDlmqXVERQwmJJ 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 ISS1dnG59/VFke67Nj16x0T/wHFNn9AbFd9nBfK8UtdKS+/0gNBbn7Dwo3KxhN83nWAckrpJ pOR4aVGeMIOazrLf5fIdpT4Sedb/dzzlwVa9wHvT84raNzapuAGRty9PTp26SA0O9eO9SWsv 8r/1hbRv6PhI6D1ii/DZ+JWnjEy6kbpmEb/KhIt2FIn807sjP9Jde5NCSKeE3g1XHiRylfrG e4IZ772Gu0diR6dPllHe1/tF1qtdbeXXsWHhR2WphA4vfOz9m32sYUhftJCjW8opSXM4U3L6 +I+0XZ3kUD+Z6O5bb71wVOiQ+0ki8/0jGj2+8bI6b+wvv4iOvFqkc6VSm7zSSvxG2/oLMB4Q yflnfSFdINJxk/ec2iscUtKVp4xMupG6ZhHZP+WiS72uQ4cgNdfepBDSU96D5bAx3UUK1ys1 zjtzwNlDvK+H1oQufTK8NuizXO/t9hMiS2PDwo/KL72CRq74fU/v3+wOS9cbhaRG+K/nnkma w0x/03wV+tms5G2O7+49x/zwlQ8W39hSWq9Xn+aLHP3yH0aLHFgdHfm59+Rz+LNPejPuvUVV eFHsM/OFa1uHn0F2H9Lb3tYhz8w5rJ1Irnc26cpTRibdSF2ziOyfctHboVeu/6t0196kEFLN 6PBblXZveWcqj4i8JT5gdejC/xTL70InLhPplpO4cDXyqBwf2rvHZz38t9FmIc33di1MWJvg +cTb5L1F8hech36mFNt9Ra/IfHIf8jeGjw9Kz7/Hhy4sCG/r5r+Ciq1sGL1N1ReSv1zJP1Li L9rdlXLlqSOTbqSOWUT3T76oxp9NbniNYl3X3qQQkqqec1SX1n0vXRU6s3P29/bK6zR0RuR/ 7F0oR4RXM1Tf1K9lr2sTHv6RR+WO/z0gv+e4L1XpgLxez5iFtLM46Se7Id3Ef4sU/i9Dk1TC 7uumHtq1ZcF+l/wltNsnP/1W64KBkzYlDl35s2/n5x94fXgx3n9vPqywZfczfq8Sr0MT0q47 B7TqcubfPpbwoe7EK08dmXwjtWcR+8MlX/Q/3vDjI7vUce1NCiEFbl0rf1UfmhZCCtzFEjrA jSaFkIL1+LQzvNc7i1xPA7YRUrCO899xX+J6FrCOkIJ1Zuu8AXfuqn8/ZBlCAiwgJMACQgIs ICTAAkICLCAkwAJCAiwgJMACQgIsICTAAkICLCAkwAJCAiwgJMACQgIsICTAAkICLCAkwAJC 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 rkJggg==) Confidence intervals that cross the vertical, dashed line at $x=0$ are those in which the means across those groups may be equal. Other intervals have mean differences whose 95% confidence intervals do not include zero. Content last modified on 14 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to perform post-hoc analysis with Tukey's HSD test/R.md). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test-in-r/",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test-in-r/"
  },"741": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test",
    "title": "How to perform post-hoc analysis with Tukey’s HSD test",
    "content": " ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#how-to-perform-post-hoc-analysis-with-tukeys-hsd-test",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#how-to-perform-post-hoc-analysis-with-tukeys-hsd-test"
  },"742": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test",
    "title": "Description",
    "content": "If we run a one-way ANOVA test and find that there is a significant difference between population means, we might want to know which means are actually different from each other. One way to do so is with Tukey’s Honestly Significant Differences (HSD) method. It creates confidence intervals for each pair of samples, while controlling for Type I error rate across all pairs. Thus the resulting intervals are a little wider than those produced using Fisher’s LSD method. How do we make these confidence intervals, with an appropriate visualization? . ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#description",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#description"
  },"743": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test",
    "title": "Using statsmodels, Matplotlib and scikit, in Python",
    "content": "View this solution alone. We load here the same data that appears in the solution for how to perform pairwise comparisons. That solution used ANOVA to determine which pairs of groups have significant differences in their means; follow its link for more details. | 1 2 3 . | from rdatasets import data df = data('InsectSprays') df . | . | | count | spray | . | 0 | 10 | A | . | 1 | 7 | A | . | 2 | 20 | A | . | 3 | 14 | A | . | 4 | 14 | A | . | ... | ... | ... | . | 67 | 10 | F | . | 68 | 26 | F | . | 69 | 26 | F | . | 70 | 24 | F | . | 71 | 13 | F | . 72 rows × 2 columns . We now want to perform an unplanned comparison test on the data to determine the magnitudes of the differences between pairs of groups. We do this by applying Tukey’s HSD approach to perform pairwise comparisons and generate confidence intervals that maintain a specified experiment-wide error rate. Before that, the pairwise_tukeyhsd module needs to be imported from the statsmodels package. | 1 2 3 . | from statsmodels.stats.multicomp import pairwise_tukeyhsd tukey = pairwise_tukeyhsd(endog=df['count'], groups=df['spray'], alpha=0.05) print(tukey) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . | Multiple Comparison of Means - Tukey HSD, FWER=0.05 ===================================================== group1 group2 meandiff p-adj lower upper reject ----------------------------------------------------- A B 0.8333 0.9 -3.8659 5.5326 False A C -12.4167 0.001 -17.1159 -7.7174 True A D -9.5833 0.001 -14.2826 -4.8841 True A E -11.0 0.001 -15.6992 -6.3008 True A F 2.1667 0.728 -2.5326 6.8659 False B C -13.25 0.001 -17.9492 -8.5508 True B D -10.4167 0.001 -15.1159 -5.7174 True B E -11.8333 0.001 -16.5326 -7.1341 True B F 1.3333 0.9 -3.3659 6.0326 False C D 2.8333 0.4921 -1.8659 7.5326 False C E 1.4167 0.9 -3.2826 6.1159 False C F 14.5833 0.001 9.8841 19.2826 True D E -1.4167 0.9 -6.1159 3.2826 False D F 11.75 0.001 7.0508 16.4492 True E F 13.1667 0.001 8.4674 17.8659 True ----------------------------------------------------- . | . Because the above table contains a lot of information, it’s often helpful to visualize these intervals. Python’s statsmodels package does not have a built-in way to do so, but we can create our own as follows. | 1 2 3 4 5 6 7 . | import matplotlib.pyplot as plt rows = tukey.summary().data[1:] plt.hlines( range(len(rows)), [row[4] for row in rows], [row[5] for row in rows] ) plt.vlines( 0, -1, len( rows )-1, linestyles='dashed' ) plt.gca().set_yticks( range( len( rows ) ) ) plt.gca().set_yticklabels( [ f'{x[0]}-{x[1]}' for x in rows ] ) plt.show() . | . Confidence intervals that cross the vertical, dashed line at $x=0$ are those in which the means across those groups may be equal. Other intervals have mean differences whose 95% confidence intervals do not include zero. Content last modified on 10 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#using-statsmodels-matplotlib-and-scikit-in-python",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#using-statsmodels-matplotlib-and-scikit-in-python"
  },"744": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test",
    "title": "Using agricolae, in R",
    "content": "View this solution alone. We load here the same data that appears in the solution for how to perform pairwise comparisons. That solution used ANOVA to determine which pairs of groups have significant differences in their means; follow its link for more details. | 1 2 3 . | # Load an inbuilt data set called InsectSprays and assign it to the variable df df &lt;- InsectSprays head( df, 10 ) . | . | 1 2 3 4 5 6 7 8 9 10 11 . | count spray 1 10 A 2 7 A 3 20 A 4 14 A 5 14 A 6 12 A 7 10 A 8 23 A 9 17 A 10 20 A . | . We now want to perform an unplanned comparison test on the data to determine the magnitudes of the differences between pairs of groups. Although R has a built-in TukeyHSD function, its output is not as complete as the HSD.test function in the agricolae package, so here we will use that latter function. We provide it the same ANOVA results that we computed in the solution to how to perform pairwise comparisons. | 1 2 3 4 . | # install.packages( \"agricolae\" ) # if you have not already done this library(agricolae) aov1 &lt;- aov(count ~ spray, data = df) HSD.test(aov1, \"spray\", group=FALSE, console=TRUE) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 . | Study: aov1 ~ \"spray\" HSD Test for count Mean Square Error: 15.38131 spray, means count std r Min Max A 14.500000 4.719399 12 7 23 B 15.333333 4.271115 12 7 21 C 2.083333 1.975225 12 0 7 D 4.916667 2.503028 12 2 12 E 3.500000 1.732051 12 1 6 F 16.666667 6.213378 12 9 26 Alpha: 0.05 ; DF Error: 66 Critical Value of Studentized Range: 4.150851 Comparison between treatments means difference pvalue signif. LCL UCL A - B -0.8333333 0.9952 -5.532742 3.866075 A - C 12.4166667 0.0000 *** 7.717258 17.116075 A - D 9.5833333 0.0000 *** 4.883925 14.282742 A - E 11.0000000 0.0000 *** 6.300591 15.699409 A - F -2.1666667 0.7542 -6.866075 2.532742 B - C 13.2500000 0.0000 *** 8.550591 17.949409 B - D 10.4166667 0.0000 *** 5.717258 15.116075 B - E 11.8333333 0.0000 *** 7.133925 16.532742 B - F -1.3333333 0.9603 -6.032742 3.366075 C - D -2.8333333 0.4921 -7.532742 1.866075 C - E -1.4166667 0.9489 -6.116075 3.282742 C - F -14.5833333 0.0000 *** -19.282742 -9.883925 D - E 1.4166667 0.9489 -3.282742 6.116075 D - F -11.7500000 0.0000 *** -16.449409 -7.050591 E - F -13.1666667 0.0000 *** -17.866075 -8.467258 . | . The table above highlights for us those confidence intervals whose means are significantly different from zero, and provides other information as well. To see if there is any statistical different between the pairs, look at the “signif” column. The more asterisks appear there, the more significant the difference. Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#using-agricolae-in-r",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#using-agricolae-in-r"
  },"745": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test",
    "title": "Solution, in R",
    "content": "View this solution alone. We load here the same data that appears in the solution for how to perform pairwise comparisons. That solution used ANOVA to determine which pairs of groups have significant differences in their means; follow its link for more details. | 1 2 3 . | # Load an inbuilt data set called InsectSprays and assign it to the variable df df &lt;- InsectSprays head( df, 10 ) . | . | 1 2 3 4 5 6 7 8 9 10 11 . | count spray 1 10 A 2 7 A 3 20 A 4 14 A 5 14 A 6 12 A 7 10 A 8 23 A 9 17 A 10 20 A . | . We now want to perform an unplanned comparison test on the data to determine the magnitudes of the differences between pairs of groups. We do this by applying Tukey’s HSD approach to perform pairwise comparisons and generate confidence intervals that maintain a specified experiment-wide error rate. We use R’s built-in TukeyHSD function, and we give it the same ANOVA results that we computed in the solution for how to perform pairwise comparisons. | 1 2 . | aov1 &lt;- aov(count ~ spray, data = df) TukeyHSD(aov1, \"spray\", ordered=TRUE, conf.level = 0.95) . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 . | Tukey multiple comparisons of means 95% family-wise confidence level factor levels have been ordered Fit: aov(formula = count ~ spray, data = df) $spray diff lwr upr p adj E-C 1.4166667 -3.282742 6.116075 0.9488669 D-C 2.8333333 -1.866075 7.532742 0.4920707 A-C 12.4166667 7.717258 17.116075 0.0000000 B-C 13.2500000 8.550591 17.949409 0.0000000 F-C 14.5833333 9.883925 19.282742 0.0000000 D-E 1.4166667 -3.282742 6.116075 0.9488669 A-E 11.0000000 6.300591 15.699409 0.0000000 B-E 11.8333333 7.133925 16.532742 0.0000000 F-E 13.1666667 8.467258 17.866075 0.0000000 A-D 9.5833333 4.883925 14.282742 0.0000014 B-D 10.4166667 5.717258 15.116075 0.0000002 F-D 11.7500000 7.050591 16.449409 0.0000000 B-A 0.8333333 -3.866075 5.532742 0.9951810 F-A 2.1666667 -2.532742 6.866075 0.7542147 F-B 1.3333333 -3.366075 6.032742 0.9603075 . | . Because the above table contains a lot of information, it’s often helpful to visualize these intervals. R lets us do so by simply calling plot on the above table. We add a few plotting parameters to improve its appearance. | 1 2 . | plot( TukeyHSD(aov1, \"spray\", ordered=TRUE, conf.level = 0.95), las=1, cex.axis=0.9 ) . | . Confidence intervals that cross the vertical, dashed line at $x=0$ are those in which the means across those groups may be equal. Other intervals have mean differences whose 95% confidence intervals do not include zero. Content last modified on 14 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#solution-in-r",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#solution-in-r"
  },"746": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | Bentley University MA255 | . ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#topics-that-include-this-task",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#topics-that-include-this-task"
  },"747": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#opportunities",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/#opportunities"
  },"748": {
    "doc": "How to perform post-hoc analysis with Tukey's HSD test",
    "title": "How to perform post-hoc analysis with Tukey's HSD test",
    "content": " ",
    "url": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/",
    "relUrl": "/how-to-perform-post-hoc-analysis-with-tukey-s-hsd-test/"
  },"749": {
    "doc": "How to plot continuous probability distributions (in Excel)",
    "title": "How to plot continuous probability distributions (in Excel)",
    "content": "# How to plot continuous probability distributions (in Excel) [See all solutions.](../how-to-plot-continuous-probability-distributions) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to plot the distribution as a curve? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution We begin by creating the values that will be shown on the $x$-axis. These values depend not only on the distribution, but on which portion of it you wish to see. For example, for an exponential distribution, the sample space is $(0,\\infty)$, but for a standard normal distribution, it is the whole real line, and you may wish to view just $( - 5,5)$, or some other range. In the example below, we will use a Gamma distribution with $\\alpha = 5$ and $\\beta = 5$, plotted on the range $\\lbrack 0,50\\rbrack$, but the particular example doesn’t matter; you can use the procedure below for any distribution. To generate the $x$ values from 0 to 50, begin with just the first two values in the sequence, in this case 0 and 1, as shown below. Drag the small green square in the bottom right of the selection downward, to create a sequence that goes all the way up to 50. (Only the beginning of it is shown here.) If your sample spaces were a smaller range (say, just from -2 to 2), you would need to use smaller steps to get a smooth plot. For example, you might begin with -2 and -1.9 to tell Excel to take steps of size 0.1. In the adjacent column, we put the formula for the distribution, based on the $x$ values in the first column. In this example, recall that we’ll plot a Gamma distribution with $\\alpha = 5$ and $\\beta = 5$, so we use the formula shown below. The final parameter for the distribution should always be FALSE, to indicate that we are *not* asking Excel for a cumulative distribution function, but just the usual probability density function. After typing your probability density function’s formula, drag it down the column. Highlight just column B and insert a line chart from the Insert tab on the Ribbon, as shown below. This will create a chart that does not yet include your desired $x$-axis labels; rather, the horizontal axis markings will be 1, 2, 3, 4, etc. To get the correct labels on the $x$-axis, right-click the chart and choose “Select Data…” This will bring up the window shown below. Click the Edit button for the Horizontal (Category) Axis Labels and select column A. Click OK twice to return to your plot, which should then have the correct $x$-axis labels. You can then update the chart title and axis labels to be more descriptive if desired, as shown in the final result, below. Although we used the GAMMA.DIST function in Excel, you can use any of the built-in continuous probability distribution functions, such as BETA.DIST, CHISQ.DIST, F.DIST, NORM.DIST, LOGNORM.DIST, or T.DIST. Content last modified on 14 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot continuous probability distributions/Excel.docx). ",
    "url": "/how-to-plot-continuous-probability-distributions-in-excel/",
    "relUrl": "/how-to-plot-continuous-probability-distributions-in-excel/"
  },"750": {
    "doc": "How to plot continuous probability distributions (in Julia)",
    "title": "How to plot continuous probability distributions (in Julia)",
    "content": "# How to plot continuous probability distributions (in Julia) [See all solutions.](../how-to-plot-continuous-probability-distributions) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to plot the distribution as a curve? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution You can import many different random variables from Julia's `Distributions` package. The full list of them is online [here](https://juliastats.org/Distributions.jl/stable/univariate/). If you don't have that package installed, first run `using Pkg` and then `Pkg.add( \"Distributions\" )` from within Julia. The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. But we can just ask Julia to show us the central 99.98% of a continuous distribution, which is almost always indistinguishable to the human eye from the entire distribution. We style the plot below so that it is clear the sample space is continuous. ```julia using Distributions X = Normal( 10, 5 ) # use a normal distribution with μ=10 and σ=5 xmin = quantile( X, 0.0001 ) # compute min x as the 0.0001 quantile xmax = quantile( X, 0.9999 ) # compute max x as the 0.9999 quantile xs = range( xmin, xmax, length=100 ) # create 100 x values in that range using Plots plot( xs, pdf.( X, xs ) ) # plot the shape of the distribution ``` Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot continuous probability distributions/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-plot-continuous-probability-distributions-in-julia/",
    "relUrl": "/how-to-plot-continuous-probability-distributions-in-julia/"
  },"751": {
    "doc": "How to plot continuous probability distributions (in Python, using SciPy)",
    "title": "How to plot continuous probability distributions (in Python, using SciPy)",
    "content": "# How to plot continuous probability distributions (in Python, using SciPy) [See all solutions.](../how-to-plot-continuous-probability-distributions) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to plot the distribution as a curve? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution You can import many different random variables from SciPy's `stats` module. The full list of them is online [here](https://docs.scipy.org/doc/scipy/reference/stats.html#continuous-distributions). The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. But we can just ask SciPy to show us the central 99.98% of a continuous distribution, which is almost always indistinguishable to the human eye from the entire distribution. We style the plot below so that it is clear the sample space is continuous. ```python from scipy import stats X = stats.norm( 10, 5 ) # use a normal distribution with μ=10 and σ=5 xmin = X.ppf( 0.0001 ) # compute min x as the 0.0001 quantile xmax = X.ppf( 0.9999 ) # compute max x as the 0.9999 quantile import numpy as np xs = np.linspace( xmin, xmax, 100 ) # create 100 x values in that range import matplotlib.pyplot as plt plt.plot( xs, X.pdf( xs ) ) # plot the shape of the distribution plt.show() ``` ![png](data:image/png;base64,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 ) Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot continuous probability distributions/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-plot-continuous-probability-distributions-in-python-using-scipy/",
    "relUrl": "/how-to-plot-continuous-probability-distributions-in-python-using-scipy/"
  },"752": {
    "doc": "How to plot continuous probability distributions (in R)",
    "title": "How to plot continuous probability distributions (in R)",
    "content": "# How to plot continuous probability distributions (in R) [See all solutions.](../how-to-plot-continuous-probability-distributions) ## Task There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to plot the distribution as a curve? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot discrete probability distributions](../how-to-plot-discrete-probability-distributions) ## Solution Because R is designed for use in statistics, it comes with many probability distributions built in. A list of them is online [here](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Probability-distributions). The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. But we can just ask R to show us the central 99.98% of a continuous distribution, which is almost always indistinguishable to the human eye from the entire distribution. We will use a normal distribution with $\\mu=10$ and $\\sigma=5$, but if you wanted to use a different distribution, you could replace `qnorm` and `dnorm` with, for example, `qchisq` and `dchisq` (for the $\\chi^2$ distribution), adjusting the named parameters as appropriate. (For a list of supported distributions, see the link above.) We style the plot below so that it is clear the sample space is continuous. ```R xmin <- qnorm( 0.0001, mean=10, sd=5 ) # compute min x as the 0.0001 quantile xmax <- qnorm( 0.9999, mean=10, sd=5 ) # compute max x as the 0.9999 quantile xs <- seq( xmin, xmax, length.out=100 ) # create 100 values in that range ys <- dnorm( xs, mean=10, sd=5 ) # compute the shape of the distribution plot( xs, ys, type='l' ) # plot that shape as a smooth line ``` Content last modified on 28 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot continuous probability distributions/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-plot-continuous-probability-distributions-in-r/",
    "relUrl": "/how-to-plot-continuous-probability-distributions-in-r/"
  },"753": {
    "doc": "How to plot continuous probability distributions",
    "title": "How to plot continuous probability distributions",
    "content": " ",
    "url": "/how-to-plot-continuous-probability-distributions/",
    "relUrl": "/how-to-plot-continuous-probability-distributions/"
  },"754": {
    "doc": "How to plot continuous probability distributions",
    "title": "Description",
    "content": "There are many famous continuous probability distributions, such as the normal and exponential distributions. How can we get access to them in software, to plot the distribution as a curve? . Related tasks: . | How to generate random values from a distribution | How to compute probabilities from a distribution | How to plot discrete probability distributions | . ",
    "url": "/how-to-plot-continuous-probability-distributions/#description",
    "relUrl": "/how-to-plot-continuous-probability-distributions/#description"
  },"755": {
    "doc": "How to plot continuous probability distributions",
    "title": "Solution, in Excel",
    "content": "View this solution alone. We begin by creating the values that will be shown on the $x$-axis. These values depend not only on the distribution, but on which portion of it you wish to see. For example, for an exponential distribution, the sample space is $(0,\\infty)$, but for a standard normal distribution, it is the whole real line, and you may wish to view just $( - 5,5)$, or some other range. In the example below, we will use a Gamma distribution with $\\alpha = 5$ and $\\beta = 5$, plotted on the range $\\lbrack 0,50\\rbrack$, but the particular example doesn’t matter; you can use the procedure below for any distribution. To generate the $x$ values from 0 to 50, begin with just the first two values in the sequence, in this case 0 and 1, as shown below. Drag the small green square in the bottom right of the selection downward, to create a sequence that goes all the way up to 50. (Only the beginning of it is shown here.) . If your sample spaces were a smaller range (say, just from -2 to 2), you would need to use smaller steps to get a smooth plot. For example, you might begin with -2 and -1.9 to tell Excel to take steps of size 0.1. In the adjacent column, we put the formula for the distribution, based on the $x$ values in the first column. In this example, recall that we’ll plot a Gamma distribution with $\\alpha = 5$ and $\\beta = 5$, so we use the formula shown below. The final parameter for the distribution should always be FALSE, to indicate that we are not asking Excel for a cumulative distribution function, but just the usual probability density function. After typing your probability density function’s formula, drag it down the column. Highlight just column B and insert a line chart from the Insert tab on the Ribbon, as shown below. This will create a chart that does not yet include your desired $x$-axis labels; rather, the horizontal axis markings will be 1, 2, 3, 4, etc. To get the correct labels on the $x$-axis, right-click the chart and choose “Select Data…” This will bring up the window shown below. Click the Edit button for the Horizontal (Category) Axis Labels and select column A. Click OK twice to return to your plot, which should then have the correct $x$-axis labels. You can then update the chart title and axis labels to be more descriptive if desired, as shown in the final result, below. Although we used the GAMMA.DIST function in Excel, you can use any of the built-in continuous probability distribution functions, such as BETA.DIST, CHISQ.DIST, F.DIST, NORM.DIST, LOGNORM.DIST, or T.DIST. Content last modified on 14 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-continuous-probability-distributions/#solution-in-excel",
    "relUrl": "/how-to-plot-continuous-probability-distributions/#solution-in-excel"
  },"756": {
    "doc": "How to plot continuous probability distributions",
    "title": "Solution, in Julia",
    "content": "View this solution alone. You can import many different random variables from Julia’s Distributions package. The full list of them is online here. If you don’t have that package installed, first run using Pkg and then Pkg.add( \"Distributions\" ) from within Julia. The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. But we can just ask Julia to show us the central 99.98% of a continuous distribution, which is almost always indistinguishable to the human eye from the entire distribution. We style the plot below so that it is clear the sample space is continuous. | 1 2 3 4 5 6 7 8 9 . | using Distributions X = Normal( 10, 5 ) # use a normal distribution with μ=10 and σ=5 xmin = quantile( X, 0.0001 ) # compute min x as the 0.0001 quantile xmax = quantile( X, 0.9999 ) # compute max x as the 0.9999 quantile xs = range( xmin, xmax, length=100 ) # create 100 x values in that range using Plots plot( xs, pdf.( X, xs ) ) # plot the shape of the distribution . | . Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-continuous-probability-distributions/#solution-in-julia",
    "relUrl": "/how-to-plot-continuous-probability-distributions/#solution-in-julia"
  },"757": {
    "doc": "How to plot continuous probability distributions",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. You can import many different random variables from SciPy’s stats module. The full list of them is online here. The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. But we can just ask SciPy to show us the central 99.98% of a continuous distribution, which is almost always indistinguishable to the human eye from the entire distribution. We style the plot below so that it is clear the sample space is continuous. | 1 2 3 4 5 6 7 8 9 10 11 . | from scipy import stats X = stats.norm( 10, 5 ) # use a normal distribution with μ=10 and σ=5 xmin = X.ppf( 0.0001 ) # compute min x as the 0.0001 quantile xmax = X.ppf( 0.9999 ) # compute max x as the 0.9999 quantile import numpy as np xs = np.linspace( xmin, xmax, 100 ) # create 100 x values in that range import matplotlib.pyplot as plt plt.plot( xs, X.pdf( xs ) ) # plot the shape of the distribution plt.show() . | . Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-continuous-probability-distributions/#using-scipy-in-python",
    "relUrl": "/how-to-plot-continuous-probability-distributions/#using-scipy-in-python"
  },"758": {
    "doc": "How to plot continuous probability distributions",
    "title": "Solution, in R",
    "content": "View this solution alone. Because R is designed for use in statistics, it comes with many probability distributions built in. A list of them is online here. The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. But we can just ask R to show us the central 99.98% of a continuous distribution, which is almost always indistinguishable to the human eye from the entire distribution. We will use a normal distribution with $\\mu=10$ and $\\sigma=5$, but if you wanted to use a different distribution, you could replace qnorm and dnorm with, for example, qchisq and dchisq (for the $\\chi^2$ distribution), adjusting the named parameters as appropriate. (For a list of supported distributions, see the link above.) . We style the plot below so that it is clear the sample space is continuous. | 1 2 3 4 5 . | xmin &lt;- qnorm( 0.0001, mean=10, sd=5 ) # compute min x as the 0.0001 quantile xmax &lt;- qnorm( 0.9999, mean=10, sd=5 ) # compute max x as the 0.9999 quantile xs &lt;- seq( xmin, xmax, length.out=100 ) # create 100 values in that range ys &lt;- dnorm( xs, mean=10, sd=5 ) # compute the shape of the distribution plot( xs, ys, type='l' ) # plot that shape as a smooth line . | . Content last modified on 28 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-continuous-probability-distributions/#solution-in-r",
    "relUrl": "/how-to-plot-continuous-probability-distributions/#solution-in-r"
  },"759": {
    "doc": "How to plot continuous probability distributions",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | . ",
    "url": "/how-to-plot-continuous-probability-distributions/#topics-that-include-this-task",
    "relUrl": "/how-to-plot-continuous-probability-distributions/#topics-that-include-this-task"
  },"760": {
    "doc": "How to plot discrete probability distributions (in Julia)",
    "title": "How to plot discrete probability distributions (in Julia)",
    "content": "# How to plot discrete probability distributions (in Julia) [See all solutions.](../how-to-plot-discrete-probability-distributions) ## Task There are many famous discrete probability distributions, such as the binomial and geometric distributions. How can we get access to them in software, to plot the distribution as a series of points? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) ## Solution You can import many different random variables from Julia's `Distributions` package. The full list of them is online [here](https://juliastats.org/Distributions.jl/stable/univariate/). If you don't have that package installed, first run `using Pkg` and then `Pkg.add( \"Distributions\" )` from within Julia. The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. The example below uses a geometric distribution, whose sample space is $\\\\{1,2,3,\\ldots\\\\}$. We specify that we just want to use $x$ values in the set $\\\\{1,2,\\ldots,10\\\\}$. (In some software, the geometric distribution's sample space begins at 0, but not in SciPy.) We style the plot below so that it is clear the sample space is discrete. ```julia using Distributions X = Geometric( 0.5 ) # use a geometric distribution with p=0.5 xs = 1:10 # specify the range to be 1,2,3,...,10 using Plots bar( xs, pdf.( X, xs ) ) # plot the shape of the distribution ``` Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot discrete probability distributions/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-plot-discrete-probability-distributions-in-julia/",
    "relUrl": "/how-to-plot-discrete-probability-distributions-in-julia/"
  },"761": {
    "doc": "How to plot discrete probability distributions (in Python, using SciPy)",
    "title": "How to plot discrete probability distributions (in Python, using SciPy)",
    "content": "# How to plot discrete probability distributions (in Python, using SciPy) [See all solutions.](../how-to-plot-discrete-probability-distributions) ## Task There are many famous discrete probability distributions, such as the binomial and geometric distributions. How can we get access to them in software, to plot the distribution as a series of points? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) ## Solution You can import many different random variables from SciPy's `stats` module. The full list of them is online [here](https://docs.scipy.org/doc/scipy/reference/stats.html#discrete-distributions). The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. The example below uses a geometric distribution, whose sample space is $\\\\{1,2,3,\\ldots\\\\}$. We specify that we just want to use $x$ values in the set $\\\\{1,2,\\ldots,10\\\\}$. (In some software, the geometric distribution's sample space begins at 0, but not in SciPy.) We style the plot below so that it is clear the sample space is discrete. ```python from scipy import stats X = stats.geom( 0.5 ) # use a geometric distribution with p=0.5 import numpy as np xs = np.arange( 1, 11 ) # specify the range to be 1,2,3,...,10 import matplotlib.pyplot as plt ys = X.pmf( xs ) # compute the shape of the distribution plt.plot( xs, ys, 'o' ) # plot circles... plt.vlines( xs, 0, ys ) # ...and lines plt.ylim( bottom=0 ) # ensure sensible bottom border plt.show() ``` ![png](data:image/png;base64,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xkpKSjR//nzFx8crKSlJt99+u9577z3TY+F/SkpKZLPZVFBQYHqUqNXW1qaVK1dq4sSJGjdunK699lrV19ebHitqnT9/Xj/84Q/ldrs1duxYTZs2TcXFxerr6zM9WlQ4duyY8vLyNHnyZNlsNv3ud7/zu92yLG3btk2TJ0/W2LFj9fWvf13vvPPOiMxGjISxo0ePasOGDXrjjTdUXV2t8+fPKzc3V59++qnp0aLem2++qYqKCl199dWmR4la//nPf7Rw4UJdccUV+uMf/6impiY98cQTXM3ZoEcffVR79uzR7t279e677+qxxx7TT3/6U/3iF78wPVpU+PTTT3XNNddo9+7dAW9/7LHHtGvXLu3evVtvvvmmkpOTdfPNN6urq2vYZ+PU3gjy8ccfKykpSUePHtXixYtNjxO1PvnkE82bN09lZWX68Y9/rGuvvValpaWmx4o6mzdv1okTJ1RTU2N6FPzPN7/5TblcLj377LO+tTvuuEPjxo3TCy+8YHCy6GOz2fTb3/5Wt99+u6QLR0UmT56sgoICPfzww5Kk7u5uuVwuPfroo1q3bt2wzsORkQji9XolSRMmXN5XPuPybNiwQbfddptuuukm06NEtZdffllZWVn69re/raSkJM2dO1fPPPOM6bGi2g033KA//elPev/99yVJf/nLX3T8+HHdeuuthidDc3Oz2tvblZub61uz2+268cYbVVtbO+yPP6Rv7cXoY1mWCgsLdcMNNygjI8P0OFHr17/+tU6ePKk333zT9ChR75///KfKy8tVWFioRx55RHV1dXrggQdkt9v9vrICI+fhhx+W1+vVrFmzFBMTo97eXu3YsUN33XWX6dGi3sUvtP3il966XC59+OGHw/74xEiE2Lhxo/7617/q+PHjpkeJWq2trdq0aZOOHDkih8Nhepyo19fXp6ysLO3cuVOSNHfuXL3zzjsqLy8nRgyprKzU/v37deDAAc2ePVuNjY0qKCjQ5MmTdffdd5seD7rw9s3nWZbVb204ECMR4P7779fLL7+sY8eO6corrzQ9TtSqr69XR0eHMjMzfWu9vb06duyYdu/ere7ubsXExBicMLqkpKQoPT3dby0tLU0HDx40NBG+//3va/PmzfrOd74jSZozZ44+/PBDlZSUECOGJScnS7pwhCQlJcW33tHR0e9oyXDgMyNhzLIsbdy4US+99JJeffVVud1u0yNFtSVLlujtt99WY2Ojb8vKytJ3v/tdNTY2EiIjbOHChf1OdX///fd9X+qJkffZZ59pzBj/PzsxMTGc2jsKuN1uJScnq7q62rfW09Ojo0ePKicnZ9gfnyMjYWzDhg06cOCAfv/73ys+Pt73np/T6dTYsWMNTxd94uPj+31eZ/z48Zo4cSKf4zHgwQcfVE5Ojnbu3Kk777xTdXV1qqioUEVFhenRolZeXp527NihKVOmaPbs2WpoaNCuXbt07733mh4tKnzyySf6+9//7vu5ublZjY2NmjBhgqZMmaKCggLt3LlT06dP1/Tp07Vz506NGzdOK1asGP7hLIQtSQG3vXv3mh4N/3PjjTdamzZtMj1G1Dp06JCVkZFh2e12a9asWVZFRYXpkaJaZ2entWnTJmvKlCmWw+Gwpk2bZm3dutXq7u42PVpUeO211wL+zbj77rsty7Ksvr4+q6ioyEpOTrbsdru1ePFi6+233x6R2bjOCAAAMIrPjAAAAKOIEQAAYBQxAgAAjCJGAACAUcQIAAAwihgBAABGESMAAMAoYgQAABhFjAAAAKOIEQAAYBQxAgAAjCJGAACAUf8PeFJK0xVzzDsAAAAASUVORK5CYII= ) Content last modified on 28 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot discrete probability distributions/Python, using SciPy.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-plot-discrete-probability-distributions-in-python-using-scipy/",
    "relUrl": "/how-to-plot-discrete-probability-distributions-in-python-using-scipy/"
  },"762": {
    "doc": "How to plot discrete probability distributions (in R)",
    "title": "How to plot discrete probability distributions (in R)",
    "content": "# How to plot discrete probability distributions (in R) [See all solutions.](../how-to-plot-discrete-probability-distributions) ## Task There are many famous discrete probability distributions, such as the binomial and geometric distributions. How can we get access to them in software, to plot the distribution as a series of points? Related tasks: * [How to generate random values from a distribution](../how-to-generate-random-values-from-a-distribution) * [How to compute probabilities from a distribution](../how-to-compute-probabilities-from-a-distribution) * [How to plot continuous probability distributions](../how-to-plot-continuous-probability-distributions) ## Solution Because R is designed for use in statistics, it comes with many probability distributions built in. A list of them is online [here](https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Probability-distributions). The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. The example below uses a geometric distribution (with $p=0.5$), whose sample space is $\\\\{0,1,2,3,\\ldots\\\\}$. We specify that we just want to use $x$ values in the set $\\\\{0,1,2,\\ldots,10\\\\}$. (In some software, the geometric distribution's sample space begins at 1, but not in R.) If you wanted to use a different distribution, you could replace `dgeom` with, for example, `dbinom`, adjusting the named parameters as appropriate. We style the plot below so that it is clear the sample space is discrete. ```R xs = 0:8 # choose the sample space (here, it's 0,1,2,...,10) ys = dgeom( xs, prob=0.5 ) # compute the shape of the distribution plot( xs, ys, type='p', # plot circles... xlab='sample space', ylab='probability' ) segments( xs, 0, xs, ys ) # ...and lines ``` Content last modified on 28 May 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot discrete probability distributions/R.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-plot-discrete-probability-distributions-in-r/",
    "relUrl": "/how-to-plot-discrete-probability-distributions-in-r/"
  },"763": {
    "doc": "How to plot discrete probability distributions",
    "title": "How to plot discrete probability distributions",
    "content": " ",
    "url": "/how-to-plot-discrete-probability-distributions/",
    "relUrl": "/how-to-plot-discrete-probability-distributions/"
  },"764": {
    "doc": "How to plot discrete probability distributions",
    "title": "Description",
    "content": "There are many famous discrete probability distributions, such as the binomial and geometric distributions. How can we get access to them in software, to plot the distribution as a series of points? . Related tasks: . | How to generate random values from a distribution | How to compute probabilities from a distribution | How to plot continuous probability distributions | . ",
    "url": "/how-to-plot-discrete-probability-distributions/#description",
    "relUrl": "/how-to-plot-discrete-probability-distributions/#description"
  },"765": {
    "doc": "How to plot discrete probability distributions",
    "title": "Solution, in Julia",
    "content": "View this solution alone. You can import many different random variables from Julia’s Distributions package. The full list of them is online here. If you don’t have that package installed, first run using Pkg and then Pkg.add( \"Distributions\" ) from within Julia. The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. The example below uses a geometric distribution, whose sample space is $\\{1,2,3,\\ldots\\}$. We specify that we just want to use $x$ values in the set $\\{1,2,\\ldots,10\\}$. (In some software, the geometric distribution’s sample space begins at 0, but not in SciPy.) . We style the plot below so that it is clear the sample space is discrete. | 1 2 3 4 5 6 . | using Distributions X = Geometric( 0.5 ) # use a geometric distribution with p=0.5 xs = 1:10 # specify the range to be 1,2,3,...,10 using Plots bar( xs, pdf.( X, xs ) ) # plot the shape of the distribution . | . Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-discrete-probability-distributions/#solution-in-julia",
    "relUrl": "/how-to-plot-discrete-probability-distributions/#solution-in-julia"
  },"766": {
    "doc": "How to plot discrete probability distributions",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. You can import many different random variables from SciPy’s stats module. The full list of them is online here. The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. The example below uses a geometric distribution, whose sample space is $\\{1,2,3,\\ldots\\}$. We specify that we just want to use $x$ values in the set $\\{1,2,\\ldots,10\\}$. (In some software, the geometric distribution’s sample space begins at 0, but not in SciPy.) . We style the plot below so that it is clear the sample space is discrete. | 1 2 3 4 5 6 7 8 9 10 11 12 . | from scipy import stats X = stats.geom( 0.5 ) # use a geometric distribution with p=0.5 import numpy as np xs = np.arange( 1, 11 ) # specify the range to be 1,2,3,...,10 import matplotlib.pyplot as plt ys = X.pmf( xs ) # compute the shape of the distribution plt.plot( xs, ys, 'o' ) # plot circles... plt.vlines( xs, 0, ys ) # ...and lines plt.ylim( bottom=0 ) # ensure sensible bottom border plt.show() . | . Content last modified on 28 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-discrete-probability-distributions/#using-scipy-in-python",
    "relUrl": "/how-to-plot-discrete-probability-distributions/#using-scipy-in-python"
  },"767": {
    "doc": "How to plot discrete probability distributions",
    "title": "Solution, in R",
    "content": "View this solution alone. Because R is designed for use in statistics, it comes with many probability distributions built in. A list of them is online here. The challenge with plotting a random variable is knowing the appropriate sample space, because some random variables have sample spaces of infinite width, which cannot be plotted. The example below uses a geometric distribution (with $p=0.5$), whose sample space is $\\{0,1,2,3,\\ldots\\}$. We specify that we just want to use $x$ values in the set $\\{0,1,2,\\ldots,10\\}$. (In some software, the geometric distribution’s sample space begins at 1, but not in R.) . If you wanted to use a different distribution, you could replace dgeom with, for example, dbinom, adjusting the named parameters as appropriate. We style the plot below so that it is clear the sample space is discrete. | 1 2 3 4 5 . | xs = 0:8 # choose the sample space (here, it's 0,1,2,...,10) ys = dgeom( xs, prob=0.5 ) # compute the shape of the distribution plot( xs, ys, type='p', # plot circles... xlab='sample space', ylab='probability' ) segments( xs, 0, xs, ys ) # ...and lines . | . Content last modified on 28 May 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-discrete-probability-distributions/#solution-in-r",
    "relUrl": "/how-to-plot-discrete-probability-distributions/#solution-in-r"
  },"768": {
    "doc": "How to plot discrete probability distributions",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | . ",
    "url": "/how-to-plot-discrete-probability-distributions/#topics-that-include-this-task",
    "relUrl": "/how-to-plot-discrete-probability-distributions/#topics-that-include-this-task"
  },"769": {
    "doc": "How to plot discrete probability distributions",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-plot-discrete-probability-distributions/#opportunities",
    "relUrl": "/how-to-plot-discrete-probability-distributions/#opportunities"
  },"770": {
    "doc": "How to plot interaction effects of treatments (in Python, using Matplotlib and Seaborn)",
    "title": "How to plot interaction effects of treatments (in Python, using Matplotlib and Seaborn)",
    "content": "# How to plot interaction effects of treatments (in Python, using Matplotlib and Seaborn) [See all solutions.](../how-to-plot-interaction-effects-of-treatments) ## Task When there are multiple treatment conditions with multiple levels and you wish to undertsand the interaction effects of each of them, a plot can be useful. How can we create the right kind of plot for that situation? * [How to create basic plots](../how-to-create-basic-plots) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data('ToothGrowth') ``` To plot the interaction effects among tooth length, supplement, and dosage, we can use the `pointplot` function in the Seaborn package. ```python import seaborn as sns import matplotlib.pyplot as plt sns.pointplot(x='dose',y='len',hue='supp',data=df) plt.legend(loc='lower right') # Default is upper right, which overlaps the data here. plt.show() ``` ![png](data:image/png;base64,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 ) Looking at the output, we first see that there is an interaction effect because the two supp lines intersect. We also see that there is a difference in length when giving 0.5mg and 1mg dosage of either of the two delivery methods. However, there is barely any difference between the delivery methods when the dosage level is 2mg. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot interaction effects of treatments/Python, using Matplotlib and Seaborn.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-plot-interaction-effects-of-treatments-in-python-using-matplotlib-and-seaborn/",
    "relUrl": "/how-to-plot-interaction-effects-of-treatments-in-python-using-matplotlib-and-seaborn/"
  },"771": {
    "doc": "How to plot interaction effects of treatments (in R, using ggpubr)",
    "title": "How to plot interaction effects of treatments (in R, using ggpubr)",
    "content": "# How to plot interaction effects of treatments (in R, using ggpubr) [See all solutions.](../how-to-plot-interaction-effects-of-treatments) ## Task When there are multiple treatment conditions with multiple levels and you wish to undertsand the interaction effects of each of them, a plot can be useful. How can we create the right kind of plot for that situation? * [How to create basic plots](../how-to-create-basic-plots) * [How to add details to a plot](../how-to-add-details-to-a-plot) * [How to create a histogram](../how-to-create-a-histogram) * [How to create a box (and whisker) plot](../how-to-create-a-box-and-whisker-plot) * [How to change axes, ticks, and scale in a plot](../how-to-change-axes-ticks-and-scale-in-a-plot) * [How to create bivariate plots to compare groups](../how-to-create-bivariate-plots-to-compare-groups) ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R df <- ToothGrowth ``` To plot the interaction effects among tooth length, supplement, and dosage, we can use the `ggline` function in the `ggpubr` package. You can change the `x` and `color` inputs below depending on your goals, but the `y` input should always be the dependent variable. ```R # install.packages(\"ggpubr\") # If you have not already installed it library(ggpubr) ggline(df, x=\"dose\", y=\"len\", color=\"supp\", add=c(\"mean\")) ``` Loading required package: ggplot2 ![png](data:image/png;base64,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 eMFmmYGzYLFYli5dqtPpJk2apHYW4Ow1NDT8/ve/j4qKcnNzGzFixMyZMw8ePKh2KJwrvdoB 4CQ6OzunTZuWlpY2e/bsCRMm5Ofnr1+//uuvvz5y5Ii/v3+Pn9LY2CiESE1NjYyMPHn9kksu sUVi4KxkZmbOnz8/NzdX7SDAOamvr584cWJRUdG11167cOHCgoKCbdu27d2799ChQ2PGjFE7 Hc4exQ4DY/Xq1WlpaS+99NJjjz3WtXLVVVfNnTt3xYoVq1at6vFTuordI488wrYHHEVzc/PE iROTkpLS0tKSk5PVjgOcvaeffrqoqOjNN9+87777ulZmzZo1e/bsJ554Yvfu3epmw7ngrVgM jPXr1/v4+Dz44IPdK3PmzImNjd2wYcOZrrzuKnZ+fn42igicM0mSlixZ8v3338fGxqqdBTgn BoNh2rRpd999d/fKjTfe6OHhkZ6ermIqnDuKHQaA2Wz++eefJ0+e7ObmdvL6pZdeWl1dXVhY 2ONndRc7q9VaVlZWW1tri6zAOQgICFi1apXBYFA7CHCuXnvttS+//PLkf8ydnZ2SJA0fPlzF VDh3FDsMgNLSUqvVGhERccp6VFSUEKKgoKDHz2pqahJCvP7668HBwREREcHBwfHx8Zs3bx7s tACA073zzjsWiyUlJUXtIDgnnLHDAGhpaRFCeHl5nbLu7e3d/ejpunbstmzZ8thjj4WHh2dm Zq5evXrevHktLS0nvzsAABhs+/bte/TRRy+99NLFixernQXnhGKHAaPRaE5Z6Tpdd/p6l2XL lt13330zZszoboTz58+fMGHCk08+efvtt3PbMQCwjS1bttx+++3JycmffPKJXk8xcGy8FYsB MGTIENHTzlxzc7MQwsfHp8fPmjp16uzZs0/e50tMTLzmmmvq6+uPHTs2aGEBAP+hKMozzzxz yy23TJky5Z///GdAQIDaiXCuKOYYAJGRkXq9vri4+JT1/Px8IcSoUaP6/qVCQkKEECaTaQDj AQBOpyjKokWL3n///fvvv/+1117T6XRqJ8IAYMcOA8BoNE6cOPHQoUNtbW3di7Is79u3LyIi 4pT5w11MJtPbb7+9ZcuWU9a7rrTvuuoCADB4Hn744ffff//FF1/805/+RKtzGhQ7DIw777yz ra3tlVde6V559913KyoqFi1a1PWh2Ww+evRo1x6eEMLT03PFihV33XVXVlZW96d88skn+/fv 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) Looking at the output, we first see that there is an interaction effect because the two supp lines intersect. We also see that there is a difference in length when giving 0.5mg and 1mg dosage of either of the two delivery methods. However, there is barely any difference between the delivery methods when the dosage level is 2mg. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to plot interaction effects of treatments/R, using ggpubr.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-plot-interaction-effects-of-treatments-in-r-using-ggpubr/",
    "relUrl": "/how-to-plot-interaction-effects-of-treatments-in-r-using-ggpubr/"
  },"772": {
    "doc": "How to plot interaction effects of treatments",
    "title": "How to plot interaction effects of treatments",
    "content": " ",
    "url": "/how-to-plot-interaction-effects-of-treatments/",
    "relUrl": "/how-to-plot-interaction-effects-of-treatments/"
  },"773": {
    "doc": "How to plot interaction effects of treatments",
    "title": "Description",
    "content": "When there are multiple treatment conditions with multiple levels and you wish to undertsand the interaction effects of each of them, a plot can be useful. How can we create the right kind of plot for that situation? . | How to create basic plots | How to add details to a plot | How to create a histogram | How to create a box (and whisker) plot | How to change axes, ticks, and scale in a plot | How to create bivariate plots to compare groups | . ",
    "url": "/how-to-plot-interaction-effects-of-treatments/#description",
    "relUrl": "/how-to-plot-interaction-effects-of-treatments/#description"
  },"774": {
    "doc": "How to plot interaction effects of treatments",
    "title": "Using Matplotlib and Seaborn, in Python",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 2 . | from rdatasets import data df = data('ToothGrowth') . | . To plot the interaction effects among tooth length, supplement, and dosage, we can use the pointplot function in the Seaborn package. | 1 2 3 4 5 . | import seaborn as sns import matplotlib.pyplot as plt sns.pointplot(x='dose',y='len',hue='supp',data=df) plt.legend(loc='lower right') # Default is upper right, which overlaps the data here. plt.show() . | . Looking at the output, we first see that there is an interaction effect because the two supp lines intersect. We also see that there is a difference in length when giving 0.5mg and 1mg dosage of either of the two delivery methods. However, there is barely any difference between the delivery methods when the dosage level is 2mg. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-interaction-effects-of-treatments/#using-matplotlib-and-seaborn-in-python",
    "relUrl": "/how-to-plot-interaction-effects-of-treatments/#using-matplotlib-and-seaborn-in-python"
  },"775": {
    "doc": "How to plot interaction effects of treatments",
    "title": "Using ggpubr, in R",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 . | df &lt;- ToothGrowth . | . To plot the interaction effects among tooth length, supplement, and dosage, we can use the ggline function in the ggpubr package. You can change the x and color inputs below depending on your goals, but the y input should always be the dependent variable. | 1 2 3 . | # install.packages(\"ggpubr\") # If you have not already installed it library(ggpubr) ggline(df, x=\"dose\", y=\"len\", color=\"supp\", add=c(\"mean\")) . | . | 1 . | Loading required package: ggplot2 . | . Looking at the output, we first see that there is an interaction effect because the two supp lines intersect. We also see that there is a difference in length when giving 0.5mg and 1mg dosage of either of the two delivery methods. However, there is barely any difference between the delivery methods when the dosage level is 2mg. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-plot-interaction-effects-of-treatments/#using-ggpubr-in-r",
    "relUrl": "/how-to-plot-interaction-effects-of-treatments/#using-ggpubr-in-r"
  },"776": {
    "doc": "How to plot interaction effects of treatments",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-plot-interaction-effects-of-treatments/#topics-that-include-this-task",
    "relUrl": "/how-to-plot-interaction-effects-of-treatments/#topics-that-include-this-task"
  },"777": {
    "doc": "How to plot interaction effects of treatments",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-plot-interaction-effects-of-treatments/#opportunities",
    "relUrl": "/how-to-plot-interaction-effects-of-treatments/#opportunities"
  },"778": {
    "doc": "How to predict the response variable in a linear model (in Python, using statsmodels)",
    "title": "How to predict the response variable in a linear model (in Python, using statsmodels)",
    "content": "# How to predict the response variable in a linear model (in Python, using statsmodels) [See all solutions.](../how-to-predict-the-response-variable-in-a-linear-model) ## Task If we have a linear model and a value for each explanatory variable, how do we predict the corresponding value of the response variable? Related tasks: * [How to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data) * [How to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model) ## Solution Let's assume that you've already built a linear model. We do an example below with fake data, but you can use your own actual data. For more information on the following code, see [how to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model). ```python import pandas as pd df = pd.DataFrame( { 'x1' : [ 2, 7, 4, 3, 11, 18, 6, 15, 9, 12], 'x2' : [ 4, 6, 10, 1, 18, 11, 8, 20, 16, 13], 'x3' : [11, 16, 20, 6, 14, 8, 5, 23, 13, 10], 'y' : [24, 60, 32, 29, 90, 45, 130, 76, 100, 120] } ) import statsmodels.api as sm model = sm.OLS( df['y'], sm.add_constant( df[['x1','x2','x3']] ) ).fit() ``` Let's say we want to estimate $y$ given that $x_1 = 5$, $x_2 = 12$, and $x_3=50$. We can use the model's `predict()` function as shown below, but we must add an entry for the constant term in the model---we can use any value, but we choose 1. ```python model.predict( [ 1, 5, 12, 50 ] ) ``` array([-91.71014402]) For the given values of the explanatory variables, our predicted response variable is $-91.71014402$. Note that if you want to compute the predicted values for all the data on which the model was trained, simply call `model.predict()` with no arguments, and it defaults to using the training data. ```python model.predict() ``` array([ 47.5701159 , 24.35988296, 42.21531274, 47.27613825, 110.86526185, 70.03097584, 95.12689978, 70.91290879, 106.52986696, 91.11263692]) Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to predict the response variable in a linear model/Python, using statsmodels.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-predict-the-response-variable-in-a-linear-model-in-python-using-statsmodels/",
    "relUrl": "/how-to-predict-the-response-variable-in-a-linear-model-in-python-using-statsmodels/"
  },"779": {
    "doc": "How to predict the response variable in a linear model (in R)",
    "title": "How to predict the response variable in a linear model (in R)",
    "content": "# How to predict the response variable in a linear model (in R) [See all solutions.](../how-to-predict-the-response-variable-in-a-linear-model) ## Task If we have a linear model and a value for each explanatory variable, how do we predict the corresponding value of the response variable? Related tasks: * [How to fit a linear model to two columns of data](../how-to-fit-a-linear-model-to-two-columns-of-data) * [How to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model) ## Solution Let's assume that you've already built a linear model. We do an example below with fake data, but you can use your own actual data. For more information on the following code, see [how to fit a multivariate linear model](../how-to-fit-a-multivariate-linear-model). ```R x1 <- c( 2, 7, 4, 3, 11, 18, 6, 15, 9, 12) x2 <- c( 4, 6, 10, 1, 18, 11, 8, 20, 16, 13) x3 <- c(11, 16, 20, 6, 14, 8, 5, 23, 13, 10) y <- c(24, 60, 32, 29, 90, 45, 130, 76, 100, 120) model <- lm(y ~ x1 + x2 + x3) ``` Let's say we want to estimate $y$ given that $x_1 = 5$, $x_2 = 12$, and $x_3=50$. We can use R's `predict()` function as shown below. ```R predict(model, newdata = data.frame(x1 = 5, x2 = 12, x3 = 50)) ``` 1 -91.71014 For the given values of the explanatory variables, our predicted response variable is $-91.71014$. Note that if you want to compute the predicted values for all the data on which the model was trained, simply call `predict(model)` with no new data, and it defaults to using the training data. ```R predict(model) ``` 1 2 3 4 5 6 7 8 47.57012 24.35988 42.21531 47.27614 110.86526 70.03098 95.12690 70.91291 9 10 106.52987 91.11264 Content last modified on 07 December 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to predict the response variable in a linear model/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-predict-the-response-variable-in-a-linear-model-in-r/",
    "relUrl": "/how-to-predict-the-response-variable-in-a-linear-model-in-r/"
  },"780": {
    "doc": "How to predict the response variable in a linear model",
    "title": "How to predict the response variable in a linear model",
    "content": " ",
    "url": "/how-to-predict-the-response-variable-in-a-linear-model/",
    "relUrl": "/how-to-predict-the-response-variable-in-a-linear-model/"
  },"781": {
    "doc": "How to predict the response variable in a linear model",
    "title": "Description",
    "content": "If we have a linear model and a value for each explanatory variable, how do we predict the corresponding value of the response variable? . Related tasks: . | How to fit a linear model to two columns of data | How to fit a multivariate linear model | . ",
    "url": "/how-to-predict-the-response-variable-in-a-linear-model/#description",
    "relUrl": "/how-to-predict-the-response-variable-in-a-linear-model/#description"
  },"782": {
    "doc": "How to predict the response variable in a linear model",
    "title": "Using statsmodels, in Python",
    "content": "View this solution alone. Let’s assume that you’ve already built a linear model. We do an example below with fake data, but you can use your own actual data. For more information on the following code, see how to fit a multivariate linear model. | 1 2 3 4 5 6 7 8 9 10 . | import pandas as pd df = pd.DataFrame( { 'x1' : [ 2, 7, 4, 3, 11, 18, 6, 15, 9, 12], 'x2' : [ 4, 6, 10, 1, 18, 11, 8, 20, 16, 13], 'x3' : [11, 16, 20, 6, 14, 8, 5, 23, 13, 10], 'y' : [24, 60, 32, 29, 90, 45, 130, 76, 100, 120] } ) import statsmodels.api as sm model = sm.OLS( df['y'], sm.add_constant( df[['x1','x2','x3']] ) ).fit() . | . Let’s say we want to estimate $y$ given that $x_1 = 5$, $x_2 = 12$, and $x_3=50$. We can use the model’s predict() function as shown below, but we must add an entry for the constant term in the model—we can use any value, but we choose 1. | 1 . | model.predict( [ 1, 5, 12, 50 ] ) . | . | 1 . | array([-91.71014402]) . | . For the given values of the explanatory variables, our predicted response variable is $-91.71014402$. Note that if you want to compute the predicted values for all the data on which the model was trained, simply call model.predict() with no arguments, and it defaults to using the training data. | 1 . | model.predict() . | . | 1 2 3 . | array([ 47.5701159 , 24.35988296, 42.21531274, 47.27613825, 110.86526185, 70.03097584, 95.12689978, 70.91290879, 106.52986696, 91.11263692]) . | . Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-predict-the-response-variable-in-a-linear-model/#using-statsmodels-in-python",
    "relUrl": "/how-to-predict-the-response-variable-in-a-linear-model/#using-statsmodels-in-python"
  },"783": {
    "doc": "How to predict the response variable in a linear model",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s assume that you’ve already built a linear model. We do an example below with fake data, but you can use your own actual data. For more information on the following code, see how to fit a multivariate linear model. | 1 2 3 4 5 . | x1 &lt;- c( 2, 7, 4, 3, 11, 18, 6, 15, 9, 12) x2 &lt;- c( 4, 6, 10, 1, 18, 11, 8, 20, 16, 13) x3 &lt;- c(11, 16, 20, 6, 14, 8, 5, 23, 13, 10) y &lt;- c(24, 60, 32, 29, 90, 45, 130, 76, 100, 120) model &lt;- lm(y ~ x1 + x2 + x3) . | . Let’s say we want to estimate $y$ given that $x_1 = 5$, $x_2 = 12$, and $x_3=50$. We can use R’s predict() function as shown below. | 1 . | predict(model, newdata = data.frame(x1 = 5, x2 = 12, x3 = 50)) . | . | 1 2 . | 1 -91.71014 . | . For the given values of the explanatory variables, our predicted response variable is $-91.71014$. Note that if you want to compute the predicted values for all the data on which the model was trained, simply call predict(model) with no new data, and it defaults to using the training data. | 1 . | predict(model) . | . | 1 2 3 4 . | 1 2 3 4 5 6 7 8 47.57012 24.35988 42.21531 47.27614 110.86526 70.03098 95.12690 70.91291 9 10 106.52987 91.11264 . | . Content last modified on 07 December 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-predict-the-response-variable-in-a-linear-model/#solution-in-r",
    "relUrl": "/how-to-predict-the-response-variable-in-a-linear-model/#solution-in-r"
  },"784": {
    "doc": "How to predict the response variable in a linear model",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | Bentley University MA252 | . ",
    "url": "/how-to-predict-the-response-variable-in-a-linear-model/#topics-that-include-this-task",
    "relUrl": "/how-to-predict-the-response-variable-in-a-linear-model/#topics-that-include-this-task"
  },"785": {
    "doc": "How to predict the response variable in a linear model",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-predict-the-response-variable-in-a-linear-model/#opportunities",
    "relUrl": "/how-to-predict-the-response-variable-in-a-linear-model/#opportunities"
  },"786": {
    "doc": "How to quickly load some sample data (in Julia)",
    "title": "How to quickly load some sample data (in Julia)",
    "content": "# How to quickly load some sample data (in Julia) [See all solutions.](../how-to-quickly-load-some-sample-data) ## Task Sometimes you just need to try out a new piece of code, whether it be data manipulation, statistical computation, plotting, or whatever. And it's handy to be able to quickly load some example data to work with. There is a lot of freely available sample data out there. What's the easiest way to load it? ## Solution The R programming language comes with many free datasets built in. To make these same datasets available to Julia programmers as well, you can install and import the `RDatasets` package. First, ensure that you have it installed, by running the Julia commands `using Pkg` and then `Pkg.add( \"RDatasets\" )`. Then you can get access to many datasets as follows: ```julia using RDatasets iris = dataset( \"datasets\", \"iris\" ) first( iris, 5 ) # just show the first 5 rows ``` 5×5 DataFrame | Row | SepalLength | SepalWidth | PetalLength | PetalWidth | Species | . | | Float64 | Float64 | Float64 | Float64 | Cat… | . | 1 | 5.1 | 3.5 | 1.4 | 0.2 | setosa | . | 2 | 4.9 | 3.0 | 1.4 | 0.2 | setosa | . | 3 | 4.7 | 3.2 | 1.3 | 0.2 | setosa | . | 4 | 4.6 | 3.1 | 1.5 | 0.2 | setosa | . | 5 | 5.0 | 3.6 | 1.4 | 0.2 | setosa | . But what datasets are available? There are many! You can find a full list in the package itself. ```julia RDatasets.packages() ``` 34×2 DataFrame9 rows omitted | Row | Package | Title | . | | String15 | String | . | 1 | COUNT | Functions, data and code for count data. | . | 2 | Ecdat | Data sets for econometrics | . | 3 | HSAUR | A Handbook of Statistical Analyses Using R (1st Edition) | . | 4 | HistData | Data sets from the history of statistics and data visualization | . | 5 | ISLR | Data for An Introduction to Statistical Learning with Applications in R | . | 6 | KMsurv | Data sets from Klein and Moeschberger (1997), Survival Analysis | . | 7 | MASS | Support Functions and Datasets for Venables and Ripley&apos;s MASS | . | 8 | SASmixed | Data sets from &quot;SAS System for Mixed Models&quot; | . | 9 | Zelig | Everyone&apos;s Statistical Software | . | 10 | adehabitatLT | Analysis of Animal Movements | . | 11 | boot | Bootstrap Functions (Originally by Angelo Canty for S) | . | 12 | car | Companion to Applied Regression | . | 13 | cluster | Cluster Analysis Extended Rousseeuw et al. | . | &vellip; | &vellip; | &vellip; | . | 23 | plm | Linear Models for Panel Data | . | 24 | plyr | Tools for splitting, applying and combining data | . | 25 | pscl | Political Science Computational Laboratory, Stanford University | . | 26 | psych | Procedures for Psychological, Psychometric, and Personality Research | . | 27 | quantreg | Quantile Regression | . | 28 | reshape2 | Flexibly Reshape Data: A Reboot of the Reshape Package. | . | 29 | robustbase | Basic Robust Statistics | . | 30 | rpart | Recursive Partitioning and Regression Trees | . | 31 | sandwich | Robust Covariance Matrix Estimators | . | 32 | sem | Structural Equation Models | . | 33 | survival | Survival Analysis | . | 34 | vcd | Visualizing Categorical Data | . Content last modified on 04 November 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to quickly load some sample data/Julia.md). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-quickly-load-some-sample-data-in-julia/",
    "relUrl": "/how-to-quickly-load-some-sample-data-in-julia/"
  },"787": {
    "doc": "How to quickly load some sample data (in Python)",
    "title": "How to quickly load some sample data (in Python)",
    "content": "# How to quickly load some sample data (in Python) [See all solutions.](../how-to-quickly-load-some-sample-data) ## Task Sometimes you just need to try out a new piece of code, whether it be data manipulation, statistical computation, plotting, or whatever. And it's handy to be able to quickly load some example data to work with. There is a lot of freely available sample data out there. What's the easiest way to load it? ## Solution The R programming language comes with many free datasets built in. To make these same datasets available to Python programmers as well, you can install and import the `rdatasets` package. First, ensure that you have it installed, by running `pip install rdatasets` or `conda install rdatasets` from your command line. Then you can get access to many datasets as follows: ```python from rdatasets import data df = data( 'iris' ) # Load the famous Fisher's irises dataset df.head() ``` | | Sepal.Length | Sepal.Width | Petal.Length | Petal.Width | Species | . | 0 | 5.1 | 3.5 | 1.4 | 0.2 | setosa | . | 1 | 4.9 | 3.0 | 1.4 | 0.2 | setosa | . | 2 | 4.7 | 3.2 | 1.3 | 0.2 | setosa | . | 3 | 4.6 | 3.1 | 1.5 | 0.2 | setosa | . | 4 | 5.0 | 3.6 | 1.4 | 0.2 | setosa | . But what datasets are available? There are many! You can find a full list in the package itself. ```python from rdatasets import summary summary() ``` | | Package | Item | Title | Rows | Cols | n_binary | n_character | n_factor | n_logical | n_numeric | CSV | Doc | . | 0 | boot | acme | Monthly Excess Returns | 60 | 3 | 0 | 1 | 0 | 0 | 2 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1 | boot | aids | Delay in AIDS Reporting in England and Wales | 570 | 6 | 1 | 0 | 0 | 0 | 6 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 2 | boot | aircondit | Failures of Air-conditioning Equipment | 12 | 1 | 0 | 0 | 0 | 0 | 1 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 3 | boot | aircondit7 | Failures of Air-conditioning Equipment | 24 | 1 | 0 | 0 | 0 | 0 | 1 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 4 | boot | amis | Car Speeding and Warning Signs | 8437 | 4 | 1 | 0 | 0 | 0 | 4 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . | 1340 | Zelig | tobin | Tobin's Tobit Data | 20 | 3 | 0 | 0 | 0 | 0 | 3 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1341 | Zelig | turnout | Turnout Data Set from the National Election Su... | 2000 | 5 | 2 | 0 | 1 | 0 | 4 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1342 | Zelig | voteincome | Sample Turnout and Demographic Data from the 2... | 1500 | 7 | 3 | 0 | 1 | 0 | 6 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1343 | Zelig | Weimar | 1932 Weimar election data | 10 | 11 | 0 | 0 | 0 | 0 | 11 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1344 | Zelig | Zelig.url | Table of links for Zelig | 49 | 2 | 0 | 0 | 2 | 0 | 0 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . 1345 rows × 12 columns . Content last modified on 26 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to quickly load some sample data/Python.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-quickly-load-some-sample-data-in-python/",
    "relUrl": "/how-to-quickly-load-some-sample-data-in-python/"
  },"788": {
    "doc": "How to quickly load some sample data (in R)",
    "title": "How to quickly load some sample data (in R)",
    "content": "# How to quickly load some sample data (in R) [See all solutions.](../how-to-quickly-load-some-sample-data) ## Task Sometimes you just need to try out a new piece of code, whether it be data manipulation, statistical computation, plotting, or whatever. And it's handy to be able to quickly load some example data to work with. There is a lot of freely available sample data out there. What's the easiest way to load it? ## Solution R comes with many datasets in its `datasets` package. Ensure that you have it installed as follows. ```R library(datasets) ``` Then you can load any one of them with the `data` function, as follows. ```R data(iris) # Load the famous Fisher's irises dataset. head(iris) # It has been placed in a variable of the same name. ``` Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa To page through a list of all available datasets, just call `data()` with no arguments. Content last modified on 26 July 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to quickly load some sample data/R.Rmd). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-quickly-load-some-sample-data-in-r/",
    "relUrl": "/how-to-quickly-load-some-sample-data-in-r/"
  },"789": {
    "doc": "How to quickly load some sample data",
    "title": "How to quickly load some sample data",
    "content": " ",
    "url": "/how-to-quickly-load-some-sample-data/",
    "relUrl": "/how-to-quickly-load-some-sample-data/"
  },"790": {
    "doc": "How to quickly load some sample data",
    "title": "Description",
    "content": "Sometimes you just need to try out a new piece of code, whether it be data manipulation, statistical computation, plotting, or whatever. And it’s handy to be able to quickly load some example data to work with. There is a lot of freely available sample data out there. What’s the easiest way to load it? . ",
    "url": "/how-to-quickly-load-some-sample-data/#description",
    "relUrl": "/how-to-quickly-load-some-sample-data/#description"
  },"791": {
    "doc": "How to quickly load some sample data",
    "title": "Solution, in Julia",
    "content": "View this solution alone. The R programming language comes with many free datasets built in. To make these same datasets available to Julia programmers as well, you can install and import the RDatasets package. First, ensure that you have it installed, by running the Julia commands using Pkg and then Pkg.add( \"RDatasets\" ). Then you can get access to many datasets as follows: . | 1 2 3 . | using RDatasets iris = dataset( \"datasets\", \"iris\" ) first( iris, 5 ) # just show the first 5 rows . | . 5×5 DataFrame | Row | SepalLength | SepalWidth | PetalLength | PetalWidth | Species | . | | Float64 | Float64 | Float64 | Float64 | Cat… | . | 1 | 5.1 | 3.5 | 1.4 | 0.2 | setosa | . | 2 | 4.9 | 3.0 | 1.4 | 0.2 | setosa | . | 3 | 4.7 | 3.2 | 1.3 | 0.2 | setosa | . | 4 | 4.6 | 3.1 | 1.5 | 0.2 | setosa | . | 5 | 5.0 | 3.6 | 1.4 | 0.2 | setosa | . But what datasets are available? There are many! You can find a full list in the package itself. | 1 . | RDatasets.packages() . | . 34×2 DataFrame9 rows omitted | Row | Package | Title | . | | String15 | String | . | 1 | COUNT | Functions, data and code for count data. | . | 2 | Ecdat | Data sets for econometrics | . | 3 | HSAUR | A Handbook of Statistical Analyses Using R (1st Edition) | . | 4 | HistData | Data sets from the history of statistics and data visualization | . | 5 | ISLR | Data for An Introduction to Statistical Learning with Applications in R | . | 6 | KMsurv | Data sets from Klein and Moeschberger (1997), Survival Analysis | . | 7 | MASS | Support Functions and Datasets for Venables and Ripley&apos;s MASS | . | 8 | SASmixed | Data sets from &quot;SAS System for Mixed Models&quot; | . | 9 | Zelig | Everyone&apos;s Statistical Software | . | 10 | adehabitatLT | Analysis of Animal Movements | . | 11 | boot | Bootstrap Functions (Originally by Angelo Canty for S) | . | 12 | car | Companion to Applied Regression | . | 13 | cluster | Cluster Analysis Extended Rousseeuw et al. | . | &vellip; | &vellip; | &vellip; | . | 23 | plm | Linear Models for Panel Data | . | 24 | plyr | Tools for splitting, applying and combining data | . | 25 | pscl | Political Science Computational Laboratory, Stanford University | . | 26 | psych | Procedures for Psychological, Psychometric, and Personality Research | . | 27 | quantreg | Quantile Regression | . | 28 | reshape2 | Flexibly Reshape Data: A Reboot of the Reshape Package. | . | 29 | robustbase | Basic Robust Statistics | . | 30 | rpart | Recursive Partitioning and Regression Trees | . | 31 | sandwich | Robust Covariance Matrix Estimators | . | 32 | sem | Structural Equation Models | . | 33 | survival | Survival Analysis | . | 34 | vcd | Visualizing Categorical Data | . Content last modified on 04 November 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-quickly-load-some-sample-data/#solution-in-julia",
    "relUrl": "/how-to-quickly-load-some-sample-data/#solution-in-julia"
  },"792": {
    "doc": "How to quickly load some sample data",
    "title": "Solution, in Python",
    "content": "View this solution alone. The R programming language comes with many free datasets built in. To make these same datasets available to Python programmers as well, you can install and import the rdatasets package. First, ensure that you have it installed, by running pip install rdatasets or conda install rdatasets from your command line. Then you can get access to many datasets as follows: . | 1 2 3 . | from rdatasets import data df = data( 'iris' ) # Load the famous Fisher's irises dataset df.head() . | . | | Sepal.Length | Sepal.Width | Petal.Length | Petal.Width | Species | . | 0 | 5.1 | 3.5 | 1.4 | 0.2 | setosa | . | 1 | 4.9 | 3.0 | 1.4 | 0.2 | setosa | . | 2 | 4.7 | 3.2 | 1.3 | 0.2 | setosa | . | 3 | 4.6 | 3.1 | 1.5 | 0.2 | setosa | . | 4 | 5.0 | 3.6 | 1.4 | 0.2 | setosa | . But what datasets are available? There are many! You can find a full list in the package itself. | 1 2 . | from rdatasets import summary summary() . | . | | Package | Item | Title | Rows | Cols | n_binary | n_character | n_factor | n_logical | n_numeric | CSV | Doc | . | 0 | boot | acme | Monthly Excess Returns | 60 | 3 | 0 | 1 | 0 | 0 | 2 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1 | boot | aids | Delay in AIDS Reporting in England and Wales | 570 | 6 | 1 | 0 | 0 | 0 | 6 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 2 | boot | aircondit | Failures of Air-conditioning Equipment | 12 | 1 | 0 | 0 | 0 | 0 | 1 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 3 | boot | aircondit7 | Failures of Air-conditioning Equipment | 24 | 1 | 0 | 0 | 0 | 0 | 1 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 4 | boot | amis | Car Speeding and Warning Signs | 8437 | 4 | 1 | 0 | 0 | 0 | 4 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . | 1340 | Zelig | tobin | Tobin's Tobit Data | 20 | 3 | 0 | 0 | 0 | 0 | 3 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1341 | Zelig | turnout | Turnout Data Set from the National Election Su... | 2000 | 5 | 2 | 0 | 1 | 0 | 4 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1342 | Zelig | voteincome | Sample Turnout and Demographic Data from the 2... | 1500 | 7 | 3 | 0 | 1 | 0 | 6 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1343 | Zelig | Weimar | 1932 Weimar election data | 10 | 11 | 0 | 0 | 0 | 0 | 11 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . | 1344 | Zelig | Zelig.url | Table of links for Zelig | 49 | 2 | 0 | 0 | 2 | 0 | 0 | https://raw.github.com/vincentarelbundock/Rdat... | https://raw.github.com/vincentarelbundock/Rdat... | . 1345 rows × 12 columns . Content last modified on 26 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-quickly-load-some-sample-data/#solution-in-python",
    "relUrl": "/how-to-quickly-load-some-sample-data/#solution-in-python"
  },"793": {
    "doc": "How to quickly load some sample data",
    "title": "Solution, in R",
    "content": "View this solution alone. R comes with many datasets in its datasets package. Ensure that you have it installed as follows. | 1 . | library(datasets) . | . Then you can load any one of them with the data function, as follows. | 1 2 . | data(iris) # Load the famous Fisher's irises dataset. head(iris) # It has been placed in a variable of the same name. | . | 1 2 3 4 5 6 7 . | Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa . | . To page through a list of all available datasets, just call data() with no arguments. Content last modified on 26 July 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-quickly-load-some-sample-data/#solution-in-r",
    "relUrl": "/how-to-quickly-load-some-sample-data/#solution-in-r"
  },"794": {
    "doc": "How to quickly load some sample data",
    "title": "Topics that include this task",
    "content": ". | Bentley University GB213 | Bentley University GR521 | Bentley University MA346 | . ",
    "url": "/how-to-quickly-load-some-sample-data/#topics-that-include-this-task",
    "relUrl": "/how-to-quickly-load-some-sample-data/#topics-that-include-this-task"
  },"795": {
    "doc": "How to quickly load some sample data",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-quickly-load-some-sample-data/#opportunities",
    "relUrl": "/how-to-quickly-load-some-sample-data/#opportunities"
  },"796": {
    "doc": "How to solve an ordinary differential equation (in Python, using SymPy)",
    "title": "How to solve an ordinary differential equation (in Python, using SymPy)",
    "content": "# How to solve an ordinary differential equation (in Python, using SymPy) [See all solutions.](../how-to-solve-an-ordinary-differential-equation) ## Task Elsewhere we've seen [how to write an ordinary differential equation](../how-to-write-an-ordinary-differential-equation). Once one is written, how can we ask software to solve it? And since ODEs often come with initial conditions that impact the solution, how can we include those as well? ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's re-use here the code from [how to write an ordinary differential equation](../how-to-write-an-ordinary-differential-equation), to write $\\frac{dy}{dx}=y$. ```python var( 'x' ) y = Function('y')(x) dydx = Derivative( y, x ) ode = dydx - y ode ``` $\\displaystyle - y{\\left(x \\right)} + \\frac{d}{d x} y{\\left(x \\right)}$ You can solve an ODE by using the `dsolve` command. ```python solution = dsolve( ode ) solution ``` $\\displaystyle y{\\left(x \\right)} = C_{1} e^{x}$ If there are initial conditions that need to be substituted in for $x$ and $y$, it is crucial to substitute for $y$ first and then $x$. Let's assume we have the initial condition $(3,5)$. We might proceed as follows. ```python with_inits = solution.subs( y, 5 ).subs( x, 3 ) with_inits ``` $\\displaystyle 5 = C_{1} e^{3}$ ```python solve( with_inits ) ``` $\\displaystyle \\left[ \\frac{5}{e^{3}}\\right]$ To substitute $C_1=\\frac{5}{e^3}$ into the solution, note that $C_1$ is written as `var('C1')`. ```python solution.subs( var('C1'), 5/E**3 ) ``` $\\displaystyle y{\\left(x \\right)} = \\frac{5 e^{x}}{e^{3}}$ Content last modified on 02 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to solve an ordinary differential equation/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-solve-an-ordinary-differential-equation-in-python-using-sympy/",
    "relUrl": "/how-to-solve-an-ordinary-differential-equation-in-python-using-sympy/"
  },"797": {
    "doc": "How to solve an ordinary differential equation",
    "title": "How to solve an ordinary differential equation",
    "content": " ",
    "url": "/how-to-solve-an-ordinary-differential-equation/",
    "relUrl": "/how-to-solve-an-ordinary-differential-equation/"
  },"798": {
    "doc": "How to solve an ordinary differential equation",
    "title": "Description",
    "content": "Elsewhere we’ve seen how to write an ordinary differential equation. Once one is written, how can we ask software to solve it? And since ODEs often come with initial conditions that impact the solution, how can we include those as well? . ",
    "url": "/how-to-solve-an-ordinary-differential-equation/#description",
    "relUrl": "/how-to-solve-an-ordinary-differential-equation/#description"
  },"799": {
    "doc": "How to solve an ordinary differential equation",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s re-use here the code from how to write an ordinary differential equation, to write $\\frac{dy}{dx}=y$. | 1 2 3 4 5 . | var( 'x' ) y = Function('y')(x) dydx = Derivative( y, x ) ode = dydx - y ode . | . $\\displaystyle - y{\\left(x \\right)} + \\frac{d}{d x} y{\\left(x \\right)}$ . You can solve an ODE by using the dsolve command. | 1 2 . | solution = dsolve( ode ) solution . | . $\\displaystyle y{\\left(x \\right)} = C_{1} e^{x}$ . If there are initial conditions that need to be substituted in for $x$ and $y$, it is crucial to substitute for $y$ first and then $x$. Let’s assume we have the initial condition $(3,5)$. We might proceed as follows. | 1 2 . | with_inits = solution.subs( y, 5 ).subs( x, 3 ) with_inits . | . $\\displaystyle 5 = C_{1} e^{3}$ . | 1 . | solve( with_inits ) . | . $\\displaystyle \\left[ \\frac{5}{e^{3}}\\right]$ . To substitute $C_1=\\frac{5}{e^3}$ into the solution, note that $C_1$ is written as var('C1'). | 1 . | solution.subs( var('C1'), 5/E**3 ) . | . $\\displaystyle y{\\left(x \\right)} = \\frac{5 e^{x}}{e^{3}}$ . Content last modified on 02 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-solve-an-ordinary-differential-equation/#using-sympy-in-python",
    "relUrl": "/how-to-solve-an-ordinary-differential-equation/#using-sympy-in-python"
  },"800": {
    "doc": "How to solve an ordinary differential equation",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-solve-an-ordinary-differential-equation/#topics-that-include-this-task",
    "relUrl": "/how-to-solve-an-ordinary-differential-equation/#topics-that-include-this-task"
  },"801": {
    "doc": "How to solve an ordinary differential equation",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-solve-an-ordinary-differential-equation/#opportunities",
    "relUrl": "/how-to-solve-an-ordinary-differential-equation/#opportunities"
  },"802": {
    "doc": "How to solve symbolic equations (in Python, using SymPy)",
    "title": "How to solve symbolic equations (in Python, using SymPy)",
    "content": "# How to solve symbolic equations (in Python, using SymPy) [See all solutions.](../how-to-solve-symbolic-equations) ## Task Once we've expressed an equation or system of equations using the technique from [how to write symbolic equations](../how-to-write-symbolic-equations), we often want the software to solve the equation or system of equations for us. Related tasks: * [How to isolate one variable in an equation](../how-to-isolate-one-variable-in-an-equation) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` If your equation has just one variable, simply call `solve` on it. Note that you may get a list of more than one solution. ```python var( 'x' ) equation = Eq( x**2 + 3*x, -x + 9 ) solve( equation ) ``` $\\displaystyle \\left[ -2 + \\sqrt{13}, \\ - \\sqrt{13} - 2\\right]$ Sometimes you get no solutions, which is shown as a Python empty list. ```python solve( Eq( x+1, x+2 ) ) ``` $\\displaystyle \\left[ \\right]$ Sometimes the answers include complex numbers. ```python solve( Eq( x**3, -1 ) ) ``` $\\displaystyle \\left[ -1, \\ \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}, \\ \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right]$ To restrict the solution to the real numbers, use `solveset` instead, and specify the real numbers as the domain. ```python solveset( Eq( x**3, -1 ), domain=S.Reals ) ``` $\\displaystyle \\left\\\\{-1\\right\\\\}$ You can solve systems of equations by calling `solve` on them. ```python var( 'x y' ) system = [ Eq( x + 2*y, 1 ), Eq( x - 9*y, 5 ) ] solve( system ) ``` $\\displaystyle \\left\\\\{ x : \\frac{19}{11}, \\ y : - \\frac{4}{11}\\right\\\\}$ Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to solve symbolic equations/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-solve-symbolic-equations-in-python-using-sympy/",
    "relUrl": "/how-to-solve-symbolic-equations-in-python-using-sympy/"
  },"803": {
    "doc": "How to solve symbolic equations",
    "title": "How to solve symbolic equations",
    "content": " ",
    "url": "/how-to-solve-symbolic-equations/",
    "relUrl": "/how-to-solve-symbolic-equations/"
  },"804": {
    "doc": "How to solve symbolic equations",
    "title": "Description",
    "content": "Once we’ve expressed an equation or system of equations using the technique from how to write symbolic equations, we often want the software to solve the equation or system of equations for us. Related tasks: . | How to isolate one variable in an equation | . ",
    "url": "/how-to-solve-symbolic-equations/#description",
    "relUrl": "/how-to-solve-symbolic-equations/#description"
  },"805": {
    "doc": "How to solve symbolic equations",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . If your equation has just one variable, simply call solve on it. Note that you may get a list of more than one solution. | 1 2 3 . | var( 'x' ) equation = Eq( x**2 + 3*x, -x + 9 ) solve( equation ) . | . $\\displaystyle \\left[ -2 + \\sqrt{13}, \\ - \\sqrt{13} - 2\\right]$ . Sometimes you get no solutions, which is shown as a Python empty list. | 1 . | solve( Eq( x+1, x+2 ) ) . | . $\\displaystyle \\left[ \\right]$ . Sometimes the answers include complex numbers. | 1 . | solve( Eq( x**3, -1 ) ) . | . $\\displaystyle \\left[ -1, \\ \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}, \\ \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right]$ . To restrict the solution to the real numbers, use solveset instead, and specify the real numbers as the domain. | 1 . | solveset( Eq( x**3, -1 ), domain=S.Reals ) . | . $\\displaystyle \\left\\{-1\\right\\}$ . You can solve systems of equations by calling solve on them. | 1 2 3 4 5 6 . | var( 'x y' ) system = [ Eq( x + 2*y, 1 ), Eq( x - 9*y, 5 ) ] solve( system ) . | . $\\displaystyle \\left\\{ x : \\frac{19}{11}, \\ y : - \\frac{4}{11}\\right\\}$ . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-solve-symbolic-equations/#using-sympy-in-python",
    "relUrl": "/how-to-solve-symbolic-equations/#using-sympy-in-python"
  },"806": {
    "doc": "How to solve symbolic equations",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-solve-symbolic-equations/#topics-that-include-this-task",
    "relUrl": "/how-to-solve-symbolic-equations/#topics-that-include-this-task"
  },"807": {
    "doc": "How to solve symbolic equations",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-solve-symbolic-equations/#opportunities",
    "relUrl": "/how-to-solve-symbolic-equations/#opportunities"
  },"808": {
    "doc": "How to substitute a value for a symbolic variable (in Python, using SymPy)",
    "title": "How to substitute a value for a symbolic variable (in Python, using SymPy)",
    "content": "# How to substitute a value for a symbolic variable (in Python, using SymPy) [See all solutions.](../how-to-substitute-a-value-for-a-symbolic-variable) ## Task If we've defined a symbolic variable and used it in a formula, how can we substitute a value in for it, to evaluate the formula? This is often informally called \"plugging in\" a value. Related tasks: * [How to create symbolic variables](../how-to-create-symbolic-variables) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's assume we've defined a variable and created a formula, as covered in [how to create symbolic variables](../how-to-create-symbolic-variables). ```python var( 'x' ) formula = x**2 + x formula ``` $\\displaystyle x^{2} + x$ We can substitute a value for $x$ using the `subs` function. You provide the variable and the value to substitute. ```python formula.subs( x, 8 ) # computes 8**2 + 8 ``` $\\displaystyle 72$ If you had to substitute values for multiple variables, you can use multiple `subs` calls or you can pass a dictionary to `subs`. ```python var( 'y' ) formula = x/2 + y/3 formula ``` $\\displaystyle \\frac{x}{2} + \\frac{y}{3}$ ```python formula.subs( x, 10 ).subs( y, 6 ) ``` $\\displaystyle 7$ ```python formula.subs( { x: 10, y: 6 } ) ``` $\\displaystyle 7$ Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to substitute a value for a symbolic variable/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-substitute-a-value-for-a-symbolic-variable-in-python-using-sympy/",
    "relUrl": "/how-to-substitute-a-value-for-a-symbolic-variable-in-python-using-sympy/"
  },"809": {
    "doc": "How to substitute a value for a symbolic variable",
    "title": "How to substitute a value for a symbolic variable",
    "content": " ",
    "url": "/how-to-substitute-a-value-for-a-symbolic-variable/",
    "relUrl": "/how-to-substitute-a-value-for-a-symbolic-variable/"
  },"810": {
    "doc": "How to substitute a value for a symbolic variable",
    "title": "Description",
    "content": "If we’ve defined a symbolic variable and used it in a formula, how can we substitute a value in for it, to evaluate the formula? This is often informally called “plugging in” a value. Related tasks: . | How to create symbolic variables | . ",
    "url": "/how-to-substitute-a-value-for-a-symbolic-variable/#description",
    "relUrl": "/how-to-substitute-a-value-for-a-symbolic-variable/#description"
  },"811": {
    "doc": "How to substitute a value for a symbolic variable",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s assume we’ve defined a variable and created a formula, as covered in how to create symbolic variables. | 1 2 3 . | var( 'x' ) formula = x**2 + x formula . | . $\\displaystyle x^{2} + x$ . We can substitute a value for $x$ using the subs function. You provide the variable and the value to substitute. | 1 . | formula.subs( x, 8 ) # computes 8**2 + 8 . | . $\\displaystyle 72$ . If you had to substitute values for multiple variables, you can use multiple subs calls or you can pass a dictionary to subs. | 1 2 3 . | var( 'y' ) formula = x/2 + y/3 formula . | . $\\displaystyle \\frac{x}{2} + \\frac{y}{3}$ . | 1 . | formula.subs( x, 10 ).subs( y, 6 ) . | . $\\displaystyle 7$ . | 1 . | formula.subs( { x: 10, y: 6 } ) . | . $\\displaystyle 7$ . Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-substitute-a-value-for-a-symbolic-variable/#using-sympy-in-python",
    "relUrl": "/how-to-substitute-a-value-for-a-symbolic-variable/#using-sympy-in-python"
  },"812": {
    "doc": "How to substitute a value for a symbolic variable",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-substitute-a-value-for-a-symbolic-variable/#topics-that-include-this-task",
    "relUrl": "/how-to-substitute-a-value-for-a-symbolic-variable/#topics-that-include-this-task"
  },"813": {
    "doc": "How to substitute a value for a symbolic variable",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-substitute-a-value-for-a-symbolic-variable/#opportunities",
    "relUrl": "/how-to-substitute-a-value-for-a-symbolic-variable/#opportunities"
  },"814": {
    "doc": "How to summarize a column (in Excel)",
    "title": "How to summarize a column (in Excel)",
    "content": "# How to summarize a column (in Excel) [See all solutions.](../how-to-summarize-a-column) ## Task When provided with a dataset in which you want to focus on one column, how would you compute descriptive statistics for that column? Related task: * [How to compute summary statistics](../how-to-compute-summary-statistics) * [How to summarize and compare data by groups](../how-to-summarize-and-compare-data-by-groups) ## Solution Let’s assume you have some data in a single column of an Excel workbook. We show the first 10 rows (out of 27) for some example data below, but we assume you are applying what we cover here to your own real data. To compute descriptive statistics, you will need the Data Analysis Toolpak. If you’ve never enabled it before, see [these instructions from Microsoft](https://support.microsoft.com/en-us/office/load-the-analysis-toolpak-in-excel-6a63e598-cd6d-42e3-9317-6b40ba1a66b4#OfficeVersion=Windows) on how to do so. On the Data tab, click the Data Analysis button, shown below. From the list of tools it provides, choose Descriptive Statistics, as shown below, then click OK. Highlight all the cells in your column as input (excluding the column header, if any), then check the “Summary statistics” checkbox, as shown below. Then click OK. Excel will create a new sheet that reports your column’s mean, median, variance, and more, as shown below. To get a report of the unique values in your column and the frequency of each, you can use a pivot table. Highlight your column of data, then on the Insert tab, choose Pivot Table, as shown below. Drag your column’s name from the list of pivot table fields down into both the Rows and Values areas, as shown below. From the drop-down under Values, choose “Value field settings…” and change Sum to Count, as shown below. Then click OK. Your pivot table will now contain the desired report. The first few rows with our example data look like the following. Most data points appear only once, but 6 appears twice and 34 appears three times. Content last modified on 21 June 2022. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to summarize a column/Excel.docx). ",
    "url": "/how-to-summarize-a-column-in-excel/",
    "relUrl": "/how-to-summarize-a-column-in-excel/"
  },"815": {
    "doc": "How to summarize a column (in Python)",
    "title": "How to summarize a column (in Python)",
    "content": "# How to summarize a column (in Python) [See all solutions.](../how-to-summarize-a-column) ## Task When provided with a dataset in which you want to focus on one column, how would you compute descriptive statistics for that column? Related task: * [How to compute summary statistics](../how-to-compute-summary-statistics) * [How to summarize and compare data by groups](../how-to-summarize-and-compare-data-by-groups) ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data('ToothGrowth') ``` Let us consider qualitative and quantitative variables separately. Consider the qualitative column \"supp\" in the dataset (which type of supplement the animal received). To count the distribution of each categorical value, use `value_counts()`: ```python df['supp'].value_counts() # Or use df['supp'].value_counts(normalize = True) for proportions instead. ``` VC 30 OJ 30 Name: supp, dtype: int64 The output says that there are 30 observations under each of the two levels, Orange Juice and Ascorbic Acid. If you wish to jointly summarize two categorical columns, provide both to `value_counts()`: ```python df[['supp','dose']].value_counts() ``` supp dose OJ 0.5 10 1.0 10 2.0 10 VC 0.5 10 1.0 10 2.0 10 dtype: int64 This informs us that there are 10 observations for each of the combinations. Now consider the quantitative column `len` in the dataset (the length of the animal's tooth). We can compute summary statistics for it just as we can for a whole dataframe (as we cover in [how to compute summary statistics](../how-to-compute-summary-statistics)). ```python df['len'].describe() # Summary statistics ``` count 60.000000 mean 18.813333 std 7.649315 min 4.200000 25% 13.075000 50% 19.250000 75% 25.275000 max 33.900000 Name: len, dtype: float64 The individual functions for mean, standard deviation, etc. covered under \"[how to compute summary statistics](../how-to-compute-summary-statistics)\" apply to individual columns as well. For example, we can compute quantiles: ```python df['len'].quantile([0.25,0.5,0.75]) # These chosen values give quartiles. ``` 0.25 13.075 0.50 19.250 0.75 25.275 Name: len, dtype: float64 Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to summarize a column/Python.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-summarize-a-column-in-python/",
    "relUrl": "/how-to-summarize-a-column-in-python/"
  },"816": {
    "doc": "How to summarize a column (in R)",
    "title": "How to summarize a column (in R)",
    "content": "# How to summarize a column (in R) [See all solutions.](../how-to-summarize-a-column) ## Task When provided with a dataset in which you want to focus on one column, how would you compute descriptive statistics for that column? Related task: * [How to compute summary statistics](../how-to-compute-summary-statistics) * [How to summarize and compare data by groups](../how-to-summarize-and-compare-data-by-groups) ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R df <- ToothGrowth ``` Let us consider qualitative and quantitative variables separately. Consider the qualitative column \"supp\" in the dataset (which type of supplement the animal received). To count the distribution of each categorical value, use `table()`: ```R table(df$supp) # OR summary(df$supp) ``` OJ VC 30 30 The output says that there are 30 observations under each of the two levels, Orange Juice and Ascorbic Acid. If you wish to jointly summarize two categorical columns, provide both to `table()`: ```R table(df$supp, df$dose) ``` 0.5 1 2 OJ 10 10 10 VC 10 10 10 This informs us that there are 10 observations for each of the combinations. Note: If there are more than 2 categorical variables of interest, you can use `ftable()` instead. Now consider the quantitative column `len` in the dataset (the length of the animal's tooth). We can compute summary statistics for it just as we can for a whole dataframe (as we cover in [how to compute summary statistics](../how-to-compute-summary-statistics)). ```R summary(df$len) ``` Min. 1st Qu. Median Mean 3rd Qu. Max. 4.20 13.07 19.25 18.81 25.27 33.90 The individual functions for mean, standard deviation, etc. covered under \"[how to compute summary statistics](../how-to-compute-summary-statistics)\" apply to individual columns as well. For example, we can compute quantiles: ```R quantile(df$len) # quantiles ``` 0% 25% 50% 75% 100% 4.200 13.075 19.250 25.275 33.900 Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to summarize a column/R.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-summarize-a-column-in-r/",
    "relUrl": "/how-to-summarize-a-column-in-r/"
  },"817": {
    "doc": "How to summarize a column",
    "title": "How to summarize a column",
    "content": " ",
    "url": "/how-to-summarize-a-column/",
    "relUrl": "/how-to-summarize-a-column/"
  },"818": {
    "doc": "How to summarize a column",
    "title": "Description",
    "content": "When provided with a dataset in which you want to focus on one column, how would you compute descriptive statistics for that column? . Related task: . | How to compute summary statistics | How to summarize and compare data by groups | . ",
    "url": "/how-to-summarize-a-column/#description",
    "relUrl": "/how-to-summarize-a-column/#description"
  },"819": {
    "doc": "How to summarize a column",
    "title": "Solution, in Excel",
    "content": "View this solution alone. Let’s assume you have some data in a single column of an Excel workbook. We show the first 10 rows (out of 27) for some example data below, but we assume you are applying what we cover here to your own real data. To compute descriptive statistics, you will need the Data Analysis Toolpak. If you’ve never enabled it before, see these instructions from Microsoft on how to do so. On the Data tab, click the Data Analysis button, shown below. From the list of tools it provides, choose Descriptive Statistics, as shown below, then click OK. Highlight all the cells in your column as input (excluding the column header, if any), then check the “Summary statistics” checkbox, as shown below. Then click OK. Excel will create a new sheet that reports your column’s mean, median, variance, and more, as shown below. To get a report of the unique values in your column and the frequency of each, you can use a pivot table. Highlight your column of data, then on the Insert tab, choose Pivot Table, as shown below. Drag your column’s name from the list of pivot table fields down into both the Rows and Values areas, as shown below. From the drop-down under Values, choose “Value field settings…” and change Sum to Count, as shown below. Then click OK. Your pivot table will now contain the desired report. The first few rows with our example data look like the following. Most data points appear only once, but 6 appears twice and 34 appears three times. Content last modified on 21 June 2022. See a problem? Tell us or edit the source. ",
    "url": "/how-to-summarize-a-column/#solution-in-excel",
    "relUrl": "/how-to-summarize-a-column/#solution-in-excel"
  },"820": {
    "doc": "How to summarize a column",
    "title": "Solution, in Python",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 2 . | from rdatasets import data df = data('ToothGrowth') . | . Let us consider qualitative and quantitative variables separately. Consider the qualitative column “supp” in the dataset (which type of supplement the animal received). To count the distribution of each categorical value, use value_counts(): . | 1 2 . | df['supp'].value_counts() # Or use df['supp'].value_counts(normalize = True) for proportions instead. | . | 1 2 3 . | VC 30 OJ 30 Name: supp, dtype: int64 . | . The output says that there are 30 observations under each of the two levels, Orange Juice and Ascorbic Acid. If you wish to jointly summarize two categorical columns, provide both to value_counts(): . | 1 . | df[['supp','dose']].value_counts() . | . | 1 2 3 4 5 6 7 8 . | supp dose OJ 0.5 10 1.0 10 2.0 10 VC 0.5 10 1.0 10 2.0 10 dtype: int64 . | . This informs us that there are 10 observations for each of the combinations. Now consider the quantitative column len in the dataset (the length of the animal’s tooth). We can compute summary statistics for it just as we can for a whole dataframe (as we cover in how to compute summary statistics). | 1 . | df['len'].describe() # Summary statistics . | . | 1 2 3 4 5 6 7 8 9 . | count 60.000000 mean 18.813333 std 7.649315 min 4.200000 25% 13.075000 50% 19.250000 75% 25.275000 max 33.900000 Name: len, dtype: float64 . | . The individual functions for mean, standard deviation, etc. covered under “how to compute summary statistics” apply to individual columns as well. For example, we can compute quantiles: . | 1 . | df['len'].quantile([0.25,0.5,0.75]) # These chosen values give quartiles. | . | 1 2 3 4 . | 0.25 13.075 0.50 19.250 0.75 25.275 Name: len, dtype: float64 . | . Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-summarize-a-column/#solution-in-python",
    "relUrl": "/how-to-summarize-a-column/#solution-in-python"
  },"821": {
    "doc": "How to summarize a column",
    "title": "Solution, in R",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 . | df &lt;- ToothGrowth . | . Let us consider qualitative and quantitative variables separately. Consider the qualitative column “supp” in the dataset (which type of supplement the animal received). To count the distribution of each categorical value, use table(): . | 1 . | table(df$supp) # OR summary(df$supp) . | . | 1 2 . | OJ VC 30 30 . | . The output says that there are 30 observations under each of the two levels, Orange Juice and Ascorbic Acid. If you wish to jointly summarize two categorical columns, provide both to table(): . | 1 . | table(df$supp, df$dose) . | . | 1 2 3 . | 0.5 1 2 OJ 10 10 10 VC 10 10 10 . | . This informs us that there are 10 observations for each of the combinations. Note: If there are more than 2 categorical variables of interest, you can use ftable() instead. Now consider the quantitative column len in the dataset (the length of the animal’s tooth). We can compute summary statistics for it just as we can for a whole dataframe (as we cover in how to compute summary statistics). | 1 . | summary(df$len) . | . | 1 2 . | Min. 1st Qu. Median Mean 3rd Qu. Max. 4.20 13.07 19.25 18.81 25.27 33.90 . | . The individual functions for mean, standard deviation, etc. covered under “how to compute summary statistics” apply to individual columns as well. For example, we can compute quantiles: . | 1 . | quantile(df$len) # quantiles . | . | 1 2 . | 0% 25% 50% 75% 100% 4.200 13.075 19.250 25.275 33.900 . | . Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-summarize-a-column/#solution-in-r",
    "relUrl": "/how-to-summarize-a-column/#solution-in-r"
  },"822": {
    "doc": "How to summarize a column",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-summarize-a-column/#topics-that-include-this-task",
    "relUrl": "/how-to-summarize-a-column/#topics-that-include-this-task"
  },"823": {
    "doc": "How to summarize a column",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-summarize-a-column/#opportunities",
    "relUrl": "/how-to-summarize-a-column/#opportunities"
  },"824": {
    "doc": "How to summarize and compare data by groups (in Python)",
    "title": "How to summarize and compare data by groups (in Python)",
    "content": "# How to summarize and compare data by groups (in Python) [See all solutions.](../how-to-summarize-and-compare-data-by-groups) ## Task When given a set of data that has different treatment conditions and an outcome variable, we need to perform some exploratory data analysis. How would you quantitatively compare the treatment conditions with regards to the outcome variable? Related tasks: * [How to compute summary statistics](../how-to-compute-summary-statistics) ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data('ToothGrowth') ``` To obtain the descriptive statistics of the quantitative column (`len` for length of teeth) based on the treatment levels (`supp`), we can combine the `groupby` and `describe` functions. ```python df.groupby('supp')['len'].describe() ``` | | count | mean | std | min | 25% | 50% | 75% | max | . | supp | | | | | | | | | . | OJ | 30.0 | 20.663333 | 6.605561 | 8.2 | 15.525 | 22.7 | 25.725 | 30.9 | . | VC | 30.0 | 16.963333 | 8.266029 | 4.2 | 11.200 | 16.5 | 23.100 | 33.9 | . To choose which statistics you want to see, you could use the `agg` function and list the statistics you want. ```python df.groupby('supp')['len'].agg(['min','median','mean','max','std','count']) ``` | | min | median | mean | max | std | count | . | supp | | | | | | | . | OJ | 8.2 | 22.7 | 20.663333 | 30.9 | 6.605561 | 30 | . | VC | 4.2 | 16.5 | 16.963333 | 33.9 | 8.266029 | 30 | . If your focus is on just one statistic, you can often use its name in place of `agg`, as shown below, using the `quantile` function. ```python df.groupby('supp')['len'].quantile([0.25,0.5,0.75]) # Quartiles - default is median, i.e. 0.5 ``` supp OJ 0.25 15.525 0.50 22.700 0.75 25.725 VC 0.25 11.200 0.50 16.500 0.75 23.100 Name: len, dtype: float64 In this example, we grouped by just one category (`supp`), but the `groupby` function accepts a list of columns if you need to create subcategories, etc. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to summarize and compare data by groups/Python.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-summarize-and-compare-data-by-groups-in-python/",
    "relUrl": "/how-to-summarize-and-compare-data-by-groups-in-python/"
  },"825": {
    "doc": "How to summarize and compare data by groups (in R)",
    "title": "How to summarize and compare data by groups (in R)",
    "content": "# How to summarize and compare data by groups (in R) [See all solutions.](../how-to-summarize-and-compare-data-by-groups) ## Task When given a set of data that has different treatment conditions and an outcome variable, we need to perform some exploratory data analysis. How would you quantitatively compare the treatment conditions with regards to the outcome variable? Related tasks: * [How to compute summary statistics](../how-to-compute-summary-statistics) ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R df <- ToothGrowth ``` To obtain the descriptive statistics of the quantitative column (`len` for length of teeth) based on the treatment levels (`supp`), we can use either the `tapply` or `favstats` functions. ```R attach(df) tapply(len, supp, summary) ``` $OJ Min. 1st Qu. Median Mean 3rd Qu. Max. 8.20 15.53 22.70 20.66 25.73 30.90 $VC Min. 1st Qu. Median Mean 3rd Qu. Max. 4.20 11.20 16.50 16.96 23.10 33.90 You can replace `summary` in the call to `tapply` with `mean`, `median`, `max`, `min`, or `quantile` to get just one value. An example is shown below for quantiles. ```R tapply(len, supp, quantile, prob = 0.25, data=df) # 1st quartile ``` OJ VC 15.525 11.200 Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to summarize and compare data by groups/R.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-summarize-and-compare-data-by-groups-in-r/",
    "relUrl": "/how-to-summarize-and-compare-data-by-groups-in-r/"
  },"826": {
    "doc": "How to summarize and compare data by groups",
    "title": "How to summarize and compare data by groups",
    "content": " ",
    "url": "/how-to-summarize-and-compare-data-by-groups/",
    "relUrl": "/how-to-summarize-and-compare-data-by-groups/"
  },"827": {
    "doc": "How to summarize and compare data by groups",
    "title": "Description",
    "content": "When given a set of data that has different treatment conditions and an outcome variable, we need to perform some exploratory data analysis. How would you quantitatively compare the treatment conditions with regards to the outcome variable? . Related tasks: . | How to compute summary statistics | . ",
    "url": "/how-to-summarize-and-compare-data-by-groups/#description",
    "relUrl": "/how-to-summarize-and-compare-data-by-groups/#description"
  },"828": {
    "doc": "How to summarize and compare data by groups",
    "title": "Solution, in Python",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 2 . | from rdatasets import data df = data('ToothGrowth') . | . To obtain the descriptive statistics of the quantitative column (len for length of teeth) based on the treatment levels (supp), we can combine the groupby and describe functions. | 1 . | df.groupby('supp')['len'].describe() . | . | | count | mean | std | min | 25% | 50% | 75% | max | . | supp | | | | | | | | | . | OJ | 30.0 | 20.663333 | 6.605561 | 8.2 | 15.525 | 22.7 | 25.725 | 30.9 | . | VC | 30.0 | 16.963333 | 8.266029 | 4.2 | 11.200 | 16.5 | 23.100 | 33.9 | . To choose which statistics you want to see, you could use the agg function and list the statistics you want. | 1 . | df.groupby('supp')['len'].agg(['min','median','mean','max','std','count']) . | . | | min | median | mean | max | std | count | . | supp | | | | | | | . | OJ | 8.2 | 22.7 | 20.663333 | 30.9 | 6.605561 | 30 | . | VC | 4.2 | 16.5 | 16.963333 | 33.9 | 8.266029 | 30 | . If your focus is on just one statistic, you can often use its name in place of agg, as shown below, using the quantile function. | 1 . | df.groupby('supp')['len'].quantile([0.25,0.5,0.75]) # Quartiles - default is median, i.e. 0.5 . | . | 1 2 3 4 5 6 7 8 . | supp OJ 0.25 15.525 0.50 22.700 0.75 25.725 VC 0.25 11.200 0.50 16.500 0.75 23.100 Name: len, dtype: float64 . | . In this example, we grouped by just one category (supp), but the groupby function accepts a list of columns if you need to create subcategories, etc. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-summarize-and-compare-data-by-groups/#solution-in-python",
    "relUrl": "/how-to-summarize-and-compare-data-by-groups/#solution-in-python"
  },"829": {
    "doc": "How to summarize and compare data by groups",
    "title": "Solution, in R",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 . | df &lt;- ToothGrowth . | . To obtain the descriptive statistics of the quantitative column (len for length of teeth) based on the treatment levels (supp), we can use either the tapply or favstats functions. | 1 2 . | attach(df) tapply(len, supp, summary) . | . | 1 2 3 4 5 6 7 . | $OJ Min. 1st Qu. Median Mean 3rd Qu. Max. 8.20 15.53 22.70 20.66 25.73 30.90 $VC Min. 1st Qu. Median Mean 3rd Qu. Max. 4.20 11.20 16.50 16.96 23.10 33.90 . | . You can replace summary in the call to tapply with mean, median, max, min, or quantile to get just one value. An example is shown below for quantiles. | 1 . | tapply(len, supp, quantile, prob = 0.25, data=df) # 1st quartile . | . | 1 2 . | OJ VC 15.525 11.200 . | . Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-summarize-and-compare-data-by-groups/#solution-in-r",
    "relUrl": "/how-to-summarize-and-compare-data-by-groups/#solution-in-r"
  },"830": {
    "doc": "How to summarize and compare data by groups",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-summarize-and-compare-data-by-groups/#topics-that-include-this-task",
    "relUrl": "/how-to-summarize-and-compare-data-by-groups/#topics-that-include-this-task"
  },"831": {
    "doc": "How to summarize and compare data by groups",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-summarize-and-compare-data-by-groups/#opportunities",
    "relUrl": "/how-to-summarize-and-compare-data-by-groups/#opportunities"
  },"832": {
    "doc": "How to test data for normality with Pearson's chi-squared test (in R)",
    "title": "How to test data for normality with Pearson's chi-squared test (in R)",
    "content": "# How to test data for normality with Pearson's chi-squared test (in R) [See all solutions.](../how-to-test-data-for-normality-with-pearson-s-chi-squared-test) ## Task We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is Pearson's $\\chi^2$ test. How do we perform it? Related tasks: * [How to create a QQ-plot](../how-to-create-a-qq-plot) * [How to test data for normality with the D'Agostino-Pearson test](../how-to-test-data-for-normality-with-the-d-agostino-pearson-test) * [How to test data for normality with the Jarque-Bera test](../how-to-test-data-for-normality-with-the-jarque-bera-test) ## Solution We're going to use some fake restaurant data, but you can replace our fake data with your real data in the code below. The values in our fake data represent the amount of money that customers spent on a Sunday morning at the restaurant. ```R # Replace your data here spending <- c(34, 12, 19, 56, 54, 34, 45, 37, 13, 22, 65, 19, 16, 45, 19, 50, 36, 23, 28, 56, 40, 61, 45, 47, 37) mean(spending) sd(spending) ``` [1] 36.52 [1] 15.77213 We will now conduct a test of the following null hypothesis: The data comes from a population that is normally distributed with mean 36.52 and standard deviation 15.77. We will use a value $\\alpha=0.05$ as our Type I error rate. The `pearson.test()` function in the `nortest` package can perform Pearson's $\\chi^2$ test for normality. ```R # install.packages(\"nortest\") # if you have not already done so library(nortest) pearson.test(spending) ``` Pearson chi-square normality test data: spending P = 3.48, p-value = 0.6264 The p-value is 0.6264, which is greater than $\\alpha=0.05$, so we fail to reject our null hypothesis. We would continue to operate under our original assumption that the data come from a normally distributed population. Content last modified on 23 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to test data for normality with Pearson's chi-squared test/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test-in-r/",
    "relUrl": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test-in-r/"
  },"833": {
    "doc": "How to test data for normality with Pearson's chi-squared test",
    "title": "How to test data for normality with Pearson’s chi-squared test",
    "content": " ",
    "url": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#how-to-test-data-for-normality-with-pearsons-chi-squared-test",
    "relUrl": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#how-to-test-data-for-normality-with-pearsons-chi-squared-test"
  },"834": {
    "doc": "How to test data for normality with Pearson's chi-squared test",
    "title": "Description",
    "content": "We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is Pearson’s $\\chi^2$ test. How do we perform it? . Related tasks: . | How to create a QQ-plot | How to test data for normality with the D’Agostino-Pearson test | How to test data for normality with the Jarque-Bera test | . ",
    "url": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#description",
    "relUrl": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#description"
  },"835": {
    "doc": "How to test data for normality with Pearson's chi-squared test",
    "title": "Solution, in R",
    "content": "View this solution alone. We’re going to use some fake restaurant data, but you can replace our fake data with your real data in the code below. The values in our fake data represent the amount of money that customers spent on a Sunday morning at the restaurant. | 1 2 3 4 5 6 . | # Replace your data here spending &lt;- c(34, 12, 19, 56, 54, 34, 45, 37, 13, 22, 65, 19, 16, 45, 19, 50, 36, 23, 28, 56, 40, 61, 45, 47, 37) mean(spending) sd(spending) . | . | 1 2 3 4 5 . | [1] 36.52 [1] 15.77213 . | . We will now conduct a test of the following null hypothesis: The data comes from a population that is normally distributed with mean 36.52 and standard deviation 15.77. We will use a value $\\alpha=0.05$ as our Type I error rate. The pearson.test() function in the nortest package can perform Pearson’s $\\chi^2$ test for normality. | 1 2 3 . | # install.packages(\"nortest\") # if you have not already done so library(nortest) pearson.test(spending) . | . | 1 2 3 4 . | Pearson chi-square normality test data: spending P = 3.48, p-value = 0.6264 . | . The p-value is 0.6264, which is greater than $\\alpha=0.05$, so we fail to reject our null hypothesis. We would continue to operate under our original assumption that the data come from a normally distributed population. Content last modified on 23 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#solution-in-r",
    "relUrl": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#solution-in-r"
  },"836": {
    "doc": "How to test data for normality with Pearson's chi-squared test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#topics-that-include-this-task",
    "relUrl": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#topics-that-include-this-task"
  },"837": {
    "doc": "How to test data for normality with Pearson's chi-squared test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#opportunities",
    "relUrl": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/#opportunities"
  },"838": {
    "doc": "How to test data for normality with Pearson's chi-squared test",
    "title": "How to test data for normality with Pearson's chi-squared test",
    "content": " ",
    "url": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/",
    "relUrl": "/how-to-test-data-for-normality-with-pearson-s-chi-squared-test/"
  },"839": {
    "doc": "How to test data for normality with the D'Agostino-Pearson test (in Python, using SciPy)",
    "title": "How to test data for normality with the D'Agostino-Pearson test (in Python, using SciPy)",
    "content": "# How to test data for normality with the D'Agostino-Pearson test (in Python, using SciPy) [See all solutions.](../how-to-test-data-for-normality-with-the-d-agostino-pearson-test) ## Task We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is the D'Agostino-Pearson test (sometimes also called the D'Agostino-Pearson omnibus test, or the D'Agostino-Pearson $k^2$ test). How do we perform it? Related tasks: * [How to create a QQ-plot](../how-to-create-a-qq-plot) * [How to test data for normality with Pearson's chi-squared test](../how-to-test-data-for-normality-with-pearson-s-chi-squared-test) * [How to test data for normality with the Jarque-Bera test](../how-to-test-data-for-normality-with-the-jarque-bera-test) ## Solution We're going to use some fake restaurant data, but you can replace our fake data with your real data in the code below. The values in our fake data represent the amount of money that customers spent on a Sunday morning at the restaurant. ```python import numpy as np # Replace your data here spending = [34, 12, 19, 56, 54, 34, 45, 37, 13, 22, 65, 19, 16, 45, 19, 50, 36, 23, 28, 56, 40, 61, 45, 47, 37] np.mean(spending), np.std(spending, ddof=1) ``` (36.52, 15.772127313713899) We will now conduct a test of the following null hypothesis: The data comes from a population that is normally distributed with mean 36.52 and standard deviation 15.77. We will use a value $\\alpha=0.05$ as our Type I error rate. The `normaltest()` function in SciPy's `stats` package can perform the D'Agostino-Pearson test for normality, which uses the skew and kurtosis of the data. ```python from scipy import stats stats.normaltest(spending) ``` NormaltestResult(statistic=3.0866213696851097, pvalue=0.21367252674488552) The p-value is apprximately 0.21367, which is greater than $\\alpha=0.05$, so we fail to reject our null hypothesis. We would continue to operate under our original assumption that the data come from a normally distributed population. Content last modified on 30 November 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to test data for normality with the D'Agostino-Pearson test/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test-in-python-using-scipy/",
    "relUrl": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test-in-python-using-scipy/"
  },"840": {
    "doc": "How to test data for normality with the D'Agostino-Pearson test",
    "title": "How to test data for normality with the D’Agostino-Pearson test",
    "content": " ",
    "url": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#how-to-test-data-for-normality-with-the-dagostino-pearson-test",
    "relUrl": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#how-to-test-data-for-normality-with-the-dagostino-pearson-test"
  },"841": {
    "doc": "How to test data for normality with the D'Agostino-Pearson test",
    "title": "Description",
    "content": "We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is the D’Agostino-Pearson test (sometimes also called the D’Agostino-Pearson omnibus test, or the D’Agostino-Pearson $k^2$ test). How do we perform it? . Related tasks: . | How to create a QQ-plot | How to test data for normality with Pearson’s chi-squared test | How to test data for normality with the Jarque-Bera test | . ",
    "url": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#description",
    "relUrl": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#description"
  },"842": {
    "doc": "How to test data for normality with the D'Agostino-Pearson test",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’re going to use some fake restaurant data, but you can replace our fake data with your real data in the code below. The values in our fake data represent the amount of money that customers spent on a Sunday morning at the restaurant. | 1 2 3 4 5 6 7 . | import numpy as np # Replace your data here spending = [34, 12, 19, 56, 54, 34, 45, 37, 13, 22, 65, 19, 16, 45, 19, 50, 36, 23, 28, 56, 40, 61, 45, 47, 37] np.mean(spending), np.std(spending, ddof=1) . | . | 1 . | (36.52, 15.772127313713899) . | . We will now conduct a test of the following null hypothesis: The data comes from a population that is normally distributed with mean 36.52 and standard deviation 15.77. We will use a value $\\alpha=0.05$ as our Type I error rate. The normaltest() function in SciPy’s stats package can perform the D’Agostino-Pearson test for normality, which uses the skew and kurtosis of the data. | 1 2 . | from scipy import stats stats.normaltest(spending) . | . | 1 . | NormaltestResult(statistic=3.0866213696851097, pvalue=0.21367252674488552) . | . The p-value is apprximately 0.21367, which is greater than $\\alpha=0.05$, so we fail to reject our null hypothesis. We would continue to operate under our original assumption that the data come from a normally distributed population. Content last modified on 30 November 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#using-scipy-in-python",
    "relUrl": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#using-scipy-in-python"
  },"843": {
    "doc": "How to test data for normality with the D'Agostino-Pearson test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#topics-that-include-this-task",
    "relUrl": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#topics-that-include-this-task"
  },"844": {
    "doc": "How to test data for normality with the D'Agostino-Pearson test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#opportunities",
    "relUrl": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/#opportunities"
  },"845": {
    "doc": "How to test data for normality with the D'Agostino-Pearson test",
    "title": "How to test data for normality with the D'Agostino-Pearson test",
    "content": " ",
    "url": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/",
    "relUrl": "/how-to-test-data-for-normality-with-the-d-agostino-pearson-test/"
  },"846": {
    "doc": "How to test data for normality with the Jarque-Bera test (in Python, using SciPy)",
    "title": "How to test data for normality with the Jarque-Bera test (in Python, using SciPy)",
    "content": "# How to test data for normality with the Jarque-Bera test (in Python, using SciPy) [See all solutions.](../how-to-test-data-for-normality-with-the-jarque-bera-test) ## Task We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is the Jarque-Bera test for normality. How do we perform it? Related tasks: * [How to create a QQ-plot](../how-to-create-a-qq-plot) * [How to test data for normality with the D'Agostino-Pearson test](../how-to-test-data-for-normality-with-the-d-agostino-pearson-test) * [How to test data for normality with Pearson's chi-squared test](../how-to-test-data-for-normality-with-pearson-s-chi-squared-test) ## Solution We're going to use some fake restaurant data, but you can replace our fake data with your real data in the code below. The values in our fake data represent the amount of money that customers spent on a Sunday morning at the restaurant. ```python # Replace your data here spending = [ 34, 12, 19, 56, 54, 34, 45, 37, 13, 22, 65, 19, 16, 45, 19, 50, 36, 23, 28, 56, 40, 61, 45, 47, 37 ] ``` If we assume that the skewness coefficient $S$ and the kurtosis coefficient $K$ are both equal to zero, then our null hypothesis is $H_0: S=K=0$, or that the sample data comes from a normal distribution. We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. We'll let $\\alpha$ be 0.05 here. We can use the `jarque_bera()` function in SciPy's stats package to run the hypothesis test. ```python from scipy import stats stats.jarque_bera( spending ) ``` Jarque_beraResult(statistic=1.3347292970972013, pvalue=0.5130588882194845) Our $p$-value of about $0.5131$ is greater than $\\alpha$, so we fail to reject our null hypothesis. We would continue to operate under our original assumption that the data come from a normally distributed population. Content last modified on 23 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to test data for normality with the Jarque-Bera test/Python, using SciPy.ipynb). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-test-data-for-normality-with-the-jarque-bera-test-in-python-using-scipy/",
    "relUrl": "/how-to-test-data-for-normality-with-the-jarque-bera-test-in-python-using-scipy/"
  },"847": {
    "doc": "How to test data for normality with the Jarque-Bera test",
    "title": "How to test data for normality with the Jarque-Bera test",
    "content": " ",
    "url": "/how-to-test-data-for-normality-with-the-jarque-bera-test/",
    "relUrl": "/how-to-test-data-for-normality-with-the-jarque-bera-test/"
  },"848": {
    "doc": "How to test data for normality with the Jarque-Bera test",
    "title": "Description",
    "content": "We often want to know whether a set of data is normally distributed, so that we can deduce what inference tests are appropriate to conduct. If we have a set of data and want to figure out if it comes from a population that follows a normal distribution, one tool that can help is the Jarque-Bera test for normality. How do we perform it? . Related tasks: . | How to create a QQ-plot | How to test data for normality with the D’Agostino-Pearson test | How to test data for normality with Pearson’s chi-squared test | . ",
    "url": "/how-to-test-data-for-normality-with-the-jarque-bera-test/#description",
    "relUrl": "/how-to-test-data-for-normality-with-the-jarque-bera-test/#description"
  },"849": {
    "doc": "How to test data for normality with the Jarque-Bera test",
    "title": "Using SciPy, in Python",
    "content": "View this solution alone. We’re going to use some fake restaurant data, but you can replace our fake data with your real data in the code below. The values in our fake data represent the amount of money that customers spent on a Sunday morning at the restaurant. | 1 2 3 . | # Replace your data here spending = [ 34, 12, 19, 56, 54, 34, 45, 37, 13, 22, 65, 19, 16, 45, 19, 50, 36, 23, 28, 56, 40, 61, 45, 47, 37 ] . | . If we assume that the skewness coefficient $S$ and the kurtosis coefficient $K$ are both equal to zero, then our null hypothesis is $H_0: S=K=0$, or that the sample data comes from a normal distribution. We choose a value $0 \\le \\alpha \\le 1$ as our Type 1 error rate. We’ll let $\\alpha$ be 0.05 here. We can use the jarque_bera() function in SciPy’s stats package to run the hypothesis test. | 1 2 . | from scipy import stats stats.jarque_bera( spending ) . | . | 1 . | Jarque_beraResult(statistic=1.3347292970972013, pvalue=0.5130588882194845) . | . Our $p$-value of about $0.5131$ is greater than $\\alpha$, so we fail to reject our null hypothesis. We would continue to operate under our original assumption that the data come from a normally distributed population. Content last modified on 23 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-test-data-for-normality-with-the-jarque-bera-test/#using-scipy-in-python",
    "relUrl": "/how-to-test-data-for-normality-with-the-jarque-bera-test/#using-scipy-in-python"
  },"850": {
    "doc": "How to test data for normality with the Jarque-Bera test",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-test-data-for-normality-with-the-jarque-bera-test/#topics-that-include-this-task",
    "relUrl": "/how-to-test-data-for-normality-with-the-jarque-bera-test/#topics-that-include-this-task"
  },"851": {
    "doc": "How to test data for normality with the Jarque-Bera test",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-test-data-for-normality-with-the-jarque-bera-test/#opportunities",
    "relUrl": "/how-to-test-data-for-normality-with-the-jarque-bera-test/#opportunities"
  },"852": {
    "doc": "How to test for a treatment effect in a single factor design (in Python, using SciPy and statsmodels)",
    "title": "How to test for a treatment effect in a single factor design (in Python, using SciPy and statsmodels)",
    "content": "# How to test for a treatment effect in a single factor design (in Python, using SciPy and statsmodels) [See all solutions.](../how-to-test-for-a-treatment-effect-in-a-single-factor-design) ## Task Suppose you are given a dataset that has more than one treatment level and you wish to see if there is a unit-level treatment effect. How would you check that? ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```python from rdatasets import data df = data('ToothGrowth') ``` In this dataset, there are only two treatments (orange juice and ascorbic acid, in the variable `supp`). We can therefore perrform a two-sample $t$ test. But first we must filter the outcome variable `len` (tooth length) based on `supp`. ```python subjects_receiving_oj = df[df['supp']=='OJ']['len'] subjects_receiving_vc = df[df['supp']=='VC']['len'] import scipy.stats as stats stats.ttest_ind( subjects_receiving_oj, subjects_receiving_vc, equal_var=False ) ``` Ttest_indResult(statistic=1.91526826869527, pvalue=0.06063450788093387) At the 5% significance level, we see that the length of the tooth does not differ between the two delivery methods. We assume that the model assumptions are met, but do not check that here. If there are multiple levels (two or more), you can apply the parametric ANOVA test which in this case will provide a similar $p$ value. ```python from statsmodels.formula.api import ols model = ols('len ~ supp', data = df).fit() import statsmodels.api as sm sm.stats.anova_lm(model, typ=1) ``` | | df | sum_sq | mean_sq | F | PR(&gt;F) | . | supp | 1.0 | 205.350000 | 205.350000 | 3.668253 | 0.060393 | . | Residual | 58.0 | 3246.859333 | 55.980333 | NaN | NaN | . We see the $p$ value in the final column is very similar. However, if the assumptions of ANOVA are not met, we can utilize a nonparametric approach via the Kruskal-Wallis Test. We use the filtered variables defined above and import the `kruskal` function from SciPy. ```python from scipy.stats import kruskal kruskal( subjects_receiving_oj, subjects_receiving_vc ) ``` KruskalResult(statistic=3.4453580631407035, pvalue=0.06342967639688878) Similar to the previous results, the length of the tooth does not differ between the delivery methods at the 5% significance level. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to test for a treatment effect in a single factor design/Python, using SciPy and statsmodels.ipynb). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design-in-python-using-scipy-and-statsmodels/",
    "relUrl": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design-in-python-using-scipy-and-statsmodels/"
  },"853": {
    "doc": "How to test for a treatment effect in a single factor design (in R, using perm)",
    "title": "How to test for a treatment effect in a single factor design (in R, using perm)",
    "content": "# How to test for a treatment effect in a single factor design (in R, using perm) [See all solutions.](../how-to-test-for-a-treatment-effect-in-a-single-factor-design) ## Task Suppose you are given a dataset that has more than one treatment level and you wish to see if there is a unit-level treatment effect. How would you check that? ## Solution The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See [how to quickly load some sample data](../how-to-quickly-load-some-sample-data).) ```R df F) supp 1 205 205.35 3.668 0.0604 . Residuals 58 3247 55.98 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 The $p$-value for `supp` is shown at the end of the `supp` row, in the `Pr(>F)` column. Because it is 0.0604, which is greater than 0.05, at a 5% significance level, we see that the length of the tooth does not differ between the delivery methods. However, if the assumptions of ANOVA are not met, we can utilize the non parametric approach via the Kruskal-Wallis Test. ```R kruskal.test(len ~ supp, data = df) ``` Kruskal-Wallis rank sum test data: len by supp Kruskal-Wallis chi-squared = 3.4454, df = 1, p-value = 0.06343 The $p$-value is the last part of the output, and is 0.06343. Because it is greater than 0.05, at a 5% significance level, we see that the length of the tooth does not differ between the delivery methods. Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to test for a treatment effect in a single factor design/R, using perm.Rmd). Contributed by Krtin Juneja (KJUNEJA@falcon.bentley.edu) ",
    "url": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design-in-r-using-perm/",
    "relUrl": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design-in-r-using-perm/"
  },"854": {
    "doc": "How to test for a treatment effect in a single factor design",
    "title": "How to test for a treatment effect in a single factor design",
    "content": " ",
    "url": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/",
    "relUrl": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/"
  },"855": {
    "doc": "How to test for a treatment effect in a single factor design",
    "title": "Description",
    "content": "Suppose you are given a dataset that has more than one treatment level and you wish to see if there is a unit-level treatment effect. How would you check that? . ",
    "url": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#description",
    "relUrl": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#description"
  },"856": {
    "doc": "How to test for a treatment effect in a single factor design",
    "title": "Using SciPy and statsmodels, in Python",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 2 . | from rdatasets import data df = data('ToothGrowth') . | . In this dataset, there are only two treatments (orange juice and ascorbic acid, in the variable supp). We can therefore perrform a two-sample $t$ test. But first we must filter the outcome variable len (tooth length) based on supp. | 1 2 3 4 5 . | subjects_receiving_oj = df[df['supp']=='OJ']['len'] subjects_receiving_vc = df[df['supp']=='VC']['len'] import scipy.stats as stats stats.ttest_ind( subjects_receiving_oj, subjects_receiving_vc, equal_var=False ) . | . | 1 . | Ttest_indResult(statistic=1.91526826869527, pvalue=0.06063450788093387) . | . At the 5% significance level, we see that the length of the tooth does not differ between the two delivery methods. We assume that the model assumptions are met, but do not check that here. If there are multiple levels (two or more), you can apply the parametric ANOVA test which in this case will provide a similar $p$ value. | 1 2 3 4 5 . | from statsmodels.formula.api import ols model = ols('len ~ supp', data = df).fit() import statsmodels.api as sm sm.stats.anova_lm(model, typ=1) . | . | | df | sum_sq | mean_sq | F | PR(&gt;F) | . | supp | 1.0 | 205.350000 | 205.350000 | 3.668253 | 0.060393 | . | Residual | 58.0 | 3246.859333 | 55.980333 | NaN | NaN | . We see the $p$ value in the final column is very similar. However, if the assumptions of ANOVA are not met, we can utilize a nonparametric approach via the Kruskal-Wallis Test. We use the filtered variables defined above and import the kruskal function from SciPy. | 1 2 . | from scipy.stats import kruskal kruskal( subjects_receiving_oj, subjects_receiving_vc ) . | . | 1 . | KruskalResult(statistic=3.4453580631407035, pvalue=0.06342967639688878) . | . Similar to the previous results, the length of the tooth does not differ between the delivery methods at the 5% significance level. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#using-scipy-and-statsmodels-in-python",
    "relUrl": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#using-scipy-and-statsmodels-in-python"
  },"857": {
    "doc": "How to test for a treatment effect in a single factor design",
    "title": "Using perm, in R",
    "content": "View this solution alone. The solution below uses an example dataset about the teeth of 10 guinea pigs at three Vitamin C dosage levels (in mg) with two delivery methods (orange juice vs. ascorbic acid). (See how to quickly load some sample data.) . | 1 . | df &lt;- ToothGrowth . | . In this dataset, there are only two treatments (orange juice and ascorbic acid, in the variable supp). We can therefore perrform a two-sample $t$ test. But first we must filter the outcome variable len (tooth length) based on supp. | 1 . | t.test(len ~ supp, data=df) . | . | 1 2 3 4 5 6 7 8 9 10 . | Welch Two Sample t-test data: len by supp t = 1.9153, df = 55.309, p-value = 0.06063 alternative hypothesis: true difference in means between group OJ and group VC is not equal to 0 95 percent confidence interval: -0.1710156 7.5710156 sample estimates: mean in group OJ mean in group VC 20.66333 16.96333 . | . The $p$-value is reported in the first row of numerical output as 0.06063. Because this is greater than 0.05, at a 5% significance level, we see that the length of the tooth does not differ between the two delivery methods. Since the t.test makes some assumptions, we can use the permTS function instead. It can conduct a permutation or randomization test, but it requires us to load the perm package first. | 1 2 3 . | # install.packages(\"perm\") # If you have not already installed it library(perm) permTS(len ~ supp, data=df) . | . | 1 2 3 4 5 6 7 8 . | Permutation Test using Asymptotic Approximation data: len by supp Z = 1.8734, p-value = 0.06102 alternative hypothesis: true mean supp=OJ - mean supp=VC is not equal to 0 sample estimates: mean supp=OJ - mean supp=VC 3.7 . | . The $p$-value is reported in the first row of numerical output as 0.06102. Because this is greater than 0.05, at a 5% significance level, we see that the length of the tooth does not differ between the two delivery methods. We assume that the model assumptions are met but not shown in this task. If there are multiple levels (2 or more), you can apply the parametric ANOVA test which in this case will provide a similar $p$-value. | 1 2 . | aov1 &lt;- aov(len ~ supp, data = df) summary(aov1) . | . | 1 2 3 4 5 . | Df Sum Sq Mean Sq F value Pr(&gt;F) supp 1 205 205.35 3.668 0.0604 . Residuals 58 3247 55.98 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . The $p$-value for supp is shown at the end of the supp row, in the Pr(&gt;F) column. Because it is 0.0604, which is greater than 0.05, at a 5% significance level, we see that the length of the tooth does not differ between the delivery methods. However, if the assumptions of ANOVA are not met, we can utilize the non parametric approach via the Kruskal-Wallis Test. | 1 . | kruskal.test(len ~ supp, data = df) . | . | 1 2 3 4 . | Kruskal-Wallis rank sum test data: len by supp Kruskal-Wallis chi-squared = 3.4454, df = 1, p-value = 0.06343 . | . The $p$-value is the last part of the output, and is 0.06343. Because it is greater than 0.05, at a 5% significance level, we see that the length of the tooth does not differ between the delivery methods. Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#using-perm-in-r",
    "relUrl": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#using-perm-in-r"
  },"858": {
    "doc": "How to test for a treatment effect in a single factor design",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA255 | . ",
    "url": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#topics-that-include-this-task",
    "relUrl": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#topics-that-include-this-task"
  },"859": {
    "doc": "How to test for a treatment effect in a single factor design",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#opportunities",
    "relUrl": "/how-to-test-for-a-treatment-effect-in-a-single-factor-design/#opportunities"
  },"860": {
    "doc": "How to use Bonferroni's Correction method (in R)",
    "title": "How to use Bonferroni's Correction method (in R)",
    "content": "# How to use Bonferroni's Correction method (in R) [See all solutions.](../how-to-use-bonferroni-s-correction-method) ## Task If we run a one-way ANOVA test and find that there is a significant difference between population means, we might want to know which means are actually different from each other. One way to do so is with the Bonferroni correction. This method runs a $t$-test for each pair of categories using a conservative confidence level. Related tasks: * [How to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) * [How to do a two-sided hypothesis test for two sample means](../how-to-do-a-two-sided-hypothesis-test-for-two-sample-means) (which is just an ANOVA with only two samples) * [How to do a Kruskal-Wallis test](../how-to-do-a-kruskal-wallis-test) ## Solution Let's assume that you have already done an analysis of variance (ANOVA). (See [how to do a one-way analysis of variance (ANOVA)](../how-to-do-a-one-way-analysis-of-variance-anova) for details.) As an example, we will use the fake data below, which looks at the number of transactions at an ice cream shop on the weekends. Let's assume that we chose $\\alpha$ to be 0.05 in that ANOVA. ```R # Store our fake data in vectors. (You can replace this with your real data.) num.transactions F) days 2 1965 982.7 4.348 0.034 * Residuals 14 3164 226.0 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 The top-right value in the output is the $p$-value for the test, $0.034$. Because it is below our chosen significance level of $\\alpha=0.05$, there are significant differences between the mean number of transactions at the ice cream shop across at least two of these weekend days. But specifically which two, or is it more than two? We'll use the `PostHocTest()` function in the `DescTools` package, and specify that we want to use the Bonferroni method to make the confidence intervals for each pair of days. Let's let $\\alpha$ be equal to 0.05 again, but the Bonferroni correction implies that the overall probability of a Type I Error in *any* of the tests below is now at most 0.05, rather than each one being 0.05 separately. ```R # install.packages(\"DescTools\") # If you have not already installed it library(DescTools) # Run the test and print the confidence intervals for each pair of days PostHocTest(model, method = \"bonferroni\", conf.level = 0.95) ``` Posthoc multiple comparisons of means : Bonferroni 95% family-wise confidence level $days diff lwr.ci upr.ci pval Sat-Fri 18.633333 -6.108523 43.37519 0.1798 Sun-Fri 24.666667 1.076232 48.25710 0.0392 * Sun-Sat 6.033333 -18.708523 30.77519 1.0000 --- Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 In the output, R has highlighted the second row for us by placing a `*` after it. That is the one row where the $p$-value (in the final column) is below our chosen $\\alpha=0.05$. Therefore, the only significant difference in mean number of transactions is between Sundays and Fridays. Notice also that the confidence interval in that row (from `lwr.ci` to `upr.ci`) does not include zero. (In that particular row, the confidence interval is $(1.076232,48.25710)$.) Content last modified on 24 October 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to use Bonferroni's Correction method/R.md). Contributed by Elizabeth Czarniak (CZARNIA_ELIZ@bentley.edu) ",
    "url": "/how-to-use-bonferroni-s-correction-method-in-r/",
    "relUrl": "/how-to-use-bonferroni-s-correction-method-in-r/"
  },"861": {
    "doc": "How to use Bonferroni's Correction method",
    "title": "How to use Bonferroni’s Correction method",
    "content": " ",
    "url": "/how-to-use-bonferroni-s-correction-method/#how-to-use-bonferronis-correction-method",
    "relUrl": "/how-to-use-bonferroni-s-correction-method/#how-to-use-bonferronis-correction-method"
  },"862": {
    "doc": "How to use Bonferroni's Correction method",
    "title": "Description",
    "content": "If we run a one-way ANOVA test and find that there is a significant difference between population means, we might want to know which means are actually different from each other. One way to do so is with the Bonferroni correction. This method runs a $t$-test for each pair of categories using a conservative confidence level. Related tasks: . | How to do a one-way analysis of variance (ANOVA) | How to do a two-sided hypothesis test for two sample means (which is just an ANOVA with only two samples) | How to do a Kruskal-Wallis test | . ",
    "url": "/how-to-use-bonferroni-s-correction-method/#description",
    "relUrl": "/how-to-use-bonferroni-s-correction-method/#description"
  },"863": {
    "doc": "How to use Bonferroni's Correction method",
    "title": "Solution, in R",
    "content": "View this solution alone. Let’s assume that you have already done an analysis of variance (ANOVA). (See how to do a one-way analysis of variance (ANOVA) for details.) . As an example, we will use the fake data below, which looks at the number of transactions at an ice cream shop on the weekends. Let’s assume that we chose $\\alpha$ to be 0.05 in that ANOVA. | 1 2 3 4 5 6 7 8 9 . | # Store our fake data in vectors. (You can replace this with your real data.) num.transactions &lt;- c(91, 134, 98, 105, 93, 89, 145, 132, 109, 94, 105, 99, 84, 128, 120, 115, 118) days &lt;- c(\"Fri\", \"Sun\", \"Sun\", \"Sat\", \"Fri\", \"Fri\", \"Sat\", \"Sun\", \"Sun\", \"Fri\", \"Sat\", \"Sat\", \"Fri\", \"Sun\", \"Fri\", \"Sat\", \"Sun\") # Perform an ANOVA and print a summary. model &lt;- aov(num.transactions ~ days) summary(model) . | . | 1 2 3 4 5 . | Df Sum Sq Mean Sq F value Pr(&gt;F) days 2 1965 982.7 4.348 0.034 * Residuals 14 3164 226.0 --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 . | . The top-right value in the output is the $p$-value for the test, $0.034$. Because it is below our chosen significance level of $\\alpha=0.05$, there are significant differences between the mean number of transactions at the ice cream shop across at least two of these weekend days. But specifically which two, or is it more than two? . We’ll use the PostHocTest() function in the DescTools package, and specify that we want to use the Bonferroni method to make the confidence intervals for each pair of days. Let’s let $\\alpha$ be equal to 0.05 again, but the Bonferroni correction implies that the overall probability of a Type I Error in any of the tests below is now at most 0.05, rather than each one being 0.05 separately. | 1 2 3 4 5 . | # install.packages(\"DescTools\") # If you have not already installed it library(DescTools) # Run the test and print the confidence intervals for each pair of days PostHocTest(model, method = \"bonferroni\", conf.level = 0.95) . | . | 1 2 3 4 5 6 7 8 9 10 11 . | Posthoc multiple comparisons of means : Bonferroni 95% family-wise confidence level $days diff lwr.ci upr.ci pval Sat-Fri 18.633333 -6.108523 43.37519 0.1798 Sun-Fri 24.666667 1.076232 48.25710 0.0392 * Sun-Sat 6.033333 -18.708523 30.77519 1.0000 --- Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 . | . In the output, R has highlighted the second row for us by placing a * after it. That is the one row where the $p$-value (in the final column) is below our chosen $\\alpha=0.05$. Therefore, the only significant difference in mean number of transactions is between Sundays and Fridays. Notice also that the confidence interval in that row (from lwr.ci to upr.ci) does not include zero. (In that particular row, the confidence interval is $(1.076232,48.25710)$.) . Content last modified on 24 October 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-use-bonferroni-s-correction-method/#solution-in-r",
    "relUrl": "/how-to-use-bonferroni-s-correction-method/#solution-in-r"
  },"864": {
    "doc": "How to use Bonferroni's Correction method",
    "title": "Topics that include this task",
    "content": ". | Bentley University MA214 | . ",
    "url": "/how-to-use-bonferroni-s-correction-method/#topics-that-include-this-task",
    "relUrl": "/how-to-use-bonferroni-s-correction-method/#topics-that-include-this-task"
  },"865": {
    "doc": "How to use Bonferroni's Correction method",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | Python | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-use-bonferroni-s-correction-method/#opportunities",
    "relUrl": "/how-to-use-bonferroni-s-correction-method/#opportunities"
  },"866": {
    "doc": "How to use Bonferroni's Correction method",
    "title": "How to use Bonferroni's Correction method",
    "content": " ",
    "url": "/how-to-use-bonferroni-s-correction-method/",
    "relUrl": "/how-to-use-bonferroni-s-correction-method/"
  },"867": {
    "doc": "How to write a piecewise-defined function (in Python, using SymPy)",
    "title": "How to write a piecewise-defined function (in Python, using SymPy)",
    "content": "# How to write a piecewise-defined function (in Python, using SymPy) [See all solutions.](../how-to-write-a-piecewise-defined-function) ## Task In mathematics, we use the following notation for a \"piecewise-defined\" function. $$ f(x) = \\begin{cases} x^2 & \\text{if } x>2 \\\\ 1+x & \\text{if } x\\leq 2 \\end{cases} $$ This means that for all $x$ values larger than 2, $f(x)=x^2$, but for $x$ values less than or equal to 2, $f(x)=1+x$. How can we express this in mathematical software? ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` SymPy has support for piecewise functions built in, using `Piecewise`. The function above would be written as follows. ```python var( 'x' ) formula = Piecewise( (x**2, x>2), (1+x, x 2 \\\\x + 1 & \\text{otherwise} \\end{cases}$ We can test to be sure the function works correctly by plugging in a few $x$ values and ensuring the correct $y$ values result. Here we're using the method from [how to substitute a value for a symbolic variable](../how-to-substitute-a-value-for-a-symbolic-variable). ```python formula.subs(x,1), formula.subs(x,2), formula.subs(x,3) ``` $\\displaystyle \\left( 2, \\ 3, \\ 9\\right)$ For $x=1$ we got $1+1=2$. For $x=2$ we got $2+1=3$. For $x=3$, we got $3^2=9$. Content last modified on 01 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to write a piecewise-defined function/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-write-a-piecewise-defined-function-in-python-using-sympy/",
    "relUrl": "/how-to-write-a-piecewise-defined-function-in-python-using-sympy/"
  },"868": {
    "doc": "How to write a piecewise-defined function",
    "title": "How to write a piecewise-defined function",
    "content": " ",
    "url": "/how-to-write-a-piecewise-defined-function/",
    "relUrl": "/how-to-write-a-piecewise-defined-function/"
  },"869": {
    "doc": "How to write a piecewise-defined function",
    "title": "Description",
    "content": "In mathematics, we use the following notation for a “piecewise-defined” function. \\[f(x) = \\begin{cases} x^2 &amp; \\text{if } x&gt;2 \\\\ 1+x &amp; \\text{if } x\\leq 2 \\end{cases}\\] This means that for all $x$ values larger than 2, $f(x)=x^2$, but for $x$ values less than or equal to 2, $f(x)=1+x$. How can we express this in mathematical software? . ",
    "url": "/how-to-write-a-piecewise-defined-function/#description",
    "relUrl": "/how-to-write-a-piecewise-defined-function/#description"
  },"870": {
    "doc": "How to write a piecewise-defined function",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . SymPy has support for piecewise functions built in, using Piecewise. The function above would be written as follows. | 1 2 3 . | var( 'x' ) formula = Piecewise( (x**2, x&gt;2), (1+x, x&lt;=2) ) formula . | . $\\displaystyle \\begin{cases} x^{2} &amp; \\text{for}: x &gt; 2 \\x + 1 &amp; \\text{otherwise} \\end{cases}$ . We can test to be sure the function works correctly by plugging in a few $x$ values and ensuring the correct $y$ values result. Here we’re using the method from how to substitute a value for a symbolic variable. | 1 . | formula.subs(x,1), formula.subs(x,2), formula.subs(x,3) . | . $\\displaystyle \\left( 2, \\ 3, \\ 9\\right)$ . For $x=1$ we got $1+1=2$. For $x=2$ we got $2+1=3$. For $x=3$, we got $3^2=9$. Content last modified on 01 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-write-a-piecewise-defined-function/#using-sympy-in-python",
    "relUrl": "/how-to-write-a-piecewise-defined-function/#using-sympy-in-python"
  },"871": {
    "doc": "How to write a piecewise-defined function",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-write-a-piecewise-defined-function/#topics-that-include-this-task",
    "relUrl": "/how-to-write-a-piecewise-defined-function/#topics-that-include-this-task"
  },"872": {
    "doc": "How to write a piecewise-defined function",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-write-a-piecewise-defined-function/#opportunities",
    "relUrl": "/how-to-write-a-piecewise-defined-function/#opportunities"
  },"873": {
    "doc": "How to write an ordinary differential equation (in Python, using SymPy)",
    "title": "How to write an ordinary differential equation (in Python, using SymPy)",
    "content": "# How to write an ordinary differential equation (in Python, using SymPy) [See all solutions.](../how-to-write-an-ordinary-differential-equation) ## Task Differential equations are equations that contain differentials like $dy$ and $dx$, often in the form $\\frac{dy}{dx}$. How can we write them using software? ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` The following code tells SymPy that $x$ is a variable and that $y$ is a function of $x$. It then expresses $\\frac{dy}{dx}$ as the derivative of $y$ with respect to $x$. ```python var( 'x' ) # Let x be a variable. y = Function('y')(x) # Literally, y is a function, named y, based on x. dydx = Derivative( y, x ) # How to write dy/dx. dydx # Let's see how SymPy displays dy/dx. ``` $\\displaystyle \\frac{d}{d x} y{\\left(x \\right)}$ Let's now write a very simple differential equation, $\\frac{dy}{dx}=y$. As with [how to do implicit differentiation](../how-to-do-implicit-differentiation), SymPy expects us to move everything to the left hand side of the equation. In this case, that makes the equation $\\frac{dy}{dx}-y=0$, and we will use just the left-hand side to express our ODE. ```python ode = dydx - y ode ``` $\\displaystyle - y{\\left(x \\right)} + \\frac{d}{d x} y{\\left(x \\right)}$ Content last modified on 02 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to write an ordinary differential equation/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-write-an-ordinary-differential-equation-in-python-using-sympy/",
    "relUrl": "/how-to-write-an-ordinary-differential-equation-in-python-using-sympy/"
  },"874": {
    "doc": "How to write an ordinary differential equation",
    "title": "How to write an ordinary differential equation",
    "content": " ",
    "url": "/how-to-write-an-ordinary-differential-equation/",
    "relUrl": "/how-to-write-an-ordinary-differential-equation/"
  },"875": {
    "doc": "How to write an ordinary differential equation",
    "title": "Description",
    "content": "Differential equations are equations that contain differentials like $dy$ and $dx$, often in the form $\\frac{dy}{dx}$. How can we write them using software? . ",
    "url": "/how-to-write-an-ordinary-differential-equation/#description",
    "relUrl": "/how-to-write-an-ordinary-differential-equation/#description"
  },"876": {
    "doc": "How to write an ordinary differential equation",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . The following code tells SymPy that $x$ is a variable and that $y$ is a function of $x$. It then expresses $\\frac{dy}{dx}$ as the derivative of $y$ with respect to $x$. | 1 2 3 4 . | var( 'x' ) # Let x be a variable. y = Function('y')(x) # Literally, y is a function, named y, based on x. dydx = Derivative( y, x ) # How to write dy/dx. dydx # Let's see how SymPy displays dy/dx. | . $\\displaystyle \\frac{d}{d x} y{\\left(x \\right)}$ . Let’s now write a very simple differential equation, $\\frac{dy}{dx}=y$. As with how to do implicit differentiation, SymPy expects us to move everything to the left hand side of the equation. In this case, that makes the equation $\\frac{dy}{dx}-y=0$, and we will use just the left-hand side to express our ODE. | 1 2 . | ode = dydx - y ode . | . $\\displaystyle - y{\\left(x \\right)} + \\frac{d}{d x} y{\\left(x \\right)}$ . Content last modified on 02 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-write-an-ordinary-differential-equation/#using-sympy-in-python",
    "relUrl": "/how-to-write-an-ordinary-differential-equation/#using-sympy-in-python"
  },"877": {
    "doc": "How to write an ordinary differential equation",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-write-an-ordinary-differential-equation/#topics-that-include-this-task",
    "relUrl": "/how-to-write-an-ordinary-differential-equation/#topics-that-include-this-task"
  },"878": {
    "doc": "How to write an ordinary differential equation",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-write-an-ordinary-differential-equation/#opportunities",
    "relUrl": "/how-to-write-an-ordinary-differential-equation/#opportunities"
  },"879": {
    "doc": "How to write and evaluate definite integrals (in Python, using SymPy)",
    "title": "How to write and evaluate definite integrals (in Python, using SymPy)",
    "content": "# How to write and evaluate definite integrals (in Python, using SymPy) [See all solutions.](../how-to-write-and-evaluate-definite-integrals) ## Task The area under a curve can be computed using a definite integral. To compute the area above the $x$ axis and under $f(x)$, from $x=a$ to $x=b$, we write $$ \\int_a^b f(x)\\;dx. $$ How can we write and evaluate definite integrals using software? Related tasks: * [How to compute the derivative of a function](../how-to-compute-the-derivative-of-a-function) * [How to write and evaluate indefinite integrals](../how-to-write-and-evaluate-indefinite-integrals) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's compute the area under $\\sin x$ from $x=0$ to $x=\\pi$. We use the same technique as in [how to write and evaluate indefinite integrals](../how-to-write-and-evaluate-indefinite-integrals), except that we add the lower and upper bounds together with $x$, as shown below. ```python var( 'x' ) formula = sin(x) Integral( formula, (x,0,pi) ) ``` $\\displaystyle \\int\\limits_{0}^{\\pi} \\sin{\\left(x \\right)}\\, dx$ The above code just displays the definite integral. To evaluate it, use the `integrate` command. ```python integrate( formula, (x,0,pi) ) ``` $\\displaystyle 2$ Content last modified on 02 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to write and evaluate definite integrals/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-write-and-evaluate-definite-integrals-in-python-using-sympy/",
    "relUrl": "/how-to-write-and-evaluate-definite-integrals-in-python-using-sympy/"
  },"880": {
    "doc": "How to write and evaluate definite integrals",
    "title": "How to write and evaluate definite integrals",
    "content": " ",
    "url": "/how-to-write-and-evaluate-definite-integrals/",
    "relUrl": "/how-to-write-and-evaluate-definite-integrals/"
  },"881": {
    "doc": "How to write and evaluate definite integrals",
    "title": "Description",
    "content": "The area under a curve can be computed using a definite integral. To compute the area above the $x$ axis and under $f(x)$, from $x=a$ to $x=b$, we write . \\[\\int_a^b f(x)\\;dx.\\] How can we write and evaluate definite integrals using software? . Related tasks: . | How to compute the derivative of a function | How to write and evaluate indefinite integrals | . ",
    "url": "/how-to-write-and-evaluate-definite-integrals/#description",
    "relUrl": "/how-to-write-and-evaluate-definite-integrals/#description"
  },"882": {
    "doc": "How to write and evaluate definite integrals",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s compute the area under $\\sin x$ from $x=0$ to $x=\\pi$. We use the same technique as in how to write and evaluate indefinite integrals, except that we add the lower and upper bounds together with $x$, as shown below. | 1 2 3 . | var( 'x' ) formula = sin(x) Integral( formula, (x,0,pi) ) . | . $\\displaystyle \\int\\limits_{0}^{\\pi} \\sin{\\left(x \\right)}\\, dx$ . The above code just displays the definite integral. To evaluate it, use the integrate command. | 1 . | integrate( formula, (x,0,pi) ) . | . $\\displaystyle 2$ . Content last modified on 02 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-write-and-evaluate-definite-integrals/#using-sympy-in-python",
    "relUrl": "/how-to-write-and-evaluate-definite-integrals/#using-sympy-in-python"
  },"883": {
    "doc": "How to write and evaluate definite integrals",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-write-and-evaluate-definite-integrals/#topics-that-include-this-task",
    "relUrl": "/how-to-write-and-evaluate-definite-integrals/#topics-that-include-this-task"
  },"884": {
    "doc": "How to write and evaluate definite integrals",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-write-and-evaluate-definite-integrals/#opportunities",
    "relUrl": "/how-to-write-and-evaluate-definite-integrals/#opportunities"
  },"885": {
    "doc": "How to write and evaluate indefinite integrals (in Python, using SymPy)",
    "title": "How to write and evaluate indefinite integrals (in Python, using SymPy)",
    "content": "# How to write and evaluate indefinite integrals (in Python, using SymPy) [See all solutions.](../how-to-write-and-evaluate-indefinite-integrals) ## Task The antiderivative of a function is expressed using an indefinite integral, as in $$ \\int f(x)\\;dx. $$ How can we write and evaluate indefinite integrals using software? Related tasks: * [How to compute the derivative of a function](../how-to-compute-the-derivative-of-a-function) * [How to write and evaluate definite integrals](../how-to-write-and-evaluate-definite-integrals) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's choose an example formula whose antiderivative we will compute. ```python var( 'x' ) formula = 3*sqrt(x) formula ``` $\\displaystyle 3 \\sqrt{x}$ Use the `Integral` function to build a definite integral without evaluating it. The second parameter is the variable with respect to which you're integrating. ```python Integral( formula, x ) ``` $\\displaystyle \\int 3 \\sqrt{x}\\, dx$ Use the `integrate` function to perform the integration, showing the answer. ```python integrate( formula, x ) ``` $\\displaystyle 2 x^{\\frac{3}{2}}$ ```python integrate( formula, x ) + var('C') # same, but with a constant of integration ``` $\\displaystyle C + 2 x^{\\frac{3}{2}}$ Content last modified on 02 June 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to write and evaluate indefinite integrals/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-write-and-evaluate-indefinite-integrals-in-python-using-sympy/",
    "relUrl": "/how-to-write-and-evaluate-indefinite-integrals-in-python-using-sympy/"
  },"886": {
    "doc": "How to write and evaluate indefinite integrals",
    "title": "How to write and evaluate indefinite integrals",
    "content": " ",
    "url": "/how-to-write-and-evaluate-indefinite-integrals/",
    "relUrl": "/how-to-write-and-evaluate-indefinite-integrals/"
  },"887": {
    "doc": "How to write and evaluate indefinite integrals",
    "title": "Description",
    "content": "The antiderivative of a function is expressed using an indefinite integral, as in . \\[\\int f(x)\\;dx.\\] How can we write and evaluate indefinite integrals using software? . Related tasks: . | How to compute the derivative of a function | How to write and evaluate definite integrals | . ",
    "url": "/how-to-write-and-evaluate-indefinite-integrals/#description",
    "relUrl": "/how-to-write-and-evaluate-indefinite-integrals/#description"
  },"888": {
    "doc": "How to write and evaluate indefinite integrals",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s choose an example formula whose antiderivative we will compute. | 1 2 3 . | var( 'x' ) formula = 3*sqrt(x) formula . | . $\\displaystyle 3 \\sqrt{x}$ . Use the Integral function to build a definite integral without evaluating it. The second parameter is the variable with respect to which you’re integrating. | 1 . | Integral( formula, x ) . | . $\\displaystyle \\int 3 \\sqrt{x}\\, dx$ . Use the integrate function to perform the integration, showing the answer. | 1 . | integrate( formula, x ) . | . $\\displaystyle 2 x^{\\frac{3}{2}}$ . | 1 . | integrate( formula, x ) + var('C') # same, but with a constant of integration . | . $\\displaystyle C + 2 x^{\\frac{3}{2}}$ . Content last modified on 02 June 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-write-and-evaluate-indefinite-integrals/#using-sympy-in-python",
    "relUrl": "/how-to-write-and-evaluate-indefinite-integrals/#using-sympy-in-python"
  },"889": {
    "doc": "How to write and evaluate indefinite integrals",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-write-and-evaluate-indefinite-integrals/#topics-that-include-this-task",
    "relUrl": "/how-to-write-and-evaluate-indefinite-integrals/#topics-that-include-this-task"
  },"890": {
    "doc": "How to write and evaluate indefinite integrals",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-write-and-evaluate-indefinite-integrals/#opportunities",
    "relUrl": "/how-to-write-and-evaluate-indefinite-integrals/#opportunities"
  },"891": {
    "doc": "How to write symbolic equations (in Python, using SymPy)",
    "title": "How to write symbolic equations (in Python, using SymPy)",
    "content": "# How to write symbolic equations (in Python, using SymPy) [See all solutions.](../how-to-write-symbolic-equations) ## Task In programming, when we write `a=b`, the computer interprets it as an instruction, to change the value of `a` to `b`. But in mathematics, $a=b$ is a statement that $a$ and $b$ are equal; it's often a starting point for algebraic work. How can we write a mathematical equation using software? Related tasks: * [How to solve symbolic equations](../how-to-solve-symbolic-equations) * [How to isolate one variable in an equation](../how-to-isolate-one-variable-in-an-equation) ## Solution This answer assumes you have imported SymPy as follows. ```python from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output ``` Let's say we want to write the equation $x^2+y^2=2$. We must first define $x$ and $y$ as mathematical variables, then use SymPy's `Eq` function to build an equation. This helps SymPy distinguish a mathematical equation from a Python assignment statement. ```python var( 'x y' ) Eq( x**2 + y**2, 2 ) # Two parameters: left and right sides of equation ``` $\\displaystyle x^{2} + y^{2} = 2$ You can make a system of equations just by placing several equations in a Python list. ```python system = [ Eq( x + 2*y, 1 ), Eq( x - 9*y, 5 ) ] system ``` $\\displaystyle \\left[ x + 2 y = 1, \\ x - 9 y = 5\\right]$ Content last modified on 10 September 2021. See a problem? [Tell us](https://github.com/nathancarter/how2data/issues/new/choose) or [edit the source](https://github.com/nathancarter/how2data/tree/main/database/tasks/How to write symbolic equations/Python, using SymPy.ipynb). Contributed by Nathan Carter (ncarter@bentley.edu) ",
    "url": "/how-to-write-symbolic-equations-in-python-using-sympy/",
    "relUrl": "/how-to-write-symbolic-equations-in-python-using-sympy/"
  },"892": {
    "doc": "How to write symbolic equations",
    "title": "How to write symbolic equations",
    "content": " ",
    "url": "/how-to-write-symbolic-equations/",
    "relUrl": "/how-to-write-symbolic-equations/"
  },"893": {
    "doc": "How to write symbolic equations",
    "title": "Description",
    "content": "In programming, when we write a=b, the computer interprets it as an instruction, to change the value of a to b. But in mathematics, $a=b$ is a statement that $a$ and $b$ are equal; it’s often a starting point for algebraic work. How can we write a mathematical equation using software? . Related tasks: . | How to solve symbolic equations | How to isolate one variable in an equation | . ",
    "url": "/how-to-write-symbolic-equations/#description",
    "relUrl": "/how-to-write-symbolic-equations/#description"
  },"894": {
    "doc": "How to write symbolic equations",
    "title": "Using SymPy, in Python",
    "content": "View this solution alone. This answer assumes you have imported SymPy as follows. | 1 2 . | from sympy import * # load all math functions init_printing( use_latex='mathjax' ) # use pretty math output . | . Let’s say we want to write the equation $x^2+y^2=2$. We must first define $x$ and $y$ as mathematical variables, then use SymPy’s Eq function to build an equation. This helps SymPy distinguish a mathematical equation from a Python assignment statement. | 1 2 . | var( 'x y' ) Eq( x**2 + y**2, 2 ) # Two parameters: left and right sides of equation . | . $\\displaystyle x^{2} + y^{2} = 2$ . You can make a system of equations just by placing several equations in a Python list. | 1 2 3 4 5 . | system = [ Eq( x + 2*y, 1 ), Eq( x - 9*y, 5 ) ] system . | . $\\displaystyle \\left[ x + 2 y = 1, \\ x - 9 y = 5\\right]$ . Content last modified on 10 September 2021. See a problem? Tell us or edit the source. ",
    "url": "/how-to-write-symbolic-equations/#using-sympy-in-python",
    "relUrl": "/how-to-write-symbolic-equations/#using-sympy-in-python"
  },"895": {
    "doc": "How to write symbolic equations",
    "title": "Topics that include this task",
    "content": ". | Bentley University GR526 | . ",
    "url": "/how-to-write-symbolic-equations/#topics-that-include-this-task",
    "relUrl": "/how-to-write-symbolic-equations/#topics-that-include-this-task"
  },"896": {
    "doc": "How to write symbolic equations",
    "title": "Opportunities",
    "content": "This website does not yet contain a solution for this task in any of the following software packages. | R | Excel | Julia | . If you can contribute a solution using any of these pieces of software, see our Contributing page for how to help extend this website. ",
    "url": "/how-to-write-symbolic-equations/#opportunities",
    "relUrl": "/how-to-write-symbolic-equations/#opportunities"
  },"897": {
    "doc": "Welcome",
    "title": "Welcome to How to Data!",
    "content": "A reference for data science students . ",
    "url": "/#welcome-to-how-to-data",
    "relUrl": "/#welcome-to-how-to-data"
  },"898": {
    "doc": "Welcome",
    "title": "What’s on the site?",
    "content": ". | Tasks: Data-related how-tos using software like Python, R, and Excel. Examples: . | How to compare two nested linear models | How to create basic plots | . | Topics: Groups of tasks organized by course of study. Examples: . | Intro statistics at Bentley University | Data Science at Bentley University | . | . ",
    "url": "/#whats-on-the-site",
    "relUrl": "/#whats-on-the-site"
  },"899": {
    "doc": "Welcome",
    "title": "How much is here?",
    "content": "This site began at Bentley University, but accepts contributions from any school or business, and is happy to work with you to let you add content that would be useful to your students or employees. See the Contributing page for details. | Content | Quantity | . | Topics | 7 | . | Tasks | 105 | . | Solutions | 205 | . | Software packages | 4 | . ",
    "url": "/#how-much-is-here",
    "relUrl": "/#how-much-is-here"
  },"900": {
    "doc": "Welcome",
    "title": "Welcome",
    "content": " ",
    "url": "/",
    "relUrl": "/"
  },"901": {
    "doc": "Software package: Excel",
    "title": "Software package: Excel",
    "content": ". ",
    "url": "/software-package-excel/",
    "relUrl": "/software-package-excel/"
  },"902": {
    "doc": "Software package: Excel",
    "title": "Solutions in Excel (6)",
    "content": "| Task | Solutions in Excel | Solutions in other software packages | . | How to compute probabilities from a distribution | solution | 3 (view) | . | How to compute summary statistics | solution | 3 (view) | . | How to do basic mathematical computations | solution | 5 (view) | . | How to generate random values from a distribution | solution | 3 (view) | . | How to plot continuous probability distributions | solution | 3 (view) | . | How to summarize a column | solution | 2 (view) | . ",
    "url": "/software-package-excel/#solutions-in-excel-6",
    "relUrl": "/software-package-excel/#solutions-in-excel-6"
  },"903": {
    "doc": "Software package: Excel",
    "title": "Solutions needed in Excel",
    "content": "| Task | Solutions in Excel | Solutions in other software packages | . | How to add a polynomial term to a model | none yet(Want to submit one?) | 2 (view) | . | How to add a transformed term to a model | none yet(Want to submit one?) | 2 (view) | . | How to add an interaction term to a model | none yet(Want to submit one?) | 1 (view) | . | How to add details to a plot | none yet(Want to submit one?) | 2 (view) | . | How to analyze the sample means of different treatment conditions | none yet(Want to submit one?) | 2 (view) | . | How to change axes, ticks, and scale in a plot | none yet(Want to submit one?) | 1 (view) | . | How to check the assumptions of a linear model | none yet(Want to submit one?) | 2 (view) | . | How to choose the sample size in a study with two population means | none yet(Want to submit one?) | 2 (view) | . | How to compare two nested linear models | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for a mean difference (matched pairs) | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for a population mean | none yet(Want to submit one?) | 3 (view) | . | How to compute a confidence interval for a population mean using z-scores | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for a regression coefficient | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for a single population variance | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the difference between two means when both population variances are known | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the difference between two means when population variances are unknown | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the difference between two proportions | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the expected value of a response variable | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the population proportion | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the ratio of two population variances | none yet(Want to submit one?) | 2 (view) | . | How to compute adjusted R-squared | none yet(Want to submit one?) | 2 (view) | . | How to compute covariance and correlation coefficients | none yet(Want to submit one?) | 2 (view) | . | How to compute Fisher’s confidence intervals | none yet(Want to submit one?) | 1 (view) | . | How to compute R-squared for a simple linear model | none yet(Want to submit one?) | 3 (view) | . | How to compute the derivative of a function | none yet(Want to submit one?) | 2 (view) | . | How to compute the domain of a function | none yet(Want to submit one?) | 1 (view) | . | How to compute the error bounds on a Taylor approximation | none yet(Want to submit one?) | 1 (view) | . | How to compute the limit of a function | none yet(Want to submit one?) | 1 (view) | . | How to compute the power of a test comparing two population means | none yet(Want to submit one?) | 2 (view) | . | How to compute the residuals of a linear model | none yet(Want to submit one?) | 2 (view) | . | How to compute the standard error of the estimate for a model | none yet(Want to submit one?) | 2 (view) | . | How to compute the Taylor series for a function | none yet(Want to submit one?) | 1 (view) | . | How to conduct a mixed designs ANOVA | none yet(Want to submit one?) | 2 (view) | . | How to conduct a repeated measures ANOVA | none yet(Want to submit one?) | 2 (view) | . | How to convert a text column into dates | none yet(Want to submit one?) | 2 (view) | . | How to create a box (and whisker) plot | none yet(Want to submit one?) | 2 (view) | . | How to create a data frame from scratch | none yet(Want to submit one?) | 2 (view) | . | How to create a histogram | none yet(Want to submit one?) | 2 (view) | . | How to create a QQ-plot | none yet(Want to submit one?) | 3 (view) | . | How to create basic plots | none yet(Want to submit one?) | 2 (view) | . | How to create bivariate plots to compare groups | none yet(Want to submit one?) | 2 (view) | . | How to create symbolic variables | none yet(Want to submit one?) | 1 (view) | . | How to define a mathematical sequence | none yet(Want to submit one?) | 1 (view) | . | How to define a mathematical series | none yet(Want to submit one?) | 1 (view) | . | How to do a goodness of fit test for a multinomial experiment | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for a mean difference (matched pairs) | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for a population proportion | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for population variance | none yet(Want to submit one?) | 1 (view) | . | How to do a hypothesis test for the difference between means when both population variances are known | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for the difference between two proportions | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for the mean with known standard deviation | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for the ratio of two population variances | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test of a coefficient’s significance | none yet(Want to submit one?) | 1 (view) | . | How to do a Kruskal-Wallis test | none yet(Want to submit one?) | 2 (view) | . | How to do a one-sided hypothesis test for two sample means | none yet(Want to submit one?) | 2 (view) | . | How to do a one-way analysis of variance (ANOVA) | none yet(Want to submit one?) | 3 (view) | . | How to do a Spearman rank correlation test | none yet(Want to submit one?) | 2 (view) | . | How to do a test of joint significance | none yet(Want to submit one?) | 2 (view) | . | How to do a two-sided hypothesis test for a sample mean | none yet(Want to submit one?) | 3 (view) | . | How to do a two-sided hypothesis test for two sample means | none yet(Want to submit one?) | 3 (view) | . | How to do a two-way ANOVA test with interaction | none yet(Want to submit one?) | 2 (view) | . | How to do a two-way ANOVA test without interaction | none yet(Want to submit one?) | 2 (view) | . | How to do a Wilcoxon rank-sum test | none yet(Want to submit one?) | 2 (view) | . | How to do a Wilcoxon signed-rank test | none yet(Want to submit one?) | 2 (view) | . | How to do a Wilcoxon signed-rank test for matched pairs | none yet(Want to submit one?) | 2 (view) | . | How to do implicit differentiation | none yet(Want to submit one?) | 1 (view) | . | How to find critical values and p-values from the normal distribution | none yet(Want to submit one?) | 2 (view) | . | How to find critical values and p-values from the t-distribution | none yet(Want to submit one?) | 2 (view) | . | How to find the critical numbers of a function | none yet(Want to submit one?) | 1 (view) | . | How to fit a linear model to two columns of data | none yet(Want to submit one?) | 4 (view) | . | How to fit a multivariate linear model | none yet(Want to submit one?) | 2 (view) | . | How to graph a two-variable function as a surface | none yet(Want to submit one?) | 1 (view) | . | How to graph curves that are not functions | none yet(Want to submit one?) | 1 (view) | . | How to graph mathematical functions | none yet(Want to submit one?) | 3 (view) | . | How to graph mathematical sequences | none yet(Want to submit one?) | 1 (view) | . | How to isolate one variable in an equation | none yet(Want to submit one?) | 1 (view) | . | How to perform a chi-squared test on a contingency table | none yet(Want to submit one?) | 3 (view) | . | How to perform a planned comparison test | none yet(Want to submit one?) | 1 (view) | . | How to perform an analysis of covariance (ANCOVA) | none yet(Want to submit one?) | 2 (view) | . | How to perform pairwise comparisons | none yet(Want to submit one?) | 2 (view) | . | How to perform post-hoc analysis with Tukey’s HSD test | none yet(Want to submit one?) | 3 (view) | . | How to plot discrete probability distributions | none yet(Want to submit one?) | 3 (view) | . | How to plot interaction effects of treatments | none yet(Want to submit one?) | 2 (view) | . | How to predict the response variable in a linear model | none yet(Want to submit one?) | 2 (view) | . | How to quickly load some sample data | none yet(Want to submit one?) | 3 (view) | . | How to solve an ordinary differential equation | none yet(Want to submit one?) | 1 (view) | . | How to solve symbolic equations | none yet(Want to submit one?) | 1 (view) | . | How to substitute a value for a symbolic variable | none yet(Want to submit one?) | 1 (view) | . | How to summarize and compare data by groups | none yet(Want to submit one?) | 2 (view) | . | How to test data for normality with Pearson’s chi-squared test | none yet(Want to submit one?) | 1 (view) | . | How to test data for normality with the D’Agostino-Pearson test | none yet(Want to submit one?) | 1 (view) | . | How to test data for normality with the Jarque-Bera test | none yet(Want to submit one?) | 1 (view) | . | How to test for a treatment effect in a single factor design | none yet(Want to submit one?) | 2 (view) | . | How to use Bonferroni’s Correction method | none yet(Want to submit one?) | 1 (view) | . | How to write a piecewise-defined function | none yet(Want to submit one?) | 1 (view) | . | How to write an ordinary differential equation | none yet(Want to submit one?) | 1 (view) | . | How to write and evaluate definite integrals | none yet(Want to submit one?) | 1 (view) | . | How to write and evaluate indefinite integrals | none yet(Want to submit one?) | 1 (view) | . | How to write symbolic equations | none yet(Want to submit one?) | 1 (view) | . ",
    "url": "/software-package-excel/#solutions-needed-in-excel",
    "relUrl": "/software-package-excel/#solutions-needed-in-excel"
  },"904": {
    "doc": "Software package: Julia",
    "title": "Software package: Julia",
    "content": ". ",
    "url": "/software-package-julia/",
    "relUrl": "/software-package-julia/"
  },"905": {
    "doc": "Software package: Julia",
    "title": "Solutions in Julia (16)",
    "content": "| Task | Solutions in Julia | Solutions in other software packages | . | How to compute a confidence interval for a population mean | solution | 2 (view) | . | How to compute probabilities from a distribution | solution | 3 (view) | . | How to compute R-squared for a simple linear model | solution | 2 (view) | . | How to compute summary statistics | solution | 3 (view) | . | How to do a one-way analysis of variance (ANOVA) | solution | 2 (view) | . | How to do a two-sided hypothesis test for a sample mean | solution | 2 (view) | . | How to do a two-sided hypothesis test for two sample means | solution | 2 (view) | . | How to do basic mathematical computations | solution | 5 (view) | . | How to find critical values and p-values from the normal distribution | solution | 1 (view) | . | How to find critical values and p-values from the t-distribution | solution | 1 (view) | . | How to fit a linear model to two columns of data | solution | 3 (view) | . | How to generate random values from a distribution | solution | 3 (view) | . | How to perform a chi-squared test on a contingency table | solution | 2 (view) | . | How to plot continuous probability distributions | solution | 3 (view) | . | How to plot discrete probability distributions | solution | 2 (view) | . | How to quickly load some sample data | solution | 2 (view) | . ",
    "url": "/software-package-julia/#solutions-in-julia-16",
    "relUrl": "/software-package-julia/#solutions-in-julia-16"
  },"906": {
    "doc": "Software package: Julia",
    "title": "Solutions needed in Julia",
    "content": "| Task | Solutions in Julia | Solutions in other software packages | . | How to add a polynomial term to a model | none yet(Want to submit one?) | 2 (view) | . | How to add a transformed term to a model | none yet(Want to submit one?) | 2 (view) | . | How to add an interaction term to a model | none yet(Want to submit one?) | 1 (view) | . | How to add details to a plot | none yet(Want to submit one?) | 2 (view) | . | How to analyze the sample means of different treatment conditions | none yet(Want to submit one?) | 2 (view) | . | How to change axes, ticks, and scale in a plot | none yet(Want to submit one?) | 1 (view) | . | How to check the assumptions of a linear model | none yet(Want to submit one?) | 2 (view) | . | How to choose the sample size in a study with two population means | none yet(Want to submit one?) | 2 (view) | . | How to compare two nested linear models | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for a mean difference (matched pairs) | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for a population mean using z-scores | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for a regression coefficient | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for a single population variance | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the difference between two means when both population variances are known | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the difference between two means when population variances are unknown | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the difference between two proportions | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the expected value of a response variable | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the population proportion | none yet(Want to submit one?) | 2 (view) | . | How to compute a confidence interval for the ratio of two population variances | none yet(Want to submit one?) | 2 (view) | . | How to compute adjusted R-squared | none yet(Want to submit one?) | 2 (view) | . | How to compute covariance and correlation coefficients | none yet(Want to submit one?) | 2 (view) | . | How to compute Fisher’s confidence intervals | none yet(Want to submit one?) | 1 (view) | . | How to compute the derivative of a function | none yet(Want to submit one?) | 2 (view) | . | How to compute the domain of a function | none yet(Want to submit one?) | 1 (view) | . | How to compute the error bounds on a Taylor approximation | none yet(Want to submit one?) | 1 (view) | . | How to compute the limit of a function | none yet(Want to submit one?) | 1 (view) | . | How to compute the power of a test comparing two population means | none yet(Want to submit one?) | 2 (view) | . | How to compute the residuals of a linear model | none yet(Want to submit one?) | 2 (view) | . | How to compute the standard error of the estimate for a model | none yet(Want to submit one?) | 2 (view) | . | How to compute the Taylor series for a function | none yet(Want to submit one?) | 1 (view) | . | How to conduct a mixed designs ANOVA | none yet(Want to submit one?) | 2 (view) | . | How to conduct a repeated measures ANOVA | none yet(Want to submit one?) | 2 (view) | . | How to convert a text column into dates | none yet(Want to submit one?) | 2 (view) | . | How to create a box (and whisker) plot | none yet(Want to submit one?) | 2 (view) | . | How to create a data frame from scratch | none yet(Want to submit one?) | 2 (view) | . | How to create a histogram | none yet(Want to submit one?) | 2 (view) | . | How to create a QQ-plot | none yet(Want to submit one?) | 3 (view) | . | How to create basic plots | none yet(Want to submit one?) | 2 (view) | . | How to create bivariate plots to compare groups | none yet(Want to submit one?) | 2 (view) | . | How to create symbolic variables | none yet(Want to submit one?) | 1 (view) | . | How to define a mathematical sequence | none yet(Want to submit one?) | 1 (view) | . | How to define a mathematical series | none yet(Want to submit one?) | 1 (view) | . | How to do a goodness of fit test for a multinomial experiment | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for a mean difference (matched pairs) | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for a population proportion | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for population variance | none yet(Want to submit one?) | 1 (view) | . | How to do a hypothesis test for the difference between means when both population variances are known | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for the difference between two proportions | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for the mean with known standard deviation | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test for the ratio of two population variances | none yet(Want to submit one?) | 2 (view) | . | How to do a hypothesis test of a coefficient’s significance | none yet(Want to submit one?) | 1 (view) | . | How to do a Kruskal-Wallis test | none yet(Want to submit one?) | 2 (view) | . | How to do a one-sided hypothesis test for two sample means | none yet(Want to submit one?) | 2 (view) | . | How to do a Spearman rank correlation test | none yet(Want to submit one?) | 2 (view) | . | How to do a test of joint significance | none yet(Want to submit one?) | 2 (view) | . | How to do a two-way ANOVA test with interaction | none yet(Want to submit one?) | 2 (view) | . | How to do a two-way ANOVA test without interaction | none yet(Want to submit one?) | 2 (view) | . | How to do a Wilcoxon rank-sum test | none yet(Want to submit one?) | 2 (view) | . | How to do a Wilcoxon signed-rank test | none yet(Want to submit one?) | 2 (view) | . | How to do a Wilcoxon signed-rank test for matched pairs | none yet(Want to submit one?) | 2 (view) | . | How to do implicit differentiation | none yet(Want to submit one?) | 1 (view) | . | How to find the critical numbers of a function | none yet(Want to submit one?) | 1 (view) | . | How to fit a multivariate linear model | none yet(Want to submit one?) | 2 (view) | . | How to graph a two-variable function as a surface | none yet(Want to submit one?) | 1 (view) | . | How to graph curves that are not functions | none yet(Want to submit one?) | 1 (view) | . | How to graph mathematical functions | none yet(Want to submit one?) | 3 (view) | . | How to graph mathematical sequences | none yet(Want to submit one?) | 1 (view) | . | How to isolate one variable in an equation | none yet(Want to submit one?) | 1 (view) | . | How to perform a planned comparison test | none yet(Want to submit one?) | 1 (view) | . | How to perform an analysis of covariance (ANCOVA) | none yet(Want to submit one?) | 2 (view) | . | How to perform pairwise comparisons | none yet(Want to submit one?) | 2 (view) | . | How to perform post-hoc analysis with Tukey’s HSD test | none yet(Want to submit one?) | 3 (view) | . | How to plot interaction effects of treatments | none yet(Want to submit one?) | 2 (view) | . | How to predict the response variable in a linear model | none yet(Want to submit one?) | 2 (view) | . | How to solve an ordinary differential equation | none yet(Want to submit one?) | 1 (view) | . | How to solve symbolic equations | none yet(Want to submit one?) | 1 (view) | . | How to substitute a value for a symbolic variable | none yet(Want to submit one?) | 1 (view) | . | How to summarize a column | none yet(Want to submit one?) | 3 (view) | . | How to summarize and compare data by groups | none yet(Want to submit one?) | 2 (view) | . | How to test data for normality with Pearson’s chi-squared test | none yet(Want to submit one?) | 1 (view) | . | How to test data for normality with the D’Agostino-Pearson test | none yet(Want to submit one?) | 1 (view) | . | How to test data for normality with the Jarque-Bera test | none yet(Want to submit one?) | 1 (view) | . | How to test for a treatment effect in a single factor design | none yet(Want to submit one?) | 2 (view) | . | How to use Bonferroni’s Correction method | none yet(Want to submit one?) | 1 (view) | . | How to write a piecewise-defined function | none yet(Want to submit one?) | 1 (view) | . | How to write an ordinary differential equation | none yet(Want to submit one?) | 1 (view) | . | How to write and evaluate definite integrals | none yet(Want to submit one?) | 1 (view) | . | How to write and evaluate indefinite integrals | none yet(Want to submit one?) | 1 (view) | . | How to write symbolic equations | none yet(Want to submit one?) | 1 (view) | . ",
    "url": "/software-package-julia/#solutions-needed-in-julia",
    "relUrl": "/software-package-julia/#solutions-needed-in-julia"
  },"907": {
    "doc": "Software package: Python",
    "title": "Software package: Python",
    "content": ". ",
    "url": "/software-package-python/",
    "relUrl": "/software-package-python/"
  },"908": {
    "doc": "Software package: Python",
    "title": "Solutions in Python (101)",
    "content": "| Task | Solutions in Python | Solutions in other software packages | . | How to add a polynomial term to a model | using sklearn | 1 (view) | . | How to add a transformed term to a model | using NumPy and sklearn | 1 (view) | . | How to add details to a plot | using Matplotlib | 1 (view) | . | How to analyze the sample means of different treatment conditions | using Matplotlib and Seaborn | 1 (view) | . | How to change axes, ticks, and scale in a plot | using Matplotlib | None | . | How to check the assumptions of a linear model | using NumPy, SciPy, sklearn, Matplotlib and Seaborn | 1 (view) | . | How to choose the sample size in a study with two population means | using statsmodels | 1 (view) | . | How to compare two nested linear models | using statsmodels | 1 (view) | . | How to compute a confidence interval for a mean difference (matched pairs) | using NumPy and SciPy | 1 (view) | . | How to compute a confidence interval for a population mean | using SciPy | 2 (view) | . | How to compute a confidence interval for a population mean using z-scores | using SciPy | 1 (view) | . | How to compute a confidence interval for a regression coefficient | using statsmodels | 1 (view) | . | How to compute a confidence interval for a single population variance | using SciPy | 1 (view) | . | How to compute a confidence interval for the difference between two means when both population variances are known | using NumPy and SciPy | 1 (view) | . | How to compute a confidence interval for the difference between two means when population variances are unknown | using NumPy and SciPy | 1 (view) | . | How to compute a confidence interval for the difference between two proportions | using SciPy | 1 (view) | . | How to compute a confidence interval for the expected value of a response variable | using statsmodels and sklearn | 1 (view) | . | How to compute a confidence interval for the population proportion | using SciPy | 1 (view) | . | How to compute a confidence interval for the ratio of two population variances | using SciPy | 1 (view) | . | How to compute adjusted R-squared | using statsmodels | 1 (view) | . | How to compute covariance and correlation coefficients | using pandas and NumPy | 1 (view) | . | How to compute probabilities from a distribution | using SciPy | 3 (view) | . | How to compute R-squared for a simple linear model | using SciPy | 2 (view) | . | How to compute summary statistics | using pandas and NumPy | 3 (view) | . | How to compute the derivative of a function | using SymPy | 1 (view) | . | How to compute the domain of a function | using SymPy | None | . | How to compute the error bounds on a Taylor approximation | using SymPy | None | . | How to compute the limit of a function | using SymPy | None | . | How to compute the power of a test comparing two population means | using statsmodels | 1 (view) | . | How to compute the residuals of a linear model | using statsmodels | 1 (view) | . | How to compute the standard error of the estimate for a model | using statsmodels | 1 (view) | . | How to compute the Taylor series for a function | using SymPy | None | . | How to conduct a mixed designs ANOVA | using pandas and pingouin | 1 (view) | . | How to conduct a repeated measures ANOVA | using pandas and pingouin | 1 (view) | . | How to convert a text column into dates | using pandas | 1 (view) | . | How to create a box (and whisker) plot | using Matplotlib | 1 (view) | . | How to create a data frame from scratch | solution | 1 (view) | . | How to create a histogram | using Matplotlib | 1 (view) | . | How to create a QQ-plot | using SciPy, using statsmodels | 1 (view) | . | How to create basic plots | using Matplotlib | 1 (view) | . | How to create bivariate plots to compare groups | using Matplotlib and Seaborn | 1 (view) | . | How to create symbolic variables | using SymPy | None | . | How to define a mathematical sequence | using SymPy | None | . | How to define a mathematical series | using SymPy | None | . | How to do a goodness of fit test for a multinomial experiment | using SciPy | 1 (view) | . | How to do a hypothesis test for a mean difference (matched pairs) | using SciPy | 1 (view) | . | How to do a hypothesis test for a population proportion | using SciPy | 1 (view) | . | How to do a hypothesis test for the difference between means when both population variances are known | using SciPy | 1 (view) | . | How to do a hypothesis test for the difference between two proportions | using SciPy | 1 (view) | . | How to do a hypothesis test for the mean with known standard deviation | using SciPy | 1 (view) | . | How to do a hypothesis test for the ratio of two population variances | using SciPy | 1 (view) | . | How to do a Kruskal-Wallis test | using SciPy | 1 (view) | . | How to do a one-sided hypothesis test for two sample means | using SciPy | 1 (view) | . | How to do a one-way analysis of variance (ANOVA) | using SciPy | 2 (view) | . | How to do a Spearman rank correlation test | using SciPy | 1 (view) | . | How to do a test of joint significance | using Statsmodels | 1 (view) | . | How to do a two-sided hypothesis test for a sample mean | using SciPy | 2 (view) | . | How to do a two-sided hypothesis test for two sample means | using SciPy | 2 (view) | . | How to do a two-way ANOVA test with interaction | using Statsmodels | 1 (view) | . | How to do a two-way ANOVA test without interaction | using Statsmodels | 1 (view) | . | How to do a Wilcoxon rank-sum test | using SciPy | 1 (view) | . | How to do a Wilcoxon signed-rank test | using SciPy | 1 (view) | . | How to do a Wilcoxon signed-rank test for matched pairs | using SciPy | 1 (view) | . | How to do basic mathematical computations | using NumPy, using SymPy, solution | 3 (view) | . | How to do implicit differentiation | using SymPy | None | . | How to find the critical numbers of a function | using SymPy | None | . | How to fit a linear model to two columns of data | using SciPy, using statsmodels | 2 (view) | . | How to fit a multivariate linear model | using statsmodels | 1 (view) | . | How to generate random values from a distribution | using SciPy | 3 (view) | . | How to graph a two-variable function as a surface | using SymPy | None | . | How to graph curves that are not functions | using SymPy | None | . | How to graph mathematical functions | using NumPy and Matplotlib, using SymPy | 1 (view) | . | How to graph mathematical sequences | using SymPy and Matplotlib | None | . | How to isolate one variable in an equation | using SymPy | None | . | How to perform a chi-squared test on a contingency table | using SciPy | 2 (view) | . | How to perform an analysis of covariance (ANCOVA) | using pingouin | 1 (view) | . | How to perform pairwise comparisons | using statsmodels, Matplotlib and scikit | 1 (view) | . | How to perform post-hoc analysis with Tukey’s HSD test | using statsmodels, Matplotlib and scikit | 2 (view) | . | How to plot continuous probability distributions | using SciPy | 3 (view) | . | How to plot discrete probability distributions | using SciPy | 2 (view) | . | How to plot interaction effects of treatments | using Matplotlib and Seaborn | 1 (view) | . | How to predict the response variable in a linear model | using statsmodels | 1 (view) | . | How to quickly load some sample data | solution | 2 (view) | . | How to solve an ordinary differential equation | using SymPy | None | . | How to solve symbolic equations | using SymPy | None | . | How to substitute a value for a symbolic variable | using SymPy | None | . | How to summarize a column | solution | 2 (view) | . | How to summarize and compare data by groups | solution | 1 (view) | . | How to test data for normality with the D’Agostino-Pearson test | using SciPy | None | . | How to test data for normality with the Jarque-Bera test | using SciPy | None | . | How to test for a treatment effect in a single factor design | using SciPy and statsmodels | 1 (view) | . | How to write a piecewise-defined function | using SymPy | None | . | How to write an ordinary differential equation | using SymPy | None | . | How to write and evaluate definite integrals | using SymPy | None | . | How to write and evaluate indefinite integrals | using SymPy | None | . | How to write symbolic equations | using SymPy | None | . ",
    "url": "/software-package-python/#solutions-in-python-101",
    "relUrl": "/software-package-python/#solutions-in-python-101"
  },"909": {
    "doc": "Software package: Python",
    "title": "Solutions needed in Python",
    "content": "| Task | Solutions in Python | Solutions in other software packages | . | How to add an interaction term to a model | none yet(Want to submit one?) | 1 (view) | . | How to compute Fisher’s confidence intervals | none yet(Want to submit one?) | 1 (view) | . | How to do a hypothesis test for population variance | none yet(Want to submit one?) | 1 (view) | . | How to do a hypothesis test of a coefficient’s significance | none yet(Want to submit one?) | 1 (view) | . | How to find critical values and p-values from the normal distribution | none yet(Want to submit one?) | 2 (view) | . | How to find critical values and p-values from the t-distribution | none yet(Want to submit one?) | 2 (view) | . | How to perform a planned comparison test | none yet(Want to submit one?) | 1 (view) | . | How to test data for normality with Pearson’s chi-squared test | none yet(Want to submit one?) | 1 (view) | . | How to use Bonferroni’s Correction method | none yet(Want to submit one?) | 1 (view) | . ",
    "url": "/software-package-python/#solutions-needed-in-python",
    "relUrl": "/software-package-python/#solutions-needed-in-python"
  },"910": {
    "doc": "Software package: R",
    "title": "Software package: R",
    "content": ". ",
    "url": "/software-package-r/",
    "relUrl": "/software-package-r/"
  },"911": {
    "doc": "Software package: R",
    "title": "Solutions in R (82)",
    "content": "| Task | Solutions in R | Solutions in other software packages | . | How to add a polynomial term to a model | solution | 1 (view) | . | How to add a transformed term to a model | solution | 1 (view) | . | How to add an interaction term to a model | solution | None | . | How to add details to a plot | solution | 1 (view) | . | How to analyze the sample means of different treatment conditions | using gplots and emmeans | 1 (view) | . | How to check the assumptions of a linear model | solution | 1 (view) | . | How to choose the sample size in a study with two population means | solution | 1 (view) | . | How to compare two nested linear models | solution | 1 (view) | . | How to compute a confidence interval for a mean difference (matched pairs) | solution | 1 (view) | . | How to compute a confidence interval for a population mean | solution | 2 (view) | . | How to compute a confidence interval for a population mean using z-scores | solution | 1 (view) | . | How to compute a confidence interval for a regression coefficient | solution | 1 (view) | . | How to compute a confidence interval for a single population variance | solution | 1 (view) | . | How to compute a confidence interval for the difference between two means when both population variances are known | solution | 1 (view) | . | How to compute a confidence interval for the difference between two means when population variances are unknown | solution | 1 (view) | . | How to compute a confidence interval for the difference between two proportions | solution | 1 (view) | . | How to compute a confidence interval for the expected value of a response variable | solution | 1 (view) | . | How to compute a confidence interval for the population proportion | solution | 1 (view) | . | How to compute a confidence interval for the ratio of two population variances | solution | 1 (view) | . | How to compute adjusted R-squared | solution | 1 (view) | . | How to compute covariance and correlation coefficients | solution | 1 (view) | . | How to compute Fisher’s confidence intervals | solution | None | . | How to compute probabilities from a distribution | solution | 3 (view) | . | How to compute R-squared for a simple linear model | solution | 2 (view) | . | How to compute summary statistics | solution | 3 (view) | . | How to compute the derivative of a function | solution | 1 (view) | . | How to compute the power of a test comparing two population means | solution | 1 (view) | . | How to compute the residuals of a linear model | solution | 1 (view) | . | How to compute the standard error of the estimate for a model | solution | 1 (view) | . | How to conduct a mixed designs ANOVA | solution | 1 (view) | . | How to conduct a repeated measures ANOVA | using rstatix and tidyr and car | 1 (view) | . | How to convert a text column into dates | solution | 1 (view) | . | How to create a box (and whisker) plot | solution | 1 (view) | . | How to create a data frame from scratch | solution | 1 (view) | . | How to create a histogram | solution | 1 (view) | . | How to create a QQ-plot | solution | 2 (view) | . | How to create basic plots | solution | 1 (view) | . | How to create bivariate plots to compare groups | using lattice and gplots | 1 (view) | . | How to do a goodness of fit test for a multinomial experiment | solution | 1 (view) | . | How to do a hypothesis test for a mean difference (matched pairs) | solution | 1 (view) | . | How to do a hypothesis test for a population proportion | solution | 1 (view) | . | How to do a hypothesis test for population variance | solution | None | . | How to do a hypothesis test for the difference between means when both population variances are known | solution | 1 (view) | . | How to do a hypothesis test for the difference between two proportions | solution | 1 (view) | . | How to do a hypothesis test for the mean with known standard deviation | solution | 1 (view) | . | How to do a hypothesis test for the ratio of two population variances | solution | 1 (view) | . | How to do a hypothesis test of a coefficient’s significance | solution | None | . | How to do a Kruskal-Wallis test | solution | 1 (view) | . | How to do a one-sided hypothesis test for two sample means | solution | 1 (view) | . | How to do a one-way analysis of variance (ANOVA) | solution | 2 (view) | . | How to do a Spearman rank correlation test | solution | 1 (view) | . | How to do a test of joint significance | solution | 1 (view) | . | How to do a two-sided hypothesis test for a sample mean | solution | 2 (view) | . | How to do a two-sided hypothesis test for two sample means | solution | 2 (view) | . | How to do a two-way ANOVA test with interaction | solution | 1 (view) | . | How to do a two-way ANOVA test without interaction | solution | 1 (view) | . | How to do a Wilcoxon rank-sum test | solution | 1 (view) | . | How to do a Wilcoxon signed-rank test | solution | 1 (view) | . | How to do a Wilcoxon signed-rank test for matched pairs | solution | 1 (view) | . | How to do basic mathematical computations | solution | 5 (view) | . | How to find critical values and p-values from the normal distribution | solution | 1 (view) | . | How to find critical values and p-values from the t-distribution | solution | 1 (view) | . | How to fit a linear model to two columns of data | solution | 3 (view) | . | How to fit a multivariate linear model | solution | 1 (view) | . | How to generate random values from a distribution | solution | 3 (view) | . | How to graph mathematical functions | solution | 2 (view) | . | How to perform a chi-squared test on a contingency table | solution | 2 (view) | . | How to perform a planned comparison test | using gmodels | None | . | How to perform an analysis of covariance (ANCOVA) | solution | 1 (view) | . | How to perform pairwise comparisons | solution | 1 (view) | . | How to perform post-hoc analysis with Tukey’s HSD test | using agricolae, solution | 1 (view) | . | How to plot continuous probability distributions | solution | 3 (view) | . | How to plot discrete probability distributions | solution | 2 (view) | . | How to plot interaction effects of treatments | using ggpubr | 1 (view) | . | How to predict the response variable in a linear model | solution | 1 (view) | . | How to quickly load some sample data | solution | 2 (view) | . | How to summarize a column | solution | 2 (view) | . | How to summarize and compare data by groups | solution | 1 (view) | . | How to test data for normality with Pearson’s chi-squared test | solution | None | . | How to test for a treatment effect in a single factor design | using perm | 1 (view) | . | How to use Bonferroni’s Correction method | solution | None | . ",
    "url": "/software-package-r/#solutions-in-r-82",
    "relUrl": "/software-package-r/#solutions-in-r-82"
  },"912": {
    "doc": "Software package: R",
    "title": "Solutions needed in R",
    "content": "| Task | Solutions in R | Solutions in other software packages | . | How to change axes, ticks, and scale in a plot | none yet(Want to submit one?) | 1 (view) | . | How to compute the domain of a function | none yet(Want to submit one?) | 1 (view) | . | How to compute the error bounds on a Taylor approximation | none yet(Want to submit one?) | 1 (view) | . | How to compute the limit of a function | none yet(Want to submit one?) | 1 (view) | . | How to compute the Taylor series for a function | none yet(Want to submit one?) | 1 (view) | . | How to create symbolic variables | none yet(Want to submit one?) | 1 (view) | . | How to define a mathematical sequence | none yet(Want to submit one?) | 1 (view) | . | How to define a mathematical series | none yet(Want to submit one?) | 1 (view) | . | How to do implicit differentiation | none yet(Want to submit one?) | 1 (view) | . | How to find the critical numbers of a function | none yet(Want to submit one?) | 1 (view) | . | How to graph a two-variable function as a surface | none yet(Want to submit one?) | 1 (view) | . | How to graph curves that are not functions | none yet(Want to submit one?) | 1 (view) | . | How to graph mathematical sequences | none yet(Want to submit one?) | 1 (view) | . | How to isolate one variable in an equation | none yet(Want to submit one?) | 1 (view) | . | How to solve an ordinary differential equation | none yet(Want to submit one?) | 1 (view) | . | How to solve symbolic equations | none yet(Want to submit one?) | 1 (view) | . | How to substitute a value for a symbolic variable | none yet(Want to submit one?) | 1 (view) | . | How to test data for normality with the D’Agostino-Pearson test | none yet(Want to submit one?) | 1 (view) | . | How to test data for normality with the Jarque-Bera test | none yet(Want to submit one?) | 1 (view) | . | How to write a piecewise-defined function | none yet(Want to submit one?) | 1 (view) | . | How to write an ordinary differential equation | none yet(Want to submit one?) | 1 (view) | . | How to write and evaluate definite integrals | none yet(Want to submit one?) | 1 (view) | . | How to write and evaluate indefinite integrals | none yet(Want to submit one?) | 1 (view) | . | How to write symbolic equations | none yet(Want to submit one?) | 1 (view) | . ",
    "url": "/software-package-r/#solutions-needed-in-r",
    "relUrl": "/software-package-r/#solutions-needed-in-r"
  },"913": {
    "doc": "Software Packages",
    "title": "Software Packages",
    "content": "Here is a list of the software packages that appear in the solutions on this website. This list can include standard applications like Microsoft Excel, web-based applications like Google Sheets, or programming languages like Python and R. | Software Package | Icon | Number of solutions | Website | . | Python | | 101 | https://www.python.org/ | . | R | | 82 | https://www.r-project.org/ | . | Excel | | 6 | https://www.microsoft.com/en-us/microsoft-365/excel | . | Julia | | 16 | https://julialang.org/ | . ",
    "url": "/software/",
    "relUrl": "/software/"
  },"914": {
    "doc": "Software Packages",
    "title": "Under Construction",
    "content": "We will add additional software packages in time. Our initial priorities are on the two programming languages used in data-related courses at Bentley University, where this website is being created (and those are Python and R). Natural next steps include languages like Julia and popular software like Excel, SPSS, etc. ",
    "url": "/software/#under-construction",
    "relUrl": "/software/#under-construction"
  },"915": {
    "doc": "Tasks",
    "title": "Tasks",
    "content": "This database is a list of tasks that students of data science may want to know how to accomplish, all phrased as “How to” questions. The table below lists all tasks in the database. To see them categorized, check out the topics page. | Task | Solutions | . | How to add a polynomial term to a model | In Python: using sklearnIn R: solution | . | How to add a transformed term to a model | In Python: using NumPy and sklearnIn R: solution | . | How to add an interaction term to a model | In R: solution | . | How to add details to a plot | In Python: using MatplotlibIn R: solution | . | How to analyze the sample means of different treatment conditions | In Python: using Matplotlib and SeabornIn R: using gplots and emmeans | . | How to change axes, ticks, and scale in a plot | In Python: using Matplotlib | . | How to check the assumptions of a linear model | In Python: using NumPy, SciPy, sklearn, Matplotlib and SeabornIn R: solution | . | How to choose the sample size in a study with two population means | In Python: using statsmodelsIn R: solution | . | How to compare two nested linear models | In Python: using statsmodelsIn R: solution | . | How to compute a confidence interval for a mean difference (matched pairs) | In Python: using NumPy and SciPyIn R: solution | . | How to compute a confidence interval for a population mean | In Python: using SciPyIn R: solutionIn Julia: solution | . | How to compute a confidence interval for a population mean using z-scores | In Python: using SciPyIn R: solution | . | How to compute a confidence interval for a regression coefficient | In Python: using statsmodelsIn R: solution | . | How to compute a confidence interval for a single population variance | In Python: using SciPyIn R: solution | . | How to compute a confidence interval for the difference between two means when both population variances are known | In Python: using NumPy and SciPyIn R: solution | . | How to compute a confidence interval for the difference between two means when population variances are unknown | In Python: using NumPy and SciPyIn R: solution | . | How to compute a confidence interval for the difference between two proportions | In Python: using SciPyIn R: solution | . | How to compute a confidence interval for the expected value of a response variable | In Python: using statsmodels and sklearnIn R: solution | . | How to compute a confidence interval for the population proportion | In Python: using SciPyIn R: solution | . | How to compute a confidence interval for the ratio of two population variances | In Python: using SciPyIn R: solution | . | How to compute adjusted R-squared | In Python: using statsmodelsIn R: solution | . | How to compute covariance and correlation coefficients | In Python: using pandas and NumPyIn R: solution | . | How to compute Fisher’s confidence intervals | In R: solution | . | How to compute probabilities from a distribution | In Python: using SciPyIn R: solutionIn Excel: solutionIn Julia: solution | . | How to compute R-squared for a simple linear model | In Python: using SciPyIn R: solutionIn Julia: solution | . | How to compute summary statistics | In Python: using pandas and NumPyIn R: solutionIn Excel: solutionIn Julia: solution | . | How to compute the derivative of a function | In Python: using SymPyIn R: solution | . | How to compute the domain of a function | In Python: using SymPy | . | How to compute the error bounds on a Taylor approximation | In Python: using SymPy | . | How to compute the limit of a function | In Python: using SymPy | . | How to compute the power of a test comparing two population means | In Python: using statsmodelsIn R: solution | . | How to compute the residuals of a linear model | In Python: using statsmodelsIn R: solution | . | How to compute the standard error of the estimate for a model | In Python: using statsmodelsIn R: solution | . | How to compute the Taylor series for a function | In Python: using SymPy | . | How to conduct a mixed designs ANOVA | In Python: using pandas and pingouinIn R: solution | . | How to conduct a repeated measures ANOVA | In Python: using pandas and pingouinIn R: using rstatix and tidyr and car | . | How to convert a text column into dates | In Python: using pandasIn R: solution | . | How to create a box (and whisker) plot | In Python: using MatplotlibIn R: solution | . | How to create a data frame from scratch | In Python: solutionIn R: solution | . | How to create a histogram | In Python: using MatplotlibIn R: solution | . | How to create a QQ-plot | In Python: using SciPy, using statsmodelsIn R: solution | . | How to create basic plots | In Python: using MatplotlibIn R: solution | . | How to create bivariate plots to compare groups | In Python: using Matplotlib and SeabornIn R: using lattice and gplots | . | How to create symbolic variables | In Python: using SymPy | . | How to define a mathematical sequence | In Python: using SymPy | . | How to define a mathematical series | In Python: using SymPy | . | How to do a goodness of fit test for a multinomial experiment | In Python: using SciPyIn R: solution | . | How to do a hypothesis test for a mean difference (matched pairs) | In Python: using SciPyIn R: solution | . | How to do a hypothesis test for a population proportion | In Python: using SciPyIn R: solution | . | How to do a hypothesis test for population variance | In R: solution | . | How to do a hypothesis test for the difference between means when both population variances are known | In Python: using SciPyIn R: solution | . | How to do a hypothesis test for the difference between two proportions | In Python: using SciPyIn R: solution | . | How to do a hypothesis test for the mean with known standard deviation | In Python: using SciPyIn R: solution | . | How to do a hypothesis test for the ratio of two population variances | In Python: using SciPyIn R: solution | . | How to do a hypothesis test of a coefficient’s significance | In R: solution | . | How to do a Kruskal-Wallis test | In Python: using SciPyIn R: solution | . | How to do a one-sided hypothesis test for two sample means | In Python: using SciPyIn R: solution | . | How to do a one-way analysis of variance (ANOVA) | In Python: using SciPyIn R: solutionIn Julia: solution | . | How to do a Spearman rank correlation test | In Python: using SciPyIn R: solution | . | How to do a test of joint significance | In Python: using StatsmodelsIn R: solution | . | How to do a two-sided hypothesis test for a sample mean | In Python: using SciPyIn R: solutionIn Julia: solution | . | How to do a two-sided hypothesis test for two sample means | In Python: using SciPyIn R: solutionIn Julia: solution | . | How to do a two-way ANOVA test with interaction | In Python: using StatsmodelsIn R: solution | . | How to do a two-way ANOVA test without interaction | In Python: using StatsmodelsIn R: solution | . | How to do a Wilcoxon rank-sum test | In Python: using SciPyIn R: solution | . | How to do a Wilcoxon signed-rank test | In Python: using SciPyIn R: solution | . | How to do a Wilcoxon signed-rank test for matched pairs | In Python: using SciPyIn R: solution | . | How to do basic mathematical computations | In Python: using NumPy, using SymPy, solutionIn R: solutionIn Excel: solutionIn Julia: solution | . | How to do implicit differentiation | In Python: using SymPy | . | How to find critical values and p-values from the normal distribution | In R: solutionIn Julia: solution | . | How to find critical values and p-values from the t-distribution | In R: solutionIn Julia: solution | . | How to find the critical numbers of a function | In Python: using SymPy | . | How to fit a linear model to two columns of data | In Python: using SciPy, using statsmodelsIn R: solutionIn Julia: solution | . | How to fit a multivariate linear model | In Python: using statsmodelsIn R: solution | . | How to generate random values from a distribution | In Python: using SciPyIn R: solutionIn Excel: solutionIn Julia: solution | . | How to graph a two-variable function as a surface | In Python: using SymPy | . | How to graph curves that are not functions | In Python: using SymPy | . | How to graph mathematical functions | In Python: using NumPy and Matplotlib, using SymPyIn R: solution | . | How to graph mathematical sequences | In Python: using SymPy and Matplotlib | . | How to isolate one variable in an equation | In Python: using SymPy | . | How to perform a chi-squared test on a contingency table | In Python: using SciPyIn R: solutionIn Julia: solution | . | How to perform a planned comparison test | In R: using gmodels | . | How to perform an analysis of covariance (ANCOVA) | In Python: using pingouinIn R: solution | . | How to perform pairwise comparisons | In Python: using statsmodels, Matplotlib and scikitIn R: solution | . | How to perform post-hoc analysis with Tukey’s HSD test | In Python: using statsmodels, Matplotlib and scikitIn R: using agricolae, solution | . | How to plot continuous probability distributions | In Python: using SciPyIn R: solutionIn Excel: solutionIn Julia: solution | . | How to plot discrete probability distributions | In Python: using SciPyIn R: solutionIn Julia: solution | . | How to plot interaction effects of treatments | In Python: using Matplotlib and SeabornIn R: using ggpubr | . | How to predict the response variable in a linear model | In Python: using statsmodelsIn R: solution | . | How to quickly load some sample data | In Python: solutionIn R: solutionIn Julia: solution | . | How to solve an ordinary differential equation | In Python: using SymPy | . | How to solve symbolic equations | In Python: using SymPy | . | How to substitute a value for a symbolic variable | In Python: using SymPy | . | How to summarize a column | In Python: solutionIn R: solutionIn Excel: solution | . | How to summarize and compare data by groups | In Python: solutionIn R: solution | . | How to test data for normality with Pearson’s chi-squared test | In R: solution | . | How to test data for normality with the D’Agostino-Pearson test | In Python: using SciPy | . | How to test data for normality with the Jarque-Bera test | In Python: using SciPy | . | How to test for a treatment effect in a single factor design | In Python: using SciPy and statsmodelsIn R: using perm | . | How to use Bonferroni’s Correction method | In R: solution | . | How to write a piecewise-defined function | In Python: using SymPy | . | How to write an ordinary differential equation | In Python: using SymPy | . | How to write and evaluate definite integrals | In Python: using SymPy | . | How to write and evaluate indefinite integrals | In Python: using SymPy | . | How to write symbolic equations | In Python: using SymPy | . ",
    "url": "/tasks/",
    "relUrl": "/tasks/"
  },"916": {
    "doc": "Topics",
    "title": "Topics",
    "content": " ",
    "url": "/topics/",
    "relUrl": "/topics/"
  },"917": {
    "doc": "Topics",
    "title": "What is a “topic?”",
    "content": "Although this website is focused mostly on tasks, it can be helpful to have them organized in some way. We organize them into topics. A topic can be a course at a univeristy or other school, a textbook, a field of study, or any other category into which we can collect tasks in a way that’s helpful this site’s readers. ",
    "url": "/topics/#what-is-a-topic",
    "relUrl": "/topics/#what-is-a-topic"
  },"918": {
    "doc": "Topics",
    "title": "All topics, in alphabetical order",
    "content": ". | Bentley University GB213 | Bentley University GR521 | Bentley University GR526 | Bentley University MA214 | Bentley University MA252 | Bentley University MA255 | Bentley University MA346 | . ",
    "url": "/topics/#all-topics-in-alphabetical-order",
    "relUrl": "/topics/#all-topics-in-alphabetical-order"
  },"919": {
    "doc": "Topics",
    "title": "Under construction",
    "content": "There will be many more topics added to this site in time. This website has just begun! Check back later. ",
    "url": "/topics/#under-construction",
    "relUrl": "/topics/#under-construction"
  }
}
