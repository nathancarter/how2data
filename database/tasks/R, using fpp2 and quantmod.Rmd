---
author: "Moinak Bhaduri (mbhaduri@bentley.edu)"
---

Although not absolutely necessary, it's better, prior to graphing, to ensure we are feeding a TIME SERIES structure as the object to be graphed. That is, to ensure, the computer is treating these numbers as part of a time series and not as part of a different data structure, say, a vector. This is a great habit to develop, since, although line diagrams such as the ones to follow can be drawn with vectors too, many of the specialised modelling tasks later on can be done solely on time series objects. This is accomplished through the "ts" function below. It lives within the "fpp2" package. Be sure to install and load it.

```{r}
library(fpp2)
```

                      #---Plotting one time series---#
If we have a small data, we can type the numbers out within R's concatenation operator (i.e., within "c()"):

```{r}
time.series.vector=c(162.1, 256.9, 151.15,118.76, 100.71, 83.97, 99.4, 103.64, 71.59, 94.92, 78.73, 182.85, 165.23, 197.94, 146.8, 127.17, 112.4, 70.35, 72.98, 82.8, 70.33, 76.13, 75.54, 130.32)
time.series.vector #--Printing out the long chain of numbers--#
str(time.series.vector)
```

Imagine the numbers above are the amounts on your monthly electricity bills over two years, starting from January 1990. Check that "str" tells you its structure is a numeric vector. We can convert it to a time series object the following way through "ts":

```{r}
time.series=ts(time.series.vector,start = c(1990,1),frequency = 12)
time.series #--Notice how the arrangement looks different, organised by years and months--#
str(time.series) #--Check how it's now recognised as a time series object---#
```

The first argument inside "ts" is your numeric vector, 

"frequency" tells you how often do you collect data over a year, assumed to be equally spaced [this is an assumption, irregularly spaced data is a different field of active research]. So had this been a quarterly data, we'd have gone "4", had it been daily, we'd have gone "365", etc. 

"start" specifies when did the data collection begin. The "1" tells you it began from the first "point" of 1990. What do we mean by the first "point"? The first hour? The first day? The first month? The first quarter? "frequency" helps us with that. Setting it to 12 lets our computer know it's the first month of 1990. 

So had we tried to summarise quarterly data starting from the second quarter of 1992, we'd have gone:

"ts(..., start=c(1992,2), frequency=4)"

We are now ready to create out first time series plot. "autoplot" does that job. Explanatory axes labels and titles are crucial. If we do not specify them manually like this, default choices will be used which is not always ideal.

```{r}
autoplot(time.series)+xlab("Years")+ylab("Electricity bill amounts (in USD)")+ggtitle("Time series plot showing money spent on electricity every month over two years")
```

In case we have a longer time series, typing out the data will be feasible no more. We can import it using the "Import Dataset" button and convert the vector into a time series using the steps above. In case it is already a time series object (see below), this conversion step is unnecessary.

```{r}
austourists
str(austourists) #--check that it is already a time series object--#
autoplot(austourists) #--so going straight to the plotting without the "ts" bit--#
```

                            #-----Comparisons----#
                            
Next, we move on to comparisons. What if we want to place a time series against the backdrop formed by some others? Let's say we have two neighbouring houses and we'd want to know how much do they spend on their electricity over the months. 

```{r}
house1=c(162.1, 256.9, 151.15,118.76, 100.71, 83.97, 99.4, 103.64, 71.59, 94.92, 78.73, 182.85)
house2=c(165.23, 197.94, 146.8, 127.17, 112.4, 70.35, 72.98, 82.8, 70.33, 76.13, 75.54, 130.32)

combinedTimeSeries=ts(cbind(house1,house2),start = c(1990,1),frequency = 12) #--"cbind" (which stands for "column binding") helps create a grand time series object---#
combinedTimeSeries #--notice how they are now arranged in a matrix-type format--#

autoplot(combinedTimeSeries)+geom_smooth() +ylab("Electricity bills")+
  ggtitle("Monthly electricity bill amounts comparison over a year")
 
#--This "geom_smooth" (stands for smooth geometry) bit helps us pass smooth estimated trend lines (along with their interval estimates) calculated through LOWESS smoothing. Get rid of this piece in case you'd want a simpler comparison--# 
```

Again, our data can already be in a time series format. In that case, there'd be no need to "cbind" them.

```{r}
departures
str(departures) #--five different time series, great for comparisons---#
autoplot(departures)
```

                    #---Complications and intricacies----#
                    
Notice that on this last example, the green "vislong" series is squeezed into a tiny space. This happened because we tried to accommodate large and small numbers on the same graph. Patterns from the green graph may get hidden and midleading conclusions may emerge. For instance, we may incorrectly feel this green line is not showing a strong trend. In such cases, it's better to separate out the pieces using "facets=T":

```{r}
autoplot(departures,facets = T) #--notice how the y-axes have changed!!--#
```
Another complication could be if they do not share the same origin, i.e., if data collection for one series got delayed by a bit. We are assuming that the rates at which they get collected (i.e., their frequency values) are still the same. It's just that they do not all start at the same time. Here's how to deal with that situation: 

```{r}
#--Isolate the pieces and deal with the troublemaker separately--#
permanent=ts(departures[,1], start = c(1976,1),frequency = 12)
reslong=ts(departures[,2], start = c(1976,1),frequency = 12)
vislong=ts(departures[,3], start = c(1976,1),frequency = 12)
resshort=ts(departures[,4][72:length(departures[,4])], start = c(1982,1),frequency = 12) #--notice how the origin is different now---#
visshort=ts(departures[,5], start = c(1976,1),frequency = 12)

autoplot(cbind(permanent,reslong,vislong,resshort,visshort))+ylab("Departures")+ggtitle("Departures from Australia, separated by resident categories, non-constant origin")

#--Check how the blue graph starts late---#
```

We have looked at the following ways to create time series data fit for graphing:

i) entering the observations as a numeric vector, and converting the vector to a time series object through "ts(..., start =... , frequency =...)"
ii) importing data available in some other format (txt, Excel, SPSS, etc.) through "Import Dataset", identifying the vector of interest and dealing with it in the way we dealt with  possibility (i) above.
iii) objects that may already be in a time series format.

Possibility (iii) may seem remote initially, but in several fields, it's quite routine to store observations as time series fit for graphing straightaway. The "ts(..)" call becomes redundant then. An example could be around analysing stock prices for a company, say Facebook (ticker symbol: "FB").

```{r}
library(quantmod) #--a short for "quantitative modeling" stores these daily prices, #                                                                        #-----volumes--#
getSymbols("FB")
head(getSymbols("FB",auto.assign = F)) #--the first few days---#
tail(getSymbols("FB",auto.assign = F)) #--the last few days---#
chartSeries(FB) #--notice that "FB" is automatically detected as a time series, without us #              #--having to define it to be so through "ts", "start", "frequency", etc..-#
autoplot(dailyReturn(FB)) #-the same advantage carries over to the "autoplot" function too-#
```

